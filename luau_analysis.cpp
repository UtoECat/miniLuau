/* @@@@@ PACK.LUA : THIS FILE WAS AUTOGENERATED USING PACK.lua v.2.0!
 * @@@@@ SEE https://github.com/UtoECat/miniLuau/blob/main/PACK.lua FOR DETAILS
 */

#include "luau_analysisint_.hpp"

#pragma once

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/LValue.h>

#include "luau_ast_int.hpp"

// @@@ PACK.lua : not found, likely and std header
#include <vector>

namespace Luau {

bool Field::operator==(const Field &rhs) const {
  LUAU_ASSERT(parent && rhs.parent);
  return key == rhs.key && (parent == rhs.parent || *parent == *rhs.parent);
}

bool Field::operator!=(const Field &rhs) const { return !(*this == rhs); }

size_t LValueHasher::operator()(const LValue &lvalue) const {
  // Most likely doesn't produce high quality hashes, but we're probably ok
  // enough with it. When an evidence is shown that operator==(LValue) is used
  // more often than it should, we can have a look at improving the hash
  // quality.
  size_t acc = 0;
  size_t offset = 0;

  const LValue *current = &lvalue;
  while (current) {
    if (auto field = get<Field>(*current))
      acc ^= (std::hash<std::string>{}(field->key) << 1) >> ++offset;
    else if (auto symbol = get<Symbol>(*current))
      acc ^= std::hash<Symbol>{}(*symbol) << 1;
    else
      LUAU_ASSERT(!"Hash not accumulated for this new LValue alternative.");

    current = baseof(*current);
  }

  return acc;
}

const LValue *baseof(const LValue &lvalue) {
  if (auto field = get<Field>(lvalue))
    return field->parent.get();

  auto symbol = get<Symbol>(lvalue);
  LUAU_ASSERT(symbol);
  return nullptr; // Base of root is null.
}

std::optional<LValue> tryGetLValue(const AstExpr &node) {
  const AstExpr *expr = &node;
  while (auto e = expr->as<AstExprGroup>())
    expr = e->expr;

  if (auto local = expr->as<AstExprLocal>())
    return Symbol{local->local};
  else if (auto global = expr->as<AstExprGlobal>())
    return Symbol{global->name};
  else if (auto indexname = expr->as<AstExprIndexName>()) {
    if (auto lvalue = tryGetLValue(*indexname->expr))
      return Field{std::make_shared<LValue>(*lvalue), indexname->index.value};
  } else if (auto indexexpr = expr->as<AstExprIndexExpr>()) {
    if (auto lvalue = tryGetLValue(*indexexpr->expr))
      if (auto string = indexexpr->index->as<AstExprConstantString>())
        return Field{std::make_shared<LValue>(*lvalue),
                     std::string(string->value.data, string->value.size)};
  }

  return std::nullopt;
}

Symbol getBaseSymbol(const LValue &lvalue) {
  const LValue *current = &lvalue;
  while (auto field = get<Field>(*current))
    current = baseof(*current);

  const Symbol *symbol = get<Symbol>(*current);
  LUAU_ASSERT(symbol);
  return *symbol;
}

void merge(RefinementMap &l, const RefinementMap &r,
           std::function<TypeId(TypeId, TypeId)> f) {
  for (const auto &[k, a] : r) {
    if (auto it = l.find(k); it != l.end())
      l[k] = f(it->second, a);
    else
      l[k] = a;
  }
}

void addRefinement(RefinementMap &refis, const LValue &lvalue, TypeId ty) {
  refis[lvalue] = ty;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/ConstraintGenerator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// DONE : was aleready inlined <Luau/Def.h>

#include "luau_common_int.hpp"

// DONE : was aleready inlined <Luau/Constraint.h>

// DONE : was aleready inlined <Luau/ControlFlow.h>

// DONE : was aleready inlined <Luau/DcrLogger.h>

#include "luau_common_int.hpp"

// DONE : was aleready inlined <Luau/ModuleResolver.h>

// DONE : was aleready inlined <Luau/RecursionCounter.h>

// DONE : was aleready inlined <Luau/Refinement.h>

// DONE : was aleready inlined <Luau/Scope.h>

// DONE : was aleready inlined <Luau/Simplify.h>

#include "luau_ast_int.hpp"

// DONE : was aleready inlined <Luau/TableLiteralInference.h>

// DONE : was aleready inlined <Luau/Type.h>

// DONE : was aleready inlined <Luau/TypeFunction.h>

// DONE : was aleready inlined <Luau/TypePack.h>

// DONE : was aleready inlined <Luau/TypeUtils.h>

// DONE : was aleready inlined <Luau/Unifier2.h>

// DONE : was aleready inlined <Luau/VisitType.h>

// @@@ PACK.lua : not found, likely and std header
#include <algorithm>

// @@@ PACK.lua : not found, likely and std header
#include <memory>

LUAU_FASTINT(LuauCheckRecursionLimit);
LUAU_FASTFLAG(DebugLuauLogSolverToJson);
LUAU_FASTFLAG(DebugLuauMagicTypes);
LUAU_FASTFLAG(LuauAttributeSyntax);
LUAU_FASTFLAG(LuauDeclarationExtraPropData);

namespace Luau {

bool doesCallError(const AstExprCall *call);        // TypeInfer.cpp
const AstStat *getFallthrough(const AstStat *node); // TypeInfer.cpp

static std::optional<AstExpr *> matchRequire(const AstExprCall &call) {
  const char *require = "require";

  if (call.args.size != 1)
    return std::nullopt;

  const AstExprGlobal *funcAsGlobal = call.func->as<AstExprGlobal>();
  if (!funcAsGlobal || funcAsGlobal->name != require)
    return std::nullopt;

  if (call.args.size != 1)
    return std::nullopt;

  return call.args.data[0];
}

static bool matchSetmetatable(const AstExprCall &call) {
  const char *smt = "setmetatable";

  if (call.args.size != 2)
    return false;

  const AstExprGlobal *funcAsGlobal = call.func->as<AstExprGlobal>();
  if (!funcAsGlobal || funcAsGlobal->name != smt)
    return false;

  return true;
}

struct TypeGuard {
  bool isTypeof;
  AstExpr *target;
  std::string type;
};

static std::optional<TypeGuard> matchTypeGuard(const AstExprBinary *binary) {
  if (binary->op != AstExprBinary::CompareEq &&
      binary->op != AstExprBinary::CompareNe)
    return std::nullopt;

  AstExpr *left = binary->left;
  AstExpr *right = binary->right;
  if (right->is<AstExprCall>())
    std::swap(left, right);

  if (!right->is<AstExprConstantString>())
    return std::nullopt;

  AstExprCall *call = left->as<AstExprCall>();
  AstExprConstantString *string = right->as<AstExprConstantString>();
  if (!call || !string)
    return std::nullopt;

  AstExprGlobal *callee = call->func->as<AstExprGlobal>();
  if (!callee)
    return std::nullopt;

  if (callee->name != "type" && callee->name != "typeof")
    return std::nullopt;

  if (call->args.size != 1)
    return std::nullopt;

  return TypeGuard{
      /*isTypeof*/ callee->name == "typeof",
      /*target*/ call->args.data[0],
      /*type*/ std::string(string->value.data, string->value.size),
  };
}

static bool matchAssert(const AstExprCall &call) {
  if (call.args.size < 1)
    return false;

  const AstExprGlobal *funcAsGlobal = call.func->as<AstExprGlobal>();
  if (!funcAsGlobal || funcAsGlobal->name != "assert")
    return false;

  return true;
}

namespace {

struct Checkpoint {
  size_t offset;
};

Checkpoint checkpoint(const ConstraintGenerator *cg) {
  return Checkpoint{cg->constraints.size()};
}

template <typename F>
void forEachConstraint(const Checkpoint &start, const Checkpoint &end,
                       const ConstraintGenerator *cg, F f) {
  for (size_t i = start.offset; i < end.offset; ++i)
    f(cg->constraints[i]);
}

struct HasFreeType : TypeOnceVisitor {
  bool result = false;

  HasFreeType() {}

  bool visit(TypeId ty) override {
    if (result || ty->persistent)
      return false;
    return true;
  }

  bool visit(TypePackId tp) override {
    if (result)
      return false;
    return true;
  }

  bool visit(TypeId ty, const ClassType &) override { return false; }

  bool visit(TypeId ty, const FreeType &) override {
    result = true;
    return false;
  }

  bool visit(TypePackId ty, const FreeTypePack &) override {
    result = true;
    return false;
  }
};

bool hasFreeType(TypeId ty) {
  HasFreeType hft{};
  hft.traverse(ty);
  return hft.result;
}

} // namespace

ConstraintGenerator::ConstraintGenerator(
    ModulePtr module, NotNull<Normalizer> normalizer,
    NotNull<ModuleResolver> moduleResolver, NotNull<BuiltinTypes> builtinTypes,
    NotNull<InternalErrorReporter> ice, const ScopePtr &globalScope,
    std::function<void(const ModuleName &, const ScopePtr &)>
        prepareModuleScope,
    DcrLogger *logger, NotNull<DataFlowGraph> dfg,
    std::vector<RequireCycle> requireCycles)
    : module(module), builtinTypes(builtinTypes), arena(normalizer->arena),
      rootScope(nullptr), dfg(dfg), normalizer(normalizer),
      moduleResolver(moduleResolver), ice(ice), globalScope(globalScope),
      prepareModuleScope(std::move(prepareModuleScope)),
      requireCycles(std::move(requireCycles)), logger(logger) {
  LUAU_ASSERT(module);
}

void ConstraintGenerator::visitModuleRoot(AstStatBlock *block) {
  LUAU_ASSERT(scopes.empty());
  LUAU_ASSERT(rootScope == nullptr);
  ScopePtr scope = std::make_shared<Scope>(globalScope);
  rootScope = scope.get();
  scopes.emplace_back(block->location, scope);
  rootScope->location = block->location;
  module->astScopes[block] = NotNull{scope.get()};

  rootScope->returnType = freshTypePack(scope);

  TypeId moduleFnTy = arena->addType(FunctionType{TypeLevel{}, rootScope,
                                                  builtinTypes->anyTypePack,
                                                  rootScope->returnType});
  interiorTypes.emplace_back();

  prepopulateGlobalScope(scope, block);

  Checkpoint start = checkpoint(this);

  ControlFlow cf = visitBlockWithoutChildScope(scope, block);
  if (cf == ControlFlow::None)
    addConstraint(scope, block->location,
                  PackSubtypeConstraint{builtinTypes->emptyTypePack,
                                        rootScope->returnType});

  Checkpoint end = checkpoint(this);

  TypeId result = arena->addType(BlockedType{});
  NotNull<Constraint> genConstraint =
      addConstraint(scope, block->location,
                    GeneralizationConstraint{result, moduleFnTy,
                                             std::move(interiorTypes.back())});
  getMutable<BlockedType>(result)->setOwner(genConstraint);
  forEachConstraint(start, end, this, [genConstraint](const ConstraintPtr &c) {
    genConstraint->dependencies.push_back(NotNull{c.get()});
  });

  interiorTypes.pop_back();

  fillInInferredBindings(scope, block);

  if (logger)
    logger->captureGenerationModule(module);

  for (const auto &[ty, domain] : localTypes) {
    // FIXME: This isn't the most efficient thing.
    TypeId domainTy = builtinTypes->neverType;
    for (TypeId d : domain) {
      if (d == ty)
        continue;
      domainTy = simplifyUnion(builtinTypes, arena, domainTy, d).result;
    }

    LUAU_ASSERT(get<BlockedType>(ty));
    asMutable(ty)->ty.emplace<BoundType>(domainTy);
  }
}

TypeId ConstraintGenerator::freshType(const ScopePtr &scope) {
  return Luau::freshType(arena, builtinTypes, scope.get());
}

TypePackId ConstraintGenerator::freshTypePack(const ScopePtr &scope) {
  FreeTypePack f{scope.get()};
  return arena->addTypePack(TypePackVar{std::move(f)});
}

TypePackId ConstraintGenerator::addTypePack(std::vector<TypeId> head,
                                            std::optional<TypePackId> tail) {
  if (head.empty()) {
    if (tail)
      return *tail;
    else
      return builtinTypes->emptyTypePack;
  } else
    return arena->addTypePack(TypePack{std::move(head), tail});
}

ScopePtr ConstraintGenerator::childScope(AstNode *node,
                                         const ScopePtr &parent) {
  auto scope = std::make_shared<Scope>(parent);
  scopes.emplace_back(node->location, scope);
  scope->location = node->location;

  scope->returnType = parent->returnType;
  scope->varargPack = parent->varargPack;

  parent->children.push_back(NotNull{scope.get()});
  module->astScopes[node] = scope.get();

  return scope;
}

std::optional<TypeId> ConstraintGenerator::lookup(const ScopePtr &scope,
                                                  Location location, DefId def,
                                                  bool prototype) {
  if (get<Cell>(def))
    return scope->lookup(def);
  if (auto phi = get<Phi>(def)) {
    if (auto found = scope->lookup(def))
      return *found;
    else if (!prototype && phi->operands.size() == 1)
      return lookup(scope, location, phi->operands.at(0), prototype);
    else if (!prototype)
      return std::nullopt;

    TypeId res = builtinTypes->neverType;

    for (DefId operand : phi->operands) {
      // `scope->lookup(operand)` may return nothing because we only bind a type
      // to that operand once we've seen that particular `DefId`. In this case,
      // we need to prototype those types and use those at a later time.
      std::optional<TypeId> ty =
          lookup(scope, location, operand, /*prototype*/ false);
      if (!ty) {
        ty = arena->addType(BlockedType{});
        localTypes.try_insert(*ty, {});
        rootScope->lvalueTypes[operand] = *ty;
      }

      res = makeUnion(scope, location, res, *ty);
    }

    scope->lvalueTypes[def] = res;
    return res;
  } else
    ice->ice("ConstraintGenerator::lookup is inexhaustive?");
}

NotNull<Constraint> ConstraintGenerator::addConstraint(const ScopePtr &scope,
                                                       const Location &location,
                                                       ConstraintV cv) {
  return NotNull{constraints
                     .emplace_back(new Constraint{NotNull{scope.get()},
                                                  location, std::move(cv)})
                     .get()};
}

NotNull<Constraint>
ConstraintGenerator::addConstraint(const ScopePtr &scope,
                                   std::unique_ptr<Constraint> c) {
  return NotNull{constraints.emplace_back(std::move(c)).get()};
}

void ConstraintGenerator::unionRefinements(
    const ScopePtr &scope, Location location, const RefinementContext &lhs,
    const RefinementContext &rhs, RefinementContext &dest,
    std::vector<ConstraintV> *constraints) {
  const auto intersect = [&](const std::vector<TypeId> &types) {
    if (1 == types.size())
      return types[0];
    else if (2 == types.size())
      return makeIntersect(scope, location, types[0], types[1]);

    return arena->addType(IntersectionType{types});
  };

  for (auto &[def, partition] : lhs) {
    auto rhsIt = rhs.find(def);
    if (rhsIt == rhs.end())
      continue;

    LUAU_ASSERT(!partition.discriminantTypes.empty());
    LUAU_ASSERT(!rhsIt->second.discriminantTypes.empty());

    TypeId leftDiscriminantTy = partition.discriminantTypes.size() == 1
                                    ? partition.discriminantTypes[0]
                                    : intersect(partition.discriminantTypes);

    TypeId rightDiscriminantTy =
        rhsIt->second.discriminantTypes.size() == 1
            ? rhsIt->second.discriminantTypes[0]
            : intersect(rhsIt->second.discriminantTypes);

    dest.insert(def, {});
    dest.get(def)->discriminantTypes.push_back(
        makeUnion(scope, location, leftDiscriminantTy, rightDiscriminantTy));
    dest.get(def)->shouldAppendNilType |=
        partition.shouldAppendNilType || rhsIt->second.shouldAppendNilType;
  }
}

void ConstraintGenerator::computeRefinement(
    const ScopePtr &scope, Location location, RefinementId refinement,
    RefinementContext *refis, bool sense, bool eq,
    std::vector<ConstraintV> *constraints) {
  if (!refinement)
    return;
  else if (auto variadic = get<Variadic>(refinement)) {
    for (RefinementId refi : variadic->refinements)
      computeRefinement(scope, location, refi, refis, sense, eq, constraints);
  } else if (auto negation = get<Negation>(refinement))
    return computeRefinement(scope, location, negation->refinement, refis,
                             !sense, eq, constraints);
  else if (auto conjunction = get<Conjunction>(refinement)) {
    RefinementContext lhsRefis;
    RefinementContext rhsRefis;

    computeRefinement(scope, location, conjunction->lhs,
                      sense ? refis : &lhsRefis, sense, eq, constraints);
    computeRefinement(scope, location, conjunction->rhs,
                      sense ? refis : &rhsRefis, sense, eq, constraints);

    if (!sense)
      unionRefinements(scope, location, lhsRefis, rhsRefis, *refis,
                       constraints);
  } else if (auto disjunction = get<Disjunction>(refinement)) {
    RefinementContext lhsRefis;
    RefinementContext rhsRefis;

    computeRefinement(scope, location, disjunction->lhs,
                      sense ? &lhsRefis : refis, sense, eq, constraints);
    computeRefinement(scope, location, disjunction->rhs,
                      sense ? &rhsRefis : refis, sense, eq, constraints);

    if (sense)
      unionRefinements(scope, location, lhsRefis, rhsRefis, *refis,
                       constraints);
  } else if (auto equivalence = get<Equivalence>(refinement)) {
    computeRefinement(scope, location, equivalence->lhs, refis, sense, true,
                      constraints);
    computeRefinement(scope, location, equivalence->rhs, refis, sense, true,
                      constraints);
  } else if (auto proposition = get<Proposition>(refinement)) {
    TypeId discriminantTy = proposition->discriminantTy;

    // if we have a negative sense, then we need to negate the discriminant
    if (!sense)
      discriminantTy = arena->addType(NegationType{discriminantTy});

    if (eq)
      discriminantTy =
          createTypeFunctionInstance(builtinTypeFunctions().singletonFunc,
                                     {discriminantTy}, {}, scope, location);

    for (const RefinementKey *key = proposition->key; key; key = key->parent) {
      refis->insert(key->def, {});
      refis->get(key->def)->discriminantTypes.push_back(discriminantTy);

      // Reached leaf node
      if (!key->propName)
        break;

      TypeId nextDiscriminantTy = arena->addType(TableType{});
      NotNull<TableType> table{getMutable<TableType>(nextDiscriminantTy)};
      // When we fully support read-write properties (i.e. when we allow
      // properties with completely disparate read and write types), then the
      // following property can be set to read-only since refinements only tell
      // us about what we read. This cannot be allowed yet though because it
      // causes read and write types to diverge.
      table->props[*key->propName] = Property::rw(discriminantTy);
      table->scope = scope.get();
      table->state = TableState::Sealed;

      discriminantTy = nextDiscriminantTy;
    }

    // When the top-level expression is `t[x]`, we want to refine it into `nil`,
    // not `never`.
    LUAU_ASSERT(refis->get(proposition->key->def));
    refis->get(proposition->key->def)->shouldAppendNilType =
        (sense || !eq) && containsSubscriptedDefinition(proposition->key->def);
  }
}

namespace {

/*
 * Constraint generation may be called upon to simplify an intersection or union
 * of types that are not sufficiently solved yet.  We use
 * FindSimplificationBlockers to recognize these types and defer the
 * simplification until constraint solution.
 */
struct FindSimplificationBlockers : TypeOnceVisitor {
  bool found = false;

  bool visit(TypeId) override { return !found; }

  bool visit(TypeId, const BlockedType &) override {
    found = true;
    return false;
  }

  bool visit(TypeId, const FreeType &) override {
    found = true;
    return false;
  }

  bool visit(TypeId, const PendingExpansionType &) override {
    found = true;
    return false;
  }

  // We do not need to know anything at all about a function's argument or
  // return types in order to simplify it in an intersection or union.
  bool visit(TypeId, const FunctionType &) override { return false; }

  bool visit(TypeId, const ClassType &) override { return false; }
};

bool mustDeferIntersection(TypeId ty) {
  FindSimplificationBlockers bts;
  bts.traverse(ty);
  return bts.found;
}
} // namespace

void ConstraintGenerator::applyRefinements(const ScopePtr &scope,
                                           Location location,
                                           RefinementId refinement) {
  if (!refinement)
    return;

  RefinementContext refinements;
  std::vector<ConstraintV> constraints;
  computeRefinement(scope, location, refinement, &refinements, /*sense*/ true,
                    /*eq*/ false, &constraints);

  for (auto &[def, partition] : refinements) {
    if (std::optional<TypeId> defTy = lookup(scope, location, def)) {
      TypeId ty = *defTy;
      if (partition.shouldAppendNilType)
        ty = arena->addType(UnionType{{ty, builtinTypes->nilType}});

      // Intersect ty with every discriminant type. If either type is not
      // sufficiently solved, we queue the intersection up via an
      // IntersectConstraint.

      for (TypeId dt : partition.discriminantTypes) {
        if (mustDeferIntersection(ty) || mustDeferIntersection(dt)) {
          TypeId resultType = createTypeFunctionInstance(
              builtinTypeFunctions().refineFunc, {ty, dt}, {}, scope, location);

          ty = resultType;
        } else {
          switch (shouldSuppressErrors(normalizer, ty)) {
          case ErrorSuppression::DoNotSuppress:
            ty = makeIntersect(scope, location, ty, dt);
            break;
          case ErrorSuppression::Suppress:
            ty = makeIntersect(scope, location, ty, dt);
            ty = makeUnion(scope, location, ty, builtinTypes->errorType);
            break;
          case ErrorSuppression::NormalizationFailed:
            reportError(location, NormalizationTooComplex{});
            ty = makeIntersect(scope, location, ty, dt);
            break;
          }
        }
      }

      scope->rvalueRefinements[def] = ty;
    }
  }

  for (auto &c : constraints)
    addConstraint(scope, location, c);
}

ControlFlow
ConstraintGenerator::visitBlockWithoutChildScope(const ScopePtr &scope,
                                                 AstStatBlock *block) {
  RecursionCounter counter{&recursionCount};

  if (recursionCount >= FInt::LuauCheckRecursionLimit) {
    reportCodeTooComplex(block->location);
    return ControlFlow::None;
  }

  std::unordered_map<Name, Location> aliasDefinitionLocations;

  // In order to enable mutually-recursive type aliases, we need to
  // populate the type bindings before we actually check any of the
  // alias statements.
  for (AstStat *stat : block->body) {
    if (auto alias = stat->as<AstStatTypeAlias>()) {
      if (scope->exportedTypeBindings.count(alias->name.value) ||
          scope->privateTypeBindings.count(alias->name.value)) {
        auto it = aliasDefinitionLocations.find(alias->name.value);
        LUAU_ASSERT(it != aliasDefinitionLocations.end());
        reportError(alias->location,
                    DuplicateTypeDefinition{alias->name.value, it->second});
        continue;
      }

      // A type alias might have no name if the code is syntactically
      // illegal. We mustn't prepopulate anything in this case.
      if (alias->name == kParseNameError || alias->name == "typeof")
        continue;

      ScopePtr defnScope = childScope(alias, scope);

      TypeId initialType = arena->addType(BlockedType{});
      TypeFun initialFun{initialType};

      for (const auto &[name, gen] :
           createGenerics(defnScope, alias->generics, /* useCache */ true)) {
        initialFun.typeParams.push_back(gen);
      }

      for (const auto &[name, genPack] : createGenericPacks(
               defnScope, alias->genericPacks, /* useCache */ true)) {
        initialFun.typePackParams.push_back(genPack);
      }

      if (alias->exported)
        scope->exportedTypeBindings[alias->name.value] = std::move(initialFun);
      else
        scope->privateTypeBindings[alias->name.value] = std::move(initialFun);

      astTypeAliasDefiningScopes[alias] = defnScope;
      aliasDefinitionLocations[alias->name.value] = alias->location;
    }
  }

  std::optional<ControlFlow> firstControlFlow;
  for (AstStat *stat : block->body) {
    ControlFlow cf = visit(scope, stat);
    if (cf != ControlFlow::None && !firstControlFlow)
      firstControlFlow = cf;
  }

  return firstControlFlow.value_or(ControlFlow::None);
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope, AstStat *stat) {
  RecursionLimiter limiter{&recursionCount, FInt::LuauCheckRecursionLimit};

  if (auto s = stat->as<AstStatBlock>())
    return visit(scope, s);
  else if (auto i = stat->as<AstStatIf>())
    return visit(scope, i);
  else if (auto s = stat->as<AstStatWhile>())
    return visit(scope, s);
  else if (auto s = stat->as<AstStatRepeat>())
    return visit(scope, s);
  else if (stat->is<AstStatBreak>())
    return ControlFlow::Breaks;
  else if (stat->is<AstStatContinue>())
    return ControlFlow::Continues;
  else if (auto r = stat->as<AstStatReturn>())
    return visit(scope, r);
  else if (auto e = stat->as<AstStatExpr>()) {
    checkPack(scope, e->expr);

    if (auto call = e->expr->as<AstExprCall>(); call && doesCallError(call))
      return ControlFlow::Throws;

    return ControlFlow::None;
  } else if (auto s = stat->as<AstStatLocal>())
    return visit(scope, s);
  else if (auto s = stat->as<AstStatFor>())
    return visit(scope, s);
  else if (auto s = stat->as<AstStatForIn>())
    return visit(scope, s);
  else if (auto a = stat->as<AstStatAssign>())
    return visit(scope, a);
  else if (auto a = stat->as<AstStatCompoundAssign>())
    return visit(scope, a);
  else if (auto f = stat->as<AstStatFunction>())
    return visit(scope, f);
  else if (auto f = stat->as<AstStatLocalFunction>())
    return visit(scope, f);
  else if (auto a = stat->as<AstStatTypeAlias>())
    return visit(scope, a);
  else if (auto s = stat->as<AstStatDeclareGlobal>())
    return visit(scope, s);
  else if (auto s = stat->as<AstStatDeclareFunction>())
    return visit(scope, s);
  else if (auto s = stat->as<AstStatDeclareClass>())
    return visit(scope, s);
  else if (auto s = stat->as<AstStatError>())
    return visit(scope, s);
  else {
    LUAU_ASSERT(0 && "Internal error: Unknown AstStat type");
    return ControlFlow::None;
  }
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatLocal *statLocal) {
  std::vector<TypeId> annotatedTypes;
  annotatedTypes.reserve(statLocal->vars.size);
  bool hasAnnotation = false;

  std::vector<std::optional<TypeId>> expectedTypes;
  expectedTypes.reserve(statLocal->vars.size);

  std::vector<TypeId> assignees;
  assignees.reserve(statLocal->vars.size);

  // Used to name the first value type, even if it's not placed in varTypes,
  // for the purpose of synthetic name attribution.
  std::optional<TypeId> firstValueType;

  for (AstLocal *local : statLocal->vars) {
    const Location location = local->location;

    TypeId assignee = arena->addType(BlockedType{});
    localTypes.try_insert(assignee, {});

    assignees.push_back(assignee);

    if (!firstValueType)
      firstValueType = assignee;

    if (local->annotation) {
      hasAnnotation = true;
      TypeId annotationTy =
          resolveType(scope, local->annotation, /* inTypeArguments */ false);
      annotatedTypes.push_back(annotationTy);
      expectedTypes.push_back(annotationTy);

      scope->bindings[local] = Binding{annotationTy, location};
    } else {
      // annotatedTypes must contain one type per local.  If a particular
      // local has no annotation at, assume the most conservative thing.
      annotatedTypes.push_back(builtinTypes->unknownType);

      expectedTypes.push_back(std::nullopt);
      scope->bindings[local] = Binding{builtinTypes->unknownType, location};

      inferredBindings[local] = {scope.get(), location, {assignee}};
    }

    DefId def = dfg->getDef(local);
    scope->lvalueTypes[def] = assignee;
  }

  TypePackId rvaluePack = checkPack(scope, statLocal->values, expectedTypes).tp;

  if (hasAnnotation) {
    for (size_t i = 0; i < statLocal->vars.size; ++i) {
      LUAU_ASSERT(get<BlockedType>(assignees[i]));
      TypeIds *localDomain = localTypes.find(assignees[i]);
      LUAU_ASSERT(localDomain);
      localDomain->insert(annotatedTypes[i]);
    }

    TypePackId annotatedPack = arena->addTypePack(std::move(annotatedTypes));
    addConstraint(scope, statLocal->location,
                  PackSubtypeConstraint{rvaluePack, annotatedPack});
  } else {
    std::vector<TypeId> valueTypes;
    valueTypes.reserve(statLocal->vars.size);

    auto [head, tail] = flatten(rvaluePack);

    if (head.size() >= statLocal->vars.size) {
      for (size_t i = 0; i < statLocal->vars.size; ++i)
        valueTypes.push_back(head[i]);
    } else {
      for (size_t i = 0; i < statLocal->vars.size; ++i)
        valueTypes.push_back(arena->addType(BlockedType{}));

      auto uc = addConstraint(scope, statLocal->location,
                              UnpackConstraint{valueTypes, rvaluePack});

      for (TypeId t : valueTypes)
        getMutable<BlockedType>(t)->setOwner(uc);
    }

    for (size_t i = 0; i < statLocal->vars.size; ++i) {
      LUAU_ASSERT(get<BlockedType>(assignees[i]));
      TypeIds *localDomain = localTypes.find(assignees[i]);
      LUAU_ASSERT(localDomain);
      localDomain->insert(valueTypes[i]);
    }
  }

  if (statLocal->vars.size == 1 && statLocal->values.size == 1 &&
      firstValueType && scope.get() == rootScope && !hasAnnotation) {
    AstLocal *var = statLocal->vars.data[0];
    AstExpr *value = statLocal->values.data[0];

    if (value->is<AstExprTable>())
      addConstraint(
          scope, value->location,
          NameConstraint{*firstValueType, var->name.value, /*synthetic*/ true});
    else if (const AstExprCall *call = value->as<AstExprCall>()) {
      if (const AstExprGlobal *global = call->func->as<AstExprGlobal>();
          global && global->name == "setmetatable") {
        addConstraint(scope, value->location,
                      NameConstraint{*firstValueType, var->name.value,
                                     /*synthetic*/ true});
      }
    }
  }

  if (statLocal->values.size > 0) {
    // To correctly handle 'require', we need to import the exported type
    // bindings into the variable 'namespace'.
    for (size_t i = 0; i < statLocal->values.size && i < statLocal->vars.size;
         ++i) {
      const AstExprCall *call = statLocal->values.data[i]->as<AstExprCall>();
      if (!call)
        continue;

      auto maybeRequire = matchRequire(*call);
      if (!maybeRequire)
        continue;

      AstExpr *require = *maybeRequire;

      auto moduleInfo =
          moduleResolver->resolveModuleInfo(module->name, *require);
      if (!moduleInfo)
        continue;

      ModulePtr module = moduleResolver->getModule(moduleInfo->name);
      if (!module)
        continue;

      const Name name{statLocal->vars.data[i]->name.value};
      scope->importedTypeBindings[name] = module->exportedTypeBindings;
      scope->importedModules[name] = moduleInfo->name;

      // Imported types of requires that transitively refer to current module
      // have to be replaced with 'any'
      for (const auto &[location, path] : requireCycles) {
        if (path.empty() || path.front() != moduleInfo->name)
          continue;

        for (auto &[name, tf] : scope->importedTypeBindings[name])
          tf = TypeFun{{}, {}, builtinTypes->anyType};
      }
    }
  }

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatFor *for_) {
  TypeId annotationTy = builtinTypes->numberType;
  if (for_->var->annotation)
    annotationTy =
        resolveType(scope, for_->var->annotation, /* inTypeArguments */ false);

  auto inferNumber = [&](AstExpr *expr) {
    if (!expr)
      return;

    TypeId t = check(scope, expr).ty;
    addConstraint(scope, expr->location,
                  SubtypeConstraint{t, builtinTypes->numberType});
  };

  inferNumber(for_->from);
  inferNumber(for_->to);
  inferNumber(for_->step);

  ScopePtr forScope = childScope(for_, scope);
  forScope->bindings[for_->var] = Binding{annotationTy, for_->var->location};

  DefId def = dfg->getDef(for_->var);
  forScope->lvalueTypes[def] = annotationTy;
  forScope->rvalueRefinements[def] = annotationTy;

  visit(forScope, for_->body);

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatForIn *forIn) {
  ScopePtr loopScope = childScope(forIn, scope);
  TypePackId iterator = checkPack(scope, forIn->values).tp;

  std::vector<TypeId> variableTypes;
  variableTypes.reserve(forIn->vars.size);

  for (AstLocal *var : forIn->vars) {
    TypeId assignee = arena->addType(BlockedType{});
    variableTypes.push_back(assignee);

    TypeId loopVar = arena->addType(BlockedType{});
    localTypes[loopVar].insert(assignee);

    if (var->annotation) {
      TypeId annotationTy =
          resolveType(loopScope, var->annotation, /*inTypeArguments*/ false);
      loopScope->bindings[var] = Binding{annotationTy, var->location};
      addConstraint(scope, var->location,
                    SubtypeConstraint{loopVar, annotationTy});
    } else
      loopScope->bindings[var] = Binding{loopVar, var->location};

    DefId def = dfg->getDef(var);
    loopScope->lvalueTypes[def] = loopVar;
  }

  auto iterable = addConstraint(loopScope, getLocation(forIn->values),
                                IterableConstraint{iterator, variableTypes,
                                                   forIn->values.data[0],
                                                   &module->astForInNextTypes});

  for (TypeId var : variableTypes) {
    auto bt = getMutable<BlockedType>(var);
    LUAU_ASSERT(bt);
    bt->setOwner(iterable);
  }

  Checkpoint start = checkpoint(this);
  visit(loopScope, forIn->body);
  Checkpoint end = checkpoint(this);

  // This iter constraint must dispatch first.
  forEachConstraint(start, end, this,
                    [&iterable](const ConstraintPtr &runLater) {
                      runLater->dependencies.push_back(iterable);
                    });

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatWhile *while_) {
  RefinementId refinement = check(scope, while_->condition).refinement;

  ScopePtr whileScope = childScope(while_, scope);
  applyRefinements(whileScope, while_->condition->location, refinement);

  visit(whileScope, while_->body);

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatRepeat *repeat) {
  ScopePtr repeatScope = childScope(repeat, scope);

  visitBlockWithoutChildScope(repeatScope, repeat->body);

  check(repeatScope, repeat->condition);

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatLocalFunction *function) {
  // Local
  // Global
  // Dotted path
  // Self?

  TypeId functionType = nullptr;
  auto ty = scope->lookup(function->name);
  LUAU_ASSERT(!ty.has_value()); // The parser ensures that every local function
                                // has a distinct Symbol for its name.

  functionType = arena->addType(BlockedType{});
  scope->bindings[function->name] =
      Binding{functionType, function->name->location};

  FunctionSignature sig = checkFunctionSignature(
      scope, function->func, /* expectedType */ std::nullopt,
      function->name->location);
  sig.bodyScope->bindings[function->name] =
      Binding{sig.signature, function->func->location};

  bool sigFullyDefined = !hasFreeType(sig.signature);
  if (sigFullyDefined)
    emplaceType<BoundType>(asMutable(functionType), sig.signature);

  DefId def = dfg->getDef(function->name);
  scope->lvalueTypes[def] = functionType;
  scope->rvalueRefinements[def] = functionType;
  sig.bodyScope->lvalueTypes[def] = sig.signature;
  sig.bodyScope->rvalueRefinements[def] = sig.signature;

  Checkpoint start = checkpoint(this);
  checkFunctionBody(sig.bodyScope, function->func);
  Checkpoint end = checkpoint(this);

  if (!sigFullyDefined) {
    NotNull<Scope> constraintScope{sig.signatureScope ? sig.signatureScope.get()
                                                      : sig.bodyScope.get()};
    std::unique_ptr<Constraint> c = std::make_unique<Constraint>(
        constraintScope, function->name->location,
        GeneralizationConstraint{functionType, sig.signature});

    Constraint *previous = nullptr;
    forEachConstraint(
        start, end, this, [&c, &previous](const ConstraintPtr &constraint) {
          c->dependencies.push_back(NotNull{constraint.get()});

          if (auto psc = get<PackSubtypeConstraint>(*constraint);
              psc && psc->returns) {
            if (previous)
              constraint->dependencies.push_back(NotNull{previous});

            previous = constraint.get();
          }
        });

    getMutable<BlockedType>(functionType)
        ->setOwner(addConstraint(scope, std::move(c)));
    module->astTypes[function->func] = functionType;
  } else
    module->astTypes[function->func] = sig.signature;

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatFunction *function) {
  // Name could be AstStatLocal, AstStatGlobal, AstStatIndexName.
  // With or without self

  Checkpoint start = checkpoint(this);
  FunctionSignature sig = checkFunctionSignature(
      scope, function->func, /* expectedType */ std::nullopt,
      function->name->location);
  bool sigFullyDefined = !hasFreeType(sig.signature);

  checkFunctionBody(sig.bodyScope, function->func);
  Checkpoint end = checkpoint(this);

  TypeId generalizedType = arena->addType(BlockedType{});
  if (sigFullyDefined)
    emplaceType<BoundType>(asMutable(generalizedType), sig.signature);
  else {
    const ScopePtr &constraintScope =
        sig.signatureScope ? sig.signatureScope : sig.bodyScope;

    NotNull<Constraint> c =
        addConstraint(constraintScope, function->name->location,
                      GeneralizationConstraint{generalizedType, sig.signature});
    getMutable<BlockedType>(generalizedType)->setOwner(c);

    Constraint *previous = nullptr;
    forEachConstraint(
        start, end, this, [&c, &previous](const ConstraintPtr &constraint) {
          c->dependencies.push_back(NotNull{constraint.get()});

          if (auto psc = get<PackSubtypeConstraint>(*constraint);
              psc && psc->returns) {
            if (previous)
              constraint->dependencies.push_back(NotNull{previous});

            previous = constraint.get();
          }
        });
  }

  DefId def = dfg->getDef(function->name);
  std::optional<TypeId> existingFunctionTy =
      follow(lookup(scope, function->name->location, def));

  if (AstExprLocal *localName = function->name->as<AstExprLocal>()) {
    visitLValue(scope, localName, generalizedType);

    scope->bindings[localName->local] =
        Binding{sig.signature, localName->location};
    scope->lvalueTypes[def] = sig.signature;
  } else if (AstExprGlobal *globalName = function->name->as<AstExprGlobal>()) {
    if (!existingFunctionTy)
      ice->ice("prepopulateGlobalScope did not populate a global name",
               globalName->location);

    // Sketchy: We're specifically looking for BlockedTypes that were
    // initially created by ConstraintGenerator::prepopulateGlobalScope.
    if (auto bt = get<BlockedType>(*existingFunctionTy);
        bt && nullptr == bt->getOwner())
      emplaceType<BoundType>(asMutable(*existingFunctionTy), generalizedType);

    scope->bindings[globalName->name] =
        Binding{sig.signature, globalName->location};
    scope->lvalueTypes[def] = sig.signature;
  } else if (AstExprIndexName *indexName =
                 function->name->as<AstExprIndexName>()) {
    visitLValue(scope, indexName, generalizedType);
  } else if (AstExprError *err = function->name->as<AstExprError>()) {
    generalizedType = builtinTypes->errorRecoveryType();
  }

  if (generalizedType == nullptr)
    ice->ice("generalizedType == nullptr", function->location);

  scope->rvalueRefinements[def] = generalizedType;

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatReturn *ret) {
  // At this point, the only way scope->returnType should have anything
  // interesting in it is if the function has an explicit return annotation.
  // If this is the case, then we can expect that the return expression
  // conforms to that.
  std::vector<std::optional<TypeId>> expectedTypes;
  for (TypeId ty : scope->returnType)
    expectedTypes.push_back(ty);

  TypePackId exprTypes = checkPack(scope, ret->list, expectedTypes).tp;
  addConstraint(
      scope, ret->location,
      PackSubtypeConstraint{exprTypes, scope->returnType, /*returns*/ true});

  return ControlFlow::Returns;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatBlock *block) {
  ScopePtr innerScope = childScope(block, scope);

  ControlFlow flow = visitBlockWithoutChildScope(innerScope, block);

  // An AstStatBlock has linear control flow, i.e. one entry and one exit, so we
  // can inherit all the changes to the environment occurred by the statements
  // in that block.
  scope->inheritRefinements(innerScope);
  scope->inheritAssignments(innerScope);

  return flow;
}

// TODO Clip?
static void bindFreeType(TypeId a, TypeId b) {
  FreeType *af = getMutable<FreeType>(a);
  FreeType *bf = getMutable<FreeType>(b);

  LUAU_ASSERT(af || bf);

  if (!bf)
    emplaceType<BoundType>(asMutable(a), b);
  else if (!af)
    emplaceType<BoundType>(asMutable(b), a);
  else if (subsumes(bf->scope, af->scope))
    emplaceType<BoundType>(asMutable(a), b);
  else if (subsumes(af->scope, bf->scope))
    emplaceType<BoundType>(asMutable(b), a);
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatAssign *assign) {
  TypePackId resultPack = checkPack(scope, assign->values).tp;

  std::vector<TypeId> valueTypes;
  valueTypes.reserve(assign->vars.size);

  auto [head, tail] = flatten(resultPack);
  if (head.size() >= assign->vars.size) {
    // If the resultPack is definitely long enough for each variable, we can
    // skip the UnpackConstraint and use the result types directly.

    for (size_t i = 0; i < assign->vars.size; ++i)
      valueTypes.push_back(head[i]);
  } else {
    // We're not sure how many types are produced by the right-side
    // expressions.  We'll use an UnpackConstraint to defer this until
    // later.
    for (size_t i = 0; i < assign->vars.size; ++i)
      valueTypes.push_back(arena->addType(BlockedType{}));

    auto uc = addConstraint(scope, assign->location,
                            UnpackConstraint{valueTypes, resultPack});

    for (TypeId t : valueTypes)
      getMutable<BlockedType>(t)->setOwner(uc);
  }

  for (size_t i = 0; i < assign->vars.size; ++i) {
    visitLValue(scope, assign->vars.data[i], valueTypes[i]);
  }

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatCompoundAssign *assign) {
  AstExprBinary binop =
      AstExprBinary{assign->location, assign->op, assign->var, assign->value};
  TypeId resultTy = check(scope, &binop).ty;
  module->astCompoundAssignResultTypes[assign] = resultTy;

  TypeId lhsType = check(scope, assign->var).ty;
  visitLValue(scope, assign->var, lhsType);

  follow(lhsType);
  follow(resultTy);

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatIf *ifStatement) {
  RefinementId refinement = [&]() {
    InConditionalContext flipper{&typeContext};
    return check(scope, ifStatement->condition, std::nullopt).refinement;
  }();

  ScopePtr thenScope = childScope(ifStatement->thenbody, scope);
  applyRefinements(thenScope, ifStatement->condition->location, refinement);

  ScopePtr elseScope = childScope(
      ifStatement->elsebody ? ifStatement->elsebody : ifStatement, scope);
  applyRefinements(
      elseScope,
      ifStatement->elseLocation.value_or(ifStatement->condition->location),
      refinementArena.negation(refinement));

  ControlFlow thencf = visit(thenScope, ifStatement->thenbody);
  ControlFlow elsecf = ControlFlow::None;
  if (ifStatement->elsebody)
    elsecf = visit(elseScope, ifStatement->elsebody);

  if (thencf != ControlFlow::None && elsecf == ControlFlow::None)
    scope->inheritRefinements(elseScope);
  else if (thencf == ControlFlow::None && elsecf != ControlFlow::None)
    scope->inheritRefinements(thenScope);

  if (thencf == ControlFlow::None)
    scope->inheritAssignments(thenScope);
  if (elsecf == ControlFlow::None)
    scope->inheritAssignments(elseScope);

  if (thencf == elsecf)
    return thencf;
  else if (matches(thencf, ControlFlow::Returns | ControlFlow::Throws) &&
           matches(elsecf, ControlFlow::Returns | ControlFlow::Throws))
    return ControlFlow::Returns;
  else
    return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatTypeAlias *alias) {
  if (alias->name == kParseNameError)
    return ControlFlow::None;

  if (alias->name == "typeof") {
    reportError(alias->location,
                GenericError{"Type aliases cannot be named typeof"});
    return ControlFlow::None;
  }

  scope->typeAliasLocations[alias->name.value] = alias->location;
  scope->typeAliasNameLocations[alias->name.value] = alias->nameLocation;

  ScopePtr *defnScope = astTypeAliasDefiningScopes.find(alias);

  std::unordered_map<Name, TypeFun> *typeBindings;
  if (alias->exported)
    typeBindings = &scope->exportedTypeBindings;
  else
    typeBindings = &scope->privateTypeBindings;

  // These will be undefined if the alias was a duplicate definition, in which
  // case we just skip over it.
  auto bindingIt = typeBindings->find(alias->name.value);
  if (bindingIt == typeBindings->end() || defnScope == nullptr)
    return ControlFlow::None;

  TypeId ty = resolveType(*defnScope, alias->type, /* inTypeArguments */ false,
                          /* replaceErrorWithFresh */ false);

  TypeId aliasTy = bindingIt->second.type;
  LUAU_ASSERT(get<BlockedType>(aliasTy));
  if (occursCheck(aliasTy, ty)) {
    emplaceType<BoundType>(asMutable(aliasTy), builtinTypes->anyType);
    reportError(alias->nameLocation, OccursCheckFailed{});
  } else
    emplaceType<BoundType>(asMutable(aliasTy), ty);

  std::vector<TypeId> typeParams;
  for (auto tyParam : createGenerics(*defnScope, alias->generics,
                                     /* useCache */ true, /* addTypes */ false))
    typeParams.push_back(tyParam.second.ty);

  std::vector<TypePackId> typePackParams;
  for (auto tpParam :
       createGenericPacks(*defnScope, alias->genericPacks, /* useCache */ true,
                          /* addTypes */ false))
    typePackParams.push_back(tpParam.second.tp);

  addConstraint(scope, alias->type->location,
                NameConstraint{
                    ty,
                    alias->name.value,
                    /*synthetic=*/false,
                    std::move(typeParams),
                    std::move(typePackParams),
                });

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatDeclareGlobal *global) {
  LUAU_ASSERT(global->type);

  TypeId globalTy =
      resolveType(scope, global->type, /* inTypeArguments */ false);
  Name globalName(global->name.value);

  module->declaredGlobals[globalName] = globalTy;
  rootScope->bindings[global->name] = Binding{globalTy, global->location};

  DefId def = dfg->getDef(global);
  rootScope->lvalueTypes[def] = globalTy;
  rootScope->rvalueRefinements[def] = globalTy;

  return ControlFlow::None;
}

static bool isMetamethod(const Name &name) {
  return name == "__index" || name == "__newindex" || name == "__call" ||
         name == "__concat" || name == "__unm" || name == "__add" ||
         name == "__sub" || name == "__mul" || name == "__div" ||
         name == "__mod" || name == "__pow" || name == "__tostring" ||
         name == "__metatable" || name == "__eq" || name == "__lt" ||
         name == "__le" || name == "__mode" || name == "__iter" ||
         name == "__len" || name == "__idiv";
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatDeclareClass *declaredClass) {
  std::optional<TypeId> superTy = std::make_optional(builtinTypes->classType);
  if (declaredClass->superName) {
    Name superName = Name(declaredClass->superName->value);
    std::optional<TypeFun> lookupType = scope->lookupType(superName);

    if (!lookupType) {
      reportError(declaredClass->location,
                  UnknownSymbol{superName, UnknownSymbol::Type});
      return ControlFlow::None;
    }

    // We don't have generic classes, so this assertion _should_ never be hit.
    LUAU_ASSERT(lookupType->typeParams.size() == 0 &&
                lookupType->typePackParams.size() == 0);
    superTy = lookupType->type;

    if (!get<ClassType>(follow(*superTy))) {
      reportError(
          declaredClass->location,
          GenericError{format(
              "Cannot use non-class type '%s' as a superclass of class '%s'",
              superName.c_str(), declaredClass->name.value)});

      return ControlFlow::None;
    }
  }

  Name className(declaredClass->name.value);

  TypeId classTy = arena->addType(
      ClassType(className, {}, superTy, std::nullopt, {}, {}, module->name));
  ClassType *ctv = getMutable<ClassType>(classTy);

  TypeId metaTy =
      arena->addType(TableType{TableState::Sealed, scope->level, scope.get()});
  TableType *metatable = getMutable<TableType>(metaTy);

  ctv->metatable = metaTy;

  scope->exportedTypeBindings[className] = TypeFun{{}, classTy};

  if (declaredClass->indexer) {
    RecursionCounter counter{&recursionCount};

    if (recursionCount >= FInt::LuauCheckRecursionLimit) {
      reportCodeTooComplex(declaredClass->indexer->location);
    } else {
      ctv->indexer = TableIndexer{
          resolveType(scope, declaredClass->indexer->indexType,
                      /* inTypeArguments */ false),
          resolveType(scope, declaredClass->indexer->resultType,
                      /* inTypeArguments */ false),
      };
    }
  }

  for (const AstDeclaredClassProp &prop : declaredClass->props) {
    Name propName(prop.name.value);
    TypeId propTy = resolveType(scope, prop.ty, /* inTypeArguments */ false);

    bool assignToMetatable = isMetamethod(propName);

    // Function types always take 'self', but this isn't reflected in the
    // parsed annotation. Add it here.
    if (prop.isMethod) {
      if (FunctionType *ftv = getMutable<FunctionType>(propTy)) {
        ftv->argNames.insert(ftv->argNames.begin(),
                             FunctionArgument{"self", {}});
        ftv->argTypes = addTypePack({classTy}, ftv->argTypes);

        ftv->hasSelf = true;

        if (FFlag::LuauDeclarationExtraPropData) {
          FunctionDefinition defn;

          defn.definitionModuleName = module->name;
          defn.definitionLocation = prop.location;
          // No data is preserved for varargLocation
          defn.originalNameLocation = prop.nameLocation;

          ftv->definition = defn;
        }
      }
    }

    TableType::Props &props = assignToMetatable ? metatable->props : ctv->props;

    if (props.count(propName) == 0) {
      if (FFlag::LuauDeclarationExtraPropData)
        props[propName] = {propTy, /*deprecated*/ false,
                           /*deprecatedSuggestion*/ "", prop.location};
      else
        props[propName] = {propTy};
    } else if (FFlag::LuauDeclarationExtraPropData) {
      Luau::Property &prop = props[propName];
      TypeId currentTy = prop.type();

      // We special-case this logic to keep the intersection flat; otherwise we
      // would create a ton of nested intersection types.
      if (const IntersectionType *itv = get<IntersectionType>(currentTy)) {
        std::vector<TypeId> options = itv->parts;
        options.push_back(propTy);
        TypeId newItv = arena->addType(IntersectionType{std::move(options)});

        prop.readTy = newItv;
        prop.writeTy = newItv;
      } else if (get<FunctionType>(currentTy)) {
        TypeId intersection =
            arena->addType(IntersectionType{{currentTy, propTy}});

        prop.readTy = intersection;
        prop.writeTy = intersection;
      } else {
        reportError(declaredClass->location,
                    GenericError{
                        format("Cannot overload non-function class member '%s'",
                               propName.c_str())});
      }
    } else {
      TypeId currentTy = props[propName].type();

      // We special-case this logic to keep the intersection flat; otherwise we
      // would create a ton of nested intersection types.
      if (const IntersectionType *itv = get<IntersectionType>(currentTy)) {
        std::vector<TypeId> options = itv->parts;
        options.push_back(propTy);
        TypeId newItv = arena->addType(IntersectionType{std::move(options)});

        props[propName] = {newItv};
      } else if (get<FunctionType>(currentTy)) {
        TypeId intersection =
            arena->addType(IntersectionType{{currentTy, propTy}});

        props[propName] = {intersection};
      } else {
        reportError(declaredClass->location,
                    GenericError{
                        format("Cannot overload non-function class member '%s'",
                               propName.c_str())});
      }
    }
  }

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatDeclareFunction *global) {
  std::vector<std::pair<Name, GenericTypeDefinition>> generics =
      createGenerics(scope, global->generics);
  std::vector<std::pair<Name, GenericTypePackDefinition>> genericPacks =
      createGenericPacks(scope, global->genericPacks);

  std::vector<TypeId> genericTys;
  genericTys.reserve(generics.size());
  for (auto &[name, generic] : generics) {
    genericTys.push_back(generic.ty);
  }

  std::vector<TypePackId> genericTps;
  genericTps.reserve(genericPacks.size());
  for (auto &[name, generic] : genericPacks) {
    genericTps.push_back(generic.tp);
  }

  ScopePtr funScope = scope;
  if (!generics.empty() || !genericPacks.empty())
    funScope = childScope(global, scope);

  TypePackId paramPack =
      resolveTypePack(funScope, global->params, /* inTypeArguments */ false);
  TypePackId retPack =
      resolveTypePack(funScope, global->retTypes, /* inTypeArguments */ false);

  FunctionDefinition defn;

  if (FFlag::LuauDeclarationExtraPropData) {
    defn.definitionModuleName = module->name;
    defn.definitionLocation = global->location;
    defn.varargLocation = global->vararg
                              ? std::make_optional(global->varargLocation)
                              : std::nullopt;
    defn.originalNameLocation = global->nameLocation;
  }

  TypeId fnType = arena->addType(
      FunctionType{TypeLevel{}, funScope.get(), std::move(genericTys),
                   std::move(genericTps), paramPack, retPack, defn});
  FunctionType *ftv = getMutable<FunctionType>(fnType);
  ftv->isCheckedFunction =
      FFlag::LuauAttributeSyntax ? global->isCheckedFunction() : false;

  ftv->argNames.reserve(global->paramNames.size);
  for (const auto &el : global->paramNames)
    ftv->argNames.push_back(FunctionArgument{el.first.value, el.second});

  Name fnName(global->name.value);

  module->declaredGlobals[fnName] = fnType;
  scope->bindings[global->name] = Binding{fnType, global->location};

  DefId def = dfg->getDef(global);
  rootScope->lvalueTypes[def] = fnType;
  rootScope->rvalueRefinements[def] = fnType;

  return ControlFlow::None;
}

ControlFlow ConstraintGenerator::visit(const ScopePtr &scope,
                                       AstStatError *error) {
  for (AstStat *stat : error->statements)
    visit(scope, stat);
  for (AstExpr *expr : error->expressions)
    check(scope, expr);

  return ControlFlow::None;
}

InferencePack ConstraintGenerator::checkPack(
    const ScopePtr &scope, AstArray<AstExpr *> exprs,
    const std::vector<std::optional<TypeId>> &expectedTypes) {
  std::vector<TypeId> head;
  std::optional<TypePackId> tail;

  for (size_t i = 0; i < exprs.size; ++i) {
    AstExpr *expr = exprs.data[i];
    if (i < exprs.size - 1) {
      std::optional<TypeId> expectedType;
      if (i < expectedTypes.size())
        expectedType = expectedTypes[i];
      head.push_back(check(scope, expr, expectedType).ty);
    } else {
      std::vector<std::optional<TypeId>> expectedTailTypes;
      if (i < expectedTypes.size())
        expectedTailTypes.assign(begin(expectedTypes) + i, end(expectedTypes));
      tail = checkPack(scope, expr, expectedTailTypes).tp;
    }
  }

  return InferencePack{addTypePack(std::move(head), tail)};
}

InferencePack ConstraintGenerator::checkPack(
    const ScopePtr &scope, AstExpr *expr,
    const std::vector<std::optional<TypeId>> &expectedTypes, bool generalize) {
  RecursionCounter counter{&recursionCount};

  if (recursionCount >= FInt::LuauCheckRecursionLimit) {
    reportCodeTooComplex(expr->location);
    return InferencePack{builtinTypes->errorRecoveryTypePack()};
  }

  InferencePack result;

  if (AstExprCall *call = expr->as<AstExprCall>())
    result = checkPack(scope, call);
  else if (AstExprVarargs *varargs = expr->as<AstExprVarargs>()) {
    if (scope->varargPack)
      result = InferencePack{*scope->varargPack};
    else
      result = InferencePack{builtinTypes->errorRecoveryTypePack()};
  } else {
    std::optional<TypeId> expectedType;
    if (!expectedTypes.empty())
      expectedType = expectedTypes[0];
    TypeId t =
        check(scope, expr, expectedType, /*forceSingletons*/ false, generalize)
            .ty;
    result = InferencePack{arena->addTypePack({t})};
  }

  LUAU_ASSERT(result.tp);
  module->astTypePacks[expr] = result.tp;
  return result;
}

InferencePack ConstraintGenerator::checkPack(const ScopePtr &scope,
                                             AstExprCall *call) {
  std::vector<AstExpr *> exprArgs;

  std::vector<RefinementId> returnRefinements;
  std::vector<std::optional<TypeId>> discriminantTypes;

  if (call->self) {
    AstExprIndexName *indexExpr = call->func->as<AstExprIndexName>();
    if (!indexExpr)
      ice->ice("method call expression has no 'self'");

    exprArgs.push_back(indexExpr->expr);

    if (auto key = dfg->getRefinementKey(indexExpr->expr)) {
      TypeId discriminantTy = arena->addType(BlockedType{});
      returnRefinements.push_back(
          refinementArena.proposition(key, discriminantTy));
      discriminantTypes.push_back(discriminantTy);
    } else
      discriminantTypes.push_back(std::nullopt);
  }

  for (AstExpr *arg : call->args) {
    exprArgs.push_back(arg);

    if (auto key = dfg->getRefinementKey(arg)) {
      TypeId discriminantTy = arena->addType(BlockedType{});
      returnRefinements.push_back(
          refinementArena.proposition(key, discriminantTy));
      discriminantTypes.push_back(discriminantTy);
    } else
      discriminantTypes.push_back(std::nullopt);
  }

  Checkpoint funcBeginCheckpoint = checkpoint(this);

  TypeId fnType = check(scope, call->func).ty;

  Checkpoint funcEndCheckpoint = checkpoint(this);

  std::vector<std::optional<TypeId>> expectedTypesForCall =
      getExpectedCallTypesForFunctionOverloads(fnType);

  module->astOriginalCallTypes[call->func] = fnType;
  module->astOriginalCallTypes[call] = fnType;

  Checkpoint argBeginCheckpoint = checkpoint(this);

  std::vector<TypeId> args;
  std::optional<TypePackId> argTail;
  std::vector<RefinementId> argumentRefinements;

  for (size_t i = 0; i < exprArgs.size(); ++i) {
    AstExpr *arg = exprArgs[i];

    if (i == 0 && call->self) {
      // The self type has already been computed as a side effect of
      // computing fnType.  If computing that did not cause us to exceed a
      // recursion limit, we can fetch it from astTypes rather than
      // recomputing it.
      TypeId *selfTy = module->astTypes.find(exprArgs[0]);
      if (selfTy)
        args.push_back(*selfTy);
      else
        args.push_back(freshType(scope));
    } else if (i < exprArgs.size() - 1 ||
               !(arg->is<AstExprCall>() || arg->is<AstExprVarargs>())) {
      auto [ty, refinement] =
          check(scope, arg, /*expectedType*/ std::nullopt,
                /*forceSingleton*/ false, /*generalize*/ false);
      args.push_back(ty);
      argumentRefinements.push_back(refinement);
    } else {
      auto [tp, refis] = checkPack(scope, arg, {});
      argTail = tp;
      argumentRefinements.insert(argumentRefinements.end(), refis.begin(),
                                 refis.end());
    }
  }

  Checkpoint argEndCheckpoint = checkpoint(this);

  if (matchSetmetatable(*call)) {
    TypePack argTailPack;
    if (argTail && args.size() < 2)
      argTailPack =
          extendTypePack(*arena, builtinTypes, *argTail, 2 - args.size());

    TypeId target = nullptr;
    TypeId mt = nullptr;

    if (args.size() + argTailPack.head.size() == 2) {
      target = args.size() > 0 ? args[0] : argTailPack.head[0];
      mt = args.size() > 1 ? args[1]
                           : argTailPack.head[args.size() == 0 ? 1 : 0];
    } else {
      std::vector<TypeId> unpackedTypes;
      if (args.size() > 0)
        target = args[0];
      else {
        target = arena->addType(BlockedType{});
        unpackedTypes.emplace_back(target);
      }

      mt = arena->addType(BlockedType{});
      unpackedTypes.emplace_back(mt);

      auto c = addConstraint(scope, call->location,
                             UnpackConstraint{unpackedTypes, *argTail});
      getMutable<BlockedType>(mt)->setOwner(c);
      if (auto b = getMutable<BlockedType>(target);
          b && b->getOwner() == nullptr)
        b->setOwner(c);
    }

    LUAU_ASSERT(target);
    LUAU_ASSERT(mt);

    target = follow(target);

    AstExpr *targetExpr = call->args.data[0];

    TypeId resultTy = nullptr;

    if (isTableUnion(target)) {
      const UnionType *targetUnion = get<UnionType>(target);
      std::vector<TypeId> newParts;

      for (TypeId ty : targetUnion)
        newParts.push_back(arena->addType(MetatableType{ty, mt}));

      resultTy = arena->addType(UnionType{std::move(newParts)});
    } else
      resultTy = arena->addType(MetatableType{target, mt});

    if (AstExprLocal *targetLocal = targetExpr->as<AstExprLocal>()) {
      scope->bindings[targetLocal->local].typeId = resultTy;

      DefId def = dfg->getDef(targetLocal);
      scope->lvalueTypes[def] =
          resultTy; // TODO: typestates: track this as an assignment
      scope->rvalueRefinements[def] =
          resultTy; // TODO: typestates: track this as an assignment

      recordInferredBinding(targetLocal->local, resultTy);
    }

    return InferencePack{arena->addTypePack({resultTy}),
                         {refinementArena.variadic(returnRefinements)}};
  } else {
    if (matchAssert(*call) && !argumentRefinements.empty())
      applyRefinements(scope, call->args.data[0]->location,
                       argumentRefinements[0]);

    // TODO: How do expectedTypes play into this?  Do they?
    TypePackId rets = arena->addTypePack(BlockedTypePack{});
    TypePackId argPack = addTypePack(std::move(args), argTail);
    FunctionType ftv(TypeLevel{}, scope.get(), argPack, rets, std::nullopt,
                     call->self);

    /*
     * To make bidirectional type checking work, we need to solve these
     * constraints in a particular order:
     *
     * 1. Solve the function type
     * 2. Propagate type information from the function type to the argument
     * types
     * 3. Solve the argument types
     * 4. Solve the call
     */

    NotNull<Constraint> checkConstraint =
        addConstraint(scope, call->func->location,
                      FunctionCheckConstraint{
                          fnType, argPack, call, NotNull{&module->astTypes},
                          NotNull{&module->astExpectedTypes}});

    forEachConstraint(funcBeginCheckpoint, funcEndCheckpoint, this,
                      [checkConstraint](const ConstraintPtr &constraint) {
                        checkConstraint->dependencies.emplace_back(
                            constraint.get());
                      });

    NotNull<Constraint> callConstraint =
        addConstraint(scope, call->func->location,
                      FunctionCallConstraint{
                          fnType,
                          argPack,
                          rets,
                          call,
                          std::move(discriminantTypes),
                          &module->astOverloadResolvedTypes,
                      });

    getMutable<BlockedTypePack>(rets)->owner = callConstraint.get();

    callConstraint->dependencies.push_back(checkConstraint);

    forEachConstraint(
        argBeginCheckpoint, argEndCheckpoint, this,
        [checkConstraint, callConstraint](const ConstraintPtr &constraint) {
          constraint->dependencies.emplace_back(checkConstraint);

          callConstraint->dependencies.emplace_back(constraint.get());
        });

    return InferencePack{rets, {refinementArena.variadic(returnRefinements)}};
  }
}

Inference ConstraintGenerator::check(const ScopePtr &scope, AstExpr *expr,
                                     std::optional<TypeId> expectedType,
                                     bool forceSingleton, bool generalize) {
  RecursionCounter counter{&recursionCount};

  if (recursionCount >= FInt::LuauCheckRecursionLimit) {
    reportCodeTooComplex(expr->location);
    return Inference{builtinTypes->errorRecoveryType()};
  }

  Inference result;

  if (auto group = expr->as<AstExprGroup>())
    result = check(scope, group->expr, expectedType, forceSingleton);
  else if (auto stringExpr = expr->as<AstExprConstantString>())
    result = check(scope, stringExpr, expectedType, forceSingleton);
  else if (expr->is<AstExprConstantNumber>())
    result = Inference{builtinTypes->numberType};
  else if (auto boolExpr = expr->as<AstExprConstantBool>())
    result = check(scope, boolExpr, expectedType, forceSingleton);
  else if (expr->is<AstExprConstantNil>())
    result = Inference{builtinTypes->nilType};
  else if (auto local = expr->as<AstExprLocal>())
    result = check(scope, local);
  else if (auto global = expr->as<AstExprGlobal>())
    result = check(scope, global);
  else if (expr->is<AstExprVarargs>())
    result = flattenPack(scope, expr->location, checkPack(scope, expr));
  else if (auto call = expr->as<AstExprCall>())
    result = flattenPack(scope, expr->location,
                         checkPack(scope, call)); // TODO: needs predicates too
  else if (auto a = expr->as<AstExprFunction>())
    result = check(scope, a, expectedType, generalize);
  else if (auto indexName = expr->as<AstExprIndexName>())
    result = check(scope, indexName);
  else if (auto indexExpr = expr->as<AstExprIndexExpr>())
    result = check(scope, indexExpr);
  else if (auto table = expr->as<AstExprTable>())
    result = check(scope, table, expectedType);
  else if (auto unary = expr->as<AstExprUnary>())
    result = check(scope, unary);
  else if (auto binary = expr->as<AstExprBinary>())
    result = check(scope, binary, expectedType);
  else if (auto ifElse = expr->as<AstExprIfElse>())
    result = check(scope, ifElse, expectedType);
  else if (auto typeAssert = expr->as<AstExprTypeAssertion>())
    result = check(scope, typeAssert);
  else if (auto interpString = expr->as<AstExprInterpString>())
    result = check(scope, interpString);
  else if (auto err = expr->as<AstExprError>()) {
    // Open question: Should we traverse into this?
    for (AstExpr *subExpr : err->expressions)
      check(scope, subExpr);

    result = Inference{builtinTypes->errorRecoveryType()};
  } else {
    LUAU_ASSERT(0);
    result = Inference{freshType(scope)};
  }

  LUAU_ASSERT(result.ty);
  module->astTypes[expr] = result.ty;
  if (expectedType)
    module->astExpectedTypes[expr] = *expectedType;
  return result;
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprConstantString *string,
                                     std::optional<TypeId> expectedType,
                                     bool forceSingleton) {
  if (forceSingleton)
    return Inference{arena->addType(SingletonType{
        StringSingleton{std::string{string->value.data, string->value.size}}})};

  FreeType ft = FreeType{scope.get()};
  ft.lowerBound = arena->addType(SingletonType{
      StringSingleton{std::string{string->value.data, string->value.size}}});
  ft.upperBound = builtinTypes->stringType;
  const TypeId freeTy = arena->addType(ft);
  addConstraint(
      scope, string->location,
      PrimitiveTypeConstraint{freeTy, expectedType, builtinTypes->stringType});
  return Inference{freeTy};
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprConstantBool *boolExpr,
                                     std::optional<TypeId> expectedType,
                                     bool forceSingleton) {
  const TypeId singletonType =
      boolExpr->value ? builtinTypes->trueType : builtinTypes->falseType;
  if (forceSingleton)
    return Inference{singletonType};

  FreeType ft = FreeType{scope.get()};
  ft.lowerBound = singletonType;
  ft.upperBound = builtinTypes->booleanType;
  const TypeId freeTy = arena->addType(ft);
  addConstraint(
      scope, boolExpr->location,
      PrimitiveTypeConstraint{freeTy, expectedType, builtinTypes->booleanType});
  return Inference{freeTy};
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprLocal *local) {
  const RefinementKey *key = dfg->getRefinementKey(local);
  std::optional<DefId> rvalueDef = dfg->getRValueDefForCompoundAssign(local);
  LUAU_ASSERT(key || rvalueDef);

  std::optional<TypeId> maybeTy;

  // if we have a refinement key, we can look up its type.
  if (key)
    maybeTy = lookup(scope, local->location, key->def);

  // if the current def doesn't have a type, we might be doing a compound
  // assignment and therefore might need to look at the rvalue def instead.
  if (!maybeTy && rvalueDef)
    maybeTy = lookup(scope, local->location, *rvalueDef);

  if (maybeTy) {
    TypeId ty = follow(*maybeTy);

    recordInferredBinding(local->local, ty);

    return Inference{
        ty, refinementArena.proposition(key, builtinTypes->truthyType)};
  } else
    ice->ice("CG: AstExprLocal came before its declaration?");
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprGlobal *global) {
  const RefinementKey *key = dfg->getRefinementKey(global);
  std::optional<DefId> rvalueDef = dfg->getRValueDefForCompoundAssign(global);
  LUAU_ASSERT(key || rvalueDef);

  // we'll use whichever of the two definitions we have here.
  DefId def = key ? key->def : *rvalueDef;

  /* prepopulateGlobalScope() has already added all global functions to the
   * environment by this point, so any global that is not already in-scope is
   * definitely an unknown symbol.
   */
  if (auto ty = lookup(scope, global->location, def, /*prototype=*/false)) {
    rootScope->lvalueTypes[def] = *ty;
    return Inference{
        *ty, refinementArena.proposition(key, builtinTypes->truthyType)};
  } else
    return Inference{builtinTypes->errorRecoveryType()};
}

Inference ConstraintGenerator::checkIndexName(const ScopePtr &scope,
                                              const RefinementKey *key,
                                              AstExpr *indexee,
                                              const std::string &index,
                                              Location indexLocation) {
  TypeId obj = check(scope, indexee).ty;
  TypeId result = nullptr;

  // We optimize away the HasProp constraint in simple cases so that we can
  // reason about updates to unsealed tables more accurately.

  const TableType *tt = getTableType(obj);

  // This is a little bit iffy but I *believe* it is okay because, if the
  // local's domain is going to be extended at all, it will be someplace after
  // the current lexical position within the script.
  if (!tt) {
    if (TypeIds *localDomain = localTypes.find(obj);
        localDomain && 1 == localDomain->size())
      tt = getTableType(*localDomain->begin());
  }

  if (tt) {
    auto it = tt->props.find(index);
    if (it != tt->props.end() && it->second.readTy.has_value())
      result = *it->second.readTy;
  }

  if (!result) {
    result = arena->addType(BlockedType{});

    auto c = addConstraint(scope, indexee->location,
                           HasPropConstraint{result, obj, std::move(index),
                                             ValueContext::RValue,
                                             inConditional(typeContext)});
    getMutable<BlockedType>(result)->setOwner(c);
  }

  if (key) {
    if (auto ty = lookup(scope, indexLocation, key->def))
      return Inference{
          *ty, refinementArena.proposition(key, builtinTypes->truthyType)};

    scope->rvalueRefinements[key->def] = result;
  }

  if (key)
    return Inference{
        result, refinementArena.proposition(key, builtinTypes->truthyType)};
  else
    return Inference{result};
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprIndexName *indexName) {
  const RefinementKey *key = dfg->getRefinementKey(indexName);
  return checkIndexName(scope, key, indexName->expr, indexName->index.value,
                        indexName->indexLocation);
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprIndexExpr *indexExpr) {
  if (auto constantString = indexExpr->index->as<AstExprConstantString>()) {
    const RefinementKey *key = dfg->getRefinementKey(indexExpr);
    return checkIndexName(scope, key, indexExpr->expr,
                          constantString->value.data, indexExpr->location);
  }

  TypeId obj = check(scope, indexExpr->expr).ty;
  TypeId indexType = check(scope, indexExpr->index).ty;

  TypeId result = arena->addType(BlockedType{});

  const RefinementKey *key = dfg->getRefinementKey(indexExpr);
  if (key) {
    if (auto ty = lookup(scope, indexExpr->location, key->def))
      return Inference{
          *ty, refinementArena.proposition(key, builtinTypes->truthyType)};

    scope->rvalueRefinements[key->def] = result;
  }

  auto c = addConstraint(scope, indexExpr->expr->location,
                         HasIndexerConstraint{result, obj, indexType});
  getMutable<BlockedType>(result)->setOwner(c);

  if (key)
    return Inference{
        result, refinementArena.proposition(key, builtinTypes->truthyType)};
  else
    return Inference{result};
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprFunction *func,
                                     std::optional<TypeId> expectedType,
                                     bool generalize) {
  Checkpoint startCheckpoint = checkpoint(this);
  FunctionSignature sig = checkFunctionSignature(scope, func, expectedType);

  interiorTypes.push_back(std::vector<TypeId>{});
  checkFunctionBody(sig.bodyScope, func);
  Checkpoint endCheckpoint = checkpoint(this);

  TypeId generalizedTy = arena->addType(BlockedType{});
  NotNull<Constraint> gc =
      addConstraint(sig.signatureScope, func->location,
                    GeneralizationConstraint{generalizedTy, sig.signature,
                                             std::move(interiorTypes.back())});
  getMutable<BlockedType>(generalizedTy)->setOwner(gc);
  interiorTypes.pop_back();

  Constraint *previous = nullptr;
  forEachConstraint(startCheckpoint, endCheckpoint, this,
                    [gc, &previous](const ConstraintPtr &constraint) {
                      gc->dependencies.emplace_back(constraint.get());

                      if (auto psc = get<PackSubtypeConstraint>(*constraint);
                          psc && psc->returns) {
                        if (previous)
                          constraint->dependencies.push_back(NotNull{previous});

                        previous = constraint.get();
                      }
                    });

  if (generalize && hasFreeType(sig.signature)) {
    return Inference{generalizedTy};
  } else {
    return Inference{sig.signature};
  }
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprUnary *unary) {
  auto [operandType, refinement] = check(scope, unary->expr);

  switch (unary->op) {
  case AstExprUnary::Op::Not: {
    TypeId resultType =
        createTypeFunctionInstance(builtinTypeFunctions().notFunc,
                                   {operandType}, {}, scope, unary->location);
    return Inference{resultType, refinementArena.negation(refinement)};
  }
  case AstExprUnary::Op::Len: {
    TypeId resultType =
        createTypeFunctionInstance(builtinTypeFunctions().lenFunc,
                                   {operandType}, {}, scope, unary->location);
    return Inference{resultType, refinementArena.negation(refinement)};
  }
  case AstExprUnary::Op::Minus: {
    TypeId resultType =
        createTypeFunctionInstance(builtinTypeFunctions().unmFunc,
                                   {operandType}, {}, scope, unary->location);
    return Inference{resultType, refinementArena.negation(refinement)};
  }
  default: // msvc can't prove that this is exhaustive.
    LUAU_UNREACHABLE();
  }
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprBinary *binary,
                                     std::optional<TypeId> expectedType) {
  auto [leftType, rightType, refinement] =
      checkBinary(scope, binary, expectedType);

  switch (binary->op) {
  case AstExprBinary::Op::Add: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().addFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Sub: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().subFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Mul: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().mulFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Div: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().divFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::FloorDiv: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().idivFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Pow: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().powFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Mod: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().modFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Concat: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().concatFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::And: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().andFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Or: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().orFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::CompareLt: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().ltFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::CompareGe: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().ltFunc,
        {rightType, leftType}, // lua decided that `__ge(a, b)` is instead just
                               // `__lt(b, a)`
        {}, scope, binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::CompareLe: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().leFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::CompareGt: {
    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().leFunc,
        {rightType, leftType}, // lua decided that `__gt(a, b)` is instead just
                               // `__le(b, a)`
        {}, scope, binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::CompareEq:
  case AstExprBinary::Op::CompareNe: {
    DefId leftDef = dfg->getDef(binary->left);
    DefId rightDef = dfg->getDef(binary->right);
    bool leftSubscripted = containsSubscriptedDefinition(leftDef);
    bool rightSubscripted = containsSubscriptedDefinition(rightDef);

    if (leftSubscripted && rightSubscripted) {
      // we cannot add nil in this case because then we will blindly accept
      // comparisons that we should not.
    } else if (leftSubscripted)
      leftType =
          makeUnion(scope, binary->location, leftType, builtinTypes->nilType);
    else if (rightSubscripted)
      rightType =
          makeUnion(scope, binary->location, rightType, builtinTypes->nilType);

    TypeId resultType = createTypeFunctionInstance(
        builtinTypeFunctions().eqFunc, {leftType, rightType}, {}, scope,
        binary->location);
    return Inference{resultType, std::move(refinement)};
  }
  case AstExprBinary::Op::Op__Count:
    ice->ice("Op__Count should never be generated in an AST.");
  default: // msvc can't prove that this is exhaustive.
    LUAU_UNREACHABLE();
  }
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprIfElse *ifElse,
                                     std::optional<TypeId> expectedType) {
  RefinementId refinement = [&]() {
    InConditionalContext flipper{&typeContext};
    ScopePtr condScope = childScope(ifElse->condition, scope);
    return check(condScope, ifElse->condition).refinement;
  }();

  ScopePtr thenScope = childScope(ifElse->trueExpr, scope);
  applyRefinements(thenScope, ifElse->trueExpr->location, refinement);
  TypeId thenType = check(thenScope, ifElse->trueExpr, expectedType).ty;

  ScopePtr elseScope = childScope(ifElse->falseExpr, scope);
  applyRefinements(elseScope, ifElse->falseExpr->location,
                   refinementArena.negation(refinement));
  TypeId elseType = check(elseScope, ifElse->falseExpr, expectedType).ty;

  return Inference{
      expectedType ? *expectedType
                   : makeUnion(scope, ifElse->location, thenType, elseType)};
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprTypeAssertion *typeAssert) {
  check(scope, typeAssert->expr, std::nullopt);
  return Inference{
      resolveType(scope, typeAssert->annotation, /* inTypeArguments */ false)};
}

Inference ConstraintGenerator::check(const ScopePtr &scope,
                                     AstExprInterpString *interpString) {
  for (AstExpr *expr : interpString->expressions)
    check(scope, expr);

  return Inference{builtinTypes->stringType};
}

std::tuple<TypeId, TypeId, RefinementId>
ConstraintGenerator::checkBinary(const ScopePtr &scope, AstExprBinary *binary,
                                 std::optional<TypeId> expectedType) {
  if (binary->op == AstExprBinary::And) {
    std::optional<TypeId> relaxedExpectedLhs;

    if (expectedType)
      relaxedExpectedLhs =
          arena->addType(UnionType{{builtinTypes->falsyType, *expectedType}});

    auto [leftType, leftRefinement] =
        check(scope, binary->left, relaxedExpectedLhs);

    ScopePtr rightScope = childScope(binary->right, scope);
    applyRefinements(rightScope, binary->right->location, leftRefinement);
    auto [rightType, rightRefinement] =
        check(rightScope, binary->right, expectedType);

    return {leftType, rightType,
            refinementArena.conjunction(leftRefinement, rightRefinement)};
  } else if (binary->op == AstExprBinary::Or) {
    std::optional<TypeId> relaxedExpectedLhs;

    if (expectedType)
      relaxedExpectedLhs =
          arena->addType(UnionType{{builtinTypes->falsyType, *expectedType}});

    auto [leftType, leftRefinement] =
        check(scope, binary->left, relaxedExpectedLhs);

    ScopePtr rightScope = childScope(binary->right, scope);
    applyRefinements(rightScope, binary->right->location,
                     refinementArena.negation(leftRefinement));
    auto [rightType, rightRefinement] =
        check(rightScope, binary->right, expectedType);

    return {leftType, rightType,
            refinementArena.disjunction(leftRefinement, rightRefinement)};
  } else if (auto typeguard = matchTypeGuard(binary)) {
    TypeId leftType = check(scope, binary->left).ty;
    TypeId rightType = check(scope, binary->right).ty;

    const RefinementKey *key = dfg->getRefinementKey(typeguard->target);
    if (!key)
      return {leftType, rightType, nullptr};

    TypeId discriminantTy = builtinTypes->neverType;
    if (typeguard->type == "nil")
      discriminantTy = builtinTypes->nilType;
    else if (typeguard->type == "string")
      discriminantTy = builtinTypes->stringType;
    else if (typeguard->type == "number")
      discriminantTy = builtinTypes->numberType;
    else if (typeguard->type == "boolean")
      discriminantTy = builtinTypes->booleanType;
    else if (typeguard->type == "thread")
      discriminantTy = builtinTypes->threadType;
    else if (typeguard->type == "buffer")
      discriminantTy = builtinTypes->bufferType;
    else if (typeguard->type == "table")
      discriminantTy = builtinTypes->tableType;
    else if (typeguard->type == "function")
      discriminantTy = builtinTypes->functionType;
    else if (typeguard->type == "userdata") {
      // For now, we don't really care about being accurate with userdata if the
      // typeguard was using typeof.
      discriminantTy = builtinTypes->classType;
    } else if (!typeguard->isTypeof && typeguard->type == "vector")
      discriminantTy = builtinTypes->neverType; // TODO: figure out a way to
                                                // deal with this quirky type
    else if (!typeguard->isTypeof)
      discriminantTy = builtinTypes->neverType;
    else if (auto typeFun = globalScope->lookupType(typeguard->type);
             typeFun && typeFun->typeParams.empty() &&
             typeFun->typePackParams.empty()) {
      TypeId ty = follow(typeFun->type);

      // We're only interested in the root class of any classes.
      if (auto ctv = get<ClassType>(ty);
          ctv && ctv->parent == builtinTypes->classType)
        discriminantTy = ty;
    }

    RefinementId proposition = refinementArena.proposition(key, discriminantTy);
    if (binary->op == AstExprBinary::CompareEq)
      return {leftType, rightType, proposition};
    else if (binary->op == AstExprBinary::CompareNe)
      return {leftType, rightType, refinementArena.negation(proposition)};
    else
      ice->ice("matchTypeGuard should only return a Some under `==` or `~=`!");
  } else if (binary->op == AstExprBinary::CompareEq ||
             binary->op == AstExprBinary::CompareNe) {
    // We are checking a binary expression of the form a op b
    // Just because a op b is epxected to return a bool, doesn't mean a, b are
    // expected to be bools too
    TypeId leftType = check(scope, binary->left, {}, true).ty;
    TypeId rightType = check(scope, binary->right, {}, true).ty;

    RefinementId leftRefinement = refinementArena.proposition(
        dfg->getRefinementKey(binary->left), rightType);
    RefinementId rightRefinement = refinementArena.proposition(
        dfg->getRefinementKey(binary->right), leftType);

    if (binary->op == AstExprBinary::CompareNe) {
      leftRefinement = refinementArena.negation(leftRefinement);
      rightRefinement = refinementArena.negation(rightRefinement);
    }

    return {leftType, rightType,
            refinementArena.equivalence(leftRefinement, rightRefinement)};
  } else {
    TypeId leftType = check(scope, binary->left).ty;
    TypeId rightType = check(scope, binary->right).ty;
    return {leftType, rightType, nullptr};
  }
}

void ConstraintGenerator::visitLValue(const ScopePtr &scope, AstExpr *expr,
                                      TypeId rhsType) {
  if (auto e = expr->as<AstExprLocal>())
    visitLValue(scope, e, rhsType);
  else if (auto e = expr->as<AstExprGlobal>())
    visitLValue(scope, e, rhsType);
  else if (auto e = expr->as<AstExprIndexName>())
    visitLValue(scope, e, rhsType);
  else if (auto e = expr->as<AstExprIndexExpr>())
    visitLValue(scope, e, rhsType);
  else if (auto e = expr->as<AstExprError>()) {
    // Nothing?
  } else
    ice->ice("Unexpected lvalue expression", expr->location);
}

void ConstraintGenerator::visitLValue(const ScopePtr &scope,
                                      AstExprLocal *local, TypeId rhsType) {
  std::optional<TypeId> annotatedTy = scope->lookup(local->local);
  LUAU_ASSERT(annotatedTy);

  const DefId defId = dfg->getDef(local);
  std::optional<TypeId> ty = scope->lookupUnrefinedType(defId);

  if (ty) {
    TypeIds *localDomain = localTypes.find(*ty);
    if (localDomain)
      localDomain->insert(rhsType);
  } else {
    ty = arena->addType(BlockedType{});
    localTypes[*ty].insert(rhsType);

    if (annotatedTy) {
      switch (shouldSuppressErrors(normalizer, *annotatedTy)) {
      case ErrorSuppression::DoNotSuppress:
        break;
      case ErrorSuppression::Suppress:
        ty = simplifyUnion(builtinTypes, arena, *ty, builtinTypes->errorType)
                 .result;
        break;
      case ErrorSuppression::NormalizationFailed:
        reportError(local->local->annotation->location,
                    NormalizationTooComplex{});
        break;
      }
    }

    scope->lvalueTypes[defId] = *ty;
  }

  recordInferredBinding(local->local, *ty);

  if (annotatedTy)
    addConstraint(scope, local->location,
                  SubtypeConstraint{rhsType, *annotatedTy});

  if (TypeIds *localDomain = localTypes.find(*ty))
    localDomain->insert(rhsType);
}

void ConstraintGenerator::visitLValue(const ScopePtr &scope,
                                      AstExprGlobal *global, TypeId rhsType) {
  std::optional<TypeId> annotatedTy = scope->lookup(Symbol{global->name});
  if (annotatedTy) {
    DefId def = dfg->getDef(global);
    rootScope->lvalueTypes[def] = rhsType;

    addConstraint(scope, global->location,
                  SubtypeConstraint{rhsType, *annotatedTy});
  }
}

void ConstraintGenerator::visitLValue(const ScopePtr &scope,
                                      AstExprIndexName *expr, TypeId rhsType) {
  TypeId lhsTy = check(scope, expr->expr).ty;
  TypeId propTy = arena->addType(BlockedType{});
  module->astTypes[expr] = propTy;

  bool incremented = recordPropertyAssignment(lhsTy);

  auto apc = addConstraint(scope, expr->location,
                           AssignPropConstraint{lhsTy, expr->index.value,
                                                rhsType, expr->indexLocation,
                                                propTy, incremented});
  getMutable<BlockedType>(propTy)->setOwner(apc);
}

void ConstraintGenerator::visitLValue(const ScopePtr &scope,
                                      AstExprIndexExpr *expr, TypeId rhsType) {
  if (auto constantString = expr->index->as<AstExprConstantString>()) {
    TypeId lhsTy = check(scope, expr->expr).ty;
    TypeId propTy = arena->addType(BlockedType{});
    module->astTypes[expr] = propTy;
    module->astTypes[expr->index] =
        builtinTypes->stringType; // FIXME? Singleton strings exist.
    std::string propName{constantString->value.data,
                         constantString->value.size};

    bool incremented = recordPropertyAssignment(lhsTy);

    auto apc = addConstraint(
        scope, expr->location,
        AssignPropConstraint{lhsTy, std::move(propName), rhsType,
                             expr->index->location, propTy, incremented});
    getMutable<BlockedType>(propTy)->setOwner(apc);

    return;
  }

  TypeId lhsTy = check(scope, expr->expr).ty;
  TypeId indexTy = check(scope, expr->index).ty;
  TypeId propTy = arena->addType(BlockedType{});
  module->astTypes[expr] = propTy;
  auto aic =
      addConstraint(scope, expr->location,
                    AssignIndexConstraint{lhsTy, indexTy, rhsType, propTy});
  getMutable<BlockedType>(propTy)->setOwner(aic);
}

Inference ConstraintGenerator::check(const ScopePtr &scope, AstExprTable *expr,
                                     std::optional<TypeId> expectedType) {
  TypeId ty = arena->addType(TableType{});
  TableType *ttv = getMutable<TableType>(ty);
  LUAU_ASSERT(ttv);

  ttv->state = TableState::Unsealed;
  ttv->definitionModuleName = module->name;
  ttv->scope = scope.get();

  interiorTypes.back().push_back(ty);

  TypeIds indexKeyLowerBound;
  TypeIds indexValueLowerBound;

  auto createIndexer = [&indexKeyLowerBound, &indexValueLowerBound](
                           const Location &location, TypeId currentIndexType,
                           TypeId currentResultType) {
    indexKeyLowerBound.insert(follow(currentIndexType));
    indexValueLowerBound.insert(follow(currentResultType));
  };

  TypeIds valuesLowerBound;

  for (const AstExprTable::Item &item : expr->items) {
    // Expected types are threaded through table literals separately via the
    // function matchLiteralType.

    TypeId itemTy = check(scope, item.value).ty;

    if (item.key) {
      // Even though we don't need to use the type of the item's key if
      // it's a string constant, we still want to check it to populate
      // astTypes.
      TypeId keyTy = check(scope, item.key).ty;

      if (AstExprConstantString *key = item.key->as<AstExprConstantString>()) {
        std::string propName{key->value.data, key->value.size};
        ttv->props[propName] = {
            itemTy, /*deprecated*/ false, {}, key->location};
      } else {
        createIndexer(item.key->location, keyTy, itemTy);
      }
    } else {
      TypeId numberType = builtinTypes->numberType;
      // FIXME?  The location isn't quite right here.  Not sure what is
      // right.
      createIndexer(item.value->location, numberType, itemTy);
    }
  }

  if (!indexKeyLowerBound.empty()) {
    LUAU_ASSERT(!indexValueLowerBound.empty());

    TypeId indexKey =
        indexKeyLowerBound.size() == 1
            ? *indexKeyLowerBound.begin()
            : arena->addType(UnionType{std::vector(indexKeyLowerBound.begin(),
                                                   indexKeyLowerBound.end())});

    TypeId indexValue =
        indexValueLowerBound.size() == 1
            ? *indexValueLowerBound.begin()
            : arena->addType(UnionType{std::vector(
                  indexValueLowerBound.begin(), indexValueLowerBound.end())});

    ttv->indexer = TableIndexer{indexKey, indexValue};
  }

  if (expectedType) {
    Unifier2 unifier{arena, builtinTypes, NotNull{scope.get()}, ice};
    std::vector<TypeId> toBlock;
    matchLiteralType(NotNull{&module->astTypes},
                     NotNull{&module->astExpectedTypes}, builtinTypes, arena,
                     NotNull{&unifier}, *expectedType, ty, expr, toBlock);
  }

  return Inference{ty};
}

ConstraintGenerator::FunctionSignature
ConstraintGenerator::checkFunctionSignature(
    const ScopePtr &parent, AstExprFunction *fn,
    std::optional<TypeId> expectedType, std::optional<Location> originalName) {
  ScopePtr signatureScope = nullptr;
  ScopePtr bodyScope = nullptr;
  TypePackId returnType = nullptr;

  std::vector<TypeId> genericTypes;
  std::vector<TypePackId> genericTypePacks;

  if (expectedType)
    expectedType = follow(*expectedType);

  bool hasGenerics = fn->generics.size > 0 || fn->genericPacks.size > 0;

  signatureScope = childScope(fn, parent);

  // We need to assign returnType before creating bodyScope so that the
  // return type gets propogated to bodyScope.
  returnType = freshTypePack(signatureScope);
  signatureScope->returnType = returnType;

  bodyScope = childScope(fn->body, signatureScope);

  if (hasGenerics) {
    std::vector<std::pair<Name, GenericTypeDefinition>> genericDefinitions =
        createGenerics(signatureScope, fn->generics);
    std::vector<std::pair<Name, GenericTypePackDefinition>>
        genericPackDefinitions =
            createGenericPacks(signatureScope, fn->genericPacks);

    // We do not support default values on function generics, so we only
    // care about the types involved.
    for (const auto &[name, g] : genericDefinitions) {
      genericTypes.push_back(g.ty);
    }

    for (const auto &[name, g] : genericPackDefinitions) {
      genericTypePacks.push_back(g.tp);
    }

    // Local variable works around an odd gcc 11.3 warning: <anonymous> may be
    // used uninitialized
    std::optional<TypeId> none = std::nullopt;
    expectedType = none;
  }

  std::vector<TypeId> argTypes;
  std::vector<std::optional<FunctionArgument>> argNames;
  TypePack expectedArgPack;

  const FunctionType *expectedFunction =
      expectedType ? get<FunctionType>(*expectedType) : nullptr;
  // This check ensures that expectedType is precisely optional and not any
  // (since any is also an optional type)
  if (expectedType && isOptional(*expectedType) &&
      !get<AnyType>(*expectedType)) {
    if (auto ut = get<UnionType>(*expectedType)) {
      for (auto u : ut) {
        if (get<FunctionType>(u) && !isNil(u)) {
          expectedFunction = get<FunctionType>(u);
          break;
        }
      }
    }
  }

  if (expectedFunction) {
    expectedArgPack = extendTypePack(*arena, builtinTypes,
                                     expectedFunction->argTypes, fn->args.size);

    genericTypes = expectedFunction->generics;
    genericTypePacks = expectedFunction->genericPacks;
  }

  if (fn->self) {
    TypeId selfType = freshType(signatureScope);
    argTypes.push_back(selfType);
    argNames.emplace_back(
        FunctionArgument{fn->self->name.value, fn->self->location});
    signatureScope->bindings[fn->self] = Binding{selfType, fn->self->location};

    DefId def = dfg->getDef(fn->self);
    signatureScope->lvalueTypes[def] = selfType;
    signatureScope->rvalueRefinements[def] = selfType;
  }

  for (size_t i = 0; i < fn->args.size; ++i) {
    AstLocal *local = fn->args.data[i];

    TypeId argTy = nullptr;
    if (local->annotation)
      argTy = resolveType(signatureScope, local->annotation,
                          /* inTypeArguments */ false,
                          /* replaceErrorWithFresh*/ true);
    else {
      if (i < expectedArgPack.head.size())
        argTy = expectedArgPack.head[i];
      else
        argTy = freshType(signatureScope);
    }

    argTypes.push_back(argTy);
    argNames.emplace_back(FunctionArgument{local->name.value, local->location});

    signatureScope->bindings[local] = Binding{argTy, local->location};

    DefId def = dfg->getDef(local);
    signatureScope->lvalueTypes[def] = argTy;
    signatureScope->rvalueRefinements[def] = argTy;
  }

  TypePackId varargPack = nullptr;

  if (fn->vararg) {
    if (fn->varargAnnotation) {
      TypePackId annotationType = resolveTypePack(
          signatureScope, fn->varargAnnotation, /* inTypeArguments */ false,
          /* replaceErrorWithFresh */ true);
      varargPack = annotationType;
    } else if (expectedArgPack.tail &&
               get<VariadicTypePack>(*expectedArgPack.tail))
      varargPack = *expectedArgPack.tail;
    else
      varargPack = builtinTypes->anyTypePack;

    signatureScope->varargPack = varargPack;
    bodyScope->varargPack = varargPack;
  } else {
    varargPack = arena->addTypePack(
        VariadicTypePack{builtinTypes->anyType, /*hidden*/ true});
    // We do not add to signatureScope->varargPack because ... is not valid
    // in functions without an explicit ellipsis.

    signatureScope->varargPack = std::nullopt;
    bodyScope->varargPack = std::nullopt;
  }

  LUAU_ASSERT(nullptr != varargPack);

  // If there is both an annotation and an expected type, the annotation wins.
  // Type checking will sort out any discrepancies later.
  if (fn->returnAnnotation) {
    TypePackId annotatedRetType = resolveTypePack(
        signatureScope, *fn->returnAnnotation, /* inTypeArguments */ false,
        /* replaceErrorWithFresh*/ true);
    // We bind the annotated type directly here so that, when we need to
    // generate constraints for return types, we have a guarantee that we
    // know the annotated return type already, if one was provided.
    LUAU_ASSERT(get<FreeTypePack>(returnType));
    emplaceTypePack<BoundTypePack>(asMutable(returnType), annotatedRetType);
  } else if (expectedFunction) {
    emplaceTypePack<BoundTypePack>(asMutable(returnType),
                                   expectedFunction->retTypes);
  }

  // TODO: Preserve argument names in the function's type.

  FunctionType actualFunction{TypeLevel{}, parent.get(),
                              arena->addTypePack(argTypes, varargPack),
                              returnType};
  actualFunction.generics = std::move(genericTypes);
  actualFunction.genericPacks = std::move(genericTypePacks);
  actualFunction.argNames = std::move(argNames);
  actualFunction.hasSelf = fn->self != nullptr;

  FunctionDefinition defn;
  defn.definitionModuleName = module->name;
  defn.definitionLocation = fn->location;
  defn.varargLocation =
      fn->vararg ? std::make_optional(fn->varargLocation) : std::nullopt;
  defn.originalNameLocation =
      originalName.value_or(Location(fn->location.begin, 0));
  actualFunction.definition = defn;

  TypeId actualFunctionType = arena->addType(std::move(actualFunction));
  LUAU_ASSERT(actualFunctionType);
  module->astTypes[fn] = actualFunctionType;

  if (expectedType && get<FreeType>(*expectedType))
    bindFreeType(*expectedType, actualFunctionType);

  return {
      /* signature */ actualFunctionType,
      /* signatureScope */ signatureScope,
      /* bodyScope */ bodyScope,
  };
}

void ConstraintGenerator::checkFunctionBody(const ScopePtr &scope,
                                            AstExprFunction *fn) {
  // If it is possible for execution to reach the end of the function, the
  // return type must be compatible with ()
  ControlFlow cf = visitBlockWithoutChildScope(scope, fn->body);
  if (cf == ControlFlow::None)
    addConstraint(
        scope, fn->location,
        PackSubtypeConstraint{builtinTypes->emptyTypePack, scope->returnType});
}

TypeId ConstraintGenerator::resolveType(const ScopePtr &scope, AstType *ty,
                                        bool inTypeArguments,
                                        bool replaceErrorWithFresh) {
  TypeId result = nullptr;

  if (auto ref = ty->as<AstTypeReference>()) {
    if (FFlag::DebugLuauMagicTypes) {
      if (ref->name == "_luau_ice")
        ice->ice("_luau_ice encountered", ty->location);
      else if (ref->name == "_luau_print") {
        if (ref->parameters.size != 1 || !ref->parameters.data[0].type) {
          reportError(
              ty->location,
              GenericError{"_luau_print requires one generic parameter"});
          module->astResolvedTypes[ty] = builtinTypes->errorRecoveryType();
          return builtinTypes->errorRecoveryType();
        } else
          return resolveType(scope, ref->parameters.data[0].type,
                             inTypeArguments);
      }
    }

    std::optional<TypeFun> alias;

    if (ref->prefix.has_value()) {
      alias = scope->lookupImportedType(ref->prefix->value, ref->name.value);
    } else {
      alias = scope->lookupType(ref->name.value);
    }

    if (alias.has_value()) {
      // If the alias is not generic, we don't need to set up a blocked
      // type and an instantiation constraint.
      if (alias.has_value() && alias->typeParams.empty() &&
          alias->typePackParams.empty()) {
        result = alias->type;
      } else {
        std::vector<TypeId> parameters;
        std::vector<TypePackId> packParameters;

        for (const AstTypeOrPack &p : ref->parameters) {
          // We do not enforce the ordering of types vs. type packs here;
          // that is done in the parser.
          if (p.type) {
            parameters.push_back(
                resolveType(scope, p.type, /* inTypeArguments */ true));
          } else if (p.typePack) {
            packParameters.push_back(
                resolveTypePack(scope, p.typePack, /* inTypeArguments */ true));
          } else {
            // This indicates a parser bug: one of these two pointers
            // should be set.
            LUAU_ASSERT(false);
          }
        }

        result = arena->addType(PendingExpansionType{
            ref->prefix, ref->name, parameters, packParameters});

        // If we're not in a type argument context, we need to create a
        // constraint that expands this. The dispatching of the above constraint
        // will queue up additional constraints for nested type function
        // applications.
        if (!inTypeArguments)
          addConstraint(scope, ty->location,
                        TypeAliasExpansionConstraint{/* target */ result});
      }
    } else {
      result = builtinTypes->errorRecoveryType();
      if (replaceErrorWithFresh)
        result = freshType(scope);
    }
  } else if (auto tab = ty->as<AstTypeTable>()) {
    TableType::Props props;
    std::optional<TableIndexer> indexer;

    for (const AstTableProp &prop : tab->props) {
      // TODO: Recursion limit.
      TypeId propTy = resolveType(scope, prop.type, inTypeArguments);

      Property &p = props[prop.name.value];
      p.typeLocation = prop.location;

      switch (prop.access) {
      case AstTableAccess::ReadWrite:
        p.readTy = propTy;
        p.writeTy = propTy;
        break;
      case AstTableAccess::Read:
        p.readTy = propTy;
        break;
      case AstTableAccess::Write:
        reportError(*prop.accessLocation,
                    GenericError{"write keyword is illegal here"});
        p.readTy = propTy;
        p.writeTy = propTy;
        break;
      default:
        ice->ice("Unexpected property access " +
                 std::to_string(int(prop.access)));
        break;
      }
    }

    if (AstTableIndexer *astIndexer = tab->indexer) {
      if (astIndexer->access == AstTableAccess::Read)
        reportError(astIndexer->accessLocation.value_or(Location{}),
                    GenericError{"read keyword is illegal here"});
      else if (astIndexer->access == AstTableAccess::Write)
        reportError(astIndexer->accessLocation.value_or(Location{}),
                    GenericError{"write keyword is illegal here"});
      else if (astIndexer->access == AstTableAccess::ReadWrite) {
        // TODO: Recursion limit.
        indexer = TableIndexer{
            resolveType(scope, astIndexer->indexType, inTypeArguments),
            resolveType(scope, astIndexer->resultType, inTypeArguments),
        };
      } else
        ice->ice("Unexpected property access " +
                 std::to_string(int(astIndexer->access)));
    }

    result = arena->addType(TableType{props, indexer, scope->level, scope.get(),
                                      TableState::Sealed});
  } else if (auto fn = ty->as<AstTypeFunction>()) {
    // TODO: Recursion limit.
    bool hasGenerics = fn->generics.size > 0 || fn->genericPacks.size > 0;
    ScopePtr signatureScope = nullptr;

    std::vector<TypeId> genericTypes;
    std::vector<TypePackId> genericTypePacks;

    // If we don't have generics, we do not need to generate a child scope
    // for the generic bindings to live on.
    if (hasGenerics) {
      signatureScope = childScope(fn, scope);

      std::vector<std::pair<Name, GenericTypeDefinition>> genericDefinitions =
          createGenerics(signatureScope, fn->generics);
      std::vector<std::pair<Name, GenericTypePackDefinition>>
          genericPackDefinitions =
              createGenericPacks(signatureScope, fn->genericPacks);

      for (const auto &[name, g] : genericDefinitions) {
        genericTypes.push_back(g.ty);
      }

      for (const auto &[name, g] : genericPackDefinitions) {
        genericTypePacks.push_back(g.tp);
      }
    } else {
      // To eliminate the need to branch on hasGenerics below, we say that
      // the signature scope is the parent scope if we don't have
      // generics.
      signatureScope = scope;
    }

    TypePackId argTypes = resolveTypePack(
        signatureScope, fn->argTypes, inTypeArguments, replaceErrorWithFresh);
    TypePackId returnTypes =
        resolveTypePack(signatureScope, fn->returnTypes, inTypeArguments,
                        replaceErrorWithFresh);

    // TODO: FunctionType needs a pointer to the scope so that we know
    // how to quantify/instantiate it.
    FunctionType ftv{TypeLevel{}, scope.get(), {}, {}, argTypes, returnTypes};
    ftv.isCheckedFunction =
        FFlag::LuauAttributeSyntax ? fn->isCheckedFunction() : false;

    // This replicates the behavior of the appropriate FunctionType
    // constructors.
    ftv.generics = std::move(genericTypes);
    ftv.genericPacks = std::move(genericTypePacks);

    ftv.argNames.reserve(fn->argNames.size);
    for (const auto &el : fn->argNames) {
      if (el) {
        const auto &[name, location] = *el;
        ftv.argNames.push_back(FunctionArgument{name.value, location});
      } else {
        ftv.argNames.push_back(std::nullopt);
      }
    }

    result = arena->addType(std::move(ftv));
  } else if (auto tof = ty->as<AstTypeTypeof>()) {
    // TODO: Recursion limit.
    TypeId exprType = check(scope, tof->expr).ty;
    result = exprType;
  } else if (auto unionAnnotation = ty->as<AstTypeUnion>()) {
    std::vector<TypeId> parts;
    for (AstType *part : unionAnnotation->types) {
      // TODO: Recursion limit.
      parts.push_back(resolveType(scope, part, inTypeArguments));
    }

    result = arena->addType(UnionType{parts});
  } else if (auto intersectionAnnotation = ty->as<AstTypeIntersection>()) {
    std::vector<TypeId> parts;
    for (AstType *part : intersectionAnnotation->types) {
      // TODO: Recursion limit.
      parts.push_back(resolveType(scope, part, inTypeArguments));
    }

    result = arena->addType(IntersectionType{parts});
  } else if (auto boolAnnotation = ty->as<AstTypeSingletonBool>()) {
    if (boolAnnotation->value)
      result = builtinTypes->trueType;
    else
      result = builtinTypes->falseType;
  } else if (auto stringAnnotation = ty->as<AstTypeSingletonString>()) {
    result = arena->addType(SingletonType(StringSingleton{std::string(
        stringAnnotation->value.data, stringAnnotation->value.size)}));
  } else if (ty->is<AstTypeError>()) {
    result = builtinTypes->errorRecoveryType();
    if (replaceErrorWithFresh)
      result = freshType(scope);
  } else {
    LUAU_ASSERT(0);
    result = builtinTypes->errorRecoveryType();
  }

  module->astResolvedTypes[ty] = result;
  return result;
}

TypePackId ConstraintGenerator::resolveTypePack(const ScopePtr &scope,
                                                AstTypePack *tp,
                                                bool inTypeArgument,
                                                bool replaceErrorWithFresh) {
  TypePackId result;
  if (auto expl = tp->as<AstTypePackExplicit>()) {
    result = resolveTypePack(scope, expl->typeList, inTypeArgument,
                             replaceErrorWithFresh);
  } else if (auto var = tp->as<AstTypePackVariadic>()) {
    TypeId ty = resolveType(scope, var->variadicType, inTypeArgument,
                            replaceErrorWithFresh);
    result = arena->addTypePack(TypePackVar{VariadicTypePack{ty}});
  } else if (auto gen = tp->as<AstTypePackGeneric>()) {
    if (std::optional<TypePackId> lookup =
            scope->lookupPack(gen->genericName.value)) {
      result = *lookup;
    } else {
      reportError(tp->location, UnknownSymbol{gen->genericName.value,
                                              UnknownSymbol::Context::Type});
      result = builtinTypes->errorRecoveryTypePack();
    }
  } else {
    LUAU_ASSERT(0);
    result = builtinTypes->errorRecoveryTypePack();
  }

  module->astResolvedTypePacks[tp] = result;
  return result;
}

TypePackId ConstraintGenerator::resolveTypePack(const ScopePtr &scope,
                                                const AstTypeList &list,
                                                bool inTypeArguments,
                                                bool replaceErrorWithFresh) {
  std::vector<TypeId> head;

  for (AstType *headTy : list.types) {
    head.push_back(
        resolveType(scope, headTy, inTypeArguments, replaceErrorWithFresh));
  }

  std::optional<TypePackId> tail = std::nullopt;
  if (list.tailType) {
    tail = resolveTypePack(scope, list.tailType, inTypeArguments,
                           replaceErrorWithFresh);
  }

  return addTypePack(std::move(head), tail);
}

std::vector<std::pair<Name, GenericTypeDefinition>>
ConstraintGenerator::createGenerics(const ScopePtr &scope,
                                    AstArray<AstGenericType> generics,
                                    bool useCache, bool addTypes) {
  std::vector<std::pair<Name, GenericTypeDefinition>> result;
  for (const auto &generic : generics) {
    TypeId genericTy = nullptr;

    if (auto it =
            scope->parent->typeAliasTypeParameters.find(generic.name.value);
        useCache && it != scope->parent->typeAliasTypeParameters.end())
      genericTy = it->second;
    else {
      genericTy = arena->addType(GenericType{scope.get(), generic.name.value});
      scope->parent->typeAliasTypeParameters[generic.name.value] = genericTy;
    }

    std::optional<TypeId> defaultTy = std::nullopt;

    if (generic.defaultValue)
      defaultTy =
          resolveType(scope, generic.defaultValue, /* inTypeArguments */ false);

    if (addTypes)
      scope->privateTypeBindings[generic.name.value] = TypeFun{genericTy};

    result.push_back(
        {generic.name.value, GenericTypeDefinition{genericTy, defaultTy}});
  }

  return result;
}

std::vector<std::pair<Name, GenericTypePackDefinition>>
ConstraintGenerator::createGenericPacks(const ScopePtr &scope,
                                        AstArray<AstGenericTypePack> generics,
                                        bool useCache, bool addTypes) {
  std::vector<std::pair<Name, GenericTypePackDefinition>> result;
  for (const auto &generic : generics) {
    TypePackId genericTy;

    if (auto it =
            scope->parent->typeAliasTypePackParameters.find(generic.name.value);
        useCache && it != scope->parent->typeAliasTypePackParameters.end())
      genericTy = it->second;
    else {
      genericTy = arena->addTypePack(
          TypePackVar{GenericTypePack{scope.get(), generic.name.value}});
      scope->parent->typeAliasTypePackParameters[generic.name.value] =
          genericTy;
    }

    std::optional<TypePackId> defaultTy = std::nullopt;

    if (generic.defaultValue)
      defaultTy = resolveTypePack(scope, generic.defaultValue,
                                  /* inTypeArguments */ false);

    if (addTypes)
      scope->privateTypePackBindings[generic.name.value] = genericTy;

    result.push_back(
        {generic.name.value, GenericTypePackDefinition{genericTy, defaultTy}});
  }

  return result;
}

Inference ConstraintGenerator::flattenPack(const ScopePtr &scope,
                                           Location location,
                                           InferencePack pack) {
  const auto &[tp, refinements] = pack;
  RefinementId refinement = nullptr;
  if (!refinements.empty())
    refinement = refinements[0];

  if (auto f = first(tp))
    return Inference{*f, refinement};

  TypeId typeResult = arena->addType(BlockedType{});
  auto c = addConstraint(scope, location, UnpackConstraint{{typeResult}, tp});
  getMutable<BlockedType>(typeResult)->setOwner(c);

  return Inference{typeResult, refinement};
}

void ConstraintGenerator::reportError(Location location, TypeErrorData err) {
  errors.push_back(TypeError{location, module->name, std::move(err)});

  if (logger)
    logger->captureGenerationError(errors.back());
}

void ConstraintGenerator::reportCodeTooComplex(Location location) {
  errors.push_back(TypeError{location, module->name, CodeTooComplex{}});

  if (logger)
    logger->captureGenerationError(errors.back());
}

TypeId ConstraintGenerator::makeUnion(const ScopePtr &scope, Location location,
                                      TypeId lhs, TypeId rhs) {
  if (get<NeverType>(follow(lhs)))
    return rhs;
  if (get<NeverType>(follow(rhs)))
    return lhs;

  TypeId resultType = createTypeFunctionInstance(
      builtinTypeFunctions().unionFunc, {lhs, rhs}, {}, scope, location);

  return resultType;
}

TypeId ConstraintGenerator::makeIntersect(const ScopePtr &scope,
                                          Location location, TypeId lhs,
                                          TypeId rhs) {
  TypeId resultType = createTypeFunctionInstance(
      builtinTypeFunctions().intersectFunc, {lhs, rhs}, {}, scope, location);

  return resultType;
}

struct GlobalPrepopulator : AstVisitor {
  const NotNull<Scope> globalScope;
  const NotNull<TypeArena> arena;
  const NotNull<const DataFlowGraph> dfg;

  GlobalPrepopulator(NotNull<Scope> globalScope, NotNull<TypeArena> arena,
                     NotNull<const DataFlowGraph> dfg)
      : globalScope(globalScope), arena(arena), dfg(dfg) {}

  bool visit(AstExprGlobal *global) override {
    if (auto ty = globalScope->lookup(global->name)) {
      DefId def = dfg->getDef(global);
      globalScope->lvalueTypes[def] = *ty;
    }

    return true;
  }

  bool visit(AstStatFunction *function) override {
    if (AstExprGlobal *g = function->name->as<AstExprGlobal>()) {
      TypeId bt = arena->addType(BlockedType{});
      globalScope->bindings[g->name] = Binding{bt};
    }

    return true;
  }

  bool visit(AstType *) override { return true; }

  bool visit(class AstTypePack *node) override { return true; }
};

void ConstraintGenerator::prepopulateGlobalScope(const ScopePtr &globalScope,
                                                 AstStatBlock *program) {
  GlobalPrepopulator gp{NotNull{globalScope.get()}, arena, dfg};

  if (prepareModuleScope)
    prepareModuleScope(module->name, globalScope);

  program->visit(&gp);
}

bool ConstraintGenerator::recordPropertyAssignment(TypeId ty) {
  DenseHashSet<TypeId> seen{nullptr};
  VecDeque<TypeId> queue;

  queue.push_back(ty);

  bool incremented = false;

  while (!queue.empty()) {
    const TypeId t = follow(queue.front());
    queue.pop_front();

    if (seen.find(t))
      continue;
    seen.insert(t);

    if (auto tt = getMutable<TableType>(t);
        tt && tt->state == TableState::Unsealed) {
      tt->remainingProps += 1;
      incremented = true;
    } else if (auto mt = get<MetatableType>(t))
      queue.push_back(mt->table);
    else if (TypeIds *localDomain = localTypes.find(t)) {
      for (TypeId domainTy : *localDomain)
        queue.push_back(domainTy);
    } else if (auto ut = get<UnionType>(t)) {
      for (TypeId part : ut)
        queue.push_back(part);
    }
  }

  return incremented;
}

void ConstraintGenerator::recordInferredBinding(AstLocal *local, TypeId ty) {
  if (InferredBinding *ib = inferredBindings.find(local))
    ib->types.insert(ty);
}

void ConstraintGenerator::fillInInferredBindings(const ScopePtr &globalScope,
                                                 AstStatBlock *block) {
  for (const auto &[symbol, p] : inferredBindings) {
    const auto &[scope, location, types] = p;

    std::vector<TypeId> tys(types.begin(), types.end());
    if (tys.size() == 1)
      scope->bindings[symbol] = Binding{tys.front(), location};
    else {
      TypeId ty =
          createTypeFunctionInstance(builtinTypeFunctions().unionFunc,
                                     std::move(tys), {}, globalScope, location);

      scope->bindings[symbol] = Binding{ty, location};
    }
  }
}

std::vector<std::optional<TypeId>>
ConstraintGenerator::getExpectedCallTypesForFunctionOverloads(
    const TypeId fnType) {
  std::vector<TypeId> funTys;
  if (auto it = get<IntersectionType>(follow(fnType))) {
    for (TypeId intersectionComponent : it) {
      funTys.push_back(intersectionComponent);
    }
  }

  std::vector<std::optional<TypeId>> expectedTypes;
  // For a list of functions f_0 : e_0 -> r_0, ... f_n : e_n -> r_n,
  // emit a list of arguments that the function could take at each position
  // by unioning the arguments at each place
  auto assignOption = [this, &expectedTypes](size_t index, TypeId ty) {
    if (index == expectedTypes.size())
      expectedTypes.push_back(ty);
    else if (ty) {
      auto &el = expectedTypes[index];

      if (!el)
        el = ty;
      else {
        std::vector<TypeId> result = reduceUnion({*el, ty});
        if (result.empty())
          el = builtinTypes->neverType;
        else if (result.size() == 1)
          el = result[0];
        else
          el = module->internalTypes.addType(UnionType{std::move(result)});
      }
    }
  };

  for (const TypeId overload : funTys) {
    if (const FunctionType *ftv = get<FunctionType>(follow(overload))) {
      auto [argsHead, argsTail] = flatten(ftv->argTypes);
      size_t start = ftv->hasSelf ? 1 : 0;
      size_t index = 0;
      for (size_t i = start; i < argsHead.size(); ++i)
        assignOption(index++, argsHead[i]);
      if (argsTail) {
        argsTail = follow(*argsTail);
        if (const VariadicTypePack *vtp = get<VariadicTypePack>(*argsTail)) {
          while (index < funTys.size())
            assignOption(index++, vtp->ty);
        }
      }
    }
  }

  // TODO vvijay Feb 24, 2023 apparently we have to demote the types here?

  return expectedTypes;
}

TypeId ConstraintGenerator::createTypeFunctionInstance(
    const TypeFunction &family, std::vector<TypeId> typeArguments,
    std::vector<TypePackId> packArguments, const ScopePtr &scope,
    Location location) {
  TypeId result = arena->addTypeFunction(family, typeArguments, packArguments);
  addConstraint(scope, location, ReduceConstraint{result});
  return result;
}

std::vector<NotNull<Constraint>>
borrowConstraints(const std::vector<ConstraintPtr> &constraints) {
  std::vector<NotNull<Constraint>> result;
  result.reserve(constraints.size());

  for (const auto &c : constraints)
    result.emplace_back(c.get());

  return result;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/TypePath.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// DONE : was aleready inlined <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// DONE : was aleready inlined <Luau/TypeOrPack.h>

// @@@ PACK.lua : not found, likely and std header
#include <functional>

// @@@ PACK.lua : not found, likely and std header
#include <optional>

// @@@ PACK.lua : not found, likely and std header
#include <sstream>

// @@@ PACK.lua : not found, likely and std header
#include <type_traits>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

// Maximum number of steps to follow when traversing a path. May not always
// equate to the number of components in a path, depending on the traversal
// logic.
LUAU_DYNAMIC_FASTINTVARIABLE(LuauTypePathMaximumTraverseSteps, 100);

namespace Luau {

namespace TypePath {

Property::Property(std::string name) : name(std::move(name)) {
  LUAU_ASSERT(!FFlag::DebugLuauDeferredConstraintResolution);
}

Property Property::read(std::string name) {
  return Property(std::move(name), true);
}

Property Property::write(std::string name) {
  return Property(std::move(name), false);
}

bool Property::operator==(const Property &other) const {
  return name == other.name && isRead == other.isRead;
}

bool Index::operator==(const Index &other) const {
  return index == other.index;
}

bool Reduction::operator==(const Reduction &other) const {
  return resultType == other.resultType;
}

Path Path::append(const Path &suffix) const {
  std::vector<Component> joined(components);
  joined.reserve(suffix.components.size());
  joined.insert(joined.end(), suffix.components.begin(),
                suffix.components.end());
  return Path(std::move(joined));
}

Path Path::push(Component component) const {
  std::vector<Component> joined(components);
  joined.push_back(component);
  return Path(std::move(joined));
}

Path Path::push_front(Component component) const {
  std::vector<Component> joined{};
  joined.reserve(components.size() + 1);
  joined.push_back(std::move(component));
  joined.insert(joined.end(), components.begin(), components.end());
  return Path(std::move(joined));
}

Path Path::pop() const {
  if (empty())
    return kEmpty;

  std::vector<Component> popped(components);
  popped.pop_back();
  return Path(std::move(popped));
}

std::optional<Component> Path::last() const {
  if (empty())
    return std::nullopt;

  return components.back();
}

bool Path::empty() const { return components.empty(); }

bool Path::operator==(const Path &other) const {
  return components == other.components;
}

size_t PathHash::operator()(const Property &prop) const {
  return std::hash<std::string>()(prop.name) ^ static_cast<size_t>(prop.isRead);
}

size_t PathHash::operator()(const Index &idx) const { return idx.index; }

size_t PathHash::operator()(const TypeField &field) const {
  return static_cast<size_t>(field);
}

size_t PathHash::operator()(const PackField &field) const {
  return static_cast<size_t>(field);
}

size_t PathHash::operator()(const Reduction &reduction) const {
  return std::hash<TypeId>()(reduction.resultType);
}

size_t PathHash::operator()(const Component &component) const {
  return visit(*this, component);
}

size_t PathHash::operator()(const Path &path) const {
  size_t hash = 0;

  for (const Component &component : path.components)
    hash ^= (*this)(component);

  return hash;
}

Path PathBuilder::build() { return Path(std::move(components)); }

PathBuilder &PathBuilder::readProp(std::string name) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);
  components.push_back(Property{std::move(name), true});
  return *this;
}

PathBuilder &PathBuilder::writeProp(std::string name) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);
  components.push_back(Property{std::move(name), false});
  return *this;
}

PathBuilder &PathBuilder::prop(std::string name) {
  LUAU_ASSERT(!FFlag::DebugLuauDeferredConstraintResolution);
  components.push_back(Property{std::move(name)});
  return *this;
}

PathBuilder &PathBuilder::index(size_t i) {
  components.push_back(Index{i});
  return *this;
}

PathBuilder &PathBuilder::mt() {
  components.push_back(TypeField::Metatable);
  return *this;
}

PathBuilder &PathBuilder::lb() {
  components.push_back(TypeField::LowerBound);
  return *this;
}

PathBuilder &PathBuilder::ub() {
  components.push_back(TypeField::UpperBound);
  return *this;
}

PathBuilder &PathBuilder::indexKey() {
  components.push_back(TypeField::IndexLookup);
  return *this;
}

PathBuilder &PathBuilder::indexValue() {
  components.push_back(TypeField::IndexResult);
  return *this;
}

PathBuilder &PathBuilder::negated() {
  components.push_back(TypeField::Negated);
  return *this;
}

PathBuilder &PathBuilder::variadic() {
  components.push_back(TypeField::Variadic);
  return *this;
}

PathBuilder &PathBuilder::args() {
  components.push_back(PackField::Arguments);
  return *this;
}

PathBuilder &PathBuilder::rets() {
  components.push_back(PackField::Returns);
  return *this;
}

PathBuilder &PathBuilder::tail() {
  components.push_back(PackField::Tail);
  return *this;
}

} // namespace TypePath

namespace {

struct TraversalState {
  TraversalState(TypeId root, NotNull<BuiltinTypes> builtinTypes)
      : current(root), builtinTypes(builtinTypes) {}
  TraversalState(TypePackId root, NotNull<BuiltinTypes> builtinTypes)
      : current(root), builtinTypes(builtinTypes) {}

  TypeOrPack current;
  NotNull<BuiltinTypes> builtinTypes;
  int steps = 0;

  void updateCurrent(TypeId ty) {
    LUAU_ASSERT(ty);
    current = follow(ty);
  }

  void updateCurrent(TypePackId tp) {
    LUAU_ASSERT(tp);
    current = follow(tp);
  }

  bool tooLong() { return ++steps > DFInt::LuauTypePathMaximumTraverseSteps; }

  bool checkInvariants() { return tooLong(); }

  bool traverse(const TypePath::Property &property) {
    auto currentType = get<TypeId>(current);
    if (!currentType)
      return false;

    if (checkInvariants())
      return false;

    const Property *prop = nullptr;

    if (auto t = get<TableType>(*currentType)) {
      auto it = t->props.find(property.name);
      if (it != t->props.end()) {
        prop = &it->second;
      }
    } else if (auto c = get<ClassType>(*currentType)) {
      prop = lookupClassProp(c, property.name);
    }
    // For a metatable type, the table takes priority; check that before
    // falling through to the metatable entry below.
    else if (auto m = get<MetatableType>(*currentType)) {
      TypeOrPack pinned = current;
      updateCurrent(m->table);

      if (traverse(property))
        return true;

      // Restore the old current type if we didn't traverse the metatable
      // successfully; we'll use the next branch to address this.
      current = pinned;
    }

    if (!prop) {
      if (auto m = getMetatable(*currentType, builtinTypes)) {
        // Weird: rather than use findMetatableEntry, which requires a lot
        // of stuff that we don't have and don't want to pull in, we use the
        // path traversal logic to grab __index and then re-enter the lookup
        // logic there.
        updateCurrent(*m);

        if (!traverse(TypePath::Property::read("__index")))
          return false;

        return traverse(property);
      }
    }

    if (prop) {
      std::optional<TypeId> maybeType;
      if (FFlag::DebugLuauDeferredConstraintResolution)
        maybeType = property.isRead ? prop->readTy : prop->writeTy;
      else
        maybeType = prop->type();

      if (maybeType) {
        updateCurrent(*maybeType);
        return true;
      }
    }

    return false;
  }

  bool traverse(const TypePath::Index &index) {
    if (checkInvariants())
      return false;

    if (auto currentType = get<TypeId>(current)) {
      if (auto u = get<UnionType>(*currentType)) {
        auto it = begin(u);
        std::advance(it, index.index);
        if (it != end(u)) {
          updateCurrent(*it);
          return true;
        }
      } else if (auto i = get<IntersectionType>(*currentType)) {
        auto it = begin(i);
        std::advance(it, index.index);
        if (it != end(i)) {
          updateCurrent(*it);
          return true;
        }
      }
    } else {
      auto currentPack = get<TypePackId>(current);
      LUAU_ASSERT(currentPack);
      if (get<TypePack>(*currentPack)) {
        auto it = begin(*currentPack);

        for (size_t i = 0; i < index.index && it != end(*currentPack); ++i)
          ++it;

        if (it != end(*currentPack)) {
          updateCurrent(*it);
          return true;
        }
      }
    }

    return false;
  }

  bool traverse(TypePath::TypeField field) {
    if (checkInvariants())
      return false;

    switch (field) {
    case TypePath::TypeField::Metatable:
      if (auto currentType = get<TypeId>(current)) {
        if (std::optional<TypeId> mt =
                getMetatable(*currentType, builtinTypes)) {
          updateCurrent(*mt);
          return true;
        }
      }

      return false;
    case TypePath::TypeField::LowerBound:
    case TypePath::TypeField::UpperBound:
      if (auto ft = get<FreeType>(current)) {
        updateCurrent(field == TypePath::TypeField::LowerBound
                          ? ft->lowerBound
                          : ft->upperBound);
        return true;
      }

      return false;
    case TypePath::TypeField::IndexLookup:
    case TypePath::TypeField::IndexResult: {
      const TableIndexer *indexer = nullptr;

      if (auto tt = get<TableType>(current); tt && tt->indexer)
        indexer = &(*tt->indexer);
      else if (auto mt = get<MetatableType>(current)) {
        if (auto mtTab = get<TableType>(follow(mt->table));
            mtTab && mtTab->indexer)
          indexer = &(*mtTab->indexer);
        else if (auto mtMt = get<TableType>(follow(mt->metatable));
                 mtMt && mtMt->indexer)
          indexer = &(*mtMt->indexer);
      }
      // Note: we don't appear to walk the class hierarchy for indexers
      else if (auto ct = get<ClassType>(current); ct && ct->indexer)
        indexer = &(*ct->indexer);

      if (indexer) {
        updateCurrent(field == TypePath::TypeField::IndexLookup
                          ? indexer->indexType
                          : indexer->indexResultType);
        return true;
      }

      return false;
    }
    case TypePath::TypeField::Negated:
      if (auto nt = get<NegationType>(current)) {
        updateCurrent(nt->ty);
        return true;
      }

      return false;
    case TypePath::TypeField::Variadic:
      if (auto vtp = get<VariadicTypePack>(current)) {
        updateCurrent(vtp->ty);
        return true;
      }

      return false;
    }

    return false;
  }

  bool traverse(TypePath::Reduction reduction) {
    if (checkInvariants())
      return false;
    updateCurrent(reduction.resultType);
    return true;
  }

  bool traverse(TypePath::PackField field) {
    if (checkInvariants())
      return false;

    switch (field) {
    case TypePath::PackField::Arguments:
    case TypePath::PackField::Returns:
      if (auto ft = get<FunctionType>(current)) {
        updateCurrent(field == TypePath::PackField::Arguments ? ft->argTypes
                                                              : ft->retTypes);
        return true;
      }

      return false;
    case TypePath::PackField::Tail:
      if (auto currentPack = get<TypePackId>(current)) {
        auto it = begin(*currentPack);
        while (it != end(*currentPack))
          ++it;

        if (auto tail = it.tail()) {
          updateCurrent(*tail);
          return true;
        }
      }

      return false;
    }

    return false;
  }
};

} // namespace

std::string toString(const TypePath::Path &path, bool prefixDot) {
  std::stringstream result;
  bool first = true;

  auto strComponent = [&](auto &&c) {
    using T = std::decay_t<decltype(c)>;
    if constexpr (std::is_same_v<T, TypePath::Property>) {
      result << '[';
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        if (c.isRead)
          result << "read ";
        else
          result << "write ";
      }

      result << '"' << c.name << '"' << ']';
    } else if constexpr (std::is_same_v<T, TypePath::Index>) {
      result << '[' << std::to_string(c.index) << ']';
    } else if constexpr (std::is_same_v<T, TypePath::TypeField>) {
      if (!first || prefixDot)
        result << '.';

      switch (c) {
      case TypePath::TypeField::Metatable:
        result << "metatable";
        break;
      case TypePath::TypeField::LowerBound:
        result << "lowerBound";
        break;
      case TypePath::TypeField::UpperBound:
        result << "upperBound";
        break;
      case TypePath::TypeField::IndexLookup:
        result << "indexer";
        break;
      case TypePath::TypeField::IndexResult:
        result << "indexResult";
        break;
      case TypePath::TypeField::Negated:
        result << "negated";
        break;
      case TypePath::TypeField::Variadic:
        result << "variadic";
        break;
      }

      result << "()";
    } else if constexpr (std::is_same_v<T, TypePath::PackField>) {
      if (!first || prefixDot)
        result << '.';

      switch (c) {
      case TypePath::PackField::Arguments:
        result << "arguments";
        break;
      case TypePath::PackField::Returns:
        result << "returns";
        break;
      case TypePath::PackField::Tail:
        result << "tail";
        break;
      }
      result << "()";
    } else if constexpr (std::is_same_v<T, TypePath::Reduction>) {
      // We need to rework the TypePath system to make subtyping failures easier
      // to understand https://roblox.atlassian.net/browse/CLI-104422
      result << "~~>";
    } else {
      static_assert(always_false_v<T>, "Unhandled Component variant");
    }

    first = false;
  };

  for (const TypePath::Component &component : path.components)
    Luau::visit(strComponent, component);

  return result.str();
}

static bool traverse(TraversalState &state, const Path &path) {
  auto step = [&state](auto &&c) { return state.traverse(c); };

  for (const TypePath::Component &component : path.components) {
    bool stepSuccess = visit(step, component);
    if (!stepSuccess)
      return false;
  }

  return true;
}

std::optional<TypeOrPack> traverse(TypeId root, const Path &path,
                                   NotNull<BuiltinTypes> builtinTypes) {
  TraversalState state(follow(root), builtinTypes);
  if (traverse(state, path))
    return state.current;
  else
    return std::nullopt;
}

std::optional<TypeOrPack> traverse(TypePackId root, const Path &path,
                                   NotNull<BuiltinTypes> builtinTypes) {
  TraversalState state(follow(root), builtinTypes);
  if (traverse(state, path))
    return state.current;
  else
    return std::nullopt;
}

std::optional<TypeId> traverseForType(TypeId root, const Path &path,
                                      NotNull<BuiltinTypes> builtinTypes) {
  TraversalState state(follow(root), builtinTypes);
  if (traverse(state, path)) {
    auto ty = get<TypeId>(state.current);
    return ty ? std::make_optional(*ty) : std::nullopt;
  } else
    return std::nullopt;
}

std::optional<TypeId> traverseForType(TypePackId root, const Path &path,
                                      NotNull<BuiltinTypes> builtinTypes) {
  TraversalState state(follow(root), builtinTypes);
  if (traverse(state, path)) {
    auto ty = get<TypeId>(state.current);
    return ty ? std::make_optional(*ty) : std::nullopt;
  } else
    return std::nullopt;
}

std::optional<TypePackId> traverseForPack(TypeId root, const Path &path,
                                          NotNull<BuiltinTypes> builtinTypes) {
  TraversalState state(follow(root), builtinTypes);
  if (traverse(state, path)) {
    auto ty = get<TypePackId>(state.current);
    return ty ? std::make_optional(*ty) : std::nullopt;
  } else
    return std::nullopt;
}

std::optional<TypePackId> traverseForPack(TypePackId root, const Path &path,
                                          NotNull<BuiltinTypes> builtinTypes) {
  TraversalState state(follow(root), builtinTypes);
  if (traverse(state, path)) {
    auto ty = get<TypePackId>(state.current);
    return ty ? std::make_optional(*ty) : std::nullopt;
  } else
    return std::nullopt;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Anyification.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// DONE : was aleready inlined <Luau/Normalize.h>

// DONE : was aleready inlined <Luau/TxnLog.h>

namespace Luau {

Anyification::Anyification(TypeArena *arena, NotNull<Scope> scope,
                           NotNull<BuiltinTypes> builtinTypes,
                           InternalErrorReporter *iceHandler, TypeId anyType,
                           TypePackId anyTypePack)
    : Substitution(TxnLog::empty(), arena), scope(scope),
      builtinTypes(builtinTypes), iceHandler(iceHandler), anyType(anyType),
      anyTypePack(anyTypePack) {}

Anyification::Anyification(TypeArena *arena, const ScopePtr &scope,
                           NotNull<BuiltinTypes> builtinTypes,
                           InternalErrorReporter *iceHandler, TypeId anyType,
                           TypePackId anyTypePack)
    : Anyification(arena, NotNull{scope.get()}, builtinTypes, iceHandler,
                   anyType, anyTypePack) {}

bool Anyification::isDirty(TypeId ty) {
  if (ty->persistent)
    return false;

  if (const TableType *ttv = log->getMutable<TableType>(ty))
    return (ttv->state == TableState::Free ||
            ttv->state == TableState::Unsealed);
  else if (log->getMutable<FreeType>(ty))
    return true;
  else
    return false;
}

bool Anyification::isDirty(TypePackId tp) {
  if (tp->persistent)
    return false;

  if (log->getMutable<FreeTypePack>(tp))
    return true;
  else
    return false;
}

TypeId Anyification::clean(TypeId ty) {
  LUAU_ASSERT(isDirty(ty));
  if (const TableType *ttv = log->getMutable<TableType>(ty)) {
    TableType clone =
        TableType{ttv->props, ttv->indexer, ttv->level, TableState::Sealed};
    clone.definitionModuleName = ttv->definitionModuleName;
    clone.definitionLocation = ttv->definitionLocation;
    clone.name = ttv->name;
    clone.syntheticName = ttv->syntheticName;
    clone.tags = ttv->tags;
    TypeId res = addType(std::move(clone));
    return res;
  } else
    return anyType;
}

TypePackId Anyification::clean(TypePackId tp) {
  LUAU_ASSERT(isDirty(tp));
  return anyTypePack;
}

bool Anyification::ignoreChildren(TypeId ty) {
  if (get<ClassType>(ty))
    return true;

  return ty->persistent;
}
bool Anyification::ignoreChildren(TypePackId ty) { return ty->persistent; }

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DcrLogger.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// DONE : was aleready inlined <Luau/JsonEmitter.h>

namespace Luau {

template <typename T> static std::string toPointerId(const T *ptr) {
  return std::to_string(reinterpret_cast<size_t>(ptr));
}

static std::string toPointerId(NotNull<const Constraint> ptr) {
  return std::to_string(reinterpret_cast<size_t>(ptr.get()));
}

namespace Json {

template <typename T> void write(JsonEmitter &emitter, const T *ptr) {
  write(emitter, toPointerId(ptr));
}

void write(JsonEmitter &emitter, NotNull<const Constraint> ptr) {
  write(emitter, toPointerId(ptr));
}

void write(JsonEmitter &emitter, const Location &location) {
  ArrayEmitter a = emitter.writeArray();
  a.writeValue(location.begin.line);
  a.writeValue(location.begin.column);
  a.writeValue(location.end.line);
  a.writeValue(location.end.column);
  a.finish();
}

void write(JsonEmitter &emitter, const ErrorSnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("message", snapshot.message);
  o.writePair("location", snapshot.location);
  o.finish();
}

void write(JsonEmitter &emitter, const BindingSnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("typeId", snapshot.typeId);
  o.writePair("typeString", snapshot.typeString);
  o.writePair("location", snapshot.location);
  o.finish();
}

void write(JsonEmitter &emitter, const TypeBindingSnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("typeId", snapshot.typeId);
  o.writePair("typeString", snapshot.typeString);
  o.finish();
}

template <typename K, typename V>
void write(JsonEmitter &emitter, const DenseHashMap<const K *, V> &map) {
  ObjectEmitter o = emitter.writeObject();
  for (const auto &[k, v] : map)
    o.writePair(toPointerId(k), v);
  o.finish();
}

void write(JsonEmitter &emitter, const ExprTypesAtLocation &tys) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("location", tys.location);
  o.writePair("ty", toPointerId(tys.ty));

  if (tys.expectedTy)
    o.writePair("expectedTy", toPointerId(*tys.expectedTy));

  o.finish();
}

void write(JsonEmitter &emitter, const AnnotationTypesAtLocation &tys) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("location", tys.location);
  o.writePair("resolvedTy", toPointerId(tys.resolvedTy));
  o.finish();
}

void write(JsonEmitter &emitter, const ConstraintGenerationLog &log) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("source", log.source);
  o.writePair("errors", log.errors);
  o.writePair("exprTypeLocations", log.exprTypeLocations);
  o.writePair("annotationTypeLocations", log.annotationTypeLocations);

  o.finish();
}

void write(JsonEmitter &emitter, const ScopeSnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("bindings", snapshot.bindings);
  o.writePair("typeBindings", snapshot.typeBindings);
  o.writePair("typePackBindings", snapshot.typePackBindings);
  o.writePair("children", snapshot.children);
  o.finish();
}

void write(JsonEmitter &emitter, const ConstraintBlock &block) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("stringification", block.stringification);

  auto go = [&o](auto &&t) {
    using T = std::decay_t<decltype(t)>;

    o.writePair("id", toPointerId(t));

    if constexpr (std::is_same_v<T, TypeId>) {
      o.writePair("kind", "type");
    } else if constexpr (std::is_same_v<T, TypePackId>) {
      o.writePair("kind", "typePack");
    } else if constexpr (std::is_same_v<T, NotNull<const Constraint>>) {
      o.writePair("kind", "constraint");
    } else
      static_assert(always_false_v<T>, "non-exhaustive possibility switch");
  };

  visit(go, block.target);

  o.finish();
}

void write(JsonEmitter &emitter, const ConstraintSnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("stringification", snapshot.stringification);
  o.writePair("location", snapshot.location);
  o.writePair("blocks", snapshot.blocks);
  o.finish();
}

void write(JsonEmitter &emitter, const BoundarySnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("rootScope", snapshot.rootScope);
  o.writePair("unsolvedConstraints", snapshot.unsolvedConstraints);
  o.writePair("typeStrings", snapshot.typeStrings);
  o.finish();
}

void write(JsonEmitter &emitter, const StepSnapshot &snapshot) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("currentConstraint", snapshot.currentConstraint);
  o.writePair("forced", snapshot.forced);
  o.writePair("unsolvedConstraints", snapshot.unsolvedConstraints);
  o.writePair("rootScope", snapshot.rootScope);
  o.writePair("typeStrings", snapshot.typeStrings);
  o.finish();
}

void write(JsonEmitter &emitter, const TypeSolveLog &log) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("initialState", log.initialState);
  o.writePair("stepStates", log.stepStates);
  o.writePair("finalState", log.finalState);
  o.finish();
}

void write(JsonEmitter &emitter, const TypeCheckLog &log) {
  ObjectEmitter o = emitter.writeObject();
  o.writePair("errors", log.errors);
  o.finish();
}

} // namespace Json

static ScopeSnapshot snapshotScope(const Scope *scope, ToStringOptions &opts) {
  std::unordered_map<Name, BindingSnapshot> bindings;
  std::unordered_map<Name, TypeBindingSnapshot> typeBindings;
  std::unordered_map<Name, TypeBindingSnapshot> typePackBindings;
  std::vector<ScopeSnapshot> children;

  for (const auto &[name, binding] : scope->bindings) {
    std::string id = std::to_string(reinterpret_cast<size_t>(binding.typeId));
    ToStringResult result = toStringDetailed(binding.typeId, opts);

    bindings[name.c_str()] = BindingSnapshot{
        id,
        result.name,
        binding.location,
    };
  }

  for (const auto &[name, tf] : scope->exportedTypeBindings) {
    std::string id = std::to_string(reinterpret_cast<size_t>(tf.type));

    typeBindings[name] = TypeBindingSnapshot{
        id,
        toString(tf.type, opts),
    };
  }

  for (const auto &[name, tf] : scope->privateTypeBindings) {
    std::string id = std::to_string(reinterpret_cast<size_t>(tf.type));

    typeBindings[name] = TypeBindingSnapshot{
        id,
        toString(tf.type, opts),
    };
  }

  for (const auto &[name, tp] : scope->privateTypePackBindings) {
    std::string id = std::to_string(reinterpret_cast<size_t>(tp));

    typePackBindings[name] = TypeBindingSnapshot{
        id,
        toString(tp, opts),
    };
  }

  for (const auto &child : scope->children) {
    children.push_back(snapshotScope(child.get(), opts));
  }

  return ScopeSnapshot{
      bindings,
      typeBindings,
      typePackBindings,
      children,
  };
}

std::string DcrLogger::compileOutput() {
  Json::JsonEmitter emitter;
  Json::ObjectEmitter o = emitter.writeObject();
  o.writePair("generation", generationLog);
  o.writePair("solve", solveLog);
  o.writePair("check", checkLog);
  o.finish();

  return emitter.str();
}

void DcrLogger::captureSource(std::string source) {
  generationLog.source = std::move(source);
}

void DcrLogger::captureGenerationModule(const ModulePtr &module) {
  generationLog.exprTypeLocations.reserve(module->astTypes.size());
  for (const auto &[expr, ty] : module->astTypes) {
    ExprTypesAtLocation tys;
    tys.location = expr->location;
    tys.ty = ty;

    if (auto expectedTy = module->astExpectedTypes.find(expr))
      tys.expectedTy = *expectedTy;

    generationLog.exprTypeLocations.push_back(tys);
  }

  generationLog.annotationTypeLocations.reserve(
      module->astResolvedTypes.size());
  for (const auto &[annot, ty] : module->astResolvedTypes) {
    AnnotationTypesAtLocation tys;
    tys.location = annot->location;
    tys.resolvedTy = ty;

    generationLog.annotationTypeLocations.push_back(tys);
  }
}

void DcrLogger::captureGenerationError(const TypeError &error) {
  std::string stringifiedError = toString(error);
  generationLog.errors.push_back(ErrorSnapshot{
      /* message */ stringifiedError,
      /* location */ error.location,
  });
}

void DcrLogger::pushBlock(NotNull<const Constraint> constraint, TypeId block) {
  constraintBlocks[constraint].push_back(block);
}

void DcrLogger::pushBlock(NotNull<const Constraint> constraint,
                          TypePackId block) {
  constraintBlocks[constraint].push_back(block);
}

void DcrLogger::pushBlock(NotNull<const Constraint> constraint,
                          NotNull<const Constraint> block) {
  constraintBlocks[constraint].push_back(block);
}

void DcrLogger::popBlock(TypeId block) {
  for (auto &[_, list] : constraintBlocks) {
    list.erase(std::remove(list.begin(), list.end(), block), list.end());
  }
}

void DcrLogger::popBlock(TypePackId block) {
  for (auto &[_, list] : constraintBlocks) {
    list.erase(std::remove(list.begin(), list.end(), block), list.end());
  }
}

void DcrLogger::popBlock(NotNull<const Constraint> block) {
  for (auto &[_, list] : constraintBlocks) {
    list.erase(std::remove(list.begin(), list.end(), block), list.end());
  }
}

static void snapshotTypeStrings(
    const std::vector<ExprTypesAtLocation> &interestedExprs,
    const std::vector<AnnotationTypesAtLocation> &interestedAnnots,
    DenseHashMap<const void *, std::string> &map, ToStringOptions &opts) {
  for (const ExprTypesAtLocation &tys : interestedExprs) {
    map[tys.ty] = toString(tys.ty, opts);

    if (tys.expectedTy)
      map[*tys.expectedTy] = toString(*tys.expectedTy, opts);
  }

  for (const AnnotationTypesAtLocation &tys : interestedAnnots) {
    map[tys.resolvedTy] = toString(tys.resolvedTy, opts);
  }
}

void DcrLogger::captureBoundaryState(
    BoundarySnapshot &target, const Scope *rootScope,
    const std::vector<NotNull<const Constraint>> &unsolvedConstraints) {
  target.rootScope = snapshotScope(rootScope, opts);
  target.unsolvedConstraints.clear();

  for (NotNull<const Constraint> c : unsolvedConstraints) {
    target.unsolvedConstraints[c.get()] = {
        toString(*c.get(), opts),
        c->location,
        snapshotBlocks(c),
    };
  }

  snapshotTypeStrings(generationLog.exprTypeLocations,
                      generationLog.annotationTypeLocations, target.typeStrings,
                      opts);
}

void DcrLogger::captureInitialSolverState(
    const Scope *rootScope,
    const std::vector<NotNull<const Constraint>> &unsolvedConstraints) {
  captureBoundaryState(solveLog.initialState, rootScope, unsolvedConstraints);
}

StepSnapshot DcrLogger::prepareStepSnapshot(
    const Scope *rootScope, NotNull<const Constraint> current, bool force,
    const std::vector<NotNull<const Constraint>> &unsolvedConstraints) {
  ScopeSnapshot scopeSnapshot = snapshotScope(rootScope, opts);
  DenseHashMap<const Constraint *, ConstraintSnapshot> constraints{nullptr};

  for (NotNull<const Constraint> c : unsolvedConstraints) {
    constraints[c.get()] = {
        toString(*c.get(), opts),
        c->location,
        snapshotBlocks(c),
    };
  }

  DenseHashMap<const void *, std::string> typeStrings{nullptr};
  snapshotTypeStrings(generationLog.exprTypeLocations,
                      generationLog.annotationTypeLocations, typeStrings, opts);

  return StepSnapshot{
      current,
      force,
      std::move(constraints),
      scopeSnapshot,
      std::move(typeStrings),
  };
}

void DcrLogger::commitStepSnapshot(StepSnapshot snapshot) {
  solveLog.stepStates.push_back(std::move(snapshot));
}

void DcrLogger::captureFinalSolverState(
    const Scope *rootScope,
    const std::vector<NotNull<const Constraint>> &unsolvedConstraints) {
  captureBoundaryState(solveLog.finalState, rootScope, unsolvedConstraints);
}

void DcrLogger::captureTypeCheckError(const TypeError &error) {
  std::string stringifiedError = toString(error);
  checkLog.errors.push_back(ErrorSnapshot{
      /* message */ stringifiedError,
      /* location */ error.location,
  });
}

std::vector<ConstraintBlock>
DcrLogger::snapshotBlocks(NotNull<const Constraint> c) {
  auto it = constraintBlocks.find(c);
  if (it == constraintBlocks.end()) {
    return {};
  }

  std::vector<ConstraintBlock> snapshot;

  for (const ConstraintBlockTarget &target : it->second) {
    if (const TypeId *ty = get_if<TypeId>(&target)) {
      snapshot.push_back({
          *ty,
          toString(*ty, opts),
      });
    } else if (const TypePackId *tp = get_if<TypePackId>(&target)) {
      snapshot.push_back({
          *tp,
          toString(*tp, opts),
      });
    } else if (const NotNull<const Constraint> *c =
                   get_if<NotNull<const Constraint>>(&target)) {
      snapshot.push_back({
          *c,
          toString(*(c->get()), opts),
      });
    } else {
      LUAU_ASSERT(0);
    }
  }

  return snapshot;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Generalization.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// DONE : was aleready inlined <Luau/ToString.h>

// DONE : was aleready inlined <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

namespace Luau {

struct MutatingGeneralizer : TypeOnceVisitor {
  NotNull<BuiltinTypes> builtinTypes;

  NotNull<Scope> scope;
  NotNull<DenseHashSet<TypeId>> cachedTypes;
  DenseHashMap<const void *, size_t> positiveTypes;
  DenseHashMap<const void *, size_t> negativeTypes;
  std::vector<TypeId> generics;
  std::vector<TypePackId> genericPacks;

  bool isWithinFunction = false;
  bool avoidSealingTables = false;

  MutatingGeneralizer(NotNull<BuiltinTypes> builtinTypes, NotNull<Scope> scope,
                      NotNull<DenseHashSet<TypeId>> cachedTypes,
                      DenseHashMap<const void *, size_t> positiveTypes,
                      DenseHashMap<const void *, size_t> negativeTypes,
                      bool avoidSealingTables)
      : TypeOnceVisitor(/* skipBoundTypes */ true), builtinTypes(builtinTypes),
        scope(scope), cachedTypes(cachedTypes),
        positiveTypes(std::move(positiveTypes)),
        negativeTypes(std::move(negativeTypes)),
        avoidSealingTables(avoidSealingTables) {}

  static void replace(DenseHashSet<TypeId> &seen, TypeId haystack,
                      TypeId needle, TypeId replacement) {
    haystack = follow(haystack);

    if (seen.find(haystack))
      return;
    seen.insert(haystack);

    if (UnionType *ut = getMutable<UnionType>(haystack)) {
      for (auto iter = ut->options.begin(); iter != ut->options.end();) {
        // FIXME: I bet this function has reentrancy problems
        TypeId option = follow(*iter);

        if (option == needle && get<NeverType>(replacement)) {
          iter = ut->options.erase(iter);
          continue;
        }

        if (option == needle) {
          *iter = replacement;
          iter++;
          continue;
        }

        // advance the iterator, nothing after this can use it.
        iter++;

        if (seen.find(option))
          continue;
        seen.insert(option);

        if (get<UnionType>(option))
          replace(seen, option, needle, haystack);
        else if (get<IntersectionType>(option))
          replace(seen, option, needle, haystack);
      }

      if (ut->options.size() == 1) {
        TypeId onlyType = ut->options[0];
        LUAU_ASSERT(onlyType != haystack);
        emplaceType<BoundType>(asMutable(haystack), onlyType);
      }

      return;
    }

    if (IntersectionType *it = getMutable<IntersectionType>(needle)) {
      for (auto iter = it->parts.begin(); iter != it->parts.end();) {
        // FIXME: I bet this function has reentrancy problems
        TypeId part = follow(*iter);

        if (part == needle && get<UnknownType>(replacement)) {
          iter = it->parts.erase(iter);
          continue;
        }

        if (part == needle) {
          *iter = replacement;
          iter++;
          continue;
        }

        // advance the iterator, nothing after this can use it.
        iter++;

        if (seen.find(part))
          continue;
        seen.insert(part);

        if (get<UnionType>(part))
          replace(seen, part, needle, haystack);
        else if (get<IntersectionType>(part))
          replace(seen, part, needle, haystack);
      }

      if (it->parts.size() == 1) {
        TypeId onlyType = it->parts[0];
        LUAU_ASSERT(onlyType != needle);
        emplaceType<BoundType>(asMutable(needle), onlyType);
      }

      return;
    }
  }

  bool visit(TypeId ty, const FunctionType &ft) override {
    if (cachedTypes->contains(ty))
      return false;

    const bool oldValue = isWithinFunction;

    isWithinFunction = true;

    traverse(ft.argTypes);
    traverse(ft.retTypes);

    isWithinFunction = oldValue;

    return false;
  }

  bool visit(TypeId ty, const FreeType &) override {
    LUAU_ASSERT(!cachedTypes->contains(ty));

    const FreeType *ft = get<FreeType>(ty);
    LUAU_ASSERT(ft);

    traverse(ft->lowerBound);
    traverse(ft->upperBound);

    // It is possible for the above traverse() calls to cause ty to be
    // transmuted.  We must reacquire ft if this happens.
    ty = follow(ty);
    ft = get<FreeType>(ty);
    if (!ft)
      return false;

    const size_t positiveCount = getCount(positiveTypes, ty);
    const size_t negativeCount = getCount(negativeTypes, ty);

    if (!positiveCount && !negativeCount)
      return false;

    const bool hasLowerBound = !get<NeverType>(follow(ft->lowerBound));
    const bool hasUpperBound = !get<UnknownType>(follow(ft->upperBound));

    DenseHashSet<TypeId> seen{nullptr};
    seen.insert(ty);

    if (!hasLowerBound && !hasUpperBound) {
      if (!isWithinFunction || (positiveCount + negativeCount == 1))
        emplaceType<BoundType>(asMutable(ty), builtinTypes->unknownType);
      else {
        emplaceType<GenericType>(asMutable(ty), scope);
        generics.push_back(ty);
      }
    }

    // It is possible that this free type has other free types in its upper
    // or lower bounds.  If this is the case, we must replace those
    // references with never (for the lower bound) or unknown (for the upper
    // bound).
    //
    // If we do not do this, we get tautological bounds like a <: a <: unknown.
    else if (positiveCount && !hasUpperBound) {
      TypeId lb = follow(ft->lowerBound);
      if (FreeType *lowerFree = getMutable<FreeType>(lb);
          lowerFree && lowerFree->upperBound == ty)
        lowerFree->upperBound = builtinTypes->unknownType;
      else {
        DenseHashSet<TypeId> replaceSeen{nullptr};
        replace(replaceSeen, lb, ty, builtinTypes->unknownType);
      }

      if (lb != ty)
        emplaceType<BoundType>(asMutable(ty), lb);
      else if (!isWithinFunction || (positiveCount + negativeCount == 1))
        emplaceType<BoundType>(asMutable(ty), builtinTypes->unknownType);
      else {
        // if the lower bound is the type in question, we don't actually have a
        // lower bound.
        emplaceType<GenericType>(asMutable(ty), scope);
        generics.push_back(ty);
      }
    } else {
      TypeId ub = follow(ft->upperBound);
      if (FreeType *upperFree = getMutable<FreeType>(ub);
          upperFree && upperFree->lowerBound == ty)
        upperFree->lowerBound = builtinTypes->neverType;
      else {
        DenseHashSet<TypeId> replaceSeen{nullptr};
        replace(replaceSeen, ub, ty, builtinTypes->neverType);
      }

      if (ub != ty)
        emplaceType<BoundType>(asMutable(ty), ub);
      else if (!isWithinFunction || (positiveCount + negativeCount == 1))
        emplaceType<BoundType>(asMutable(ty), builtinTypes->unknownType);
      else {
        // if the upper bound is the type in question, we don't actually have an
        // upper bound.
        emplaceType<GenericType>(asMutable(ty), scope);
        generics.push_back(ty);
      }
    }

    return false;
  }

  size_t getCount(const DenseHashMap<const void *, size_t> &map,
                  const void *ty) {
    if (const size_t *count = map.find(ty))
      return *count;
    else
      return 0;
  }

  bool visit(TypeId ty, const TableType &) override {
    if (cachedTypes->contains(ty))
      return false;

    const size_t positiveCount = getCount(positiveTypes, ty);
    const size_t negativeCount = getCount(negativeTypes, ty);

    // FIXME: Free tables should probably just be replaced by upper bounds on
    // free types.
    //
    // eg never <: 'a <: {x: number} & {z: boolean}

    if (!positiveCount && !negativeCount)
      return true;

    TableType *tt = getMutable<TableType>(ty);
    LUAU_ASSERT(tt);

    if (!avoidSealingTables)
      tt->state = TableState::Sealed;

    return true;
  }

  bool visit(TypePackId tp, const FreeTypePack &ftp) override {
    if (!subsumes(scope, ftp.scope))
      return true;

    tp = follow(tp);

    const size_t positiveCount = getCount(positiveTypes, tp);
    const size_t negativeCount = getCount(negativeTypes, tp);

    if (1 == positiveCount + negativeCount)
      emplaceTypePack<BoundTypePack>(asMutable(tp),
                                     builtinTypes->unknownTypePack);
    else {
      emplaceTypePack<GenericTypePack>(asMutable(tp), scope);
      genericPacks.push_back(tp);
    }

    return true;
  }
};

struct FreeTypeSearcher : TypeVisitor {
  NotNull<Scope> scope;
  NotNull<DenseHashSet<TypeId>> cachedTypes;

  explicit FreeTypeSearcher(NotNull<Scope> scope,
                            NotNull<DenseHashSet<TypeId>> cachedTypes)
      : TypeVisitor(/*skipBoundTypes*/ true), scope(scope),
        cachedTypes(cachedTypes) {}

  enum Polarity {
    Positive,
    Negative,
    Both,
  };

  Polarity polarity = Positive;

  void flip() {
    switch (polarity) {
    case Positive:
      polarity = Negative;
      break;
    case Negative:
      polarity = Positive;
      break;
    case Both:
      break;
    }
  }

  DenseHashSet<const void *> seenPositive{nullptr};
  DenseHashSet<const void *> seenNegative{nullptr};

  bool seenWithPolarity(const void *ty) {
    switch (polarity) {
    case Positive: {
      if (seenPositive.contains(ty))
        return true;

      seenPositive.insert(ty);
      return false;
    }
    case Negative: {
      if (seenNegative.contains(ty))
        return true;

      seenNegative.insert(ty);
      return false;
    }
    case Both: {
      if (seenPositive.contains(ty) && seenNegative.contains(ty))
        return true;

      seenPositive.insert(ty);
      seenNegative.insert(ty);
      return false;
    }
    }

    return false;
  }

  // The keys in these maps are either TypeIds or TypePackIds. It's safe to
  // mix them because we only use these pointers as unique keys.  We never
  // indirect them.
  DenseHashMap<const void *, size_t> negativeTypes{0};
  DenseHashMap<const void *, size_t> positiveTypes{0};

  bool visit(TypeId ty) override {
    if (cachedTypes->contains(ty) || seenWithPolarity(ty))
      return false;

    LUAU_ASSERT(ty);
    return true;
  }

  bool visit(TypeId ty, const FreeType &ft) override {
    if (cachedTypes->contains(ty) || seenWithPolarity(ty))
      return false;

    if (!subsumes(scope, ft.scope))
      return true;

    switch (polarity) {
    case Positive:
      positiveTypes[ty]++;
      break;
    case Negative:
      negativeTypes[ty]++;
      break;
    case Both:
      positiveTypes[ty]++;
      negativeTypes[ty]++;
      break;
    }

    return true;
  }

  bool visit(TypeId ty, const TableType &tt) override {
    if (cachedTypes->contains(ty) || seenWithPolarity(ty))
      return false;

    if ((tt.state == TableState::Free || tt.state == TableState::Unsealed) &&
        subsumes(scope, tt.scope)) {
      switch (polarity) {
      case Positive:
        positiveTypes[ty]++;
        break;
      case Negative:
        negativeTypes[ty]++;
        break;
      case Both:
        positiveTypes[ty]++;
        negativeTypes[ty]++;
        break;
      }
    }

    for (const auto &[_name, prop] : tt.props) {
      if (prop.isReadOnly())
        traverse(*prop.readTy);
      else {
        LUAU_ASSERT(prop.isShared());

        Polarity p = polarity;
        polarity = Both;
        traverse(prop.type());
        polarity = p;
      }
    }

    if (tt.indexer) {
      traverse(tt.indexer->indexType);
      traverse(tt.indexer->indexResultType);
    }

    return false;
  }

  bool visit(TypeId ty, const FunctionType &ft) override {
    if (cachedTypes->contains(ty) || seenWithPolarity(ty))
      return false;

    flip();
    traverse(ft.argTypes);
    flip();

    traverse(ft.retTypes);

    return false;
  }

  bool visit(TypeId, const ClassType &) override { return false; }

  bool visit(TypePackId tp, const FreeTypePack &ftp) override {
    if (seenWithPolarity(tp))
      return false;

    if (!subsumes(scope, ftp.scope))
      return true;

    switch (polarity) {
    case Positive:
      positiveTypes[tp]++;
      break;
    case Negative:
      negativeTypes[tp]++;
      break;
    case Both:
      positiveTypes[tp]++;
      negativeTypes[tp]++;
      break;
    }

    return true;
  }
};

// We keep a running set of types that will not change under generalization and
// only have outgoing references to types that are the same.  We use this to
// short circuit generalization.  It improves performance quite a lot.
//
// We do this by tracing through the type and searching for types that are
// uncacheable. If a type has a reference to an uncacheable type, it is itself
// uncacheable.
//
// If a type has no outbound references to uncacheable types, we add it to the
// cache.
struct TypeCacher : TypeOnceVisitor {
  NotNull<DenseHashSet<TypeId>> cachedTypes;

  DenseHashSet<TypeId> uncacheable{nullptr};
  DenseHashSet<TypePackId> uncacheablePacks{nullptr};

  explicit TypeCacher(NotNull<DenseHashSet<TypeId>> cachedTypes)
      : TypeOnceVisitor(/* skipBoundTypes */ true), cachedTypes(cachedTypes) {}

  void cache(TypeId ty) { cachedTypes->insert(ty); }

  bool isCached(TypeId ty) const { return cachedTypes->contains(ty); }

  void markUncacheable(TypeId ty) { uncacheable.insert(ty); }

  void markUncacheable(TypePackId tp) { uncacheablePacks.insert(tp); }

  bool isUncacheable(TypeId ty) const { return uncacheable.contains(ty); }

  bool isUncacheable(TypePackId tp) const {
    return uncacheablePacks.contains(tp);
  }

  bool visit(TypeId ty) override {
    if (isUncacheable(ty) || isCached(ty))
      return false;
    return true;
  }

  bool visit(TypeId ty, const FreeType &ft) override {
    // Free types are never cacheable.
    LUAU_ASSERT(!isCached(ty));

    if (!isUncacheable(ty)) {
      traverse(ft.lowerBound);
      traverse(ft.upperBound);

      markUncacheable(ty);
    }

    return false;
  }

  bool visit(TypeId ty, const GenericType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const PrimitiveType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const SingletonType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const BlockedType &) override {
    markUncacheable(ty);
    return false;
  }

  bool visit(TypeId ty, const PendingExpansionType &) override {
    markUncacheable(ty);
    return false;
  }

  bool visit(TypeId ty, const FunctionType &ft) override {
    if (isCached(ty) || isUncacheable(ty))
      return false;

    traverse(ft.argTypes);
    traverse(ft.retTypes);
    for (TypeId gen : ft.generics)
      traverse(gen);

    bool uncacheable = false;

    if (isUncacheable(ft.argTypes))
      uncacheable = true;

    else if (isUncacheable(ft.retTypes))
      uncacheable = true;

    for (TypeId argTy : ft.argTypes) {
      if (isUncacheable(argTy)) {
        uncacheable = true;
        break;
      }
    }

    for (TypeId retTy : ft.retTypes) {
      if (isUncacheable(retTy)) {
        uncacheable = true;
        break;
      }
    }

    for (TypeId g : ft.generics) {
      if (isUncacheable(g)) {
        uncacheable = true;
        break;
      }
    }

    if (uncacheable)
      markUncacheable(ty);
    else
      cache(ty);

    return false;
  }

  bool visit(TypeId ty, const TableType &tt) override {
    if (isCached(ty) || isUncacheable(ty))
      return false;

    if (tt.boundTo) {
      traverse(*tt.boundTo);
      if (isUncacheable(*tt.boundTo)) {
        markUncacheable(ty);
        return false;
      }
    }

    bool uncacheable = false;

    // This logic runs immediately after generalization, so any remaining
    // unsealed tables are assuredly not cacheable.  They may yet have
    // properties added to them.
    if (tt.state == TableState::Free || tt.state == TableState::Unsealed)
      uncacheable = true;

    for (const auto &[_name, prop] : tt.props) {
      if (prop.readTy) {
        traverse(*prop.readTy);

        if (isUncacheable(*prop.readTy))
          uncacheable = true;
      }
      if (prop.writeTy && prop.writeTy != prop.readTy) {
        traverse(*prop.writeTy);

        if (isUncacheable(*prop.writeTy))
          uncacheable = true;
      }
    }

    if (tt.indexer) {
      traverse(tt.indexer->indexType);
      if (isUncacheable(tt.indexer->indexType))
        uncacheable = true;

      traverse(tt.indexer->indexResultType);
      if (isUncacheable(tt.indexer->indexResultType))
        uncacheable = true;
    }

    if (uncacheable)
      markUncacheable(ty);
    else
      cache(ty);

    return false;
  }

  bool visit(TypeId ty, const ClassType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const AnyType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const UnionType &ut) override {
    if (isUncacheable(ty) || isCached(ty))
      return false;

    bool uncacheable = false;

    for (TypeId partTy : ut.options) {
      traverse(partTy);

      uncacheable |= isUncacheable(partTy);
    }

    if (uncacheable)
      markUncacheable(ty);
    else
      cache(ty);

    return false;
  }

  bool visit(TypeId ty, const IntersectionType &it) override {
    if (isUncacheable(ty) || isCached(ty))
      return false;

    bool uncacheable = false;

    for (TypeId partTy : it.parts) {
      traverse(partTy);

      uncacheable |= isUncacheable(partTy);
    }

    if (uncacheable)
      markUncacheable(ty);
    else
      cache(ty);

    return false;
  }

  bool visit(TypeId ty, const UnknownType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const NeverType &) override {
    cache(ty);
    return false;
  }

  bool visit(TypeId ty, const NegationType &nt) override {
    if (!isCached(ty) && !isUncacheable(ty)) {
      traverse(nt.ty);

      if (isUncacheable(nt.ty))
        markUncacheable(ty);
      else
        cache(ty);
    }

    return false;
  }

  bool visit(TypeId ty, const TypeFunctionInstanceType &tfit) override {
    if (isCached(ty) || isUncacheable(ty))
      return false;

    bool uncacheable = false;

    for (TypeId argTy : tfit.typeArguments) {
      traverse(argTy);

      if (isUncacheable(argTy))
        uncacheable = true;
    }

    for (TypePackId argPack : tfit.packArguments) {
      traverse(argPack);

      if (isUncacheable(argPack))
        uncacheable = true;
    }

    if (uncacheable)
      markUncacheable(ty);
    else
      cache(ty);

    return false;
  }

  bool visit(TypePackId tp, const FreeTypePack &) override {
    markUncacheable(tp);
    return false;
  }

  bool visit(TypePackId tp, const VariadicTypePack &vtp) override {
    if (isUncacheable(tp))
      return false;

    traverse(vtp.ty);

    if (isUncacheable(vtp.ty))
      markUncacheable(tp);

    return false;
  }

  bool visit(TypePackId tp, const BlockedTypePack &) override {
    markUncacheable(tp);
    return false;
  }

  bool visit(TypePackId tp, const TypeFunctionInstanceTypePack &) override {
    markUncacheable(tp);
    return false;
  }
};

std::optional<TypeId> generalize(NotNull<TypeArena> arena,
                                 NotNull<BuiltinTypes> builtinTypes,
                                 NotNull<Scope> scope,
                                 NotNull<DenseHashSet<TypeId>> cachedTypes,
                                 TypeId ty, bool avoidSealingTables) {
  ty = follow(ty);

  if (ty->owningArena != arena || ty->persistent)
    return ty;

  if (const FunctionType *ft = get<FunctionType>(ty);
      ft && (!ft->generics.empty() || !ft->genericPacks.empty()))
    return ty;

  FreeTypeSearcher fts{scope, cachedTypes};
  fts.traverse(ty);

  MutatingGeneralizer gen{builtinTypes,
                          scope,
                          cachedTypes,
                          std::move(fts.positiveTypes),
                          std::move(fts.negativeTypes),
                          avoidSealingTables};

  gen.traverse(ty);

  /* MutatingGeneralizer mutates types in place, so it is possible that ty has
   * been transmuted to a BoundType. We must follow it again and verify that
   * we are allowed to mutate it before we attach generics to it.
   */
  ty = follow(ty);

  if (ty->owningArena != arena || ty->persistent)
    return ty;

  TypeCacher cacher{cachedTypes};
  cacher.traverse(ty);

  FunctionType *ftv = getMutable<FunctionType>(ty);
  if (ftv) {
    ftv->generics = std::move(gen.generics);
    ftv->genericPacks = std::move(gen.genericPacks);
  }

  return ty;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeOrPack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

namespace Luau {

const void *ptr(TypeOrPack tyOrTp) {
  if (auto ty = get<TypeId>(tyOrTp))
    return static_cast<const void *>(*ty);
  else if (auto tp = get<TypePackId>(tyOrTp))
    return static_cast<const void *>(*tp);
  else
    LUAU_UNREACHABLE();
}

TypeOrPack follow(TypeOrPack tyOrTp) {
  if (auto ty = get<TypeId>(tyOrTp))
    return follow(*ty);
  else if (auto tp = get<TypePackId>(tyOrTp))
    return follow(*tp);
  else
    LUAU_UNREACHABLE();
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/IostreamHelpers.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePath.h>

namespace Luau {

std::ostream &operator<<(std::ostream &stream, const Position &position) {
  return stream << "{ line = " << position.line << ", col = " << position.column
                << " }";
}

std::ostream &operator<<(std::ostream &stream, const Location &location) {
  return stream << "Location { " << location.begin << ", " << location.end
                << " }";
}

std::ostream &operator<<(std::ostream &stream, const AstName &name) {
  if (name.value)
    return stream << name.value;
  else
    return stream << "<empty>";
}

template <typename T>
static void errorToString(std::ostream &stream, const T &err) {
  if constexpr (false) {
  } else if constexpr (std::is_same_v<T, TypeMismatch>)
    stream << "TypeMismatch { " << toString(err.wantedType) << ", "
           << toString(err.givenType) << " }";
  else if constexpr (std::is_same_v<T, UnknownSymbol>)
    stream << "UnknownSymbol { " << err.name << " , context " << err.context
           << " }";
  else if constexpr (std::is_same_v<T, UnknownProperty>)
    stream << "UnknownProperty { " << toString(err.table)
           << ", key = " << err.key << " }";
  else if constexpr (std::is_same_v<T, NotATable>)
    stream << "NotATable { " << toString(err.ty) << " }";
  else if constexpr (std::is_same_v<T, CannotExtendTable>)
    stream << "CannotExtendTable { " << toString(err.tableType) << ", context "
           << err.context << ", prop \"" << err.prop << "\" }";
  else if constexpr (std::is_same_v<T, OnlyTablesCanHaveMethods>)
    stream << "OnlyTablesCanHaveMethods { " << toString(err.tableType) << " }";
  else if constexpr (std::is_same_v<T, DuplicateTypeDefinition>)
    stream << "DuplicateTypeDefinition { " << err.name << " }";
  else if constexpr (std::is_same_v<T, CountMismatch>)
    stream << "CountMismatch { expected " << err.expected << ", got "
           << err.actual << ", context " << err.context << " }";
  else if constexpr (std::is_same_v<T, FunctionDoesNotTakeSelf>)
    stream << "FunctionDoesNotTakeSelf { }";
  else if constexpr (std::is_same_v<T, FunctionRequiresSelf>)
    stream << "FunctionRequiresSelf { }";
  else if constexpr (std::is_same_v<T, OccursCheckFailed>)
    stream << "OccursCheckFailed { }";
  else if constexpr (std::is_same_v<T, UnknownRequire>)
    stream << "UnknownRequire { " << err.modulePath << " }";
  else if constexpr (std::is_same_v<T, IncorrectGenericParameterCount>) {
    stream << "IncorrectGenericParameterCount { name = " << err.name;

    if (!err.typeFun.typeParams.empty() ||
        !err.typeFun.typePackParams.empty()) {
      stream << "<";
      bool first = true;
      for (auto param : err.typeFun.typeParams) {
        if (first)
          first = false;
        else
          stream << ", ";

        stream << toString(param.ty);
      }

      for (auto param : err.typeFun.typePackParams) {
        if (first)
          first = false;
        else
          stream << ", ";

        stream << toString(param.tp);
      }

      stream << ">";
    }

    stream << ", typeFun = " << toString(err.typeFun.type)
           << ", actualCount = " << err.actualParameters << " }";
  } else if constexpr (std::is_same_v<T, SyntaxError>)
    stream << "SyntaxError { " << err.message << " }";
  else if constexpr (std::is_same_v<T, CodeTooComplex>)
    stream << "CodeTooComplex {}";
  else if constexpr (std::is_same_v<T, UnificationTooComplex>)
    stream << "UnificationTooComplex {}";
  else if constexpr (std::is_same_v<T, UnknownPropButFoundLikeProp>) {
    stream << "UnknownPropButFoundLikeProp { key = '" << err.key
           << "', suggested = { ";

    bool first = true;
    for (Name name : err.candidates) {
      if (first)
        first = false;
      else
        stream << ", ";

      stream << "'" << name << "'";
    }

    stream << " }, table = " << toString(err.table) << " } ";
  } else if constexpr (std::is_same_v<T, GenericError>)
    stream << "GenericError { " << err.message << " }";
  else if constexpr (std::is_same_v<T, InternalError>)
    stream << "InternalError { " << err.message << " }";
  else if constexpr (std::is_same_v<T, CannotCallNonFunction>)
    stream << "CannotCallNonFunction { " << toString(err.ty) << " }";
  else if constexpr (std::is_same_v<T, ExtraInformation>)
    stream << "ExtraInformation { " << err.message << " }";
  else if constexpr (std::is_same_v<T, DeprecatedApiUsed>)
    stream << "DeprecatedApiUsed { " << err.symbol
           << ", useInstead = " << err.useInstead << " }";
  else if constexpr (std::is_same_v<T, ModuleHasCyclicDependency>) {
    stream << "ModuleHasCyclicDependency {";

    bool first = true;
    for (const ModuleName &name : err.cycle) {
      if (first)
        first = false;
      else
        stream << ", ";

      stream << name;
    }

    stream << "}";
  } else if constexpr (std::is_same_v<T, IllegalRequire>)
    stream << "IllegalRequire { " << err.moduleName
           << ", reason = " << err.reason << " }";
  else if constexpr (std::is_same_v<T, FunctionExitsWithoutReturning>)
    stream << "FunctionExitsWithoutReturning {"
           << toString(err.expectedReturnType) << "}";
  else if constexpr (std::is_same_v<T, DuplicateGenericParameter>)
    stream << "DuplicateGenericParameter { " + err.parameterName + " }";
  else if constexpr (std::is_same_v<T, CannotInferBinaryOperation>)
    stream << "CannotInferBinaryOperation { op = " + toString(err.op) +
                  ", suggested = '" +
                  (err.suggestedToAnnotate ? *err.suggestedToAnnotate : "") +
                  "', kind "
           << err.kind << "}";
  else if constexpr (std::is_same_v<T, MissingProperties>) {
    stream << "MissingProperties { superType = '" << toString(err.superType)
           << "', subType = '" << toString(err.subType) << "', properties = { ";

    bool first = true;
    for (Name name : err.properties) {
      if (first)
        first = false;
      else
        stream << ", ";

      stream << "'" << name << "'";
    }

    stream << " }, context " << err.context << " } ";
  } else if constexpr (std::is_same_v<T, SwappedGenericTypeParameter>)
    stream << "SwappedGenericTypeParameter { name = '" + err.name +
                  "', kind = " + std::to_string(err.kind) + " }";
  else if constexpr (std::is_same_v<T, OptionalValueAccess>)
    stream << "OptionalValueAccess { optional = '" + toString(err.optional) +
                  "' }";
  else if constexpr (std::is_same_v<T, MissingUnionProperty>) {
    stream << "MissingUnionProperty { type = '" + toString(err.type) +
                  "', missing = { ";

    bool first = true;
    for (auto ty : err.missing) {
      if (first)
        first = false;
      else
        stream << ", ";

      stream << "'" << toString(ty) << "'";
    }

    stream << " }, key = '" + err.key + "' }";
  } else if constexpr (std::is_same_v<T, TypesAreUnrelated>)
    stream << "TypesAreUnrelated { left = '" + toString(err.left) +
                  "', right = '" + toString(err.right) + "' }";
  else if constexpr (std::is_same_v<T, NormalizationTooComplex>)
    stream << "NormalizationTooComplex { }";
  else if constexpr (std::is_same_v<T, TypePackMismatch>)
    stream << "TypePackMismatch { wanted = '" + toString(err.wantedTp) +
                  "', given = '" + toString(err.givenTp) + "' }";
  else if constexpr (std::is_same_v<T, DynamicPropertyLookupOnClassesUnsafe>)
    stream << "DynamicPropertyLookupOnClassesUnsafe { " << toString(err.ty)
           << " }";
  else if constexpr (std::is_same_v<T, UninhabitedTypeFunction>)
    stream << "UninhabitedTypeFunction { " << toString(err.ty) << " }";
  else if constexpr (std::is_same_v<T, ExplicitFunctionAnnotationRecommended>) {
    std::string recArgs = "[";
    for (auto [s, t] : err.recommendedArgs)
      recArgs += " " + s + ": " + toString(t);
    recArgs += " ]";
    stream << "ExplicitFunctionAnnotationRecommended { recommmendedReturn = '" +
                  toString(err.recommendedReturn) +
                  "', recommmendedArgs = " + recArgs + "}";
  } else if constexpr (std::is_same_v<T, UninhabitedTypePackFunction>)
    stream << "UninhabitedTypePackFunction { " << toString(err.tp) << " }";
  else if constexpr (std::is_same_v<T, WhereClauseNeeded>)
    stream << "WhereClauseNeeded { " << toString(err.ty) << " }";
  else if constexpr (std::is_same_v<T, PackWhereClauseNeeded>)
    stream << "PackWhereClauseNeeded { " << toString(err.tp) << " }";
  else if constexpr (std::is_same_v<T, CheckedFunctionCallError>)
    stream << "CheckedFunctionCallError { expected = '"
           << toString(err.expected) << "', passed = '" << toString(err.passed)
           << "', checkedFunctionName = " << err.checkedFunctionName
           << ", argumentIndex = " << std::to_string(err.argumentIndex) << " }";
  else if constexpr (std::is_same_v<T, NonStrictFunctionDefinitionError>)
    stream << "NonStrictFunctionDefinitionError { functionName = '" +
                  err.functionName + "', argument = '" + err.argument +
                  "', argumentType = '" + toString(err.argumentType) + "' }";
  else if constexpr (std::is_same_v<T, PropertyAccessViolation>)
    stream << "PropertyAccessViolation { table = " << toString(err.table)
           << ", prop = '" << err.key << "', context = " << err.context << " }";
  else if constexpr (std::is_same_v<T, CheckedFunctionIncorrectArgs>)
    stream << "CheckedFunction {  functionName = '" + err.functionName +
                  ", expected = " + std::to_string(err.expected) +
                  ", actual = " + std::to_string(err.actual) + "}";
  else if constexpr (std::is_same_v<T, UnexpectedTypeInSubtyping>)
    stream << "UnexpectedTypeInSubtyping {  ty = '" + toString(err.ty) + "' }";
  else if constexpr (std::is_same_v<T, UnexpectedTypePackInSubtyping>)
    stream << "UnexpectedTypePackInSubtyping {  tp = '" + toString(err.tp) +
                  "' }";
  else if constexpr (std::is_same_v<T, CannotAssignToNever>) {
    stream << "CannotAssignToNever { rvalueType = '" << toString(err.rhsType)
           << "', reason = '" << err.reason << "', cause = { ";

    bool first = true;
    for (TypeId ty : err.cause) {
      if (first)
        first = false;
      else
        stream << ", ";

      stream << "'" << toString(ty) << "'";
    }

    stream << " } } ";
  } else
    static_assert(always_false_v<T>, "Non-exhaustive type switch");
}

std::ostream &operator<<(std::ostream &stream,
                         const CannotAssignToNever::Reason &reason) {
  switch (reason) {
  case CannotAssignToNever::Reason::PropertyNarrowed:
    return stream << "PropertyNarrowed";
  default:
    return stream << "UnknownReason";
  }
}

std::ostream &operator<<(std::ostream &stream, const TypeErrorData &data) {
  auto cb = [&](const auto &e) { return errorToString(stream, e); };
  visit(cb, data);
  return stream;
}

std::ostream &operator<<(std::ostream &stream, const TypeError &error) {
  return stream << "TypeError { \"" << error.moduleName << "\", "
                << error.location << ", " << error.data << " }";
}

std::ostream &operator<<(std::ostream &stream, const TableState &tv) {
  return stream << static_cast<std::underlying_type<TableState>::type>(tv);
}

std::ostream &operator<<(std::ostream &stream, const Type &tv) {
  return stream << toString(tv);
}

std::ostream &operator<<(std::ostream &stream, const TypePackVar &tv) {
  return stream << toString(tv);
}

std::ostream &operator<<(std::ostream &stream, TypeId ty) {
  // we commonly use a null pointer when a type may not be present; we need to
  // account for that here.
  if (!ty)
    return stream << "<nullptr>";

  return stream << toString(ty);
}

std::ostream &operator<<(std::ostream &stream, TypePackId tp) {
  // we commonly use a null pointer when a type may not be present; we need to
  // account for that here.
  if (!tp)
    return stream << "<nullptr>";

  return stream << toString(tp);
}

namespace TypePath {

std::ostream &operator<<(std::ostream &stream, const Path &path) {
  return stream << toString(path);
}

} // namespace TypePath

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// DONE : was aleready inlined <Luau/Set.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// DONE : was aleready inlined <Luau/TypePairHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTINT(LuauTypeReductionRecursionLimit)
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)
LUAU_DYNAMIC_FASTINTVARIABLE(LuauSimplificationComplexityLimit, 8);

namespace Luau {

using SimplifierSeenSet = Set<std::pair<TypeId, TypeId>, TypePairHash>;

struct TypeSimplifier {
  NotNull<BuiltinTypes> builtinTypes;
  NotNull<TypeArena> arena;

  DenseHashSet<TypeId> blockedTypes{nullptr};

  int recursionDepth = 0;

  TypeId mkNegation(TypeId ty);

  TypeId intersectFromParts(std::set<TypeId> parts);

  TypeId intersectUnionWithType(TypeId unionTy, TypeId right);
  TypeId intersectUnions(TypeId left, TypeId right);
  TypeId intersectNegatedUnion(TypeId unionTy, TypeId right);

  TypeId intersectTypeWithNegation(TypeId a, TypeId b);
  TypeId intersectNegations(TypeId a, TypeId b);

  TypeId intersectIntersectionWithType(TypeId left, TypeId right);

  // Attempt to intersect the two types.  Does not recurse.  Does not handle
  // unions, intersections, or negations.
  std::optional<TypeId> basicIntersect(TypeId left, TypeId right);

  TypeId intersect(TypeId ty, TypeId discriminant);
  TypeId union_(TypeId ty, TypeId discriminant);

  TypeId simplify(TypeId ty);
  TypeId simplify(TypeId ty, DenseHashSet<TypeId> &seen);
};

// Match the exact type false|nil
static bool isFalsyType(TypeId ty) {
  ty = follow(ty);
  const UnionType *ut = get<UnionType>(ty);
  if (!ut)
    return false;

  bool hasFalse = false;
  bool hasNil = false;

  auto it = begin(ut);
  if (it == end(ut))
    return false;

  TypeId t = follow(*it);

  if (auto pt = get<PrimitiveType>(t); pt && pt->type == PrimitiveType::NilType)
    hasNil = true;
  else if (auto st = get<SingletonType>(t);
           st && st->variant == BooleanSingleton{false})
    hasFalse = true;
  else
    return false;

  ++it;
  if (it == end(ut))
    return false;

  t = follow(*it);

  if (auto pt = get<PrimitiveType>(t); pt && pt->type == PrimitiveType::NilType)
    hasNil = true;
  else if (auto st = get<SingletonType>(t);
           st && st->variant == BooleanSingleton{false})
    hasFalse = true;
  else
    return false;

  ++it;
  if (it != end(ut))
    return false;

  return hasFalse && hasNil;
}

// Match the exact type ~(false|nil)
bool isTruthyType(TypeId ty) {
  ty = follow(ty);

  const NegationType *nt = get<NegationType>(ty);
  if (!nt)
    return false;

  return isFalsyType(nt->ty);
}

Relation flip(Relation rel) {
  switch (rel) {
  case Relation::Subset:
    return Relation::Superset;
  case Relation::Superset:
    return Relation::Subset;
  default:
    return rel;
  }
}

// FIXME: I'm not completely certain that this function is theoretically
// reasonable.
Relation combine(Relation a, Relation b) {
  switch (a) {
  case Relation::Disjoint:
    switch (b) {
    case Relation::Disjoint:
      return Relation::Disjoint;
    case Relation::Coincident:
      return Relation::Superset;
    case Relation::Intersects:
      return Relation::Intersects;
    case Relation::Subset:
      return Relation::Intersects;
    case Relation::Superset:
      return Relation::Intersects;
    }
  case Relation::Coincident:
    switch (b) {
    case Relation::Disjoint:
      return Relation::Coincident;
    case Relation::Coincident:
      return Relation::Coincident;
    case Relation::Intersects:
      return Relation::Superset;
    case Relation::Subset:
      return Relation::Coincident;
    case Relation::Superset:
      return Relation::Intersects;
    }
  case Relation::Superset:
    switch (b) {
    case Relation::Disjoint:
      return Relation::Superset;
    case Relation::Coincident:
      return Relation::Superset;
    case Relation::Intersects:
      return Relation::Intersects;
    case Relation::Subset:
      return Relation::Intersects;
    case Relation::Superset:
      return Relation::Superset;
    }
  case Relation::Subset:
    switch (b) {
    case Relation::Disjoint:
      return Relation::Subset;
    case Relation::Coincident:
      return Relation::Coincident;
    case Relation::Intersects:
      return Relation::Intersects;
    case Relation::Subset:
      return Relation::Subset;
    case Relation::Superset:
      return Relation::Intersects;
    }
  case Relation::Intersects:
    switch (b) {
    case Relation::Disjoint:
      return Relation::Intersects;
    case Relation::Coincident:
      return Relation::Superset;
    case Relation::Intersects:
      return Relation::Intersects;
    case Relation::Subset:
      return Relation::Intersects;
    case Relation::Superset:
      return Relation::Intersects;
    }
  }

  LUAU_UNREACHABLE();
  return Relation::Intersects;
}

// Given A & B, what is A & ~B?
Relation invert(Relation r) {
  switch (r) {
  case Relation::Disjoint:
    return Relation::Subset;
  case Relation::Coincident:
    return Relation::Disjoint;
  case Relation::Intersects:
    return Relation::Intersects;
  case Relation::Subset:
    return Relation::Disjoint;
  case Relation::Superset:
    return Relation::Intersects;
  }

  LUAU_UNREACHABLE();
  return Relation::Intersects;
}

static bool isTypeVariable(TypeId ty) {
  return get<FreeType>(ty) || get<GenericType>(ty) || get<BlockedType>(ty) ||
         get<PendingExpansionType>(ty);
}

Relation relate(TypeId left, TypeId right, SimplifierSeenSet &seen);

Relation relateTables(TypeId left, TypeId right, SimplifierSeenSet &seen) {
  NotNull<const TableType> leftTable{get<TableType>(left)};
  NotNull<const TableType> rightTable{get<TableType>(right)};
  LUAU_ASSERT(1 == rightTable->props.size());
  // Disjoint props have nothing in common
  // t1 with props p1's cannot appear in t2 and t2 with props p2's cannot appear
  // in t1
  bool foundPropFromLeftInRight = std::any_of(
      begin(leftTable->props), end(leftTable->props),
      [&](auto prop) { return rightTable->props.count(prop.first) > 0; });
  bool foundPropFromRightInLeft = std::any_of(
      begin(rightTable->props), end(rightTable->props),
      [&](auto prop) { return leftTable->props.count(prop.first) > 0; });

  if (!foundPropFromLeftInRight && !foundPropFromRightInLeft &&
      leftTable->props.size() >= 1 && rightTable->props.size() >= 1)
    return Relation::Disjoint;

  const auto [propName, rightProp] = *begin(rightTable->props);

  auto it = leftTable->props.find(propName);
  if (it == leftTable->props.end()) {
    // Every table lacking a property is a supertype of a table having that
    // property but the reverse is not true.
    return Relation::Superset;
  }

  const Property leftProp = it->second;

  if (!leftProp.isShared() || !rightProp.isShared())
    return Relation::Intersects;

  Relation r = relate(leftProp.type(), rightProp.type(), seen);
  if (r == Relation::Coincident && 1 != leftTable->props.size()) {
    // eg {tag: "cat", prop: string} & {tag: "cat"}
    return Relation::Subset;
  } else
    return r;
}

// A cheap and approximate subtype test
Relation relate(TypeId left, TypeId right, SimplifierSeenSet &seen) {
  // TODO nice to have: Relate functions of equal argument and return arity

  left = follow(left);
  right = follow(right);

  if (left == right)
    return Relation::Coincident;

  std::pair<TypeId, TypeId> typePair{left, right};
  if (!seen.insert(typePair)) {
    // TODO: is this right at all?
    // The thinking here is that this is a cycle if we get here, and therefore
    // its coincident.
    return Relation::Coincident;
  }

  if (get<UnknownType>(left)) {
    if (get<AnyType>(right))
      return Relation::Subset;
    else if (get<UnknownType>(right))
      return Relation::Coincident;
    else if (get<ErrorType>(right))
      return Relation::Disjoint;
    else
      return Relation::Superset;
  }

  if (get<UnknownType>(right))
    return flip(relate(right, left, seen));

  if (get<AnyType>(left)) {
    if (get<AnyType>(right))
      return Relation::Coincident;
    else
      return Relation::Superset;
  }

  if (get<AnyType>(right))
    return flip(relate(right, left, seen));

  // Type variables
  // * FreeType
  // * GenericType
  // * BlockedType
  // * PendingExpansionType

  // Tops and bottoms
  // * ErrorType
  // * AnyType
  // * NeverType
  // * UnknownType

  // Concrete
  // * PrimitiveType
  // * SingletonType
  // * FunctionType
  // * TableType
  // * MetatableType
  // * ClassType
  // * UnionType
  // * IntersectionType
  // * NegationType

  if (isTypeVariable(left) || isTypeVariable(right))
    return Relation::Intersects;

  if (get<ErrorType>(left)) {
    if (get<ErrorType>(right))
      return Relation::Coincident;
    else if (get<AnyType>(right))
      return Relation::Subset;
    else
      return Relation::Disjoint;
  }
  if (get<ErrorType>(right))
    return flip(relate(right, left, seen));

  if (get<NeverType>(left)) {
    if (get<NeverType>(right))
      return Relation::Coincident;
    else
      return Relation::Subset;
  }
  if (get<NeverType>(right))
    return flip(relate(right, left, seen));

  if (auto ut = get<IntersectionType>(left))
    return Relation::Intersects;
  else if (auto ut = get<IntersectionType>(right))
    return Relation::Intersects;

  if (auto ut = get<UnionType>(left))
    return Relation::Intersects;
  else if (auto ut = get<UnionType>(right)) {
    std::vector<Relation> opts;
    for (TypeId part : ut) {
      Relation r = relate(left, part, seen);

      if (r == Relation::Subset || r == Relation::Coincident)
        return Relation::Subset;
    }
    return Relation::Intersects;
  }

  if (auto rnt = get<NegationType>(right)) {
    Relation a = relate(left, rnt->ty, seen);
    switch (a) {
    case Relation::Coincident:
      // number & ~number
      return Relation::Disjoint;
    case Relation::Disjoint:
      if (get<NegationType>(left)) {
        // ~number & ~string
        return Relation::Intersects;
      } else {
        // number & ~string
        return Relation::Subset;
      }
    case Relation::Intersects:
      // ~(false?) & ~boolean
      return Relation::Intersects;
    case Relation::Subset:
      // "hello" & ~string
      return Relation::Disjoint;
    case Relation::Superset:
      // ~function & ~(false?)  -> ~function
      // boolean & ~(false?)    -> true
      // string & ~"hello"      -> string & ~"hello"
      return Relation::Intersects;
    }
  } else if (get<NegationType>(left))
    return flip(relate(right, left, seen));

  if (auto lp = get<PrimitiveType>(left)) {
    if (auto rp = get<PrimitiveType>(right)) {
      if (lp->type == rp->type)
        return Relation::Coincident;
      else
        return Relation::Disjoint;
    }

    if (auto rs = get<SingletonType>(right)) {
      if (lp->type == PrimitiveType::String &&
          rs->variant.get_if<StringSingleton>())
        return Relation::Superset;
      else if (lp->type == PrimitiveType::Boolean &&
               rs->variant.get_if<BooleanSingleton>())
        return Relation::Superset;
      else
        return Relation::Disjoint;
    }

    if (lp->type == PrimitiveType::Function) {
      if (get<FunctionType>(right))
        return Relation::Superset;
      else
        return Relation::Disjoint;
    }
    if (lp->type == PrimitiveType::Table) {
      if (get<TableType>(right))
        return Relation::Superset;
      else
        return Relation::Disjoint;
    }

    if (get<FunctionType>(right) || get<TableType>(right) ||
        get<MetatableType>(right) || get<ClassType>(right))
      return Relation::Disjoint;
  }

  if (auto ls = get<SingletonType>(left)) {
    if (get<FunctionType>(right) || get<TableType>(right) ||
        get<MetatableType>(right) || get<ClassType>(right))
      return Relation::Disjoint;

    if (get<PrimitiveType>(right))
      return flip(relate(right, left, seen));
    if (auto rs = get<SingletonType>(right)) {
      if (ls->variant == rs->variant)
        return Relation::Coincident;
      else
        return Relation::Disjoint;
    }
  }

  if (get<FunctionType>(left)) {
    if (auto rp = get<PrimitiveType>(right)) {
      if (rp->type == PrimitiveType::Function)
        return Relation::Subset;
      else
        return Relation::Disjoint;
    } else
      return Relation::Intersects;
  }

  if (auto lt = get<TableType>(left)) {
    if (auto rp = get<PrimitiveType>(right)) {
      if (rp->type == PrimitiveType::Table)
        return Relation::Subset;
      else
        return Relation::Disjoint;
    } else if (auto rt = get<TableType>(right)) {
      // TODO PROBABLY indexers and metatables.
      if (1 == rt->props.size()) {
        Relation r = relateTables(left, right, seen);
        /*
         * A reduction of these intersections is certainly possible, but
         * it would require minting new table types. Also, I don't think
         * it's super likely for this to arise from a refinement.
         *
         * Time will tell!
         *
         * ex we simplify this
         *     {tag: string} & {tag: "cat"}
         * but not this
         *     {tag: string, prop: number} & {tag: "cat"}
         */
        if (lt->props.size() > 1 && r == Relation::Superset)
          return Relation::Intersects;
        else
          return r;
      } else if (1 == lt->props.size())
        return flip(relate(right, left, seen));
      else
        return Relation::Intersects;
    }
    // TODO metatables

    return Relation::Disjoint;
  }

  if (auto ct = get<ClassType>(left)) {
    if (auto rct = get<ClassType>(right)) {
      if (isSubclass(ct, rct))
        return Relation::Subset;
      else if (isSubclass(rct, ct))
        return Relation::Superset;
      else
        return Relation::Disjoint;
    }

    return Relation::Disjoint;
  }

  return Relation::Intersects;
}

// A cheap and approximate subtype test
Relation relate(TypeId left, TypeId right) {
  SimplifierSeenSet seen{{}};
  return relate(left, right, seen);
}

TypeId TypeSimplifier::mkNegation(TypeId ty) {
  TypeId result = nullptr;

  if (ty == builtinTypes->truthyType)
    result = builtinTypes->falsyType;
  else if (ty == builtinTypes->falsyType)
    result = builtinTypes->truthyType;
  else if (auto ntv = get<NegationType>(ty))
    result = follow(ntv->ty);
  else
    result = arena->addType(NegationType{ty});

  return result;
}

TypeId TypeSimplifier::intersectFromParts(std::set<TypeId> parts) {
  if (0 == parts.size())
    return builtinTypes->neverType;
  else if (1 == parts.size())
    return *begin(parts);

  {
    auto it = begin(parts);
    while (it != end(parts)) {
      TypeId t = follow(*it);

      auto copy = it;
      ++it;

      if (auto ut = get<IntersectionType>(t)) {
        for (TypeId part : ut)
          parts.insert(part);
        parts.erase(copy);
      }
    }
  }

  std::set<TypeId> newParts;

  /*
   * It is possible that the parts of the passed intersection are themselves
   * reducable.
   *
   * eg false & boolean
   *
   * We do a comparison between each pair of types and look for things that we
   * can elide.
   */
  for (TypeId part : parts) {
    if (newParts.empty()) {
      newParts.insert(part);
      continue;
    }

    auto it = begin(newParts);
    while (it != end(newParts)) {
      TypeId p = *it;

      switch (relate(part, p)) {
      case Relation::Disjoint:
        // eg boolean & string
        return builtinTypes->neverType;
      case Relation::Subset: {
        /* part is a subset of p.  Remove p from the set and replace it
         * with part.
         *
         * eg boolean & true
         */
        auto saveIt = it;
        ++it;
        newParts.erase(saveIt);
        continue;
      }
      case Relation::Coincident:
      case Relation::Superset: {
        /* part is coincident or a superset of p.  We do not need to
         * include part in the final intersection.
         *
         * ex true & boolean
         */
        ++it;
        continue;
      }
      case Relation::Intersects: {
        /* It's complicated!  A simplification may still be possible,
         * but we have to pull the types apart to figure it out.
         *
         * ex boolean & ~false
         */
        std::optional<TypeId> simplified = basicIntersect(part, p);

        auto saveIt = it;
        ++it;

        if (simplified) {
          newParts.erase(saveIt);
          newParts.insert(*simplified);
        } else
          newParts.insert(part);
        continue;
      }
      }
    }
  }

  if (0 == newParts.size())
    return builtinTypes->neverType;
  else if (1 == newParts.size())
    return *begin(newParts);
  else
    return arena->addType(
        IntersectionType{std::vector<TypeId>{begin(newParts), end(newParts)}});
}

TypeId TypeSimplifier::intersectUnionWithType(TypeId left, TypeId right) {
  const UnionType *leftUnion = get<UnionType>(left);
  LUAU_ASSERT(leftUnion);

  bool changed = false;
  std::set<TypeId> newParts;

  if (leftUnion->options.size() >
      (size_t)DFInt::LuauSimplificationComplexityLimit)
    return arena->addType(IntersectionType{{left, right}});

  for (TypeId part : leftUnion) {
    TypeId simplified = intersect(right, part);
    changed |= simplified != part;

    if (get<NeverType>(simplified)) {
      changed = true;
      continue;
    }

    newParts.insert(simplified);
  }

  if (!changed)
    return left;
  else if (newParts.empty())
    return builtinTypes->neverType;
  else if (newParts.size() == 1)
    return *begin(newParts);
  else
    return arena->addType(
        UnionType{std::vector<TypeId>(begin(newParts), end(newParts))});
}

TypeId TypeSimplifier::intersectUnions(TypeId left, TypeId right) {
  const UnionType *leftUnion = get<UnionType>(left);
  LUAU_ASSERT(leftUnion);

  const UnionType *rightUnion = get<UnionType>(right);
  LUAU_ASSERT(rightUnion);

  std::set<TypeId> newParts;

  // Combinatorial blowup moment!!

  // combination size
  size_t optionSize =
      (int)leftUnion->options.size() * rightUnion->options.size();
  size_t maxSize = DFInt::LuauSimplificationComplexityLimit;

  if (optionSize > maxSize)
    return arena->addType(IntersectionType{{left, right}});

  for (TypeId leftPart : leftUnion) {
    for (TypeId rightPart : rightUnion) {
      TypeId simplified = intersect(leftPart, rightPart);
      if (get<NeverType>(simplified))
        continue;

      newParts.insert(simplified);
    }
  }

  if (newParts.empty())
    return builtinTypes->neverType;
  else if (newParts.size() == 1)
    return *begin(newParts);
  else
    return arena->addType(
        UnionType{std::vector<TypeId>(begin(newParts), end(newParts))});
}

TypeId TypeSimplifier::intersectNegatedUnion(TypeId left, TypeId right) {
  // ~(A | B) & C
  // (~A & C) & (~B & C)

  const NegationType *leftNegation = get<NegationType>(left);
  LUAU_ASSERT(leftNegation);

  TypeId negatedTy = follow(leftNegation->ty);

  const UnionType *negatedUnion = get<UnionType>(negatedTy);
  LUAU_ASSERT(negatedUnion);

  bool changed = false;
  std::set<TypeId> newParts;

  for (TypeId part : negatedUnion) {
    Relation r = relate(part, right);
    switch (r) {
    case Relation::Disjoint:
      // If A is disjoint from B, then ~A & B is just B.
      //
      // ~(false?) & true
      // (~false & true) & (~nil & true)
      // true & true
      newParts.insert(right);
      break;
    case Relation::Coincident:
      // If A is coincident with or a superset of B, then ~A & B is never.
      //
      // ~(false?) & false
      // (~false & false) & (~nil & false)
      // never & false
      //
      // fallthrough
    case Relation::Superset:
      // If A is a superset of B, then ~A & B is never.
      //
      // ~(boolean | nil) & true
      // (~boolean & true) & (~boolean & nil)
      // never & nil
      return builtinTypes->neverType;
    case Relation::Subset:
    case Relation::Intersects:
      // If A is a subset of B, then ~A & B is a bit more complicated.  We need
      // to think harder.
      //
      // ~(false?) & boolean
      // (~false & boolean) & (~nil & boolean)
      // true & boolean
      TypeId simplified = intersectTypeWithNegation(mkNegation(part), right);
      changed |= simplified != right;
      if (get<NeverType>(simplified))
        changed = true;
      else
        newParts.insert(simplified);
      break;
    }
  }

  if (!changed)
    return right;
  else
    return intersectFromParts(std::move(newParts));
}

TypeId TypeSimplifier::intersectTypeWithNegation(TypeId left, TypeId right) {
  const NegationType *leftNegation = get<NegationType>(left);
  LUAU_ASSERT(leftNegation);

  TypeId negatedTy = follow(leftNegation->ty);

  if (negatedTy == right)
    return builtinTypes->neverType;

  if (auto ut = get<UnionType>(negatedTy)) {
    // ~(A | B) & C
    // (~A & C) & (~B & C)

    bool changed = false;
    std::set<TypeId> newParts;

    for (TypeId part : ut) {
      Relation r = relate(part, right);
      switch (r) {
      case Relation::Coincident:
        // ~(false?) & nil
        // (~false & nil) & (~nil & nil)
        // nil & never
        //
        // fallthrough
      case Relation::Superset:
        // ~(boolean | string) & true
        // (~boolean & true) & (~boolean & string)
        // never & string

        return builtinTypes->neverType;

      case Relation::Disjoint:
        // ~nil & boolean
        newParts.insert(right);
        break;

      case Relation::Subset:
        // ~false & boolean
        // fallthrough
      case Relation::Intersects:
        // FIXME: The mkNegation here is pretty unfortunate.
        // Memoizing this will probably be important.
        changed = true;
        newParts.insert(right);
        newParts.insert(mkNegation(part));
      }
    }

    if (!changed)
      return right;
    else
      return intersectFromParts(std::move(newParts));
  }

  if (auto rightUnion = get<UnionType>(right)) {
    // ~A & (B | C)
    bool changed = false;
    std::set<TypeId> newParts;

    for (TypeId part : rightUnion) {
      Relation r = relate(negatedTy, part);
      switch (r) {
      case Relation::Coincident:
        changed = true;
        continue;
      case Relation::Disjoint:
        newParts.insert(part);
        break;
      case Relation::Superset:
        changed = true;
        continue;
      case Relation::Subset:
        // fallthrough
      case Relation::Intersects:
        changed = true;
        newParts.insert(arena->addType(IntersectionType{{left, part}}));
      }
    }

    if (!changed)
      return right;
    else if (0 == newParts.size())
      return builtinTypes->neverType;
    else if (1 == newParts.size())
      return *begin(newParts);
    else
      return arena->addType(
          UnionType{std::vector<TypeId>{begin(newParts), end(newParts)}});
  }

  if (auto pt = get<PrimitiveType>(right);
      pt && pt->type == PrimitiveType::Boolean) {
    if (auto st = get<SingletonType>(negatedTy)) {
      if (st->variant == BooleanSingleton{true})
        return builtinTypes->falseType;
      else if (st->variant == BooleanSingleton{false})
        return builtinTypes->trueType;
      else
        // boolean & ~"hello"
        return builtinTypes->booleanType;
    }
  }

  Relation r = relate(negatedTy, right);

  switch (r) {
  case Relation::Disjoint:
    // ~boolean & string
    return right;
  case Relation::Coincident:
    // ~string & string
    // fallthrough
  case Relation::Superset:
    // ~string & "hello"
    return builtinTypes->neverType;
  case Relation::Subset:
    // ~string & unknown
    // ~"hello" & string
    // fallthrough
  case Relation::Intersects:
    // ~("hello" | boolean) & string
    // fallthrough
  default:
    return arena->addType(IntersectionType{{left, right}});
  }
}

TypeId TypeSimplifier::intersectNegations(TypeId left, TypeId right) {
  const NegationType *leftNegation = get<NegationType>(left);
  LUAU_ASSERT(leftNegation);

  if (get<UnionType>(follow(leftNegation->ty)))
    return intersectNegatedUnion(left, right);

  const NegationType *rightNegation = get<NegationType>(right);
  LUAU_ASSERT(rightNegation);

  if (get<UnionType>(follow(rightNegation->ty)))
    return intersectNegatedUnion(right, left);

  Relation r = relate(leftNegation->ty, rightNegation->ty);

  switch (r) {
  case Relation::Coincident:
    // ~true & ~true
    return left;
  case Relation::Subset:
    // ~true & ~boolean
    return right;
  case Relation::Superset:
    // ~boolean & ~true
    return left;
  case Relation::Intersects:
  case Relation::Disjoint:
  default:
    // ~boolean & ~string
    return arena->addType(IntersectionType{{left, right}});
  }
}

TypeId TypeSimplifier::intersectIntersectionWithType(TypeId left,
                                                     TypeId right) {
  const IntersectionType *leftIntersection = get<IntersectionType>(left);
  LUAU_ASSERT(leftIntersection);

  if (leftIntersection->parts.size() >
      (size_t)DFInt::LuauSimplificationComplexityLimit)
    return arena->addType(IntersectionType{{left, right}});

  bool changed = false;
  std::set<TypeId> newParts;

  for (TypeId part : leftIntersection) {
    Relation r = relate(part, right);
    switch (r) {
    case Relation::Disjoint:
      return builtinTypes->neverType;
    case Relation::Coincident:
      newParts.insert(part);
      continue;
    case Relation::Subset:
      newParts.insert(part);
      continue;
    case Relation::Superset:
      newParts.insert(right);
      changed = true;
      continue;
    default:
      newParts.insert(part);
      newParts.insert(right);
      changed = true;
      continue;
    }
  }

  // It is sometimes the case that an intersection operation will result in
  // clipping a free type from the result.
  //
  // eg (number & 'a) & string --> never
  //
  // We want to only report the free types that are part of the result.
  for (TypeId part : newParts) {
    if (isTypeVariable(part))
      blockedTypes.insert(part);
  }

  if (!changed)
    return left;
  return intersectFromParts(std::move(newParts));
}

std::optional<TypeId> TypeSimplifier::basicIntersect(TypeId left,
                                                     TypeId right) {
  if (get<AnyType>(left) && get<ErrorType>(right))
    return right;
  if (get<AnyType>(right) && get<ErrorType>(left))
    return left;
  if (get<AnyType>(left))
    return arena->addType(UnionType{{right, builtinTypes->errorType}});
  if (get<AnyType>(right))
    return arena->addType(UnionType{{left, builtinTypes->errorType}});
  if (get<UnknownType>(left))
    return right;
  if (get<UnknownType>(right))
    return left;
  if (get<NeverType>(left))
    return left;
  if (get<NeverType>(right))
    return right;

  if (auto pt = get<PrimitiveType>(left);
      pt && pt->type == PrimitiveType::Boolean) {
    if (auto st = get<SingletonType>(right);
        st && st->variant.get_if<BooleanSingleton>())
      return right;
    if (auto nt = get<NegationType>(right)) {
      if (auto st = get<SingletonType>(follow(nt->ty));
          st && st->variant.get_if<BooleanSingleton>()) {
        if (st->variant == BooleanSingleton{true})
          return builtinTypes->falseType;
        else
          return builtinTypes->trueType;
      }
    }
  } else if (auto pt = get<PrimitiveType>(right);
             pt && pt->type == PrimitiveType::Boolean) {
    if (auto st = get<SingletonType>(left);
        st && st->variant.get_if<BooleanSingleton>())
      return left;
    if (auto nt = get<NegationType>(left)) {
      if (auto st = get<SingletonType>(follow(nt->ty));
          st && st->variant.get_if<BooleanSingleton>()) {
        if (st->variant == BooleanSingleton{true})
          return builtinTypes->falseType;
        else
          return builtinTypes->trueType;
      }
    }
  }

  if (const auto [lt, rt] = get2<TableType, TableType>(left, right); lt && rt) {
    if (1 == lt->props.size()) {
      const auto [propName, leftProp] = *begin(lt->props);

      auto it = rt->props.find(propName);
      if (it != rt->props.end() && leftProp.isShared() &&
          it->second.isShared()) {
        Relation r = relate(leftProp.type(), it->second.type());

        switch (r) {
        case Relation::Disjoint:
          return builtinTypes->neverType;
        case Relation::Coincident:
          return right;
        default:
          break;
        }
      }
    } else if (1 == rt->props.size())
      return basicIntersect(right, left);
  }

  Relation relation = relate(left, right);
  if (left == right || Relation::Coincident == relation)
    return left;

  if (relation == Relation::Disjoint)
    return builtinTypes->neverType;
  else if (relation == Relation::Subset)
    return left;
  else if (relation == Relation::Superset)
    return right;

  return std::nullopt;
}

TypeId TypeSimplifier::intersect(TypeId left, TypeId right) {
  RecursionLimiter rl(&recursionDepth, 15);

  left = simplify(left);
  right = simplify(right);

  if (left == right)
    return left;

  if (get<AnyType>(left) && get<ErrorType>(right))
    return right;
  if (get<AnyType>(right) && get<ErrorType>(left))
    return left;
  if (get<UnknownType>(left) && !get<ErrorType>(right))
    return right;
  if (get<UnknownType>(right) && !get<ErrorType>(left))
    return left;
  if (get<AnyType>(left))
    return arena->addType(UnionType{{right, builtinTypes->errorType}});
  if (get<AnyType>(right))
    return arena->addType(UnionType{{left, builtinTypes->errorType}});
  if (get<UnknownType>(left))
    return right;
  if (get<UnknownType>(right))
    return left;
  if (get<NeverType>(left))
    return left;
  if (get<NeverType>(right))
    return right;

  if (auto lf = get<FreeType>(left)) {
    Relation r = relate(lf->upperBound, right);
    if (r == Relation::Subset || r == Relation::Coincident)
      return left;
  } else if (auto rf = get<FreeType>(right)) {
    Relation r = relate(left, rf->upperBound);
    if (r == Relation::Superset || r == Relation::Coincident)
      return right;
  }

  if (isTypeVariable(left)) {
    blockedTypes.insert(left);
    return arena->addType(IntersectionType{{left, right}});
  }

  if (isTypeVariable(right)) {
    blockedTypes.insert(right);
    return arena->addType(IntersectionType{{left, right}});
  }

  if (auto ut = get<UnionType>(left)) {
    if (get<UnionType>(right))
      return intersectUnions(left, right);
    else
      return intersectUnionWithType(left, right);
  } else if (auto ut = get<UnionType>(right))
    return intersectUnionWithType(right, left);

  if (auto it = get<IntersectionType>(left))
    return intersectIntersectionWithType(left, right);
  else if (auto it = get<IntersectionType>(right))
    return intersectIntersectionWithType(right, left);

  if (get<NegationType>(left)) {
    if (get<NegationType>(right))
      return intersectNegations(left, right);
    else
      return intersectTypeWithNegation(left, right);
  } else if (get<NegationType>(right))
    return intersectTypeWithNegation(right, left);

  std::optional<TypeId> res = basicIntersect(left, right);
  if (res)
    return *res;
  else
    return arena->addType(IntersectionType{{left, right}});
}

TypeId TypeSimplifier::union_(TypeId left, TypeId right) {
  RecursionLimiter rl(&recursionDepth, 15);

  left = simplify(left);
  right = simplify(right);

  if (get<NeverType>(left))
    return right;
  if (get<NeverType>(right))
    return left;

  if (auto leftUnion = get<UnionType>(left)) {
    bool changed = false;
    std::set<TypeId> newParts;
    for (TypeId part : leftUnion) {
      if (get<NeverType>(part)) {
        changed = true;
        continue;
      }

      Relation r = relate(part, right);
      switch (r) {
      case Relation::Coincident:
      case Relation::Superset:
        return left;
      case Relation::Subset:
        newParts.insert(right);
        changed = true;
        break;
      default:
        newParts.insert(part);
        newParts.insert(right);
        changed = true;
        break;
      }
    }

    if (!changed)
      return left;
    if (0 == newParts.size()) {
      // If the left-side is changed but has no parts, then the left-side union
      // is uninhabited.
      return right;
    } else if (1 == newParts.size())
      return *begin(newParts);
    else
      return arena->addType(
          UnionType{std::vector<TypeId>{begin(newParts), end(newParts)}});
  } else if (get<UnionType>(right))
    return union_(right, left);

  Relation r = relate(left, right);
  if (left == right || r == Relation::Coincident || r == Relation::Superset)
    return left;

  if (r == Relation::Subset)
    return right;

  if (auto as = get<SingletonType>(left)) {
    if (auto abs = as->variant.get_if<BooleanSingleton>()) {
      if (auto bs = get<SingletonType>(right)) {
        if (auto bbs = bs->variant.get_if<BooleanSingleton>()) {
          if (abs->value != bbs->value)
            return builtinTypes->booleanType;
        }
      }
    }
  }

  return arena->addType(UnionType{{left, right}});
}

TypeId TypeSimplifier::simplify(TypeId ty) {
  DenseHashSet<TypeId> seen{nullptr};
  return simplify(ty, seen);
}

TypeId TypeSimplifier::simplify(TypeId ty, DenseHashSet<TypeId> &seen) {
  RecursionLimiter limiter(&recursionDepth, 60);

  ty = follow(ty);

  if (seen.find(ty))
    return ty;
  seen.insert(ty);

  if (auto nt = get<NegationType>(ty)) {
    TypeId negatedTy = follow(nt->ty);
    if (get<AnyType>(negatedTy))
      return arena->addType(
          UnionType{{builtinTypes->neverType, builtinTypes->errorType}});
    else if (get<UnknownType>(negatedTy))
      return builtinTypes->neverType;
    else if (get<NeverType>(negatedTy))
      return builtinTypes->unknownType;
    if (auto nnt = get<NegationType>(negatedTy))
      return simplify(nnt->ty, seen);
  }

  // Promote {x: never} to never
  if (auto tt = get<TableType>(ty)) {
    if (1 == tt->props.size()) {
      if (std::optional<TypeId> readTy = begin(tt->props)->second.readTy) {
        TypeId propTy = simplify(*readTy, seen);
        if (get<NeverType>(propTy))
          return builtinTypes->neverType;
      }
    }
  }

  return ty;
}

SimplifyResult simplifyIntersection(NotNull<BuiltinTypes> builtinTypes,
                                    NotNull<TypeArena> arena, TypeId left,
                                    TypeId right) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);

  TypeSimplifier s{builtinTypes, arena};

  // fprintf(stderr, "Intersect %s and %s ...\n", toString(left).c_str(),
  // toString(right).c_str());

  TypeId res = s.intersect(left, right);

  // fprintf(stderr, "Intersect %s and %s -> %s\n", toString(left).c_str(),
  // toString(right).c_str(), toString(res).c_str());

  return SimplifyResult{res, std::move(s.blockedTypes)};
}

SimplifyResult simplifyIntersection(NotNull<BuiltinTypes> builtinTypes,
                                    NotNull<TypeArena> arena,
                                    std::set<TypeId> parts) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);

  TypeSimplifier s{builtinTypes, arena};

  TypeId res = s.intersectFromParts(std::move(parts));

  return SimplifyResult{res, std::move(s.blockedTypes)};
}

SimplifyResult simplifyUnion(NotNull<BuiltinTypes> builtinTypes,
                             NotNull<TypeArena> arena, TypeId left,
                             TypeId right) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);

  TypeSimplifier s{builtinTypes, arena};

  TypeId res = s.union_(left, right);

  // fprintf(stderr, "Union %s and %s -> %s\n", toString(left).c_str(),
  // toString(right).c_str(), toString(res).c_str());

  return SimplifyResult{res, std::move(s.blockedTypes)};
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/AstQuery.h>

// DONE : was aleready inlined <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// DONE : was aleready inlined <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);
LUAU_FASTFLAGVARIABLE(LuauFixBindingForGlobalPos, false);

namespace Luau {

namespace {

struct AutocompleteNodeFinder : public AstVisitor {
  const Position pos;
  std::vector<AstNode *> ancestry;

  explicit AutocompleteNodeFinder(Position pos, AstNode *root) : pos(pos) {}

  bool visit(AstExpr *expr) override {
    if (expr->location.begin <= pos && pos <= expr->location.end) {
      ancestry.push_back(expr);
      return true;
    }
    return false;
  }

  bool visit(AstStat *stat) override {
    if (stat->location.begin < pos && pos <= stat->location.end) {
      ancestry.push_back(stat);
      return true;
    }
    return false;
  }

  bool visit(AstType *type) override {
    if (type->location.begin < pos && pos <= type->location.end) {
      ancestry.push_back(type);
      return true;
    }
    return false;
  }

  bool visit(AstTypeError *type) override {
    // For a missing type, match the whole range including the start position
    if (type->isMissing && type->location.containsClosed(pos)) {
      ancestry.push_back(type);
      return true;
    }
    return false;
  }

  bool visit(class AstTypePack *typePack) override { return true; }

  bool visit(AstStatBlock *block) override {
    // If ancestry is empty, we are inspecting the root of the AST.  Its extent
    // is considered to be infinite.
    if (ancestry.empty()) {
      ancestry.push_back(block);
      return true;
    }

    // AstExprIndexName nodes are nested outside-in, so we want the outermost
    // node in the case of nested nodes. ex foo.bar.baz is represented in the
    // AST as IndexName{ IndexName {foo, bar}, baz}
    if (!ancestry.empty() && ancestry.back()->is<AstExprIndexName>())
      return false;

    // Type annotation error might intersect the block statement when the
    // function header is being written, annotation takes priority
    if (!ancestry.empty() && ancestry.back()->is<AstTypeError>())
      return false;

    // If the cursor is at the end of an expression or type and simultaneously
    // at the beginning of a block, the expression or type wins out. The
    // exception to this is if we are in a block under an AstExprFunction.  In
    // this case, we consider the position to be within the block.
    if (block->location.begin == pos && !ancestry.empty()) {
      if (ancestry.back()->asExpr() && !ancestry.back()->is<AstExprFunction>())
        return false;

      if (ancestry.back()->asType())
        return false;
    }

    if (block->location.begin <= pos && pos <= block->location.end) {
      ancestry.push_back(block);
      return true;
    }
    return false;
  }
};

struct FindNode : public AstVisitor {
  const Position pos;
  const Position documentEnd;
  AstNode *best = nullptr;

  explicit FindNode(Position pos, Position documentEnd)
      : pos(pos), documentEnd(documentEnd) {}

  bool visit(AstNode *node) override {
    if (node->location.contains(pos)) {
      best = node;
      return true;
    }

    // Edge case: If we ask for the node at the position that is the very end of
    // the document return the innermost AST element that ends at that position.

    if (node->location.end == documentEnd && pos >= documentEnd) {
      best = node;
      return true;
    }

    return false;
  }

  bool visit(AstStatFunction *node) override {
    visit(static_cast<AstNode *>(node));
    if (node->name->location.contains(pos))
      node->name->visit(this);
    else if (node->func->location.contains(pos))
      node->func->visit(this);
    return false;
  }

  bool visit(AstStatBlock *block) override {
    visit(static_cast<AstNode *>(block));

    for (AstStat *stat : block->body) {
      if (stat->location.end < pos)
        continue;
      if (stat->location.begin > pos)
        break;

      stat->visit(this);
    }

    return false;
  }
};

struct FindFullAncestry final : public AstVisitor {
  std::vector<AstNode *> nodes;
  Position pos;
  Position documentEnd;
  bool includeTypes = false;

  explicit FindFullAncestry(Position pos, Position documentEnd,
                            bool includeTypes = false)
      : pos(pos), documentEnd(documentEnd), includeTypes(includeTypes) {}

  bool visit(AstType *type) override {
    if (includeTypes)
      return visit(static_cast<AstNode *>(type));
    else
      return false;
  }

  bool visit(AstStatFunction *node) override {
    visit(static_cast<AstNode *>(node));
    if (node->name->location.contains(pos))
      node->name->visit(this);
    else if (node->func->location.contains(pos))
      node->func->visit(this);
    return false;
  }

  bool visit(AstNode *node) override {
    if (node->location.contains(pos)) {
      nodes.push_back(node);
      return true;
    }

    // Edge case: If we ask for the node at the position that is the very end of
    // the document return the innermost AST element that ends at that position.

    if (node->location.end == documentEnd && pos >= documentEnd) {
      nodes.push_back(node);
      return true;
    }

    return false;
  }
};

} // namespace

std::vector<AstNode *>
findAncestryAtPositionForAutocomplete(const SourceModule &source,
                                      Position pos) {
  return findAncestryAtPositionForAutocomplete(source.root, pos);
}

std::vector<AstNode *> findAncestryAtPositionForAutocomplete(AstStatBlock *root,
                                                             Position pos) {
  AutocompleteNodeFinder finder{pos, root};
  root->visit(&finder);
  return finder.ancestry;
}

std::vector<AstNode *> findAstAncestryOfPosition(const SourceModule &source,
                                                 Position pos,
                                                 bool includeTypes) {
  return findAstAncestryOfPosition(source.root, pos, includeTypes);
}

std::vector<AstNode *>
findAstAncestryOfPosition(AstStatBlock *root, Position pos, bool includeTypes) {
  const Position end = root->location.end;
  if (pos > end)
    pos = end;

  FindFullAncestry finder(pos, end, includeTypes);
  root->visit(&finder);
  return finder.nodes;
}

AstNode *findNodeAtPosition(const SourceModule &source, Position pos) {
  return findNodeAtPosition(source.root, pos);
}

AstNode *findNodeAtPosition(AstStatBlock *root, Position pos) {
  const Position end = root->location.end;
  if (pos < root->location.begin)
    return root;

  if (pos > end)
    pos = end;

  FindNode findNode{pos, end};
  findNode.visit(root);
  return findNode.best;
}

AstExpr *findExprAtPosition(const SourceModule &source, Position pos) {
  AstNode *node = findNodeAtPosition(source, pos);
  if (node)
    return node->asExpr();
  else
    return nullptr;
}

ScopePtr findScopeAtPosition(const Module &module, Position pos) {
  if (module.scopes.empty())
    return nullptr;

  Location scopeLocation = module.scopes.front().first;
  ScopePtr scope = module.scopes.front().second;
  for (const auto &s : module.scopes) {
    if (s.first.contains(pos)) {
      if (!scope || scopeLocation.encloses(s.first)) {
        scopeLocation = s.first;
        scope = s.second;
      }
    }
  }
  return scope;
}

std::optional<TypeId> findTypeAtPosition(const Module &module,
                                         const SourceModule &sourceModule,
                                         Position pos) {
  if (auto expr = findExprAtPosition(sourceModule, pos)) {
    if (auto it = module.astTypes.find(expr))
      return *it;
  }

  return std::nullopt;
}

std::optional<TypeId>
findExpectedTypeAtPosition(const Module &module,
                           const SourceModule &sourceModule, Position pos) {
  if (auto expr = findExprAtPosition(sourceModule, pos)) {
    if (auto it = module.astExpectedTypes.find(expr))
      return *it;
  }

  return std::nullopt;
}

static std::optional<AstStatLocal *>
findBindingLocalStatement(const SourceModule &source, const Binding &binding) {
  // Bindings coming from global sources (e.g., definition files) have a zero
  // position. They cannot be defined from a local statement
  if (FFlag::LuauFixBindingForGlobalPos &&
      binding.location == Location{{0, 0}, {0, 0}})
    return std::nullopt;

  std::vector<AstNode *> nodes =
      findAstAncestryOfPosition(source, binding.location.begin);
  auto iter = std::find_if(nodes.rbegin(), nodes.rend(), [](AstNode *node) {
    return node->is<AstStatLocal>();
  });
  return iter != nodes.rend() ? std::make_optional((*iter)->as<AstStatLocal>())
                              : std::nullopt;
}

std::optional<Binding> findBindingAtPosition(const Module &module,
                                             const SourceModule &source,
                                             Position pos) {
  AstExpr *expr = findExprAtPosition(source, pos);
  if (!expr)
    return std::nullopt;

  Symbol name;
  if (auto g = expr->as<AstExprGlobal>())
    name = g->name;
  else if (auto l = expr->as<AstExprLocal>())
    name = l->local;
  else
    return std::nullopt;

  ScopePtr currentScope = findScopeAtPosition(module, pos);

  while (currentScope) {
    auto iter = currentScope->bindings.find(name);
    if (iter != currentScope->bindings.end() &&
        iter->second.location.begin <= pos) {
      // Ignore this binding if we're inside its definition. e.g. local abc =
      // abc -- Will take the definition of abc from outer scope
      std::optional<AstStatLocal *> bindingStatement =
          findBindingLocalStatement(source, iter->second);
      if (!bindingStatement || !(*bindingStatement)->location.contains(pos))
        return iter->second;
    }
    currentScope = currentScope->parent;
  }

  return std::nullopt;
}

namespace {
struct FindExprOrLocal : public AstVisitor {
  const Position pos;
  ExprOrLocal result;

  explicit FindExprOrLocal(Position pos) : pos(pos) {}

  // We want to find the result with the smallest location range.
  bool isCloserMatch(Location newLocation) {
    auto current = result.getLocation();
    return newLocation.contains(pos) &&
           (!current || current->encloses(newLocation));
  }

  bool visit(AstStatBlock *block) override {
    for (AstStat *stat : block->body) {
      if (stat->location.end <= pos)
        continue;
      if (stat->location.begin > pos)
        break;

      stat->visit(this);
    }

    return false;
  }

  bool visit(AstExpr *expr) override {
    if (isCloserMatch(expr->location)) {
      result.setExpr(expr);
      return true;
    }
    return false;
  }

  bool visitLocal(AstLocal *local) {
    if (isCloserMatch(local->location)) {
      result.setLocal(local);
      return true;
    }
    return false;
  }

  bool visit(AstStatLocalFunction *function) override {
    visitLocal(function->name);
    return true;
  }

  bool visit(AstStatLocal *al) override {
    for (size_t i = 0; i < al->vars.size; ++i) {
      visitLocal(al->vars.data[i]);
    }
    return true;
  }

  virtual bool visit(AstExprFunction *fn) override {
    for (size_t i = 0; i < fn->args.size; ++i) {
      visitLocal(fn->args.data[i]);
    }
    return visit((class AstExpr *)fn);
  }

  virtual bool visit(AstStatFor *forStat) override {
    visitLocal(forStat->var);
    return true;
  }

  virtual bool visit(AstStatForIn *forIn) override {
    for (AstLocal *var : forIn->vars) {
      visitLocal(var);
    }
    return true;
  }
};
}; // namespace

ExprOrLocal findExprOrLocalAtPosition(const SourceModule &source,
                                      Position pos) {
  FindExprOrLocal findVisitor{pos};
  findVisitor.visit(source.root);
  return findVisitor.result;
}

static std::optional<DocumentationSymbol> checkOverloadedDocumentationSymbol(
    const Module &module, const TypeId ty, const AstExpr *parentExpr,
    const std::optional<DocumentationSymbol> documentationSymbol) {
  if (!documentationSymbol)
    return std::nullopt;

  // This might be an overloaded function.
  if (get<IntersectionType>(follow(ty))) {
    TypeId matchingOverload = nullptr;
    if (parentExpr && parentExpr->is<AstExprCall>()) {
      if (auto it = module.astOverloadResolvedTypes.find(parentExpr)) {
        matchingOverload = *it;
      }
    }

    if (matchingOverload) {
      std::string overloadSymbol = *documentationSymbol + "/overload/";
      // Default toString options are fine for this purpose.
      overloadSymbol += toString(matchingOverload);
      return overloadSymbol;
    }
  }

  return documentationSymbol;
}

std::optional<DocumentationSymbol>
getDocumentationSymbolAtPosition(const SourceModule &source,
                                 const Module &module, Position position) {
  std::vector<AstNode *> ancestry = findAstAncestryOfPosition(source, position);

  AstExpr *targetExpr =
      ancestry.size() >= 1 ? ancestry[ancestry.size() - 1]->asExpr() : nullptr;
  AstExpr *parentExpr =
      ancestry.size() >= 2 ? ancestry[ancestry.size() - 2]->asExpr() : nullptr;

  if (std::optional<Binding> binding =
          findBindingAtPosition(module, source, position))
    return checkOverloadedDocumentationSymbol(
        module, binding->typeId, parentExpr, binding->documentationSymbol);

  if (targetExpr) {
    if (AstExprIndexName *indexName = targetExpr->as<AstExprIndexName>()) {
      if (auto it = module.astTypes.find(indexName->expr)) {
        TypeId parentTy = follow(*it);
        if (const TableType *ttv = get<TableType>(parentTy)) {
          if (auto propIt = ttv->props.find(indexName->index.value);
              propIt != ttv->props.end()) {
            if (FFlag::DebugLuauDeferredConstraintResolution) {
              if (auto ty = propIt->second.readTy)
                return checkOverloadedDocumentationSymbol(
                    module, *ty, parentExpr,
                    propIt->second.documentationSymbol);
            } else
              return checkOverloadedDocumentationSymbol(
                  module, propIt->second.type(), parentExpr,
                  propIt->second.documentationSymbol);
          }
        } else if (const ClassType *ctv = get<ClassType>(parentTy)) {
          if (auto propIt = ctv->props.find(indexName->index.value);
              propIt != ctv->props.end()) {
            if (FFlag::DebugLuauDeferredConstraintResolution) {
              if (auto ty = propIt->second.readTy)
                return checkOverloadedDocumentationSymbol(
                    module, *ty, parentExpr,
                    propIt->second.documentationSymbol);
            } else
              return checkOverloadedDocumentationSymbol(
                  module, propIt->second.type(), parentExpr,
                  propIt->second.documentationSymbol);
          }
        }
      }
    } else if (AstExprFunction *fn = targetExpr->as<AstExprFunction>()) {
      // Handle event connection-like structures where we have
      // something:Connect(function(a, b, c) end)
      // In this case, we want to ascribe a documentation symbol to 'a'
      // based on the documentation symbol of Connect.
      if (parentExpr && parentExpr->is<AstExprCall>()) {
        AstExprCall *call = parentExpr->as<AstExprCall>();
        if (std::optional<DocumentationSymbol> parentSymbol =
                getDocumentationSymbolAtPosition(source, module,
                                                 call->func->location.begin)) {
          for (size_t i = 0; i < call->args.size; ++i) {
            AstExpr *callArg = call->args.data[i];
            if (callArg == targetExpr) {
              std::string fnSymbol =
                  *parentSymbol + "/param/" + std::to_string(i);
              for (size_t j = 0; j < fn->args.size; ++j) {
                AstLocal *fnArg = fn->args.data[j];

                if (fnArg->location.contains(position)) {
                  return fnSymbol + "/param/" + std::to_string(j);
                }
              }
            }
          }
        }
      }
    }
  }

  if (std::optional<TypeId> ty = findTypeAtPosition(module, source, position)) {
    if ((*ty)->documentationSymbol) {
      return (*ty)->documentationSymbol;
    }
  }

  return std::nullopt;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// DONE : was aleready inlined <Luau/ConstraintSolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// DONE : was aleready inlined <Luau/Instantiation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// DONE : was aleready inlined <Luau/NotNull.h>

// DONE : was aleready inlined <Luau/OverloadResolution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Set.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// DONE : was aleready inlined <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// DONE : was aleready inlined <Luau/TypeFunctionReductionGuesser.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifier2.h>

#include "luau_common_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@ PACK.lua : not found, likely and std header
#include <iterator>

// used to control emitting CodeTooComplex warnings on type function reduction
LUAU_DYNAMIC_FASTINTVARIABLE(LuauTypeFamilyGraphReductionMaximumSteps,
                             1'000'000);

// used to control the limits of type function application over union type
// arguments e.g. `mul<a | b, c | d>` blows up into `mul<a, c> | mul<a, d> |
// mul<b, c> | mul<b, d>`
LUAU_DYNAMIC_FASTINTVARIABLE(LuauTypeFamilyApplicationCartesianProductLimit,
                             5'000);

// used to control falling back to a more conservative reduction based on
// guessing when this value is set to a negative value, guessing will be totally
// disabled.
LUAU_DYNAMIC_FASTINTVARIABLE(LuauTypeFamilyUseGuesserDepth, -1);

LUAU_FASTFLAGVARIABLE(DebugLuauLogTypeFamilies, false);

namespace Luau {

using TypeOrTypePackIdSet = DenseHashSet<const void *>;

struct InstanceCollector : TypeOnceVisitor {
  VecDeque<TypeId> tys;
  VecDeque<TypePackId> tps;
  TypeOrTypePackIdSet shouldGuess{nullptr};
  std::vector<TypeId> cyclicInstance;

  bool visit(TypeId ty, const TypeFunctionInstanceType &) override {
    // TypeOnceVisitor performs a depth-first traversal in the absence of
    // cycles. This means that by pushing to the front of the queue, we will
    // try to reduce deeper instances first if we start with the first thing
    // in the queue. Consider Add<Add<Add<number, number>, number>, number>:
    // we want to reduce the innermost Add<number, number> instantiation
    // first.

    if (DFInt::LuauTypeFamilyUseGuesserDepth >= 0 &&
        typeFunctionDepth > DFInt::LuauTypeFamilyUseGuesserDepth)
      shouldGuess.insert(ty);

    tys.push_front(ty);

    return true;
  }

  void cycle(TypeId ty) override {
    /// Detected cyclic type pack
    TypeId t = follow(ty);
    if (get<TypeFunctionInstanceType>(t))
      cyclicInstance.push_back(t);
  }

  bool visit(TypeId ty, const ClassType &) override { return false; }

  bool visit(TypePackId tp, const TypeFunctionInstanceTypePack &) override {
    // TypeOnceVisitor performs a depth-first traversal in the absence of
    // cycles. This means that by pushing to the front of the queue, we will
    // try to reduce deeper instances first if we start with the first thing
    // in the queue. Consider Add<Add<Add<number, number>, number>, number>:
    // we want to reduce the innermost Add<number, number> instantiation
    // first.

    if (DFInt::LuauTypeFamilyUseGuesserDepth >= 0 &&
        typeFunctionDepth > DFInt::LuauTypeFamilyUseGuesserDepth)
      shouldGuess.insert(tp);

    tps.push_front(tp);

    return true;
  }
};

struct TypeFunctionReducer {
  TypeFunctionContext ctx;

  VecDeque<TypeId> queuedTys;
  VecDeque<TypePackId> queuedTps;
  TypeOrTypePackIdSet shouldGuess;
  std::vector<TypeId> cyclicTypeFamilies;
  TypeOrTypePackIdSet irreducible{nullptr};
  FunctionGraphReductionResult result;
  bool force = false;

  // Local to the constraint being reduced.
  Location location;

  TypeFunctionReducer(VecDeque<TypeId> queuedTys,
                      VecDeque<TypePackId> queuedTps,
                      TypeOrTypePackIdSet shouldGuess,
                      std::vector<TypeId> cyclicTypes, Location location,
                      TypeFunctionContext ctx, bool force = false)
      : ctx(ctx), queuedTys(std::move(queuedTys)),
        queuedTps(std::move(queuedTps)), shouldGuess(std::move(shouldGuess)),
        cyclicTypeFamilies(std::move(cyclicTypes)), force(force),
        location(location) {}

  enum class SkipTestResult {
    CyclicTypeFunction,
    Irreducible,
    Defer,
    Okay,
  };

  SkipTestResult testForSkippability(TypeId ty) {
    ty = follow(ty);

    if (is<TypeFunctionInstanceType>(ty)) {
      for (auto t : cyclicTypeFamilies) {
        if (ty == t)
          return SkipTestResult::CyclicTypeFunction;
      }

      if (!irreducible.contains(ty))
        return SkipTestResult::Defer;

      return SkipTestResult::Irreducible;
    } else if (is<GenericType>(ty)) {
      return SkipTestResult::Irreducible;
    }

    return SkipTestResult::Okay;
  }

  SkipTestResult testForSkippability(TypePackId ty) {
    ty = follow(ty);

    if (is<TypeFunctionInstanceTypePack>(ty)) {
      if (!irreducible.contains(ty))
        return SkipTestResult::Defer;
      else
        return SkipTestResult::Irreducible;
    } else if (is<GenericTypePack>(ty)) {
      return SkipTestResult::Irreducible;
    }

    return SkipTestResult::Okay;
  }

  template <typename T> void replace(T subject, T replacement) {
    if (subject->owningArena != ctx.arena.get()) {
      result.errors.emplace_back(
          location, InternalError{"Attempting to modify a type function "
                                  "instance from another arena"});
      return;
    }

    if (FFlag::DebugLuauLogTypeFamilies)
      printf("%s -> %s\n", toString(subject, {true}).c_str(),
             toString(replacement, {true}).c_str());

    asMutable(subject)->ty.template emplace<Unifiable::Bound<T>>(replacement);

    if constexpr (std::is_same_v<T, TypeId>)
      result.reducedTypes.insert(subject);
    else if constexpr (std::is_same_v<T, TypePackId>)
      result.reducedPacks.insert(subject);
  }

  template <typename T>
  void handleTypeFunctionReduction(T subject,
                                   TypeFunctionReductionResult<T> reduction) {
    if (reduction.result)
      replace(subject, *reduction.result);
    else {
      irreducible.insert(subject);

      if (reduction.uninhabited || force) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("%s is uninhabited\n", toString(subject, {true}).c_str());

        if constexpr (std::is_same_v<T, TypeId>)
          result.errors.push_back(
              TypeError{location, UninhabitedTypeFunction{subject}});
        else if constexpr (std::is_same_v<T, TypePackId>)
          result.errors.push_back(
              TypeError{location, UninhabitedTypePackFunction{subject}});
      } else if (!reduction.uninhabited && !force) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("%s is irreducible; blocked on %zu types, %zu packs\n",
                 toString(subject, {true}).c_str(),
                 reduction.blockedTypes.size(), reduction.blockedPacks.size());

        for (TypeId b : reduction.blockedTypes)
          result.blockedTypes.insert(b);

        for (TypePackId b : reduction.blockedPacks)
          result.blockedPacks.insert(b);
      }
    }
  }

  bool done() { return queuedTys.empty() && queuedTps.empty(); }

  template <typename T, typename I>
  bool testParameters(T subject, const I *tfit) {
    for (TypeId p : tfit->typeArguments) {
      SkipTestResult skip = testForSkippability(p);

      if (skip == SkipTestResult::Irreducible) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("%s is irreducible due to a dependency on %s\n",
                 toString(subject, {true}).c_str(),
                 toString(p, {true}).c_str());

        irreducible.insert(subject);
        return false;
      } else if (skip == SkipTestResult::Defer) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("Deferring %s until %s is solved\n",
                 toString(subject, {true}).c_str(),
                 toString(p, {true}).c_str());

        if constexpr (std::is_same_v<T, TypeId>)
          queuedTys.push_back(subject);
        else if constexpr (std::is_same_v<T, TypePackId>)
          queuedTps.push_back(subject);

        return false;
      }
    }

    for (TypePackId p : tfit->packArguments) {
      SkipTestResult skip = testForSkippability(p);

      if (skip == SkipTestResult::Irreducible) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("%s is irreducible due to a dependency on %s\n",
                 toString(subject, {true}).c_str(),
                 toString(p, {true}).c_str());

        irreducible.insert(subject);
        return false;
      } else if (skip == SkipTestResult::Defer) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("Deferring %s until %s is solved\n",
                 toString(subject, {true}).c_str(),
                 toString(p, {true}).c_str());

        if constexpr (std::is_same_v<T, TypeId>)
          queuedTys.push_back(subject);
        else if constexpr (std::is_same_v<T, TypePackId>)
          queuedTps.push_back(subject);

        return false;
      }
    }

    return true;
  }

  template <typename TID> inline bool tryGuessing(TID subject) {
    if (shouldGuess.contains(subject)) {
      if (FFlag::DebugLuauLogTypeFamilies)
        printf("Flagged %s for reduction with guesser.\n",
               toString(subject, {true}).c_str());

      TypeFunctionReductionGuesser guesser{ctx.arena, ctx.builtins,
                                           ctx.normalizer};
      auto guessed = guesser.guess(subject);

      if (guessed) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("Selected %s as the guessed result type.\n",
                 toString(*guessed, {true}).c_str());

        replace(subject, *guessed);
        return true;
      }

      if (FFlag::DebugLuauLogTypeFamilies)
        printf("Failed to produce a guess for the result of %s.\n",
               toString(subject, {true}).c_str());
    }

    return false;
  }

  void stepType() {
    TypeId subject = follow(queuedTys.front());
    queuedTys.pop_front();

    if (irreducible.contains(subject))
      return;

    if (FFlag::DebugLuauLogTypeFamilies)
      printf("Trying to reduce %s\n", toString(subject, {true}).c_str());

    if (const TypeFunctionInstanceType *tfit =
            get<TypeFunctionInstanceType>(subject)) {
      SkipTestResult testCyclic = testForSkippability(subject);

      if (!testParameters(subject, tfit) &&
          testCyclic != SkipTestResult::CyclicTypeFunction) {
        if (FFlag::DebugLuauLogTypeFamilies)
          printf("Irreducible due to irreducible/pending and a non-cyclic "
                 "family\n");

        return;
      }

      if (tryGuessing(subject))
        return;

      TypeFunctionReductionResult<TypeId> result = tfit->family->reducer(
          subject, tfit->typeArguments, tfit->packArguments, NotNull{&ctx});
      handleTypeFunctionReduction(subject, result);
    }
  }

  void stepPack() {
    TypePackId subject = follow(queuedTps.front());
    queuedTps.pop_front();

    if (irreducible.contains(subject))
      return;

    if (FFlag::DebugLuauLogTypeFamilies)
      printf("Trying to reduce %s\n", toString(subject, {true}).c_str());

    if (const TypeFunctionInstanceTypePack *tfit =
            get<TypeFunctionInstanceTypePack>(subject)) {
      if (!testParameters(subject, tfit))
        return;

      if (tryGuessing(subject))
        return;

      TypeFunctionReductionResult<TypePackId> result = tfit->family->reducer(
          subject, tfit->typeArguments, tfit->packArguments, NotNull{&ctx});
      handleTypeFunctionReduction(subject, result);
    }
  }

  void step() {
    if (!queuedTys.empty())
      stepType();
    else if (!queuedTps.empty())
      stepPack();
  }
};

static FunctionGraphReductionResult reduceFamiliesInternal(
    VecDeque<TypeId> queuedTys, VecDeque<TypePackId> queuedTps,
    TypeOrTypePackIdSet shouldGuess, std::vector<TypeId> cyclics,
    Location location, TypeFunctionContext ctx, bool force) {
  TypeFunctionReducer reducer{std::move(queuedTys),
                              std::move(queuedTps),
                              std::move(shouldGuess),
                              std::move(cyclics),
                              location,
                              ctx,
                              force};
  int iterationCount = 0;

  while (!reducer.done()) {
    reducer.step();

    ++iterationCount;
    if (iterationCount > DFInt::LuauTypeFamilyGraphReductionMaximumSteps) {
      reducer.result.errors.push_back(TypeError{location, CodeTooComplex{}});
      break;
    }
  }

  return std::move(reducer.result);
}

FunctionGraphReductionResult reduceTypeFunctions(TypeId entrypoint,
                                                 Location location,
                                                 TypeFunctionContext ctx,
                                                 bool force) {
  InstanceCollector collector;

  try {
    collector.traverse(entrypoint);
  } catch (RecursionLimitException &) {
    return FunctionGraphReductionResult{};
  }

  if (collector.tys.empty() && collector.tps.empty())
    return {};

  return reduceFamiliesInternal(
      std::move(collector.tys), std::move(collector.tps),
      std::move(collector.shouldGuess), std::move(collector.cyclicInstance),
      location, ctx, force);
}

FunctionGraphReductionResult reduceTypeFunctions(TypePackId entrypoint,
                                                 Location location,
                                                 TypeFunctionContext ctx,
                                                 bool force) {
  InstanceCollector collector;

  try {
    collector.traverse(entrypoint);
  } catch (RecursionLimitException &) {
    return FunctionGraphReductionResult{};
  }

  if (collector.tys.empty() && collector.tps.empty())
    return {};

  return reduceFamiliesInternal(
      std::move(collector.tys), std::move(collector.tps),
      std::move(collector.shouldGuess), std::move(collector.cyclicInstance),
      location, ctx, force);
}

bool isPending(TypeId ty, ConstraintSolver *solver) {
  return is<BlockedType, PendingExpansionType, TypeFunctionInstanceType>(ty) ||
         (solver && solver->hasUnresolvedConstraints(ty));
}

template <typename F, typename... Args>
static std::optional<TypeFunctionReductionResult<TypeId>>
tryDistributeTypeFunctionApp(F f, TypeId instance,
                             const std::vector<TypeId> &typeParams,
                             const std::vector<TypePackId> &packParams,
                             NotNull<TypeFunctionContext> ctx, Args &&...args) {
  // op (a | b) (c | d) ~ (op a (c | d)) | (op b (c | d)) ~ (op a c) | (op a d)
  // | (op b c) | (op b d)
  bool uninhabited = false;
  std::vector<TypeId> blockedTypes;
  std::vector<TypeId> results;
  size_t cartesianProductSize = 1;

  const UnionType *firstUnion = nullptr;
  size_t unionIndex;

  std::vector<TypeId> arguments = typeParams;
  for (size_t i = 0; i < arguments.size(); ++i) {
    const UnionType *ut = get<UnionType>(follow(arguments[i]));
    if (!ut)
      continue;

    // We want to find the first union type in the set of arguments to
    // distribute that one and only that one union. The function `f` we have is
    // recursive, so `arguments[unionIndex]` will be updated in-place for each
    // option in the union we've found in this context, so that index will no
    // longer be a union type. Any other arguments at index + 1 or after will
    // instead be distributed, if those are a union, which will be subjected to
    // the same rules.
    if (!firstUnion && ut) {
      firstUnion = ut;
      unionIndex = i;
    }

    cartesianProductSize *= std::distance(begin(ut), end(ut));

    // TODO: We'd like to report that the type function application is too
    // complex here.
    if (size_t(DFInt::LuauTypeFamilyApplicationCartesianProductLimit) <=
        cartesianProductSize)
      return {{std::nullopt, true, {}, {}}};
  }

  if (!firstUnion) {
    // If we couldn't find any union type argument, we're not distributing.
    return std::nullopt;
  }

  for (TypeId option : firstUnion) {
    arguments[unionIndex] = option;

    TypeFunctionReductionResult<TypeId> result =
        f(instance, arguments, packParams, ctx, args...);
    blockedTypes.insert(blockedTypes.end(), result.blockedTypes.begin(),
                        result.blockedTypes.end());
    uninhabited |= result.uninhabited;

    if (result.uninhabited || !result.result)
      break;
    else
      results.push_back(*result.result);
  }

  if (uninhabited || !blockedTypes.empty())
    return {{std::nullopt, uninhabited, blockedTypes, {}}};

  if (!results.empty()) {
    if (results.size() == 1)
      return {{results[0], false, {}, {}}};

    TypeId resultTy = ctx->arena->addType(TypeFunctionInstanceType{
        NotNull{&builtinTypeFunctions().unionFunc},
        std::move(results),
        {},
    });

    return {{resultTy, false, {}, {}}};
  }

  return std::nullopt;
}

TypeFunctionReductionResult<TypeId>
notFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("not type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId ty = follow(typeParams.at(0));

  if (ty == instance)
    return {ctx->builtins->neverType, false, {}, {}};

  if (isPending(ty, ctx->solver))
    return {std::nullopt, false, {ty}, {}};

  if (auto result = tryDistributeTypeFunctionApp(notFamilyFn, instance,
                                                 typeParams, packParams, ctx))
    return *result;

  // `not` operates on anything and returns a `boolean` always.
  return {ctx->builtins->booleanType, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
lenFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("len type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId operandTy = follow(typeParams.at(0));

  if (operandTy == instance)
    return {ctx->builtins->neverType, false, {}, {}};

  // check to see if the operand type is resolved enough, and wait to reduce if
  // not the use of `typeFromNormal` later necessitates blocking on local types.
  if (isPending(operandTy, ctx->solver))
    return {std::nullopt, false, {operandTy}, {}};

  // if the type is free but has only one remaining reference, we can generalize
  // it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> maybeGeneralized = ctx->solver->generalizeFreeType(
        ctx->scope, operandTy, /* avoidSealingTables */ true);
    if (!maybeGeneralized)
      return {std::nullopt, false, {operandTy}, {}};
    operandTy = *maybeGeneralized;
  }

  std::shared_ptr<const NormalizedType> normTy =
      ctx->normalizer->normalize(operandTy);
  NormalizationResult inhabited = ctx->normalizer->isInhabited(normTy.get());

  // if the type failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normTy || inhabited == NormalizationResult::HitLimits)
    return {std::nullopt, false, {}, {}};

  // if the operand type is error suppressing, we can immediately reduce to
  // `number`.
  if (normTy->shouldSuppressErrors())
    return {ctx->builtins->numberType, false, {}, {}};

  // if we have an uninhabited type (like `never`), we can never observe that
  // the operator didn't work.
  if (inhabited == NormalizationResult::False)
    return {ctx->builtins->neverType, false, {}, {}};

  // if we're checking the length of a string, that works!
  if (normTy->isSubtypeOfString())
    return {ctx->builtins->numberType, false, {}, {}};

  // we use the normalized operand here in case there was an intersection or
  // union.
  TypeId normalizedOperand = ctx->normalizer->typeFromNormal(*normTy);
  if (normTy->hasTopTable() || get<TableType>(normalizedOperand))
    return {ctx->builtins->numberType, false, {}, {}};

  if (auto result = tryDistributeTypeFunctionApp(notFamilyFn, instance,
                                                 typeParams, packParams, ctx))
    return *result;

  // findMetatableEntry demands the ability to emit errors, so we must give it
  // the necessary state to do that, even if we intend to just eat the errors.
  ErrorVec dummy;

  std::optional<TypeId> mmType =
      findMetatableEntry(ctx->builtins, dummy, operandTy, "__len", Location{});
  if (!mmType)
    return {std::nullopt, true, {}, {}};

  mmType = follow(*mmType);
  if (isPending(*mmType, ctx->solver))
    return {std::nullopt, false, {*mmType}, {}};

  const FunctionType *mmFtv = get<FunctionType>(*mmType);
  if (!mmFtv)
    return {std::nullopt, true, {}, {}};

  std::optional<TypeId> instantiatedMmType =
      instantiate(ctx->builtins, ctx->arena, ctx->limits, ctx->scope, *mmType);
  if (!instantiatedMmType)
    return {std::nullopt, true, {}, {}};

  const FunctionType *instantiatedMmFtv =
      get<FunctionType>(*instantiatedMmType);
  if (!instantiatedMmFtv)
    return {ctx->builtins->errorRecoveryType(), false, {}, {}};

  TypePackId inferredArgPack = ctx->arena->addTypePack({operandTy});
  Unifier2 u2{ctx->arena, ctx->builtins, ctx->scope, ctx->ice};
  if (!u2.unify(inferredArgPack, instantiatedMmFtv->argTypes))
    return {std::nullopt, true, {}, {}}; // occurs check failed

  Subtyping subtyping{ctx->builtins, ctx->arena, ctx->normalizer, ctx->ice,
                      ctx->scope};
  if (!subtyping.isSubtype(inferredArgPack, instantiatedMmFtv->argTypes)
           .isSubtype) // TODO: is this the right variance?
    return {std::nullopt, true, {}, {}};

  // `len` must return a `number`.
  return {ctx->builtins->numberType, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
unmFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("unm type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId operandTy = follow(typeParams.at(0));

  if (operandTy == instance)
    return {ctx->builtins->neverType, false, {}, {}};

  // check to see if the operand type is resolved enough, and wait to reduce if
  // not
  if (isPending(operandTy, ctx->solver))
    return {std::nullopt, false, {operandTy}, {}};

  // if the type is free but has only one remaining reference, we can generalize
  // it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> maybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, operandTy);
    if (!maybeGeneralized)
      return {std::nullopt, false, {operandTy}, {}};
    operandTy = *maybeGeneralized;
  }

  std::shared_ptr<const NormalizedType> normTy =
      ctx->normalizer->normalize(operandTy);

  // if the operand failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normTy)
    return {std::nullopt, false, {}, {}};

  // if the operand is error suppressing, we can just go ahead and reduce.
  if (normTy->shouldSuppressErrors())
    return {operandTy, false, {}, {}};

  // if we have a `never`, we can never observe that the operation didn't work.
  if (is<NeverType>(operandTy))
    return {ctx->builtins->neverType, false, {}, {}};

  // If the type is exactly `number`, we can reduce now.
  if (normTy->isExactlyNumber())
    return {ctx->builtins->numberType, false, {}, {}};

  if (auto result = tryDistributeTypeFunctionApp(notFamilyFn, instance,
                                                 typeParams, packParams, ctx))
    return *result;

  // findMetatableEntry demands the ability to emit errors, so we must give it
  // the necessary state to do that, even if we intend to just eat the errors.
  ErrorVec dummy;

  std::optional<TypeId> mmType =
      findMetatableEntry(ctx->builtins, dummy, operandTy, "__unm", Location{});
  if (!mmType)
    return {std::nullopt, true, {}, {}};

  mmType = follow(*mmType);
  if (isPending(*mmType, ctx->solver))
    return {std::nullopt, false, {*mmType}, {}};

  const FunctionType *mmFtv = get<FunctionType>(*mmType);
  if (!mmFtv)
    return {std::nullopt, true, {}, {}};

  std::optional<TypeId> instantiatedMmType =
      instantiate(ctx->builtins, ctx->arena, ctx->limits, ctx->scope, *mmType);
  if (!instantiatedMmType)
    return {std::nullopt, true, {}, {}};

  const FunctionType *instantiatedMmFtv =
      get<FunctionType>(*instantiatedMmType);
  if (!instantiatedMmFtv)
    return {ctx->builtins->errorRecoveryType(), false, {}, {}};

  TypePackId inferredArgPack = ctx->arena->addTypePack({operandTy});
  Unifier2 u2{ctx->arena, ctx->builtins, ctx->scope, ctx->ice};
  if (!u2.unify(inferredArgPack, instantiatedMmFtv->argTypes))
    return {std::nullopt, true, {}, {}}; // occurs check failed

  Subtyping subtyping{ctx->builtins, ctx->arena, ctx->normalizer, ctx->ice,
                      ctx->scope};
  if (!subtyping.isSubtype(inferredArgPack, instantiatedMmFtv->argTypes)
           .isSubtype) // TODO: is this the right variance?
    return {std::nullopt, true, {}, {}};

  if (std::optional<TypeId> ret = first(instantiatedMmFtv->retTypes))
    return {*ret, false, {}, {}};
  else
    return {std::nullopt, true, {}, {}};
}

NotNull<Constraint> TypeFunctionContext::pushConstraint(ConstraintV &&c) {
  LUAU_ASSERT(solver);
  NotNull<Constraint> newConstraint = solver->pushConstraint(
      scope, constraint ? constraint->location : Location{}, std::move(c));

  // Every constraint that is blocked on the current constraint must also be
  // blocked on this new one.
  if (constraint)
    solver->inheritBlocks(NotNull{constraint}, newConstraint);

  return newConstraint;
}

TypeFunctionReductionResult<TypeId>
numericBinopFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
                     const std::vector<TypePackId> &packParams,
                     NotNull<TypeFunctionContext> ctx,
                     const std::string metamethod) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("encountered a type function instance without the required "
                  "argument structure");
    LUAU_ASSERT(false);
  }

  TypeId lhsTy = follow(typeParams.at(0));
  TypeId rhsTy = follow(typeParams.at(1));

  // isPending of `lhsTy` or `rhsTy` would return true, even if it cycles. We
  // want a different answer for that.
  if (lhsTy == instance || rhsTy == instance)
    return {ctx->builtins->neverType, false, {}, {}};

  // if we have a `never`, we can never observe that the math operator is
  // unreachable.
  if (is<NeverType>(lhsTy) || is<NeverType>(rhsTy))
    return {ctx->builtins->neverType, false, {}, {}};

  const Location location =
      ctx->constraint ? ctx->constraint->location : Location{};

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(lhsTy, ctx->solver))
    return {std::nullopt, false, {lhsTy}, {}};
  else if (isPending(rhsTy, ctx->solver))
    return {std::nullopt, false, {rhsTy}, {}};

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> lhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, lhsTy);
    std::optional<TypeId> rhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, rhsTy);

    if (!lhsMaybeGeneralized)
      return {std::nullopt, false, {lhsTy}, {}};
    else if (!rhsMaybeGeneralized)
      return {std::nullopt, false, {rhsTy}, {}};

    lhsTy = *lhsMaybeGeneralized;
    rhsTy = *rhsMaybeGeneralized;
  }

  // TODO: Normalization needs to remove cyclic type families from a
  // `NormalizedType`.
  std::shared_ptr<const NormalizedType> normLhsTy =
      ctx->normalizer->normalize(lhsTy);
  std::shared_ptr<const NormalizedType> normRhsTy =
      ctx->normalizer->normalize(rhsTy);

  // if either failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normLhsTy || !normRhsTy)
    return {std::nullopt, false, {}, {}};

  // if one of the types is error suppressing, we can reduce to `any` since we
  // should suppress errors in the result of the usage.
  if (normLhsTy->shouldSuppressErrors() || normRhsTy->shouldSuppressErrors())
    return {ctx->builtins->anyType, false, {}, {}};

  // if we're adding two `number` types, the result is `number`.
  if (normLhsTy->isExactlyNumber() && normRhsTy->isExactlyNumber())
    return {ctx->builtins->numberType, false, {}, {}};

  if (auto result =
          tryDistributeTypeFunctionApp(numericBinopFamilyFn, instance,
                                       typeParams, packParams, ctx, metamethod))
    return *result;

  // findMetatableEntry demands the ability to emit errors, so we must give it
  // the necessary state to do that, even if we intend to just eat the errors.
  ErrorVec dummy;

  std::optional<TypeId> mmType =
      findMetatableEntry(ctx->builtins, dummy, lhsTy, metamethod, location);
  bool reversed = false;
  if (!mmType) {
    mmType =
        findMetatableEntry(ctx->builtins, dummy, rhsTy, metamethod, location);
    reversed = true;
  }

  if (!mmType)
    return {std::nullopt, true, {}, {}};

  mmType = follow(*mmType);
  if (isPending(*mmType, ctx->solver))
    return {std::nullopt, false, {*mmType}, {}};

  TypePackId argPack = ctx->arena->addTypePack({lhsTy, rhsTy});
  SolveResult solveResult;

  if (!reversed)
    solveResult =
        solveFunctionCall(ctx->arena, ctx->builtins, ctx->normalizer, ctx->ice,
                          ctx->limits, ctx->scope, location, *mmType, argPack);
  else {
    TypePack *p = getMutable<TypePack>(argPack);
    std::swap(p->head.front(), p->head.back());
    solveResult =
        solveFunctionCall(ctx->arena, ctx->builtins, ctx->normalizer, ctx->ice,
                          ctx->limits, ctx->scope, location, *mmType, argPack);
  }

  if (!solveResult.typePackId.has_value())
    return {std::nullopt, true, {}, {}};

  TypePack extracted =
      extendTypePack(*ctx->arena, ctx->builtins, *solveResult.typePackId, 1);
  if (extracted.head.empty())
    return {std::nullopt, true, {}, {}};

  return {extracted.head.front(), false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
addFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("add type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__add");
}

TypeFunctionReductionResult<TypeId>
subFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("sub type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__sub");
}

TypeFunctionReductionResult<TypeId>
mulFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("mul type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__mul");
}

TypeFunctionReductionResult<TypeId>
divFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("div type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__div");
}

TypeFunctionReductionResult<TypeId>
idivFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
             const std::vector<TypePackId> &packParams,
             NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("integer div type function: encountered a type function "
                  "instance without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__idiv");
}

TypeFunctionReductionResult<TypeId>
powFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("pow type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__pow");
}

TypeFunctionReductionResult<TypeId>
modFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("modulo type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return numericBinopFamilyFn(instance, typeParams, packParams, ctx, "__mod");
}

TypeFunctionReductionResult<TypeId>
concatFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
               const std::vector<TypePackId> &packParams,
               NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("concat type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId lhsTy = follow(typeParams.at(0));
  TypeId rhsTy = follow(typeParams.at(1));

  // isPending of `lhsTy` or `rhsTy` would return true, even if it cycles. We
  // want a different answer for that.
  if (lhsTy == instance || rhsTy == instance)
    return {ctx->builtins->neverType, false, {}, {}};

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(lhsTy, ctx->solver))
    return {std::nullopt, false, {lhsTy}, {}};
  else if (isPending(rhsTy, ctx->solver))
    return {std::nullopt, false, {rhsTy}, {}};

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> lhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, lhsTy);
    std::optional<TypeId> rhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, rhsTy);

    if (!lhsMaybeGeneralized)
      return {std::nullopt, false, {lhsTy}, {}};
    else if (!rhsMaybeGeneralized)
      return {std::nullopt, false, {rhsTy}, {}};

    lhsTy = *lhsMaybeGeneralized;
    rhsTy = *rhsMaybeGeneralized;
  }

  std::shared_ptr<const NormalizedType> normLhsTy =
      ctx->normalizer->normalize(lhsTy);
  std::shared_ptr<const NormalizedType> normRhsTy =
      ctx->normalizer->normalize(rhsTy);

  // if either failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normLhsTy || !normRhsTy)
    return {std::nullopt, false, {}, {}};

  // if one of the types is error suppressing, we can reduce to `any` since we
  // should suppress errors in the result of the usage.
  if (normLhsTy->shouldSuppressErrors() || normRhsTy->shouldSuppressErrors())
    return {ctx->builtins->anyType, false, {}, {}};

  // if we have a `never`, we can never observe that the numeric operator didn't
  // work.
  if (is<NeverType>(lhsTy) || is<NeverType>(rhsTy))
    return {ctx->builtins->neverType, false, {}, {}};

  // if we're concatenating two elements that are either strings or numbers, the
  // result is `string`.
  if ((normLhsTy->isSubtypeOfString() || normLhsTy->isExactlyNumber()) &&
      (normRhsTy->isSubtypeOfString() || normRhsTy->isExactlyNumber()))
    return {ctx->builtins->stringType, false, {}, {}};

  if (auto result = tryDistributeTypeFunctionApp(concatFamilyFn, instance,
                                                 typeParams, packParams, ctx))
    return *result;

  // findMetatableEntry demands the ability to emit errors, so we must give it
  // the necessary state to do that, even if we intend to just eat the errors.
  ErrorVec dummy;

  std::optional<TypeId> mmType =
      findMetatableEntry(ctx->builtins, dummy, lhsTy, "__concat", Location{});
  bool reversed = false;
  if (!mmType) {
    mmType =
        findMetatableEntry(ctx->builtins, dummy, rhsTy, "__concat", Location{});
    reversed = true;
  }

  if (!mmType)
    return {std::nullopt, true, {}, {}};

  mmType = follow(*mmType);
  if (isPending(*mmType, ctx->solver))
    return {std::nullopt, false, {*mmType}, {}};

  const FunctionType *mmFtv = get<FunctionType>(*mmType);
  if (!mmFtv)
    return {std::nullopt, true, {}, {}};

  std::optional<TypeId> instantiatedMmType =
      instantiate(ctx->builtins, ctx->arena, ctx->limits, ctx->scope, *mmType);
  if (!instantiatedMmType)
    return {std::nullopt, true, {}, {}};

  const FunctionType *instantiatedMmFtv =
      get<FunctionType>(*instantiatedMmType);
  if (!instantiatedMmFtv)
    return {ctx->builtins->errorRecoveryType(), false, {}, {}};

  std::vector<TypeId> inferredArgs;
  if (!reversed)
    inferredArgs = {lhsTy, rhsTy};
  else
    inferredArgs = {rhsTy, lhsTy};

  TypePackId inferredArgPack = ctx->arena->addTypePack(std::move(inferredArgs));
  Unifier2 u2{ctx->arena, ctx->builtins, ctx->scope, ctx->ice};
  if (!u2.unify(inferredArgPack, instantiatedMmFtv->argTypes))
    return {std::nullopt, true, {}, {}}; // occurs check failed

  Subtyping subtyping{ctx->builtins, ctx->arena, ctx->normalizer, ctx->ice,
                      ctx->scope};
  if (!subtyping.isSubtype(inferredArgPack, instantiatedMmFtv->argTypes)
           .isSubtype) // TODO: is this the right variance?
    return {std::nullopt, true, {}, {}};

  return {ctx->builtins->stringType, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
andFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
            const std::vector<TypePackId> &packParams,
            NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("and type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId lhsTy = follow(typeParams.at(0));
  TypeId rhsTy = follow(typeParams.at(1));

  // t1 = and<lhs, t1> ~> lhs
  if (follow(rhsTy) == instance && lhsTy != rhsTy)
    return {lhsTy, false, {}, {}};
  // t1 = and<t1, rhs> ~> rhs
  if (follow(lhsTy) == instance && lhsTy != rhsTy)
    return {rhsTy, false, {}, {}};

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(lhsTy, ctx->solver))
    return {std::nullopt, false, {lhsTy}, {}};
  else if (isPending(rhsTy, ctx->solver))
    return {std::nullopt, false, {rhsTy}, {}};

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> lhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, lhsTy);
    std::optional<TypeId> rhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, rhsTy);

    if (!lhsMaybeGeneralized)
      return {std::nullopt, false, {lhsTy}, {}};
    else if (!rhsMaybeGeneralized)
      return {std::nullopt, false, {rhsTy}, {}};

    lhsTy = *lhsMaybeGeneralized;
    rhsTy = *rhsMaybeGeneralized;
  }

  // And evalutes to a boolean if the LHS is falsey, and the RHS type if LHS is
  // truthy.
  SimplifyResult filteredLhs = simplifyIntersection(
      ctx->builtins, ctx->arena, lhsTy, ctx->builtins->falsyType);
  SimplifyResult overallResult =
      simplifyUnion(ctx->builtins, ctx->arena, rhsTy, filteredLhs.result);
  std::vector<TypeId> blockedTypes{};
  for (auto ty : filteredLhs.blockedTypes)
    blockedTypes.push_back(ty);
  for (auto ty : overallResult.blockedTypes)
    blockedTypes.push_back(ty);
  return {overallResult.result, false, std::move(blockedTypes), {}};
}

TypeFunctionReductionResult<TypeId>
orFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
           const std::vector<TypePackId> &packParams,
           NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("or type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId lhsTy = follow(typeParams.at(0));
  TypeId rhsTy = follow(typeParams.at(1));

  // t1 = or<lhs, t1> ~> lhs
  if (follow(rhsTy) == instance && lhsTy != rhsTy)
    return {lhsTy, false, {}, {}};
  // t1 = or<t1, rhs> ~> rhs
  if (follow(lhsTy) == instance && lhsTy != rhsTy)
    return {rhsTy, false, {}, {}};

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(lhsTy, ctx->solver))
    return {std::nullopt, false, {lhsTy}, {}};
  else if (isPending(rhsTy, ctx->solver))
    return {std::nullopt, false, {rhsTy}, {}};

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> lhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, lhsTy);
    std::optional<TypeId> rhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, rhsTy);

    if (!lhsMaybeGeneralized)
      return {std::nullopt, false, {lhsTy}, {}};
    else if (!rhsMaybeGeneralized)
      return {std::nullopt, false, {rhsTy}, {}};

    lhsTy = *lhsMaybeGeneralized;
    rhsTy = *rhsMaybeGeneralized;
  }

  // Or evalutes to the LHS type if the LHS is truthy, and the RHS type if LHS
  // is falsy.
  SimplifyResult filteredLhs = simplifyIntersection(
      ctx->builtins, ctx->arena, lhsTy, ctx->builtins->truthyType);
  SimplifyResult overallResult =
      simplifyUnion(ctx->builtins, ctx->arena, rhsTy, filteredLhs.result);
  std::vector<TypeId> blockedTypes{};
  for (auto ty : filteredLhs.blockedTypes)
    blockedTypes.push_back(ty);
  for (auto ty : overallResult.blockedTypes)
    blockedTypes.push_back(ty);
  return {overallResult.result, false, std::move(blockedTypes), {}};
}

static TypeFunctionReductionResult<TypeId>
comparisonFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
                   const std::vector<TypePackId> &packParams,
                   NotNull<TypeFunctionContext> ctx,
                   const std::string metamethod) {

  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("encountered a type function instance without the required "
                  "argument structure");
    LUAU_ASSERT(false);
  }

  TypeId lhsTy = follow(typeParams.at(0));
  TypeId rhsTy = follow(typeParams.at(1));

  if (lhsTy == instance || rhsTy == instance)
    return {ctx->builtins->neverType, false, {}, {}};

  if (isPending(lhsTy, ctx->solver))
    return {std::nullopt, false, {lhsTy}, {}};
  else if (isPending(rhsTy, ctx->solver))
    return {std::nullopt, false, {rhsTy}, {}};

  // Algebra Reduction Rules for comparison family functions
  // Note that comparing to never tells you nothing about the other operand
  // lt< 'a , never> -> continue
  // lt< never, 'a>  -> continue
  // lt< 'a, t>      -> 'a is t - we'll solve the constraint, return and solve
  // lt<t, t> -> bool lt< t, 'a>      -> same as above
  bool canSubmitConstraint = ctx->solver && ctx->constraint;
  bool lhsFree = get<FreeType>(lhsTy) != nullptr;
  bool rhsFree = get<FreeType>(rhsTy) != nullptr;
  if (canSubmitConstraint) {
    // Implement injective type families for comparison type families
    // lt <number, t> implies t is number
    // lt <t, number> implies t is number
    if (lhsFree && isNumber(rhsTy))
      emplaceType<BoundType>(asMutable(lhsTy), ctx->builtins->numberType);
    else if (rhsFree && isNumber(lhsTy))
      emplaceType<BoundType>(asMutable(rhsTy), ctx->builtins->numberType);
    else if (lhsFree && ctx->normalizer->isInhabited(rhsTy) !=
                            NormalizationResult::False) {
      auto c1 = ctx->pushConstraint(EqualityConstraint{lhsTy, rhsTy});
      const_cast<Constraint *>(ctx->constraint)->dependencies.emplace_back(c1);
    } else if (rhsFree && ctx->normalizer->isInhabited(lhsTy) !=
                              NormalizationResult::False) {
      auto c1 = ctx->pushConstraint(EqualityConstraint{rhsTy, lhsTy});
      const_cast<Constraint *>(ctx->constraint)->dependencies.emplace_back(c1);
    }
  }

  // The above might have caused the operand types to be rebound, we need to
  // follow them again
  lhsTy = follow(lhsTy);
  rhsTy = follow(rhsTy);

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> lhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, lhsTy);
    std::optional<TypeId> rhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, rhsTy);

    if (!lhsMaybeGeneralized)
      return {std::nullopt, false, {lhsTy}, {}};
    else if (!rhsMaybeGeneralized)
      return {std::nullopt, false, {rhsTy}, {}};

    lhsTy = *lhsMaybeGeneralized;
    rhsTy = *rhsMaybeGeneralized;
  }

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not

  std::shared_ptr<const NormalizedType> normLhsTy =
      ctx->normalizer->normalize(lhsTy);
  std::shared_ptr<const NormalizedType> normRhsTy =
      ctx->normalizer->normalize(rhsTy);
  NormalizationResult lhsInhabited =
      ctx->normalizer->isInhabited(normLhsTy.get());
  NormalizationResult rhsInhabited =
      ctx->normalizer->isInhabited(normRhsTy.get());

  // if either failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normLhsTy || !normRhsTy ||
      lhsInhabited == NormalizationResult::HitLimits ||
      rhsInhabited == NormalizationResult::HitLimits)
    return {std::nullopt, false, {}, {}};

  // if one of the types is error suppressing, we can just go ahead and reduce.
  if (normLhsTy->shouldSuppressErrors() || normRhsTy->shouldSuppressErrors())
    return {ctx->builtins->booleanType, false, {}, {}};

  // if we have an uninhabited type (e.g. `never`), we can never observe that
  // the comparison didn't work.
  if (lhsInhabited == NormalizationResult::False ||
      rhsInhabited == NormalizationResult::False)
    return {ctx->builtins->booleanType, false, {}, {}};

  // If both types are some strict subset of `string`, we can reduce now.
  if (normLhsTy->isSubtypeOfString() && normRhsTy->isSubtypeOfString())
    return {ctx->builtins->booleanType, false, {}, {}};

  // If both types are exactly `number`, we can reduce now.
  if (normLhsTy->isExactlyNumber() && normRhsTy->isExactlyNumber())
    return {ctx->builtins->booleanType, false, {}, {}};

  if (auto result =
          tryDistributeTypeFunctionApp(comparisonFamilyFn, instance, typeParams,
                                       packParams, ctx, metamethod))
    return *result;

  // findMetatableEntry demands the ability to emit errors, so we must give it
  // the necessary state to do that, even if we intend to just eat the errors.
  ErrorVec dummy;

  std::optional<TypeId> mmType =
      findMetatableEntry(ctx->builtins, dummy, lhsTy, metamethod, Location{});
  if (!mmType)
    mmType =
        findMetatableEntry(ctx->builtins, dummy, rhsTy, metamethod, Location{});

  if (!mmType)
    return {std::nullopt, true, {}, {}};

  mmType = follow(*mmType);
  if (isPending(*mmType, ctx->solver))
    return {std::nullopt, false, {*mmType}, {}};

  const FunctionType *mmFtv = get<FunctionType>(*mmType);
  if (!mmFtv)
    return {std::nullopt, true, {}, {}};

  std::optional<TypeId> instantiatedMmType =
      instantiate(ctx->builtins, ctx->arena, ctx->limits, ctx->scope, *mmType);
  if (!instantiatedMmType)
    return {std::nullopt, true, {}, {}};

  const FunctionType *instantiatedMmFtv =
      get<FunctionType>(*instantiatedMmType);
  if (!instantiatedMmFtv)
    return {ctx->builtins->errorRecoveryType(), false, {}, {}};

  TypePackId inferredArgPack = ctx->arena->addTypePack({lhsTy, rhsTy});
  Unifier2 u2{ctx->arena, ctx->builtins, ctx->scope, ctx->ice};
  if (!u2.unify(inferredArgPack, instantiatedMmFtv->argTypes))
    return {std::nullopt, true, {}, {}}; // occurs check failed

  Subtyping subtyping{ctx->builtins, ctx->arena, ctx->normalizer, ctx->ice,
                      ctx->scope};
  if (!subtyping.isSubtype(inferredArgPack, instantiatedMmFtv->argTypes)
           .isSubtype) // TODO: is this the right variance?
    return {std::nullopt, true, {}, {}};

  return {ctx->builtins->booleanType, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
ltFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
           const std::vector<TypePackId> &packParams,
           NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("lt type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return comparisonFamilyFn(instance, typeParams, packParams, ctx, "__lt");
}

TypeFunctionReductionResult<TypeId>
leFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
           const std::vector<TypePackId> &packParams,
           NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("le type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return comparisonFamilyFn(instance, typeParams, packParams, ctx, "__le");
}

TypeFunctionReductionResult<TypeId>
eqFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
           const std::vector<TypePackId> &packParams,
           NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("eq type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId lhsTy = follow(typeParams.at(0));
  TypeId rhsTy = follow(typeParams.at(1));

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(lhsTy, ctx->solver))
    return {std::nullopt, false, {lhsTy}, {}};
  else if (isPending(rhsTy, ctx->solver))
    return {std::nullopt, false, {rhsTy}, {}};

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> lhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, lhsTy);
    std::optional<TypeId> rhsMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, rhsTy);

    if (!lhsMaybeGeneralized)
      return {std::nullopt, false, {lhsTy}, {}};
    else if (!rhsMaybeGeneralized)
      return {std::nullopt, false, {rhsTy}, {}};

    lhsTy = *lhsMaybeGeneralized;
    rhsTy = *rhsMaybeGeneralized;
  }

  std::shared_ptr<const NormalizedType> normLhsTy =
      ctx->normalizer->normalize(lhsTy);
  std::shared_ptr<const NormalizedType> normRhsTy =
      ctx->normalizer->normalize(rhsTy);
  NormalizationResult lhsInhabited =
      ctx->normalizer->isInhabited(normLhsTy.get());
  NormalizationResult rhsInhabited =
      ctx->normalizer->isInhabited(normRhsTy.get());

  // if either failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normLhsTy || !normRhsTy ||
      lhsInhabited == NormalizationResult::HitLimits ||
      rhsInhabited == NormalizationResult::HitLimits)
    return {std::nullopt, false, {}, {}};

  // if one of the types is error suppressing, we can just go ahead and reduce.
  if (normLhsTy->shouldSuppressErrors() || normRhsTy->shouldSuppressErrors())
    return {ctx->builtins->booleanType, false, {}, {}};

  // if we have a `never`, we can never observe that the comparison didn't work.
  if (lhsInhabited == NormalizationResult::False ||
      rhsInhabited == NormalizationResult::False)
    return {ctx->builtins->booleanType, false, {}, {}};

  // findMetatableEntry demands the ability to emit errors, so we must give it
  // the necessary state to do that, even if we intend to just eat the errors.
  ErrorVec dummy;

  std::optional<TypeId> mmType =
      findMetatableEntry(ctx->builtins, dummy, lhsTy, "__eq", Location{});
  if (!mmType)
    mmType =
        findMetatableEntry(ctx->builtins, dummy, rhsTy, "__eq", Location{});

  // if neither type has a metatable entry for `__eq`, then we'll check for
  // inhabitance of the intersection!
  NormalizationResult intersectInhabited =
      ctx->normalizer->isIntersectionInhabited(lhsTy, rhsTy);
  if (!mmType) {
    if (intersectInhabited == NormalizationResult::True)
      return {ctx->builtins->booleanType,
              false,
              {},
              {}}; // if it's inhabited, everything is okay!

    // we might be in a case where we still want to accept the comparison...
    if (intersectInhabited == NormalizationResult::False) {
      // if they're both subtypes of `string` but have no common intersection,
      // the comparison is allowed but always `false`.
      if (normLhsTy->isSubtypeOfString() && normRhsTy->isSubtypeOfString())
        return {ctx->builtins->falseType, false, {}, {}};

      // if they're both subtypes of `boolean` but have no common intersection,
      // the comparison is allowed but always `false`.
      if (normLhsTy->isSubtypeOfBooleans() && normRhsTy->isSubtypeOfBooleans())
        return {ctx->builtins->falseType, false, {}, {}};
    }

    return {std::nullopt,
            true,
            {},
            {}}; // if it's not, then this family is irreducible!
  }

  mmType = follow(*mmType);
  if (isPending(*mmType, ctx->solver))
    return {std::nullopt, false, {*mmType}, {}};

  const FunctionType *mmFtv = get<FunctionType>(*mmType);
  if (!mmFtv)
    return {std::nullopt, true, {}, {}};

  std::optional<TypeId> instantiatedMmType =
      instantiate(ctx->builtins, ctx->arena, ctx->limits, ctx->scope, *mmType);
  if (!instantiatedMmType)
    return {std::nullopt, true, {}, {}};

  const FunctionType *instantiatedMmFtv =
      get<FunctionType>(*instantiatedMmType);
  if (!instantiatedMmFtv)
    return {ctx->builtins->errorRecoveryType(), false, {}, {}};

  TypePackId inferredArgPack = ctx->arena->addTypePack({lhsTy, rhsTy});
  Unifier2 u2{ctx->arena, ctx->builtins, ctx->scope, ctx->ice};
  if (!u2.unify(inferredArgPack, instantiatedMmFtv->argTypes))
    return {std::nullopt, true, {}, {}}; // occurs check failed

  Subtyping subtyping{ctx->builtins, ctx->arena, ctx->normalizer, ctx->ice,
                      ctx->scope};
  if (!subtyping.isSubtype(inferredArgPack, instantiatedMmFtv->argTypes)
           .isSubtype) // TODO: is this the right variance?
    return {std::nullopt, true, {}, {}};

  return {ctx->builtins->booleanType, false, {}, {}};
}

// Collect types that prevent us from reducing a particular refinement.
struct FindRefinementBlockers : TypeOnceVisitor {
  DenseHashSet<TypeId> found{nullptr};
  bool visit(TypeId ty, const BlockedType &) override {
    found.insert(ty);
    return false;
  }

  bool visit(TypeId ty, const PendingExpansionType &) override {
    found.insert(ty);
    return false;
  }

  bool visit(TypeId ty, const ClassType &) override { return false; }
};

TypeFunctionReductionResult<TypeId>
refineFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
               const std::vector<TypePackId> &packParams,
               NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("refine type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId targetTy = follow(typeParams.at(0));
  TypeId discriminantTy = follow(typeParams.at(1));

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(targetTy, ctx->solver))
    return {std::nullopt, false, {targetTy}, {}};
  else if (isPending(discriminantTy, ctx->solver))
    return {std::nullopt, false, {discriminantTy}, {}};

  // if either type is free but has only one remaining reference, we can
  // generalize it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> targetMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, targetTy);
    std::optional<TypeId> discriminantMaybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, discriminantTy);

    if (!targetMaybeGeneralized)
      return {std::nullopt, false, {targetTy}, {}};
    else if (!discriminantMaybeGeneralized)
      return {std::nullopt, false, {discriminantTy}, {}};

    targetTy = *targetMaybeGeneralized;
    discriminantTy = *discriminantMaybeGeneralized;
  }

  // we need a more complex check for blocking on the discriminant in particular
  FindRefinementBlockers frb;
  frb.traverse(discriminantTy);

  if (!frb.found.empty())
    return {std::nullopt, false, {frb.found.begin(), frb.found.end()}, {}};

  /* HACK: Refinements sometimes produce a type T & ~any under the assumption
   * that ~any is the same as any.  This is so so weird, but refinements needs
   * some way to say "I may refine this, but I'm not sure."
   *
   * It does this by refining on a blocked type and deferring the decision
   * until it is unblocked.
   *
   * Refinements also get negated, so we wind up with types like T & ~*blocked*
   *
   * We need to treat T & ~any as T in this case.
   */

  if (auto nt = get<NegationType>(discriminantTy))
    if (get<AnyType>(follow(nt->ty)))
      return {targetTy, false, {}, {}};

  // If the target type is a table, then simplification already implements the
  // logic to deal with refinements properly since the type of the discriminant
  // is guaranteed to only ever be an (arbitrarily-nested) table of a single
  // property type.
  if (get<TableType>(targetTy)) {
    SimplifyResult result = simplifyIntersection(ctx->builtins, ctx->arena,
                                                 targetTy, discriminantTy);
    if (!result.blockedTypes.empty())
      return {std::nullopt,
              false,
              {result.blockedTypes.begin(), result.blockedTypes.end()},
              {}};

    return {result.result, false, {}, {}};
  }

  // In the general case, we'll still use normalization though.
  TypeId intersection =
      ctx->arena->addType(IntersectionType{{targetTy, discriminantTy}});
  std::shared_ptr<const NormalizedType> normIntersection =
      ctx->normalizer->normalize(intersection);
  std::shared_ptr<const NormalizedType> normType =
      ctx->normalizer->normalize(targetTy);

  // if the intersection failed to normalize, we can't reduce, but know nothing
  // about inhabitance.
  if (!normIntersection || !normType)
    return {std::nullopt, false, {}, {}};

  TypeId resultTy = ctx->normalizer->typeFromNormal(*normIntersection);

  // include the error type if the target type is error-suppressing and the
  // intersection we computed is not
  if (normType->shouldSuppressErrors() &&
      !normIntersection->shouldSuppressErrors())
    resultTy =
        ctx->arena->addType(UnionType{{resultTy, ctx->builtins->errorType}});

  return {resultTy, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
singletonFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
                  const std::vector<TypePackId> &packParams,
                  NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("singleton type function: encountered a type function "
                  "instance without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId type = follow(typeParams.at(0));

  // check to see if both operand types are resolved enough, and wait to reduce
  // if not
  if (isPending(type, ctx->solver))
    return {std::nullopt, false, {type}, {}};

  // if the type is free but has only one remaining reference, we can generalize
  // it to its upper bound here.
  if (ctx->solver) {
    std::optional<TypeId> maybeGeneralized =
        ctx->solver->generalizeFreeType(ctx->scope, type);
    if (!maybeGeneralized)
      return {std::nullopt, false, {type}, {}};
    type = *maybeGeneralized;
  }

  TypeId followed = type;
  // we want to follow through a negation here as well.
  if (auto negation = get<NegationType>(followed))
    followed = follow(negation->ty);

  // if we have a singleton type or `nil`, which is its own singleton type...
  if (get<SingletonType>(followed) || isNil(followed))
    return {type, false, {}, {}};

  // otherwise, we'll return the top type, `unknown`.
  return {ctx->builtins->unknownType, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
unionFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
              const std::vector<TypePackId> &packParams,
              NotNull<TypeFunctionContext> ctx) {
  if (!packParams.empty()) {
    ctx->ice->ice("union type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  // if we only have one parameter, there's nothing to do.
  if (typeParams.size() == 1)
    return {follow(typeParams[0]), false, {}, {}};

  // we need to follow all of the type parameters.
  std::vector<TypeId> types;
  types.reserve(typeParams.size());
  for (auto ty : typeParams)
    types.emplace_back(follow(ty));

  // unfortunately, we need this short-circuit: if all but one type is `never`,
  // we will return that one type. this also will early return if _everything_
  // is `never`, since we already have to check that.
  std::optional<TypeId> lastType = std::nullopt;
  for (auto ty : types) {
    // if we have a previous type and it's not `never` and the current type
    // isn't `never`...
    if (lastType && !get<NeverType>(lastType) && !get<NeverType>(ty)) {
      // we know we are not taking the short-circuited path.
      lastType = std::nullopt;
      break;
    }

    if (get<NeverType>(ty))
      continue;
    lastType = ty;
  }

  // if we still have a `lastType` at the end, we're taking the short-circuit
  // and reducing early.
  if (lastType)
    return {lastType, false, {}, {}};

  // check to see if the operand types are resolved enough, and wait to reduce
  // if not
  for (auto ty : types)
    if (isPending(ty, ctx->solver))
      return {std::nullopt, false, {ty}, {}};

  // fold over the types with `simplifyUnion`
  TypeId resultTy = ctx->builtins->neverType;
  for (auto ty : types) {
    SimplifyResult result =
        simplifyUnion(ctx->builtins, ctx->arena, resultTy, ty);
    if (!result.blockedTypes.empty())
      return {std::nullopt,
              false,
              {result.blockedTypes.begin(), result.blockedTypes.end()},
              {}};

    resultTy = result.result;
  }

  return {resultTy, false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
intersectFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
                  const std::vector<TypePackId> &packParams,
                  NotNull<TypeFunctionContext> ctx) {
  if (!packParams.empty()) {
    ctx->ice->ice("intersect type function: encountered a type function "
                  "instance without the required argument structure");
    LUAU_ASSERT(false);
  }

  // if we only have one parameter, there's nothing to do.
  if (typeParams.size() == 1)
    return {follow(typeParams[0]), false, {}, {}};

  // we need to follow all of the type parameters.
  std::vector<TypeId> types;
  types.reserve(typeParams.size());
  for (auto ty : typeParams)
    types.emplace_back(follow(ty));

  // check to see if the operand types are resolved enough, and wait to reduce
  // if not if any of them are `never`, the intersection will always be `never`,
  // so we can reduce directly.
  for (auto ty : types) {
    if (isPending(ty, ctx->solver))
      return {std::nullopt, false, {ty}, {}};
    else if (get<NeverType>(ty))
      return {ctx->builtins->neverType, false, {}, {}};
  }

  // fold over the types with `simplifyIntersection`
  TypeId resultTy = ctx->builtins->unknownType;
  for (auto ty : types) {
    SimplifyResult result =
        simplifyIntersection(ctx->builtins, ctx->arena, resultTy, ty);
    if (!result.blockedTypes.empty())
      return {std::nullopt,
              false,
              {result.blockedTypes.begin(), result.blockedTypes.end()},
              {}};

    resultTy = result.result;
  }

  // if the intersection simplifies to `never`, this gives us bad autocomplete.
  // we'll just produce the intersection plainly instead, but this might be
  // revisitable if we ever give `never` some kind of "explanation" trail.
  if (get<NeverType>(resultTy)) {
    TypeId intersection = ctx->arena->addType(IntersectionType{typeParams});
    return {intersection, false, {}, {}};
  }

  return {resultTy, false, {}, {}};
}

// computes the keys of `ty` into `result`
// `isRaw` parameter indicates whether or not we should follow __index
// metamethods returns `false` if `result` should be ignored because the answer
// is "all strings"
bool computeKeysOf(TypeId ty, Set<std::string> &result,
                   DenseHashSet<TypeId> &seen, bool isRaw,
                   NotNull<TypeFunctionContext> ctx) {
  // if the type is the top table type, the answer is just "all strings"
  if (get<PrimitiveType>(ty))
    return false;

  // if we've already seen this type, we can do nothing
  if (seen.contains(ty))
    return true;
  seen.insert(ty);

  // if we have a particular table type, we can insert the keys
  if (auto tableTy = get<TableType>(ty)) {
    if (tableTy->indexer) {
      // if we have a string indexer, the answer is, again, "all strings"
      if (isString(tableTy->indexer->indexType))
        return false;
    }

    for (auto [key, _] : tableTy->props)
      result.insert(key);
    return true;
  }

  // otherwise, we have a metatable to deal with
  if (auto metatableTy = get<MetatableType>(ty)) {
    bool res = true;

    if (!isRaw) {
      // findMetatableEntry demands the ability to emit errors, so we must give
      // it the necessary state to do that, even if we intend to just eat the
      // errors.
      ErrorVec dummy;

      std::optional<TypeId> mmType =
          findMetatableEntry(ctx->builtins, dummy, ty, "__index", Location{});
      if (mmType)
        res = res && computeKeysOf(*mmType, result, seen, isRaw, ctx);
    }

    res = res && computeKeysOf(metatableTy->table, result, seen, isRaw, ctx);

    return res;
  }

  // this should not be reachable since the type should be a valid tables part
  // from normalization.
  LUAU_ASSERT(false);
  return false;
}

TypeFunctionReductionResult<TypeId>
keyofFamilyImpl(const std::vector<TypeId> &typeParams,
                const std::vector<TypePackId> &packParams,
                NotNull<TypeFunctionContext> ctx, bool isRaw) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("keyof type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  TypeId operandTy = follow(typeParams.at(0));

  std::shared_ptr<const NormalizedType> normTy =
      ctx->normalizer->normalize(operandTy);

  // if the operand failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!normTy)
    return {std::nullopt, false, {}, {}};

  // if we don't have either just tables or just classes, we've got nothing to
  // get keys of (at least until a future version perhaps adds classes as well)
  if (normTy->hasTables() == normTy->hasClasses())
    return {std::nullopt, true, {}, {}};

  // this is sort of atrocious, but we're trying to reject any type that has not
  // normalized to a table or a union of tables.
  if (normTy->hasTops() || normTy->hasBooleans() || normTy->hasErrors() ||
      normTy->hasNils() || normTy->hasNumbers() || normTy->hasStrings() ||
      normTy->hasThreads() || normTy->hasBuffers() || normTy->hasFunctions() ||
      normTy->hasTyvars())
    return {std::nullopt, true, {}, {}};

  // we're going to collect the keys in here
  Set<std::string> keys{{}};

  // computing the keys for classes
  if (normTy->hasClasses()) {
    LUAU_ASSERT(!normTy->hasTables());

    auto classesIter = normTy->classes.ordering.begin();
    auto classesIterEnd = normTy->classes.ordering.end();
    LUAU_ASSERT(
        classesIter !=
        classesIterEnd); // should be guaranteed by the `hasClasses` check

    auto classTy = get<ClassType>(*classesIter);
    if (!classTy) {
      LUAU_ASSERT(false); // this should not be possible according to
                          // normalization's spec
      return {std::nullopt, true, {}, {}};
    }

    for (auto [key, _] : classTy->props)
      keys.insert(key);

    // we need to look at each class to remove any keys that are not common
    // amongst them all
    while (++classesIter != classesIterEnd) {
      auto classTy = get<ClassType>(*classesIter);
      if (!classTy) {
        LUAU_ASSERT(false); // this should not be possible according to
                            // normalization's spec
        return {std::nullopt, true, {}, {}};
      }

      for (auto key : keys) {
        // remove any keys that are not present in each class
        if (classTy->props.find(key) == classTy->props.end())
          keys.erase(key);
      }
    }
  }

  // computing the keys for tables
  if (normTy->hasTables()) {
    LUAU_ASSERT(!normTy->hasClasses());

    // seen set for key computation for tables
    DenseHashSet<TypeId> seen{{}};

    auto tablesIter = normTy->tables.begin();
    LUAU_ASSERT(
        tablesIter !=
        normTy->tables
            .end()); // should be guaranteed by the `hasTables` check earlier

    // collect all the properties from the first table type
    if (!computeKeysOf(*tablesIter, keys, seen, isRaw, ctx))
      return {ctx->builtins->stringType,
              false,
              {},
              {}}; // if it failed, we have the top table type!

    // we need to look at each tables to remove any keys that are not common
    // amongst them all
    while (++tablesIter != normTy->tables.end()) {
      seen.clear(); // we'll reuse the same seen set

      Set<std::string> localKeys{{}};

      // we can skip to the next table if this one is the top table type
      if (!computeKeysOf(*tablesIter, localKeys, seen, isRaw, ctx))
        continue;

      for (auto key : keys) {
        // remove any keys that are not present in each table
        if (!localKeys.contains(key))
          keys.erase(key);
      }
    }
  }

  // if the set of keys is empty, `keyof<T>` is `never`
  if (keys.empty())
    return {ctx->builtins->neverType, false, {}, {}};

  // everything is validated, we need only construct our big union of singletons
  // now!
  std::vector<TypeId> singletons;
  singletons.reserve(keys.size());

  for (std::string key : keys)
    singletons.push_back(
        ctx->arena->addType(SingletonType{StringSingleton{key}}));

  return {ctx->arena->addType(UnionType{singletons}), false, {}, {}};
}

TypeFunctionReductionResult<TypeId>
keyofFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
              const std::vector<TypePackId> &packParams,
              NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("keyof type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return keyofFamilyImpl(typeParams, packParams, ctx, /* isRaw */ false);
}

TypeFunctionReductionResult<TypeId>
rawkeyofFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
                 const std::vector<TypePackId> &packParams,
                 NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 1 || !packParams.empty()) {
    ctx->ice->ice("rawkeyof type function: encountered a type function "
                  "instance without the required argument structure");
    LUAU_ASSERT(false);
  }

  return keyofFamilyImpl(typeParams, packParams, ctx, /* isRaw */ true);
}

/* Searches through table's or class's props/indexer to find the property of
   `ty` If found, appends that property to `result` and returns true Else,
   returns false */
bool searchPropsAndIndexer(TypeId ty, TableType::Props tblProps,
                           std::optional<TableIndexer> tblIndexer,
                           DenseHashSet<TypeId> &result,
                           NotNull<TypeFunctionContext> ctx) {
  ty = follow(ty);

  // index into tbl's properties
  if (auto stringSingleton = get<StringSingleton>(get<SingletonType>(ty))) {
    if (tblProps.find(stringSingleton->value) != tblProps.end()) {
      TypeId propTy = follow(tblProps.at(stringSingleton->value).type());

      // property is a union type -> we need to extend our reduction type
      if (auto propUnionTy = get<UnionType>(propTy)) {
        for (TypeId option : propUnionTy->options)
          result.insert(option);
      } else // property is a singular type or intersection type -> we can
             // simply append
        result.insert(propTy);

      return true;
    }
  }

  // index into tbl's indexer
  if (tblIndexer) {
    if (isSubtype(ty, tblIndexer->indexType, ctx->scope, ctx->builtins,
                  *ctx->ice)) {
      TypeId idxResultTy = follow(tblIndexer->indexResultType);

      // indexResultType is a union type -> we need to extend our reduction type
      if (auto idxResUnionTy = get<UnionType>(idxResultTy)) {
        for (TypeId option : idxResUnionTy->options)
          result.insert(option);
      } else // indexResultType is a singular type or intersection type -> we
             // can simply append
        result.insert(idxResultTy);

      return true;
    }
  }

  return false;
}

/* Handles recursion / metamethods of tables/classes
   `isRaw` parameter indicates whether or not we should follow __index
   metamethods returns false if property of `ty` could not be found */
bool tblIndexInto(TypeId indexer, TypeId indexee, DenseHashSet<TypeId> &result,
                  NotNull<TypeFunctionContext> ctx, bool isRaw) {
  indexer = follow(indexer);
  indexee = follow(indexee);

  // we have a table type to try indexing
  if (auto tableTy = get<TableType>(indexee)) {
    return searchPropsAndIndexer(indexer, tableTy->props, tableTy->indexer,
                                 result, ctx);
  }

  // we have a metatable type to try indexing
  if (auto metatableTy = get<MetatableType>(indexee)) {
    if (auto tableTy = get<TableType>(metatableTy->table)) {

      // try finding all properties within the current scope of the table
      if (searchPropsAndIndexer(indexer, tableTy->props, tableTy->indexer,
                                result, ctx))
        return true;
    }

    // if the code reached here, it means we weren't able to find all properties
    // -> look into __index metamethod
    if (!isRaw) {
      // findMetatableEntry demands the ability to emit errors, so we must give
      // it the necessary state to do that, even if we intend to just eat the
      // errors.
      ErrorVec dummy;
      std::optional<TypeId> mmType = findMetatableEntry(
          ctx->builtins, dummy, indexee, "__index", Location{});
      if (mmType)
        return tblIndexInto(indexer, *mmType, result, ctx, isRaw);
    }
  }

  return false;
}

/* Vocabulary note: indexee refers to the type that contains the properties,
                    indexer refers to the type that is used to access indexee
   Example:         index<Person, "name"> => `Person` is the indexee and
   `"name"` is the indexer */
TypeFunctionReductionResult<TypeId>
indexFamilyImpl(const std::vector<TypeId> &typeParams,
                const std::vector<TypePackId> &packParams,
                NotNull<TypeFunctionContext> ctx, bool isRaw) {
  TypeId indexeeTy = follow(typeParams.at(0));
  std::shared_ptr<const NormalizedType> indexeeNormTy =
      ctx->normalizer->normalize(indexeeTy);

  // if the indexee failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!indexeeNormTy)
    return {std::nullopt, false, {}, {}};

  // if we don't have either just tables or just classes, we've got nothing to
  // index into
  if (indexeeNormTy->hasTables() == indexeeNormTy->hasClasses())
    return {std::nullopt, true, {}, {}};

  // we're trying to reject any type that has not normalized to a table/class or
  // a union of tables/classes.
  if (indexeeNormTy->hasTops() || indexeeNormTy->hasBooleans() ||
      indexeeNormTy->hasErrors() || indexeeNormTy->hasNils() ||
      indexeeNormTy->hasNumbers() || indexeeNormTy->hasStrings() ||
      indexeeNormTy->hasThreads() || indexeeNormTy->hasBuffers() ||
      indexeeNormTy->hasFunctions() || indexeeNormTy->hasTyvars())
    return {std::nullopt, true, {}, {}};

  TypeId indexerTy = follow(typeParams.at(1));
  std::shared_ptr<const NormalizedType> indexerNormTy =
      ctx->normalizer->normalize(indexerTy);

  // if the indexer failed to normalize, we can't reduce, but know nothing about
  // inhabitance.
  if (!indexerNormTy)
    return {std::nullopt, false, {}, {}};

  // we're trying to reject any type that is not a string singleton or primitive
  // (string, number, boolean, thread, nil, function, table, or buffer)
  if (indexerNormTy->hasTops() || indexerNormTy->hasErrors())
    return {std::nullopt, true, {}, {}};

  // indexer can be a union > break them down into a vector
  const std::vector<TypeId> *typesToFind;
  const std::vector<TypeId> singleType{indexerTy};
  if (auto unionTy = get<UnionType>(indexerTy))
    typesToFind = &unionTy->options;
  else
    typesToFind = &singleType;

  DenseHashSet<TypeId> properties{{}}; // vector of types that will be returned

  if (indexeeNormTy->hasClasses()) {
    LUAU_ASSERT(!indexeeNormTy->hasTables());

    if (isRaw) // rawget should never reduce for classes (to match the behavior
               // of the rawget global function)
      return {std::nullopt, true, {}, {}};

    // at least one class is guaranteed to be in the iterator by .hasClasses()
    for (auto classesIter = indexeeNormTy->classes.ordering.begin();
         classesIter != indexeeNormTy->classes.ordering.end(); ++classesIter) {
      auto classTy = get<ClassType>(*classesIter);
      if (!classTy) {
        LUAU_ASSERT(false); // this should not be possible according to
                            // normalization's spec
        return {std::nullopt, true, {}, {}};
      }

      for (TypeId ty : *typesToFind) {
        // Search for all instances of indexer in class->props and
        // class->indexer
        if (searchPropsAndIndexer(ty, classTy->props, classTy->indexer,
                                  properties, ctx))
          continue; // Indexer was found in this class, so we can move on to the
                    // next

        // If code reaches here,that means the property not found -> check in
        // the metatable's __index

        // findMetatableEntry demands the ability to emit errors, so we must
        // give it the necessary state to do that, even if we intend to just eat
        // the errors.
        ErrorVec dummy;
        std::optional<TypeId> mmType = findMetatableEntry(
            ctx->builtins, dummy, *classesIter, "__index", Location{});
        if (!mmType) // if a metatable does not exist, there is no where else to
                     // look
          return {std::nullopt, true, {}, {}};

        if (!tblIndexInto(
                ty, *mmType, properties, ctx,
                isRaw)) // if indexer is not in the metatable, we fail to reduce
          return {std::nullopt, true, {}, {}};
      }
    }
  }

  if (indexeeNormTy->hasTables()) {
    LUAU_ASSERT(!indexeeNormTy->hasClasses());

    // at least one table is guaranteed to be in the iterator by .hasTables()
    for (auto tablesIter = indexeeNormTy->tables.begin();
         tablesIter != indexeeNormTy->tables.end(); ++tablesIter) {
      for (TypeId ty : *typesToFind)
        if (!tblIndexInto(ty, *tablesIter, properties, ctx, isRaw))
          return {std::nullopt, true, {}, {}};
    }
  }

  // Call `follow()` on each element to resolve all Bound types before returning
  std::transform(properties.begin(), properties.end(), properties.begin(),
                 [](TypeId ty) { return follow(ty); });

  // If the type being reduced to is a single type, no need to union
  if (properties.size() == 1)
    return {*properties.begin(), false, {}, {}};

  return {ctx->arena->addType(UnionType{
              std::vector<TypeId>(properties.begin(), properties.end())}),
          false,
          {},
          {}};
}

TypeFunctionReductionResult<TypeId>
indexFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
              const std::vector<TypePackId> &packParams,
              NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("index type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return indexFamilyImpl(typeParams, packParams, ctx, /* isRaw */ false);
}

TypeFunctionReductionResult<TypeId>
rawgetFamilyFn(TypeId instance, const std::vector<TypeId> &typeParams,
               const std::vector<TypePackId> &packParams,
               NotNull<TypeFunctionContext> ctx) {
  if (typeParams.size() != 2 || !packParams.empty()) {
    ctx->ice->ice("rawget type function: encountered a type function instance "
                  "without the required argument structure");
    LUAU_ASSERT(false);
  }

  return indexFamilyImpl(typeParams, packParams, ctx, /* isRaw */ true);
}

BuiltinTypeFunctions::BuiltinTypeFunctions()
    : notFunc{"not", notFamilyFn}, lenFunc{"len", lenFamilyFn},
      unmFunc{"unm", unmFamilyFn}, addFunc{"add", addFamilyFn},
      subFunc{"sub", subFamilyFn}, mulFunc{"mul", mulFamilyFn},
      divFunc{"div", divFamilyFn}, idivFunc{"idiv", idivFamilyFn},
      powFunc{"pow", powFamilyFn}, modFunc{"mod", modFamilyFn},
      concatFunc{"concat", concatFamilyFn}, andFunc{"and", andFamilyFn},
      orFunc{"or", orFamilyFn}, ltFunc{"lt", ltFamilyFn},
      leFunc{"le", leFamilyFn}, eqFunc{"eq", eqFamilyFn},
      refineFunc{"refine", refineFamilyFn},
      singletonFunc{"singleton", singletonFamilyFn},
      unionFunc{"union", unionFamilyFn},
      intersectFunc{"intersect", intersectFamilyFn},
      keyofFunc{"keyof", keyofFamilyFn},
      rawkeyofFunc{"rawkeyof", rawkeyofFamilyFn},
      indexFunc{"index", indexFamilyFn}, rawgetFunc{"rawget", rawgetFamilyFn} {}

void BuiltinTypeFunctions::addToScope(NotNull<TypeArena> arena,
                                      NotNull<Scope> scope) const {
  // make a type function for a one-argument type function
  auto mkUnaryTypeFunction = [&](const TypeFunction *tf) {
    TypeId t = arena->addType(GenericType{"T"});
    GenericTypeDefinition genericT{t};

    return TypeFun{
        {genericT},
        arena->addType(TypeFunctionInstanceType{NotNull{tf}, {t}, {}})};
  };

  // make a type function for a two-argument type function
  auto mkBinaryTypeFunction = [&](const TypeFunction *tf) {
    TypeId t = arena->addType(GenericType{"T"});
    TypeId u = arena->addType(GenericType{"U"});
    GenericTypeDefinition genericT{t};
    GenericTypeDefinition genericU{u, {t}};

    return TypeFun{
        {genericT, genericU},
        arena->addType(TypeFunctionInstanceType{NotNull{tf}, {t, u}, {}})};
  };

  scope->exportedTypeBindings[lenFunc.name] = mkUnaryTypeFunction(&lenFunc);
  scope->exportedTypeBindings[unmFunc.name] = mkUnaryTypeFunction(&unmFunc);

  scope->exportedTypeBindings[addFunc.name] = mkBinaryTypeFunction(&addFunc);
  scope->exportedTypeBindings[subFunc.name] = mkBinaryTypeFunction(&subFunc);
  scope->exportedTypeBindings[mulFunc.name] = mkBinaryTypeFunction(&mulFunc);
  scope->exportedTypeBindings[divFunc.name] = mkBinaryTypeFunction(&divFunc);
  scope->exportedTypeBindings[idivFunc.name] = mkBinaryTypeFunction(&idivFunc);
  scope->exportedTypeBindings[powFunc.name] = mkBinaryTypeFunction(&powFunc);
  scope->exportedTypeBindings[modFunc.name] = mkBinaryTypeFunction(&modFunc);
  scope->exportedTypeBindings[concatFunc.name] =
      mkBinaryTypeFunction(&concatFunc);

  scope->exportedTypeBindings[ltFunc.name] = mkBinaryTypeFunction(&ltFunc);
  scope->exportedTypeBindings[leFunc.name] = mkBinaryTypeFunction(&leFunc);
  scope->exportedTypeBindings[eqFunc.name] = mkBinaryTypeFunction(&eqFunc);

  scope->exportedTypeBindings[keyofFunc.name] = mkUnaryTypeFunction(&keyofFunc);
  scope->exportedTypeBindings[rawkeyofFunc.name] =
      mkUnaryTypeFunction(&rawkeyofFunc);

  scope->exportedTypeBindings[indexFunc.name] =
      mkBinaryTypeFunction(&indexFunc);
  scope->exportedTypeBindings[rawgetFunc.name] =
      mkBinaryTypeFunction(&rawgetFunc);
}

const BuiltinTypeFunctions &builtinTypeFunctions() {
  static std::unique_ptr<const BuiltinTypeFunctions> result =
      std::make_unique<BuiltinTypeFunctions>();

  return *result;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

namespace Luau {

Scope::Scope(TypePackId returnType)
    : parent(nullptr), returnType(returnType), level(TypeLevel()) {}

Scope::Scope(const ScopePtr &parent, int subLevel)
    : parent(parent), returnType(parent->returnType),
      level(parent->level.incr()) {
  level = level.incr();
  level.subLevel = subLevel;
}

void Scope::addBuiltinTypeBinding(const Name &name, const TypeFun &tyFun) {
  exportedTypeBindings[name] = tyFun;
  builtinTypeNames.insert(name);
}

std::optional<TypeId> Scope::lookup(Symbol sym) const {
  auto r = const_cast<Scope *>(this)->lookupEx(sym);
  if (r)
    return r->first->typeId;
  else
    return std::nullopt;
}

std::optional<std::pair<TypeId, Scope *>> Scope::lookupEx(DefId def) {
  Scope *s = this;

  while (true) {
    if (TypeId *it = s->lvalueTypes.find(def))
      return std::pair{*it, s};
    else if (TypeId *it = s->rvalueRefinements.find(def))
      return std::pair{*it, s};

    if (s->parent)
      s = s->parent.get();
    else
      return std::nullopt;
  }
}

std::optional<std::pair<Binding *, Scope *>> Scope::lookupEx(Symbol sym) {
  Scope *s = this;

  while (true) {
    auto it = s->bindings.find(sym);
    if (it != s->bindings.end())
      return std::pair{&it->second, s};

    if (s->parent)
      s = s->parent.get();
    else
      return std::nullopt;
  }
}

std::optional<TypeId> Scope::lookupUnrefinedType(DefId def) const {
  for (const Scope *current = this; current; current = current->parent.get()) {
    if (auto ty = current->lvalueTypes.find(def))
      return *ty;
  }

  return std::nullopt;
}

std::optional<TypeId> Scope::lookup(DefId def) const {
  for (const Scope *current = this; current; current = current->parent.get()) {
    if (auto ty = current->rvalueRefinements.find(def))
      return *ty;
    if (auto ty = current->lvalueTypes.find(def))
      return *ty;
  }

  return std::nullopt;
}

std::optional<TypeFun> Scope::lookupType(const Name &name) const {
  const Scope *scope = this;
  while (true) {
    auto it = scope->exportedTypeBindings.find(name);
    if (it != scope->exportedTypeBindings.end())
      return it->second;

    it = scope->privateTypeBindings.find(name);
    if (it != scope->privateTypeBindings.end())
      return it->second;

    if (scope->parent)
      scope = scope->parent.get();
    else
      return std::nullopt;
  }
}

std::optional<TypeFun> Scope::lookupImportedType(const Name &moduleAlias,
                                                 const Name &name) const {
  const Scope *scope = this;
  while (scope) {
    auto it = scope->importedTypeBindings.find(moduleAlias);
    if (it == scope->importedTypeBindings.end()) {
      scope = scope->parent.get();
      continue;
    }

    auto it2 = it->second.find(name);
    if (it2 == it->second.end()) {
      scope = scope->parent.get();
      continue;
    }

    return it2->second;
  }

  return std::nullopt;
}

std::optional<TypePackId> Scope::lookupPack(const Name &name) const {
  const Scope *scope = this;
  while (true) {
    auto it = scope->privateTypePackBindings.find(name);
    if (it != scope->privateTypePackBindings.end())
      return it->second;

    if (scope->parent)
      scope = scope->parent.get();
    else
      return std::nullopt;
  }
}

std::optional<Binding>
Scope::linearSearchForBinding(const std::string &name,
                              bool traverseScopeChain) const {
  const Scope *scope = this;

  while (scope) {
    for (const auto &[n, binding] : scope->bindings) {
      if (n.local && n.local->name == name.c_str())
        return binding;
      else if (n.global.value && n.global == name.c_str())
        return binding;
    }

    scope = scope->parent.get();

    if (!traverseScopeChain)
      break;
  }

  return std::nullopt;
}

// Updates the `this` scope with the assignments from the `childScope` including
// ones that doesn't exist in `this`.
void Scope::inheritAssignments(const ScopePtr &childScope) {
  if (!FFlag::DebugLuauDeferredConstraintResolution)
    return;

  for (const auto &[k, a] : childScope->lvalueTypes)
    lvalueTypes[k] = a;
}

// Updates the `this` scope with the refinements from the `childScope` excluding
// ones that doesn't exist in `this`.
void Scope::inheritRefinements(const ScopePtr &childScope) {
  if (FFlag::DebugLuauDeferredConstraintResolution) {
    for (const auto &[k, a] : childScope->rvalueRefinements) {
      if (lookup(NotNull{k}))
        rvalueRefinements[k] = a;
    }
  }

  for (const auto &[k, a] : childScope->refinements) {
    Symbol symbol = getBaseSymbol(k);
    if (lookup(symbol))
      refinements[k] = a;
  }
}

bool subsumesStrict(Scope *left, Scope *right) {
  while (right) {
    if (right->parent.get() == left)
      return true;

    right = right->parent.get();
  }

  return false;
}

bool subsumes(Scope *left, Scope *right) {
  return left == right || subsumesStrict(left, right);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

namespace Luau {

bool inConditional(const TypeContext &context) {
  return context == TypeContext::Condition;
}

bool occursCheck(TypeId needle, TypeId haystack) {
  LUAU_ASSERT(get<BlockedType>(needle) || get<PendingExpansionType>(needle));
  haystack = follow(haystack);

  auto checkHaystack = [needle](TypeId haystack) {
    return occursCheck(needle, haystack);
  };

  if (needle == haystack)
    return true;
  else if (auto ut = get<UnionType>(haystack))
    return std::any_of(begin(ut), end(ut), checkHaystack);
  else if (auto it = get<IntersectionType>(haystack))
    return std::any_of(begin(it), end(it), checkHaystack);

  return false;
}

// FIXME: Property is quite large.
//
// Returning it on the stack like this isn't great. We'd like to just return a
// const Property*, but we mint a property of type any if the subject type is
// any.
std::optional<Property> findTableProperty(NotNull<BuiltinTypes> builtinTypes,
                                          ErrorVec &errors, TypeId ty,
                                          const std::string &name,
                                          Location location) {
  if (get<AnyType>(ty))
    return Property::rw(ty);

  if (const TableType *tableType = getTableType(ty)) {
    const auto &it = tableType->props.find(name);
    if (it != tableType->props.end())
      return it->second;
  }

  std::optional<TypeId> mtIndex =
      findMetatableEntry(builtinTypes, errors, ty, "__index", location);
  int count = 0;
  while (mtIndex) {
    TypeId index = follow(*mtIndex);

    if (count >= 100)
      return std::nullopt;

    ++count;

    if (const auto &itt = getTableType(index)) {
      const auto &fit = itt->props.find(name);
      if (fit != itt->props.end())
        return fit->second.type();
    } else if (const auto &itf = get<FunctionType>(index)) {
      std::optional<TypeId> r = first(follow(itf->retTypes));
      if (!r)
        return builtinTypes->nilType;
      else
        return *r;
    } else if (get<AnyType>(index))
      return builtinTypes->anyType;
    else
      errors.push_back(TypeError{
          location,
          GenericError{"__index should either be a function or table. Got " +
                       toString(index)}});

    mtIndex =
        findMetatableEntry(builtinTypes, errors, *mtIndex, "__index", location);
  }

  return std::nullopt;
}

std::optional<TypeId> findMetatableEntry(NotNull<BuiltinTypes> builtinTypes,
                                         ErrorVec &errors, TypeId type,
                                         const std::string &entry,
                                         Location location) {
  type = follow(type);

  std::optional<TypeId> metatable = getMetatable(type, builtinTypes);
  if (!metatable)
    return std::nullopt;

  TypeId unwrapped = follow(*metatable);

  if (get<AnyType>(unwrapped))
    return builtinTypes->anyType;

  const TableType *mtt = getTableType(unwrapped);
  if (!mtt) {
    errors.push_back(
        TypeError{location, GenericError{"Metatable was not a table"}});
    return std::nullopt;
  }

  auto it = mtt->props.find(entry);
  if (it != mtt->props.end())
    return it->second.type();
  else
    return std::nullopt;
}

std::optional<TypeId>
findTablePropertyRespectingMeta(NotNull<BuiltinTypes> builtinTypes,
                                ErrorVec &errors, TypeId ty,
                                const std::string &name, Location location) {
  return findTablePropertyRespectingMeta(builtinTypes, errors, ty, name,
                                         ValueContext::RValue, location);
}

std::optional<TypeId> findTablePropertyRespectingMeta(
    NotNull<BuiltinTypes> builtinTypes, ErrorVec &errors, TypeId ty,
    const std::string &name, ValueContext context, Location location) {
  if (get<AnyType>(ty))
    return ty;

  if (const TableType *tableType = getTableType(ty)) {
    const auto &it = tableType->props.find(name);
    if (it != tableType->props.end()) {
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        switch (context) {
        case ValueContext::RValue:
          return it->second.readTy;
        case ValueContext::LValue:
          return it->second.writeTy;
        }
      } else
        return it->second.type();
    }
  }

  std::optional<TypeId> mtIndex =
      findMetatableEntry(builtinTypes, errors, ty, "__index", location);
  int count = 0;
  while (mtIndex) {
    TypeId index = follow(*mtIndex);

    if (count >= 100)
      return std::nullopt;

    ++count;

    if (const auto &itt = getTableType(index)) {
      const auto &fit = itt->props.find(name);
      if (fit != itt->props.end())
        return fit->second.type();
    } else if (const auto &itf = get<FunctionType>(index)) {
      std::optional<TypeId> r = first(follow(itf->retTypes));
      if (!r)
        return builtinTypes->nilType;
      else
        return *r;
    } else if (get<AnyType>(index))
      return builtinTypes->anyType;
    else
      errors.push_back(TypeError{
          location,
          GenericError{"__index should either be a function or table. Got " +
                       toString(index)}});

    mtIndex =
        findMetatableEntry(builtinTypes, errors, *mtIndex, "__index", location);
  }

  return std::nullopt;
}

std::pair<size_t, std::optional<size_t>>
getParameterExtents(const TxnLog *log, TypePackId tp,
                    bool includeHiddenVariadics) {
  size_t minCount = 0;
  size_t optionalCount = 0;

  auto it = begin(tp, log);
  auto endIter = end(tp);

  while (it != endIter) {
    TypeId ty = *it;
    if (isOptional(ty))
      ++optionalCount;
    else {
      minCount += optionalCount;
      optionalCount = 0;
      minCount++;
    }

    ++it;
  }

  if (it.tail() && isVariadicTail(*it.tail(), *log, includeHiddenVariadics))
    return {minCount, std::nullopt};
  else
    return {minCount, minCount + optionalCount};
}

TypePack extendTypePack(TypeArena &arena, NotNull<BuiltinTypes> builtinTypes,
                        TypePackId pack, size_t length,
                        std::vector<std::optional<TypeId>> overrides) {
  TypePack result;

  while (true) {
    pack = follow(pack);

    if (const TypePack *p = get<TypePack>(pack)) {
      size_t i = 0;
      while (i < p->head.size() && result.head.size() < length) {
        result.head.push_back(p->head[i]);
        ++i;
      }

      if (result.head.size() == length) {
        if (i == p->head.size())
          result.tail = p->tail;
        else {
          TypePackId newTail = arena.addTypePack(TypePack{});
          TypePack *newTailPack = getMutable<TypePack>(newTail);

          newTailPack->head.insert(newTailPack->head.begin(),
                                   p->head.begin() + i, p->head.end());
          newTailPack->tail = p->tail;

          result.tail = newTail;
        }

        return result;
      } else if (p->tail) {
        pack = *p->tail;
        continue;
      } else {
        // There just aren't enough types in this pack to satisfy the request.
        return result;
      }
    } else if (const VariadicTypePack *vtp = get<VariadicTypePack>(pack)) {
      while (result.head.size() < length)
        result.head.push_back(vtp->ty);
      result.tail = pack;
      return result;
    } else if (FreeTypePack *ftp = getMutable<FreeTypePack>(pack)) {
      // If we need to get concrete types out of a free pack, we choose to
      // interpret this as proof that the pack must have at least 'length'
      // elements.  We mint fresh types for each element we're extracting
      // and rebind the free pack to be a TypePack containing them. We
      // also have to create a new tail.

      TypePack newPack;
      newPack.tail = arena.freshTypePack(ftp->scope);
      size_t overridesIndex = 0;
      while (result.head.size() < length) {
        TypeId t;
        if (overridesIndex < overrides.size() && overrides[overridesIndex]) {
          t = *overrides[overridesIndex];
        } else {
          if (FFlag::DebugLuauDeferredConstraintResolution) {
            FreeType ft{ftp->scope, builtinTypes->neverType,
                        builtinTypes->unknownType};
            t = arena.addType(ft);
          } else
            t = arena.freshType(ftp->scope);
        }

        newPack.head.push_back(t);
        result.head.push_back(newPack.head.back());
        overridesIndex++;
      }

      asMutable(pack)->ty.emplace<TypePack>(std::move(newPack));

      return result;
    } else if (const Unifiable::Error *etp =
                   getMutable<Unifiable::Error>(pack)) {
      while (result.head.size() < length)
        result.head.push_back(builtinTypes->errorRecoveryType());

      result.tail = pack;
      return result;
    } else {
      // If the pack is blocked or generic, we can't extract.
      // Return whatever we've got with this pack as the tail.
      result.tail = pack;
      return result;
    }
  }
}

std::vector<TypeId> reduceUnion(const std::vector<TypeId> &types) {
  std::vector<TypeId> result;
  for (TypeId t : types) {
    t = follow(t);
    if (get<NeverType>(t))
      continue;

    if (get<ErrorType>(t) || get<AnyType>(t))
      return {t};

    if (const UnionType *utv = get<UnionType>(t)) {
      for (TypeId ty : utv) {
        ty = follow(ty);
        if (get<NeverType>(ty))
          continue;
        if (get<ErrorType>(ty) || get<AnyType>(ty))
          return {ty};

        if (result.end() == std::find(result.begin(), result.end(), ty))
          result.push_back(ty);
      }
    } else if (std::find(result.begin(), result.end(), t) == result.end())
      result.push_back(t);
  }

  return result;
}

static std::optional<TypeId> tryStripUnionFromNil(TypeArena &arena, TypeId ty) {
  if (const UnionType *utv = get<UnionType>(ty)) {
    if (!std::any_of(begin(utv), end(utv), isNil))
      return ty;

    std::vector<TypeId> result;

    for (TypeId option : utv) {
      if (!isNil(option))
        result.push_back(option);
    }

    if (result.empty())
      return std::nullopt;

    return result.size() == 1 ? result[0]
                              : arena.addType(UnionType{std::move(result)});
  }

  return std::nullopt;
}

TypeId stripNil(NotNull<BuiltinTypes> builtinTypes, TypeArena &arena,
                TypeId ty) {
  ty = follow(ty);

  if (get<UnionType>(ty)) {
    std::optional<TypeId> cleaned = tryStripUnionFromNil(arena, ty);

    // If there is no union option without 'nil'
    if (!cleaned)
      return builtinTypes->nilType;

    return follow(*cleaned);
  }

  return follow(ty);
}

ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer,
                                      TypeId ty) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);
  std::shared_ptr<const NormalizedType> normType = normalizer->normalize(ty);

  if (!normType)
    return ErrorSuppression::NormalizationFailed;

  return (normType->shouldSuppressErrors()) ? ErrorSuppression::Suppress
                                            : ErrorSuppression::DoNotSuppress;
}

ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer,
                                      TypePackId tp) {
  auto [tys, tail] = flatten(tp);

  // check the head, one type at a time
  for (TypeId ty : tys) {
    auto result = shouldSuppressErrors(normalizer, ty);
    if (result != ErrorSuppression::DoNotSuppress)
      return result;
  }

  // check the tail if we have one and it's finite
  if (tail && tp != tail && finite(*tail))
    return shouldSuppressErrors(normalizer, *tail);

  return ErrorSuppression::DoNotSuppress;
}

// This is a useful helper because it is often the case that we are looking at
// specifically a pair of types that might suppress.
ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer,
                                      TypeId ty1, TypeId ty2) {
  auto result = shouldSuppressErrors(normalizer, ty1);

  // if ty1 is do not suppress, ty2 determines our overall behavior
  if (result == ErrorSuppression::DoNotSuppress)
    return shouldSuppressErrors(normalizer, ty2);

  // otherwise, ty1 is either suppress or normalization failure which are both
  // the appropriate overarching result
  return result;
}

ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer,
                                      TypePackId tp1, TypePackId tp2) {
  auto result = shouldSuppressErrors(normalizer, tp1);

  // if tp1 is do not suppress, tp2 determines our overall behavior
  if (result == ErrorSuppression::DoNotSuppress)
    return shouldSuppressErrors(normalizer, tp2);

  // otherwise, tp1 is either suppress or normalization failure which are both
  // the appropriate overarching result
  return result;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@ PACK.lua : not found, likely and std header
#include <stdexcept>

namespace Luau {

const std::string nullPendingResult = "<nullptr>";

std::string toString(PendingType *pending) {
  if (pending == nullptr)
    return nullPendingResult;

  return toString(pending->pending);
}

std::string dump(PendingType *pending) {
  if (pending == nullptr) {
    printf("%s\n", nullPendingResult.c_str());
    return nullPendingResult;
  }

  ToStringOptions opts;
  opts.exhaustive = true;
  opts.functionTypeArguments = true;
  std::string result = toString(pending->pending, opts);
  printf("%s\n", result.c_str());
  return result;
}

std::string toString(PendingTypePack *pending) {
  if (pending == nullptr)
    return nullPendingResult;

  return toString(pending->pending);
}

std::string dump(PendingTypePack *pending) {
  if (pending == nullptr) {
    printf("%s\n", nullPendingResult.c_str());
    return nullPendingResult;
  }

  ToStringOptions opts;
  opts.exhaustive = true;
  opts.functionTypeArguments = true;
  std::string result = toString(pending->pending, opts);
  printf("%s\n", result.c_str());
  return result;
}

static const TxnLog emptyLog;

const TxnLog *TxnLog::empty() { return &emptyLog; }

void TxnLog::concat(TxnLog rhs) {
  for (auto &[ty, rep] : rhs.typeVarChanges) {
    if (rep->dead)
      continue;
    typeVarChanges[ty] = std::move(rep);
  }

  for (auto &[tp, rep] : rhs.typePackChanges)
    typePackChanges[tp] = std::move(rep);

  radioactive |= rhs.radioactive;
}

void TxnLog::concatAsIntersections(TxnLog rhs, NotNull<TypeArena> arena) {
  for (auto &[ty, rightRep] : rhs.typeVarChanges) {
    if (rightRep->dead)
      continue;

    if (auto leftRep = typeVarChanges.find(ty); leftRep && !(*leftRep)->dead) {
      TypeId leftTy = arena->addType((*leftRep)->pending);
      TypeId rightTy = arena->addType(rightRep->pending);
      typeVarChanges[ty]->pending.ty = IntersectionType{{leftTy, rightTy}};
    } else
      typeVarChanges[ty] = std::move(rightRep);
  }

  for (auto &[tp, rep] : rhs.typePackChanges)
    typePackChanges[tp] = std::move(rep);

  radioactive |= rhs.radioactive;
}

void TxnLog::concatAsUnion(TxnLog rhs, NotNull<TypeArena> arena) {
  /*
   * Check for cycles.
   *
   * We must not combine a log entry that binds 'a to 'b with a log that
   * binds 'b to 'a.
   *
   * Of the two, identify the one with the 'bigger' scope and eliminate the
   * entry that rebinds it.
   */
  for (const auto &[rightTy, rightRep] : rhs.typeVarChanges) {
    if (rightRep->dead)
      continue;

    // We explicitly use get_if here because we do not wish to do anything
    // if the uncommitted type is already bound to something else.
    const FreeType *rf = get_if<FreeType>(&rightTy->ty);
    if (!rf)
      continue;

    const BoundType *rb = Luau::get<BoundType>(&rightRep->pending);
    if (!rb)
      continue;

    const TypeId leftTy = rb->boundTo;
    const FreeType *lf = get_if<FreeType>(&leftTy->ty);
    if (!lf)
      continue;

    auto leftRep = typeVarChanges.find(leftTy);
    if (!leftRep)
      continue;

    if ((*leftRep)->dead)
      continue;

    const BoundType *lb = Luau::get<BoundType>(&(*leftRep)->pending);
    if (!lb)
      continue;

    if (lb->boundTo == rightTy) {
      // leftTy has been bound to rightTy, but rightTy has also been bound
      // to leftTy. We find the one that belongs to the more deeply nested
      // scope and remove it from the log.
      const bool discardLeft = useScopes ? subsumes(lf->scope, rf->scope)
                                         : lf->level.subsumes(rf->level);

      if (discardLeft)
        (*leftRep)->dead = true;
      else
        rightRep->dead = true;
    }
  }

  for (auto &[ty, rightRep] : rhs.typeVarChanges) {
    if (rightRep->dead)
      continue;

    if (auto leftRep = typeVarChanges.find(ty); leftRep && !(*leftRep)->dead) {
      TypeId leftTy = arena->addType((*leftRep)->pending);
      TypeId rightTy = arena->addType(rightRep->pending);

      if (follow(leftTy) == follow(rightTy))
        typeVarChanges[ty] = std::move(rightRep);
      else
        typeVarChanges[ty]->pending.ty = UnionType{{leftTy, rightTy}};
    } else
      typeVarChanges[ty] = std::move(rightRep);
  }

  for (auto &[tp, rep] : rhs.typePackChanges)
    typePackChanges[tp] = std::move(rep);

  radioactive |= rhs.radioactive;
}

void TxnLog::commit() {
  LUAU_ASSERT(!radioactive);

  for (auto &[ty, rep] : typeVarChanges) {
    if (!rep->dead)
      asMutable(ty)->reassign(rep.get()->pending);
  }

  for (auto &[tp, rep] : typePackChanges)
    asMutable(tp)->reassign(rep.get()->pending);

  clear();
}

void TxnLog::clear() {
  typeVarChanges.clear();
  typePackChanges.clear();
}

TxnLog TxnLog::inverse() {
  TxnLog inversed(sharedSeen);

  for (auto &[ty, _rep] : typeVarChanges) {
    if (!_rep->dead)
      inversed.typeVarChanges[ty] = std::make_unique<PendingType>(*ty);
  }

  for (auto &[tp, _rep] : typePackChanges)
    inversed.typePackChanges[tp] = std::make_unique<PendingTypePack>(*tp);

  inversed.radioactive = radioactive;

  return inversed;
}

bool TxnLog::haveSeen(TypeId lhs, TypeId rhs) const {
  return haveSeen((TypeOrPackId)lhs, (TypeOrPackId)rhs);
}

void TxnLog::pushSeen(TypeId lhs, TypeId rhs) {
  pushSeen((TypeOrPackId)lhs, (TypeOrPackId)rhs);
}

void TxnLog::popSeen(TypeId lhs, TypeId rhs) {
  popSeen((TypeOrPackId)lhs, (TypeOrPackId)rhs);
}

bool TxnLog::haveSeen(TypePackId lhs, TypePackId rhs) const {
  return haveSeen((TypeOrPackId)lhs, (TypeOrPackId)rhs);
}

void TxnLog::pushSeen(TypePackId lhs, TypePackId rhs) {
  pushSeen((TypeOrPackId)lhs, (TypeOrPackId)rhs);
}

void TxnLog::popSeen(TypePackId lhs, TypePackId rhs) {
  popSeen((TypeOrPackId)lhs, (TypeOrPackId)rhs);
}

bool TxnLog::haveSeen(TypeOrPackId lhs, TypeOrPackId rhs) const {
  const std::pair<TypeOrPackId, TypeOrPackId> sortedPair =
      (lhs > rhs) ? std::make_pair(lhs, rhs) : std::make_pair(rhs, lhs);
  if (sharedSeen->end() !=
      std::find(sharedSeen->begin(), sharedSeen->end(), sortedPair)) {
    return true;
  }

  return false;
}

void TxnLog::pushSeen(TypeOrPackId lhs, TypeOrPackId rhs) {
  const std::pair<TypeOrPackId, TypeOrPackId> sortedPair =
      (lhs > rhs) ? std::make_pair(lhs, rhs) : std::make_pair(rhs, lhs);
  sharedSeen->push_back(sortedPair);
}

void TxnLog::popSeen(TypeOrPackId lhs, TypeOrPackId rhs) {
  const std::pair<TypeOrPackId, TypeOrPackId> sortedPair =
      (lhs > rhs) ? std::make_pair(lhs, rhs) : std::make_pair(rhs, lhs);
  LUAU_ASSERT(sortedPair == sharedSeen->back());
  sharedSeen->pop_back();
}

PendingType *TxnLog::queue(TypeId ty) {
  if (ty->persistent)
    radioactive = true;

  // Explicitly don't look in ancestors. If we have discovered something new
  // about this type, we don't want to mutate the parent's state.
  auto &pending = typeVarChanges[ty];
  if (!pending || (*pending).dead) {
    pending = std::make_unique<PendingType>(*ty);
    pending->pending.owningArena = nullptr;
  }

  return pending.get();
}

PendingTypePack *TxnLog::queue(TypePackId tp) {
  if (tp->persistent)
    radioactive = true;

  // Explicitly don't look in ancestors. If we have discovered something new
  // about this type, we don't want to mutate the parent's state.
  auto &pending = typePackChanges[tp];
  if (!pending) {
    pending = std::make_unique<PendingTypePack>(*tp);
    pending->pending.owningArena = nullptr;
  }

  return pending.get();
}

PendingType *TxnLog::pending(TypeId ty) const {
  // This function will technically work if `this` is nullptr, but this
  // indicates a bug, so we explicitly assert.
  LUAU_ASSERT(static_cast<const void *>(this) != nullptr);

  for (const TxnLog *current = this; current; current = current->parent) {
    if (auto it = current->typeVarChanges.find(ty); it && !(*it)->dead)
      return it->get();
  }

  return nullptr;
}

PendingTypePack *TxnLog::pending(TypePackId tp) const {
  // This function will technically work if `this` is nullptr, but this
  // indicates a bug, so we explicitly assert.
  LUAU_ASSERT(static_cast<const void *>(this) != nullptr);

  for (const TxnLog *current = this; current; current = current->parent) {
    if (auto it = current->typePackChanges.find(tp))
      return it->get();
  }

  return nullptr;
}

PendingType *TxnLog::replace(TypeId ty, Type replacement) {
  PendingType *newTy = queue(ty);
  newTy->pending.reassign(replacement);
  return newTy;
}

PendingTypePack *TxnLog::replace(TypePackId tp, TypePackVar replacement) {
  PendingTypePack *newTp = queue(tp);
  newTp->pending.reassign(replacement);
  return newTp;
}

PendingType *TxnLog::bindTable(TypeId ty, std::optional<TypeId> newBoundTo) {
  LUAU_ASSERT(get<TableType>(ty));
  LUAU_ASSERT(ty != newBoundTo);

  PendingType *newTy = queue(ty);
  if (TableType *ttv = Luau::getMutable<TableType>(newTy))
    ttv->boundTo = newBoundTo;

  return newTy;
}

PendingType *TxnLog::changeLevel(TypeId ty, TypeLevel newLevel) {
  LUAU_ASSERT(get<FreeType>(ty) || get<TableType>(ty) || get<FunctionType>(ty));

  PendingType *newTy = queue(ty);
  if (FreeType *ftv = Luau::getMutable<FreeType>(newTy)) {
    ftv->level = newLevel;
  } else if (TableType *ttv = Luau::getMutable<TableType>(newTy)) {
    LUAU_ASSERT(ttv->state == TableState::Free ||
                ttv->state == TableState::Generic);
    ttv->level = newLevel;
  } else if (FunctionType *ftv = Luau::getMutable<FunctionType>(newTy)) {
    ftv->level = newLevel;
  }

  return newTy;
}

PendingTypePack *TxnLog::changeLevel(TypePackId tp, TypeLevel newLevel) {
  LUAU_ASSERT(get<FreeTypePack>(tp));

  PendingTypePack *newTp = queue(tp);
  if (FreeTypePack *ftp = Luau::getMutable<FreeTypePack>(newTp)) {
    ftp->level = newLevel;
  }

  return newTp;
}

PendingType *TxnLog::changeScope(TypeId ty, NotNull<Scope> newScope) {
  LUAU_ASSERT(get<FreeType>(ty) || get<TableType>(ty) || get<FunctionType>(ty));

  PendingType *newTy = queue(ty);
  if (FreeType *ftv = Luau::getMutable<FreeType>(newTy)) {
    ftv->scope = newScope;
  } else if (TableType *ttv = Luau::getMutable<TableType>(newTy)) {
    LUAU_ASSERT(ttv->state == TableState::Free ||
                ttv->state == TableState::Generic);
    ttv->scope = newScope;
  } else if (FunctionType *ftv = Luau::getMutable<FunctionType>(newTy)) {
    ftv->scope = newScope;
  }

  return newTy;
}

PendingTypePack *TxnLog::changeScope(TypePackId tp, NotNull<Scope> newScope) {
  LUAU_ASSERT(get<FreeTypePack>(tp));

  PendingTypePack *newTp = queue(tp);
  if (FreeTypePack *ftp = Luau::getMutable<FreeTypePack>(newTp)) {
    ftp->scope = newScope;
  }

  return newTp;
}

PendingType *TxnLog::changeIndexer(TypeId ty,
                                   std::optional<TableIndexer> indexer) {
  LUAU_ASSERT(get<TableType>(ty));

  PendingType *newTy = queue(ty);
  if (TableType *ttv = Luau::getMutable<TableType>(newTy)) {
    ttv->indexer = indexer;
  }

  return newTy;
}

std::optional<TypeLevel> TxnLog::getLevel(TypeId ty) const {
  if (FreeType *ftv = getMutable<FreeType>(ty))
    return ftv->level;
  else if (TableType *ttv = getMutable<TableType>(ty);
           ttv && (ttv->state == TableState::Free ||
                   ttv->state == TableState::Generic))
    return ttv->level;
  else if (FunctionType *ftv = getMutable<FunctionType>(ty))
    return ftv->level;

  return std::nullopt;
}

TypeId TxnLog::follow(TypeId ty) const {
  return Luau::follow(ty, this, [](const void *ctx, TypeId ty) -> TypeId {
    const TxnLog *self = static_cast<const TxnLog *>(ctx);
    PendingType *state = self->pending(ty);

    if (state == nullptr)
      return ty;

    // Ugly: Fabricate a TypeId that doesn't adhere to most of the invariants
    // that normally apply. This is safe because follow will only call get<>
    // on the returned pointer.
    return const_cast<const Type *>(&state->pending);
  });
}

TypePackId TxnLog::follow(TypePackId tp) const {
  return Luau::follow(tp, this,
                      [](const void *ctx, TypePackId tp) -> TypePackId {
                        const TxnLog *self = static_cast<const TxnLog *>(ctx);
                        PendingTypePack *state = self->pending(tp);

                        if (state == nullptr)
                          return tp;

                        // Ugly: Fabricate a TypePackId that doesn't adhere to
                        // most of the invariants that normally apply. This is
                        // safe because follow will only call get<> on the
                        // returned pointer.
                        return const_cast<const TypePackVar *>(&state->pending);
                      });
}

std::pair<std::vector<TypeId>, std::vector<TypePackId>>
TxnLog::getChanges() const {
  std::pair<std::vector<TypeId>, std::vector<TypePackId>> result;

  for (const auto &[typeId, _newState] : typeVarChanges)
    result.first.push_back(typeId);
  for (const auto &[typePackId, _newState] : typePackChanges)
    result.second.push_back(typePackId);

  return result;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/AstJsonEncoder.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

#include "luau_ast_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@ PACK.lua : not found, likely and std header
#include <math.h>

LUAU_FASTFLAG(LuauDeclarationExtraPropData)

namespace Luau {

struct AstJsonEncoder : public AstVisitor {
  static constexpr int CHUNK_SIZE = 1024;
  std::vector<std::string> chunks;
  bool comma = false;

  AstJsonEncoder() { newChunk(); }

  std::string str() { return join(chunks, ""); }

  bool pushComma() {
    bool c = comma;
    comma = false;
    return c;
  }

  void popComma(bool c) { comma = c; }

  void newChunk() {
    chunks.emplace_back();
    chunks.back().reserve(CHUNK_SIZE);
  }

  void appendChunk(std::string_view sv) {
    if (sv.size() > CHUNK_SIZE) {
      chunks.emplace_back(sv);
      newChunk();
      return;
    }

    auto &chunk = chunks.back();
    if (chunk.size() + sv.size() < CHUNK_SIZE) {
      chunk.append(sv.data(), sv.size());
      return;
    }

    size_t prefix = CHUNK_SIZE - chunk.size();
    chunk.append(sv.data(), prefix);
    newChunk();

    chunks.back().append(sv.data() + prefix, sv.size() - prefix);
  }

  void writeRaw(std::string_view sv) { appendChunk(sv); }

  void writeRaw(char c) { writeRaw(std::string_view{&c, 1}); }

  void writeType(std::string_view propValue) { write("type", propValue); }

  template <typename T> void write(std::string_view propName, const T &value) {
    if (comma)
      writeRaw(",");
    comma = true;
    writeRaw("\"");
    writeRaw(propName);
    writeRaw("\":");
    write(value);
  }

  void write(bool b) {
    if (b)
      writeRaw("true");
    else
      writeRaw("false");
  }

  void write(double d) {
    switch (fpclassify(d)) {
    case FP_INFINITE:
      if (d < 0)
        writeRaw("-Infinity");
      else
        writeRaw("Infinity");
      break;

    case FP_NAN:
      writeRaw("NaN");
      break;

    case FP_NORMAL:
    case FP_SUBNORMAL:
    case FP_ZERO:
    default:
      char b[32];
      snprintf(b, sizeof(b), "%.17g", d);
      writeRaw(b);
      break;
    }
  }

  void writeString(std::string_view sv) {
    // TODO escape more accurately?
    writeRaw("\"");

    for (char c : sv) {
      if (c == '"')
        writeRaw("\\\"");
      else if (c == '\\')
        writeRaw("\\\\");
      else if (c < ' ')
        writeRaw(format("\\u%04x", c));
      else if (c == '\n')
        writeRaw("\\n");
      else
        writeRaw(c);
    }

    writeRaw("\"");
  }

  void write(char c) { writeString(std::string_view(&c, 1)); }
  void write(int i) { writeRaw(std::to_string(i)); }
  void write(long i) { writeRaw(std::to_string(i)); }
  void write(long long i) { writeRaw(std::to_string(i)); }
  void write(unsigned int i) { writeRaw(std::to_string(i)); }
  void write(unsigned long i) { writeRaw(std::to_string(i)); }
  void write(unsigned long long i) { writeRaw(std::to_string(i)); }
  void write(std::nullptr_t) { writeRaw("null"); }
  void write(std::string_view str) { writeString(str); }
  void write(std::optional<AstName> name) {
    if (name)
      write(*name);
    else
      writeRaw("null");
  }
  void write(AstName name) { writeString(name.value ? name.value : ""); }
  void write(std::optional<AstArgumentName> name) {
    if (name)
      write(*name);
    else
      writeRaw("null");
  }
  void write(AstArgumentName name) {
    writeRaw("{");
    bool c = pushComma();
    writeType("AstArgumentName");
    write("name", name.first);
    write("location", name.second);
    popComma(c);
    writeRaw("}");
  }

  void write(const Position &position) {
    write(position.line);
    writeRaw(",");
    write(position.column);
  }

  void write(const Location &location) {
    writeRaw("\"");
    write(location.begin);
    writeRaw(" - ");
    write(location.end);
    writeRaw("\"");
  }

  void write(AstLocal *local) {
    writeRaw("{");
    bool c = pushComma();
    if (local->annotation != nullptr)
      write("luauType", local->annotation);
    else
      write("luauType", nullptr);
    write("name", local->name);
    writeType("AstLocal");
    write("location", local->location);
    popComma(c);
    writeRaw("}");
  }

  void writeNode(AstNode *node) { write("location", node->location); }

  template <typename F>
  void writeNode(AstNode *node, std::string_view name, F &&f) {
    writeRaw("{");
    bool c = pushComma();
    writeType(name);
    writeNode(node);
    f();
    popComma(c);
    writeRaw("}");
  }

  void write(AstNode *node) { node->visit(this); }

  void write(class AstExprGroup *node) {
    writeNode(node, "AstExprGroup", [&]() { write("expr", node->expr); });
  }

  void write(class AstExprConstantNil *node) {
    writeNode(node, "AstExprConstantNil", []() {});
  }

  void write(class AstExprConstantBool *node) {
    writeNode(node, "AstExprConstantBool",
              [&]() { write("value", node->value); });
  }

  void write(class AstExprConstantNumber *node) {
    writeNode(node, "AstExprConstantNumber",
              [&]() { write("value", node->value); });
  }

  void write(class AstExprConstantString *node) {
    writeNode(node, "AstExprConstantString",
              [&]() { write("value", node->value); });
  }

  void write(class AstExprLocal *node) {
    writeNode(node, "AstExprLocal", [&]() { write("local", node->local); });
  }

  void write(class AstExprGlobal *node) {
    writeNode(node, "AstExprGlobal", [&]() { write("global", node->name); });
  }

  void write(class AstExprVarargs *node) {
    writeNode(node, "AstExprVarargs", []() {});
  }

  template <typename T> void write(AstArray<T> arr) {
    writeRaw("[");
    bool comma = false;
    for (const auto &a : arr) {
      if (comma)
        writeRaw(",");
      else
        comma = true;

      write(a);
    }
    writeRaw("]");
  }

  void write(AstArray<char> arr) {
    write(std::string_view{arr.data, arr.size});
  }

#define PROP(prop) write(#prop, node->prop)

  void write(class AstExprCall *node) {
    writeNode(node, "AstExprCall", [&]() {
      PROP(func);
      PROP(args);
      PROP(self);
      PROP(argLocation);
    });
  }

  void write(class AstExprIndexName *node) {
    writeNode(node, "AstExprIndexName", [&]() {
      PROP(expr);
      PROP(index);
      PROP(indexLocation);
      PROP(op);
    });
  }

  void write(class AstExprIndexExpr *node) {
    writeNode(node, "AstExprIndexExpr", [&]() {
      PROP(expr);
      PROP(index);
    });
  }

  void write(class AstExprFunction *node) {
    writeNode(node, "AstExprFunction", [&]() {
      PROP(generics);
      PROP(genericPacks);
      if (node->self)
        PROP(self);
      PROP(args);
      if (node->returnAnnotation)
        PROP(returnAnnotation);
      PROP(vararg);
      PROP(varargLocation);
      if (node->varargAnnotation)
        PROP(varargAnnotation);

      PROP(body);
      PROP(functionDepth);
      PROP(debugname);
    });
  }

  void write(const std::optional<AstTypeList> &typeList) {
    if (typeList)
      write(*typeList);
    else
      writeRaw("null");
  }

  void write(const AstTypeList &typeList) {
    writeRaw("{");
    bool c = pushComma();
    writeType("AstTypeList");
    write("types", typeList.types);
    if (typeList.tailType)
      write("tailType", typeList.tailType);
    popComma(c);
    writeRaw("}");
  }

  void write(const AstGenericType &genericType) {
    writeRaw("{");
    bool c = pushComma();
    writeType("AstGenericType");
    write("name", genericType.name);
    if (genericType.defaultValue)
      write("luauType", genericType.defaultValue);
    popComma(c);
    writeRaw("}");
  }

  void write(const AstGenericTypePack &genericTypePack) {
    writeRaw("{");
    bool c = pushComma();
    writeType("AstGenericTypePack");
    write("name", genericTypePack.name);
    if (genericTypePack.defaultValue)
      write("luauType", genericTypePack.defaultValue);
    popComma(c);
    writeRaw("}");
  }

  void write(AstExprTable::Item::Kind kind) {
    switch (kind) {
    case AstExprTable::Item::List:
      return writeString("item");
    case AstExprTable::Item::Record:
      return writeString("record");
    case AstExprTable::Item::General:
      return writeString("general");
    }
  }

  void write(const AstExprTable::Item &item) {
    writeRaw("{");
    bool c = pushComma();
    writeType("AstExprTableItem");
    write("kind", item.kind);
    switch (item.kind) {
    case AstExprTable::Item::List:
      write("value", item.value);
      break;
    default:
      write("key", item.key);
      write("value", item.value);
      break;
    }
    popComma(c);
    writeRaw("}");
  }

  void write(class AstExprIfElse *node) {
    writeNode(node, "AstExprIfElse", [&]() {
      PROP(condition);
      PROP(hasThen);
      PROP(trueExpr);
      PROP(hasElse);
      PROP(falseExpr);
    });
  }

  void write(class AstExprInterpString *node) {
    writeNode(node, "AstExprInterpString", [&]() {
      PROP(strings);
      PROP(expressions);
    });
  }

  void write(class AstExprTable *node) {
    writeNode(node, "AstExprTable", [&]() { PROP(items); });
  }

  void write(AstExprUnary::Op op) {
    switch (op) {
    case AstExprUnary::Not:
      return writeString("Not");
    case AstExprUnary::Minus:
      return writeString("Minus");
    case AstExprUnary::Len:
      return writeString("Len");
    }
  }

  void write(class AstExprUnary *node) {
    writeNode(node, "AstExprUnary", [&]() {
      PROP(op);
      PROP(expr);
    });
  }

  void write(AstExprBinary::Op op) {
    switch (op) {
    case AstExprBinary::Add:
      return writeString("Add");
    case AstExprBinary::Sub:
      return writeString("Sub");
    case AstExprBinary::Mul:
      return writeString("Mul");
    case AstExprBinary::Div:
      return writeString("Div");
    case AstExprBinary::FloorDiv:
      return writeString("FloorDiv");
    case AstExprBinary::Mod:
      return writeString("Mod");
    case AstExprBinary::Pow:
      return writeString("Pow");
    case AstExprBinary::Concat:
      return writeString("Concat");
    case AstExprBinary::CompareNe:
      return writeString("CompareNe");
    case AstExprBinary::CompareEq:
      return writeString("CompareEq");
    case AstExprBinary::CompareLt:
      return writeString("CompareLt");
    case AstExprBinary::CompareLe:
      return writeString("CompareLe");
    case AstExprBinary::CompareGt:
      return writeString("CompareGt");
    case AstExprBinary::CompareGe:
      return writeString("CompareGe");
    case AstExprBinary::And:
      return writeString("And");
    case AstExprBinary::Or:
      return writeString("Or");
    default:
      LUAU_ASSERT(!"Unknown Op");
    }
  }

  void write(class AstExprBinary *node) {
    writeNode(node, "AstExprBinary", [&]() {
      PROP(op);
      PROP(left);
      PROP(right);
    });
  }

  void write(class AstExprTypeAssertion *node) {
    writeNode(node, "AstExprTypeAssertion", [&]() {
      PROP(expr);
      PROP(annotation);
    });
  }

  void write(class AstExprError *node) {
    writeNode(node, "AstExprError", [&]() {
      PROP(expressions);
      PROP(messageIndex);
    });
  }

  void write(class AstStatBlock *node) {
    writeNode(node, "AstStatBlock", [&]() {
      writeRaw(",\"hasEnd\":");
      write(node->hasEnd);
      writeRaw(",\"body\":[");
      bool comma = false;
      for (AstStat *stat : node->body) {
        if (comma)
          writeRaw(",");
        else
          comma = true;

        write(stat);
      }
      writeRaw("]");
    });
  }

  void write(class AstStatIf *node) {
    writeNode(node, "AstStatIf", [&]() {
      PROP(condition);
      PROP(thenbody);
      if (node->elsebody)
        PROP(elsebody);
      write("hasThen", node->thenLocation.has_value());
    });
  }

  void write(class AstStatWhile *node) {
    writeNode(node, "AstStatWhile", [&]() {
      PROP(condition);
      PROP(body);
      PROP(hasDo);
    });
  }

  void write(class AstStatRepeat *node) {
    writeNode(node, "AstStatRepeat", [&]() {
      PROP(condition);
      PROP(body);
    });
  }

  void write(class AstStatBreak *node) {
    writeNode(node, "AstStatBreak", []() {});
  }

  void write(class AstStatContinue *node) {
    writeNode(node, "AstStatContinue", []() {});
  }

  void write(class AstStatReturn *node) {
    writeNode(node, "AstStatReturn", [&]() { PROP(list); });
  }

  void write(class AstStatExpr *node) {
    writeNode(node, "AstStatExpr", [&]() { PROP(expr); });
  }

  void write(class AstStatLocal *node) {
    writeNode(node, "AstStatLocal", [&]() {
      PROP(vars);
      PROP(values);
    });
  }

  void write(class AstStatFor *node) {
    writeNode(node, "AstStatFor", [&]() {
      PROP(var);
      PROP(from);
      PROP(to);
      if (node->step)
        PROP(step);
      PROP(body);
      PROP(hasDo);
    });
  }

  void write(class AstStatForIn *node) {
    writeNode(node, "AstStatForIn", [&]() {
      PROP(vars);
      PROP(values);
      PROP(body);
      PROP(hasIn);
      PROP(hasDo);
    });
  }

  void write(class AstStatAssign *node) {
    writeNode(node, "AstStatAssign", [&]() {
      PROP(vars);
      PROP(values);
    });
  }

  void write(class AstStatCompoundAssign *node) {
    writeNode(node, "AstStatCompoundAssign", [&]() {
      PROP(op);
      PROP(var);
      PROP(value);
    });
  }

  void write(class AstStatFunction *node) {
    writeNode(node, "AstStatFunction", [&]() {
      PROP(name);
      PROP(func);
    });
  }

  void write(class AstStatLocalFunction *node) {
    writeNode(node, "AstStatLocalFunction", [&]() {
      PROP(name);
      PROP(func);
    });
  }

  void write(class AstStatTypeAlias *node) {
    writeNode(node, "AstStatTypeAlias", [&]() {
      PROP(name);
      PROP(generics);
      PROP(genericPacks);
      PROP(type);
      PROP(exported);
    });
  }

  void write(class AstStatDeclareFunction *node) {
    writeNode(node, "AstStatDeclareFunction", [&]() {
      // TODO: attributes
      PROP(name);

      if (FFlag::LuauDeclarationExtraPropData)
        PROP(nameLocation);

      PROP(params);

      if (FFlag::LuauDeclarationExtraPropData) {
        PROP(paramNames);
        PROP(vararg);
        PROP(varargLocation);
      }

      PROP(retTypes);
      PROP(generics);
      PROP(genericPacks);
    });
  }

  void write(class AstStatDeclareGlobal *node) {
    writeNode(node, "AstStatDeclareGlobal", [&]() {
      PROP(name);

      if (FFlag::LuauDeclarationExtraPropData)
        PROP(nameLocation);

      PROP(type);
    });
  }

  void write(const AstDeclaredClassProp &prop) {
    writeRaw("{");
    bool c = pushComma();
    write("name", prop.name);

    if (FFlag::LuauDeclarationExtraPropData)
      write("nameLocation", prop.nameLocation);

    writeType("AstDeclaredClassProp");
    write("luauType", prop.ty);

    if (FFlag::LuauDeclarationExtraPropData)
      write("location", prop.location);

    popComma(c);
    writeRaw("}");
  }

  void write(class AstStatDeclareClass *node) {
    writeNode(node, "AstStatDeclareClass", [&]() {
      PROP(name);
      if (node->superName)
        write("superName", *node->superName);
      PROP(props);
      PROP(indexer);
    });
  }

  void write(class AstStatError *node) {
    writeNode(node, "AstStatError", [&]() {
      PROP(expressions);
      PROP(statements);
    });
  }

  void write(struct AstTypeOrPack node) {
    if (node.type)
      write(node.type);
    else
      write(node.typePack);
  }

  void write(class AstTypeReference *node) {
    writeNode(node, "AstTypeReference", [&]() {
      if (node->prefix)
        PROP(prefix);
      if (node->prefixLocation)
        write("prefixLocation", *node->prefixLocation);
      PROP(name);
      PROP(nameLocation);
      PROP(parameters);
    });
  }

  void write(const AstTableProp &prop) {
    writeRaw("{");
    bool c = pushComma();

    write("name", prop.name);
    writeType("AstTableProp");
    write("location", prop.location);
    write("propType", prop.type);

    popComma(c);
    writeRaw("}");
  }

  void write(class AstTypeTable *node) {
    writeNode(node, "AstTypeTable", [&]() {
      PROP(props);
      PROP(indexer);
    });
  }

  void write(struct AstTableIndexer *indexer) {
    if (indexer) {
      writeRaw("{");
      bool c = pushComma();
      write("location", indexer->location);
      write("indexType", indexer->indexType);
      write("resultType", indexer->resultType);
      popComma(c);
      writeRaw("}");
    } else {
      writeRaw("null");
    }
  }

  void write(class AstTypeFunction *node) {
    writeNode(node, "AstTypeFunction", [&]() {
      PROP(generics);
      PROP(genericPacks);
      PROP(argTypes);
      PROP(argNames);
      PROP(returnTypes);
    });
  }

  void write(class AstTypeTypeof *node) {
    writeNode(node, "AstTypeTypeof", [&]() { PROP(expr); });
  }

  void write(class AstTypeUnion *node) {
    writeNode(node, "AstTypeUnion", [&]() { PROP(types); });
  }

  void write(class AstTypeIntersection *node) {
    writeNode(node, "AstTypeIntersection", [&]() { PROP(types); });
  }

  void write(class AstTypeError *node) {
    writeNode(node, "AstTypeError", [&]() {
      PROP(types);
      PROP(messageIndex);
    });
  }

  void write(class AstTypePackExplicit *node) {
    writeNode(node, "AstTypePackExplicit", [&]() { PROP(typeList); });
  }

  void write(class AstTypePackVariadic *node) {
    writeNode(node, "AstTypePackVariadic", [&]() { PROP(variadicType); });
  }

  void write(class AstTypePackGeneric *node) {
    writeNode(node, "AstTypePackGeneric", [&]() { PROP(genericName); });
  }

  bool visit(class AstTypeSingletonBool *node) override {
    writeNode(node, "AstTypeSingletonBool",
              [&]() { write("value", node->value); });
    return false;
  }

  bool visit(class AstTypeSingletonString *node) override {
    writeNode(node, "AstTypeSingletonString",
              [&]() { write("value", node->value); });
    return false;
  }

  bool visit(class AstExprGroup *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprConstantNil *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprConstantBool *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprConstantNumber *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprConstantString *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprIfElse *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprInterpString *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprLocal *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprGlobal *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprVarargs *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprCall *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprIndexName *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprIndexExpr *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprFunction *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprTable *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprUnary *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprBinary *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprTypeAssertion *node) override {
    write(node);
    return false;
  }

  bool visit(class AstExprError *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatBlock *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatIf *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatWhile *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatRepeat *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatBreak *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatContinue *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatReturn *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatExpr *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatLocal *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatFor *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatForIn *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatAssign *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatCompoundAssign *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatFunction *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatLocalFunction *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatTypeAlias *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatDeclareFunction *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatDeclareGlobal *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatDeclareClass *node) override {
    write(node);
    return false;
  }

  bool visit(class AstStatError *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeReference *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeTable *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeFunction *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeTypeof *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeUnion *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeIntersection *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypeError *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypePack *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypePackExplicit *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypePackVariadic *node) override {
    write(node);
    return false;
  }

  bool visit(class AstTypePackGeneric *node) override {
    write(node);
    return false;
  }

  void writeComments(std::vector<Comment> commentLocations) {
    bool commentComma = false;
    for (Comment comment : commentLocations) {
      if (commentComma) {
        writeRaw(",");
      } else {
        commentComma = true;
      }
      writeRaw("{");
      bool c = pushComma();
      switch (comment.type) {
      case Lexeme::Comment:
        writeType("Comment");
        break;
      case Lexeme::BlockComment:
        writeType("BlockComment");
        break;
      case Lexeme::BrokenComment:
        writeType("BrokenComment");
        break;
      default:
        break;
      }
      write("location", comment.location);
      popComma(c);
      writeRaw("}");
    }
  }
};

std::string toJson(AstNode *node) {
  AstJsonEncoder encoder;
  node->visit(&encoder);
  return encoder.str();
}

std::string toJson(AstNode *node,
                   const std::vector<Comment> &commentLocations) {
  AstJsonEncoder encoder;
  encoder.writeRaw(R"({"root":)");
  node->visit(&encoder);
  encoder.writeRaw(R"(,"commentLocations":[)");
  encoder.writeComments(commentLocations);
  encoder.writeRaw("]}");
  return encoder.str();
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/JsonEmitter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@ PACK.lua : not found, likely and std header
#include <string.h>

namespace Luau::Json {

static constexpr int CHUNK_SIZE = 1024;

ObjectEmitter::ObjectEmitter(NotNull<JsonEmitter> emitter)
    : emitter(emitter), finished(false) {
  comma = emitter->pushComma();
  emitter->writeRaw('{');
}

ObjectEmitter::~ObjectEmitter() { finish(); }

void ObjectEmitter::finish() {
  if (finished)
    return;

  emitter->writeRaw('}');
  emitter->popComma(comma);
  finished = true;
}

ArrayEmitter::ArrayEmitter(NotNull<JsonEmitter> emitter)
    : emitter(emitter), finished(false) {
  comma = emitter->pushComma();
  emitter->writeRaw('[');
}

ArrayEmitter::~ArrayEmitter() { finish(); }

void ArrayEmitter::finish() {
  if (finished)
    return;

  emitter->writeRaw(']');
  emitter->popComma(comma);
  finished = true;
}

JsonEmitter::JsonEmitter() { newChunk(); }

std::string JsonEmitter::str() { return join(chunks, ""); }

bool JsonEmitter::pushComma() {
  bool current = comma;
  comma = false;
  return current;
}

void JsonEmitter::popComma(bool c) { comma = c; }

void JsonEmitter::writeRaw(std::string_view sv) {
  if (sv.size() > CHUNK_SIZE) {
    chunks.emplace_back(sv);
    newChunk();
    return;
  }

  auto &chunk = chunks.back();
  if (chunk.size() + sv.size() < CHUNK_SIZE) {
    chunk.append(sv.data(), sv.size());
    return;
  }

  size_t prefix = CHUNK_SIZE - chunk.size();
  chunk.append(sv.data(), prefix);
  newChunk();

  chunks.back().append(sv.data() + prefix, sv.size() - prefix);
}

void JsonEmitter::writeRaw(char c) { writeRaw(std::string_view{&c, 1}); }

void write(JsonEmitter &emitter, bool b) {
  if (b)
    emitter.writeRaw("true");
  else
    emitter.writeRaw("false");
}

void write(JsonEmitter &emitter, double d) {
  emitter.writeRaw(std::to_string(d));
}

void write(JsonEmitter &emitter, int i) { emitter.writeRaw(std::to_string(i)); }

void write(JsonEmitter &emitter, long i) {
  emitter.writeRaw(std::to_string(i));
}

void write(JsonEmitter &emitter, long long i) {
  emitter.writeRaw(std::to_string(i));
}

void write(JsonEmitter &emitter, unsigned int i) {
  emitter.writeRaw(std::to_string(i));
}

void write(JsonEmitter &emitter, unsigned long i) {
  emitter.writeRaw(std::to_string(i));
}

void write(JsonEmitter &emitter, unsigned long long i) {
  emitter.writeRaw(std::to_string(i));
}

void write(JsonEmitter &emitter, std::string_view sv) {
  emitter.writeRaw('\"');

  for (char c : sv) {
    if (c == '"')
      emitter.writeRaw("\\\"");
    else if (c == '\\')
      emitter.writeRaw("\\\\");
    else if (c == '\n')
      emitter.writeRaw("\\n");
    else if (c < ' ')
      emitter.writeRaw(format("\\u%04x", c));
    else
      emitter.writeRaw(c);
  }

  emitter.writeRaw('\"');
}

void write(JsonEmitter &emitter, char c) {
  write(emitter, std::string_view{&c, 1});
}

void write(JsonEmitter &emitter, const char *str) {
  write(emitter, std::string_view{str, strlen(str)});
}

void write(JsonEmitter &emitter, const std::string &str) {
  write(emitter, std::string_view{str});
}

void write(JsonEmitter &emitter, std::nullptr_t) { emitter.writeRaw("null"); }

void write(JsonEmitter &emitter, std::nullopt_t) { emitter.writeRaw("null"); }

void JsonEmitter::writeComma() {
  if (comma)
    writeRaw(',');
  else
    comma = true;
}

ObjectEmitter JsonEmitter::writeObject() {
  return ObjectEmitter{NotNull(this)};
}

ArrayEmitter JsonEmitter::writeArray() { return ArrayEmitter{NotNull(this)}; }

void JsonEmitter::newChunk() {
  chunks.emplace_back();
  chunks.back().reserve(CHUNK_SIZE);
}

} // namespace Luau::Json

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Unifier.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

#include "luau_ast_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTINT(LuauTypeInferTypePackLoopLimit)
LUAU_FASTFLAG(LuauErrorRecoveryType)
LUAU_FASTFLAGVARIABLE(LuauInstantiateInSubtyping, false)
LUAU_FASTFLAGVARIABLE(LuauTransitiveSubtyping, false)
LUAU_FASTFLAG(LuauAlwaysCommitInferencesOfFunctionCalls)
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)
LUAU_FASTFLAGVARIABLE(LuauFixIndexerSubtypingOrdering, false)
LUAU_FASTFLAGVARIABLE(LuauUnifierShouldNotCopyError, false)
LUAU_FASTFLAGVARIABLE(LuauUnifierRecursionOnRestart, false)

namespace Luau {

struct PromoteTypeLevels final : TypeOnceVisitor {
  TxnLog &log;
  const TypeArena *typeArena = nullptr;
  TypeLevel minLevel;

  Scope *outerScope = nullptr;
  bool useScopes;

  PromoteTypeLevels(TxnLog &log, const TypeArena *typeArena, TypeLevel minLevel,
                    Scope *outerScope, bool useScopes)
      : log(log), typeArena(typeArena), minLevel(minLevel),
        outerScope(outerScope), useScopes(useScopes) {}

  template <typename TID, typename T> void promote(TID ty, T *t) {
    if (useScopes && !t)
      return;

    LUAU_ASSERT(t);

    if (useScopes) {
      if (subsumesStrict(outerScope, t->scope))
        log.changeScope(ty, NotNull{outerScope});
    } else {
      if (minLevel.subsumesStrict(t->level)) {
        log.changeLevel(ty, minLevel);
      }
    }
  }

  bool visit(TypeId ty) override {
    // Type levels of types from other modules are already global, so we don't
    // need to promote anything inside
    if (ty->owningArena != typeArena)
      return false;

    return true;
  }

  bool visit(TypePackId tp) override {
    // Type levels of types from other modules are already global, so we don't
    // need to promote anything inside
    if (tp->owningArena != typeArena)
      return false;

    return true;
  }

  bool visit(TypeId ty, const FreeType &) override {
    // Surprise, it's actually a BoundType that hasn't been committed yet.
    // Calling getMutable on this will trigger an assertion.
    if (!log.is<FreeType>(ty))
      return true;

    promote(ty, log.getMutable<FreeType>(ty));
    return true;
  }

  bool visit(TypeId ty, const FunctionType &) override {
    // Type levels of types from other modules are already global, so we don't
    // need to promote anything inside
    if (ty->owningArena != typeArena)
      return false;

    // Surprise, it's actually a BoundTypePack that hasn't been committed yet.
    // Calling getMutable on this will trigger an assertion.
    if (!log.is<FunctionType>(ty))
      return true;

    promote(ty, log.getMutable<FunctionType>(ty));
    return true;
  }

  bool visit(TypeId ty, const TableType &ttv) override {
    // Type levels of types from other modules are already global, so we don't
    // need to promote anything inside
    if (ty->owningArena != typeArena)
      return false;

    if (ttv.state != TableState::Free && ttv.state != TableState::Generic)
      return true;

    // Surprise, it's actually a BoundTypePack that hasn't been committed yet.
    // Calling getMutable on this will trigger an assertion.
    if (!log.is<TableType>(ty))
      return true;

    promote(ty, log.getMutable<TableType>(ty));
    return true;
  }

  bool visit(TypePackId tp, const FreeTypePack &) override {
    // Surprise, it's actually a BoundTypePack that hasn't been committed yet.
    // Calling getMutable on this will trigger an assertion.
    if (!log.is<FreeTypePack>(tp))
      return true;

    promote(tp, log.getMutable<FreeTypePack>(tp));
    return true;
  }
};

static void promoteTypeLevels(TxnLog &log, const TypeArena *typeArena,
                              TypeLevel minLevel, Scope *outerScope,
                              bool useScopes, TypeId ty) {
  // Type levels of types from other modules are already global, so we don't
  // need to promote anything inside
  if (ty->owningArena != typeArena)
    return;

  PromoteTypeLevels ptl{log, typeArena, minLevel, outerScope, useScopes};
  ptl.traverse(ty);
}

void promoteTypeLevels(TxnLog &log, const TypeArena *typeArena,
                       TypeLevel minLevel, Scope *outerScope, bool useScopes,
                       TypePackId tp) {
  // Type levels of types from other modules are already global, so we don't
  // need to promote anything inside
  if (tp->owningArena != typeArena)
    return;

  PromoteTypeLevels ptl{log, typeArena, minLevel, outerScope, useScopes};
  ptl.traverse(tp);
}

struct SkipCacheForType final : TypeOnceVisitor {
  SkipCacheForType(const DenseHashMap<TypeId, bool> &skipCacheForType,
                   const TypeArena *typeArena)
      : skipCacheForType(skipCacheForType), typeArena(typeArena) {}

  bool visit(TypeId, const FreeType &) override {
    result = true;
    return false;
  }

  bool visit(TypeId, const BoundType &) override {
    result = true;
    return false;
  }

  bool visit(TypeId, const GenericType &) override {
    result = true;
    return false;
  }

  bool visit(TypeId, const BlockedType &) override {
    result = true;
    return false;
  }

  bool visit(TypeId, const PendingExpansionType &) override {
    result = true;
    return false;
  }

  bool visit(TypeId ty, const TableType &) override {
    // Types from other modules don't contain mutable elements and are ok to
    // cache
    if (ty->owningArena != typeArena)
      return false;

    TableType &ttv = *getMutable<TableType>(ty);

    if (ttv.boundTo) {
      result = true;
      return false;
    }

    if (ttv.state != TableState::Sealed) {
      result = true;
      return false;
    }

    return true;
  }

  bool visit(TypeId ty) override {
    // Types from other modules don't contain mutable elements and are ok to
    // cache
    if (ty->owningArena != typeArena)
      return false;

    const bool *prev = skipCacheForType.find(ty);

    if (prev && *prev) {
      result = true;
      return false;
    }

    return true;
  }

  bool visit(TypePackId tp) override {
    // Types from other modules don't contain mutable elements and are ok to
    // cache
    if (tp->owningArena != typeArena)
      return false;

    return true;
  }

  bool visit(TypePackId tp, const FreeTypePack &) override {
    result = true;
    return false;
  }

  bool visit(TypePackId tp, const BoundTypePack &) override {
    result = true;
    return false;
  }

  bool visit(TypePackId tp, const GenericTypePack &) override {
    result = true;
    return false;
  }

  bool visit(TypePackId tp, const BlockedTypePack &) override {
    result = true;
    return false;
  }

  const DenseHashMap<TypeId, bool> &skipCacheForType;
  const TypeArena *typeArena = nullptr;
  bool result = false;
};

bool Widen::isDirty(TypeId ty) { return log->is<SingletonType>(ty); }

bool Widen::isDirty(TypePackId) { return false; }

TypeId Widen::clean(TypeId ty) {
  LUAU_ASSERT(isDirty(ty));
  auto stv = log->getMutable<SingletonType>(ty);
  LUAU_ASSERT(stv);

  if (get<StringSingleton>(stv))
    return builtinTypes->stringType;
  else {
    // If this assert trips, it's likely we now have number singletons.
    LUAU_ASSERT(get<BooleanSingleton>(stv));
    return builtinTypes->booleanType;
  }
}

TypePackId Widen::clean(TypePackId) {
  throw InternalCompilerError("Widen attempted to clean a dirty type pack?");
}

bool Widen::ignoreChildren(TypeId ty) {
  if (get<ClassType>(ty))
    return true;

  return !log->is<UnionType>(ty);
}

TypeId Widen::operator()(TypeId ty) { return substitute(ty).value_or(ty); }

TypePackId Widen::operator()(TypePackId tp) {
  return substitute(tp).value_or(tp);
}

std::optional<TypeError> hasUnificationTooComplex(const ErrorVec &errors) {
  auto isUnificationTooComplex = [](const TypeError &te) {
    return nullptr != get<UnificationTooComplex>(te);
  };

  auto it = std::find_if(errors.begin(), errors.end(), isUnificationTooComplex);
  if (it == errors.end())
    return std::nullopt;
  else
    return *it;
}

std::optional<TypeError> hasCountMismatch(const ErrorVec &errors) {
  auto isCountMismatch = [](const TypeError &te) {
    return nullptr != get<CountMismatch>(te);
  };

  auto it = std::find_if(errors.begin(), errors.end(), isCountMismatch);
  if (it == errors.end())
    return std::nullopt;
  else
    return *it;
}

// Used for tagged union matching heuristic, returns first singleton type field
static std::optional<std::pair<Luau::Name, const SingletonType *>>
getTableMatchTag(TypeId type) {
  if (auto ttv = getTableType(type)) {
    for (auto &&[name, prop] : ttv->props) {
      if (auto sing = get<SingletonType>(follow(prop.type())))
        return {{name, sing}};
    }
  }

  return std::nullopt;
}

template <typename TY_A, typename TY_B>
static bool subsumes(bool useScopes, TY_A *left, TY_B *right) {
  if (useScopes)
    return subsumes(left->scope, right->scope);
  else
    return left->level.subsumes(right->level);
}

TypeMismatch::Context Unifier::mismatchContext() {
  switch (variance) {
  case Covariant:
    return TypeMismatch::CovariantContext;
  case Invariant:
    return TypeMismatch::InvariantContext;
  default:
    LUAU_ASSERT(false); // This codepath should be unreachable.
    return TypeMismatch::CovariantContext;
  }
}

Unifier::Unifier(NotNull<Normalizer> normalizer, NotNull<Scope> scope,
                 const Location &location, Variance variance, TxnLog *parentLog)
    : types(normalizer->arena), builtinTypes(normalizer->builtinTypes),
      normalizer(normalizer), scope(scope), log(parentLog), location(location),
      variance(variance), sharedState(*normalizer->sharedState) {
  LUAU_ASSERT(sharedState.iceHandler);

  // Unifier is not usable when this flag is enabled! Please consider using
  // Subtyping instead.
  LUAU_ASSERT(!FFlag::DebugLuauDeferredConstraintResolution);
}

void Unifier::tryUnify(TypeId subTy, TypeId superTy, bool isFunctionCall,
                       bool isIntersection,
                       const LiteralProperties *literalProperties) {
  sharedState.counters.iterationCount = 0;

  tryUnify_(subTy, superTy, isFunctionCall, isIntersection, literalProperties);
}

static bool isBlocked(const TxnLog &log, TypeId ty) {
  ty = log.follow(ty);
  return get<BlockedType>(ty) || get<PendingExpansionType>(ty);
}

static bool isBlocked(const TxnLog &log, TypePackId tp) {
  tp = log.follow(tp);
  return get<BlockedTypePack>(tp);
}

void Unifier::tryUnify_(TypeId subTy, TypeId superTy, bool isFunctionCall,
                        bool isIntersection,
                        const LiteralProperties *literalProperties) {
  RecursionLimiter _ra(&sharedState.counters.recursionCount,
                       sharedState.counters.recursionLimit);

  ++sharedState.counters.iterationCount;

  if (sharedState.counters.iterationLimit > 0 &&
      sharedState.counters.iterationLimit <
          sharedState.counters.iterationCount) {
    reportError(location, UnificationTooComplex{});
    return;
  }

  superTy = log.follow(superTy);
  subTy = log.follow(subTy);

  if (superTy == subTy)
    return;

  if (isBlocked(log, subTy) && isBlocked(log, superTy)) {
    blockedTypes.push_back(subTy);
    blockedTypes.push_back(superTy);
  } else if (isBlocked(log, subTy))
    blockedTypes.push_back(subTy);
  else if (isBlocked(log, superTy))
    blockedTypes.push_back(superTy);

  if (log.get<TypeFunctionInstanceType>(superTy))
    ice("Unexpected TypeFunctionInstanceType superTy");

  if (log.get<TypeFunctionInstanceType>(subTy))
    ice("Unexpected TypeFunctionInstanceType subTy");

  auto superFree = log.getMutable<FreeType>(superTy);
  auto subFree = log.getMutable<FreeType>(subTy);

  if (superFree && subFree && subsumes(useNewSolver, superFree, subFree)) {
    if (!occursCheck(subTy, superTy, /* reversed = */ false))
      log.replace(subTy, BoundType(superTy));

    return;
  } else if (superFree && subFree) {
    if (!occursCheck(superTy, subTy, /* reversed = */ true)) {
      if (subsumes(useNewSolver, superFree, subFree)) {
        log.changeLevel(subTy, superFree->level);
      }

      log.replace(superTy, BoundType(subTy));
    }

    return;
  } else if (superFree) {
    // Unification can't change the level of a generic.
    auto subGeneric = log.getMutable<GenericType>(subTy);
    if (subGeneric && !subsumes(useNewSolver, subGeneric, superFree)) {
      // TODO: a more informative error message? CLI-39912
      reportError(location, GenericError{"Generic subtype escaping scope"});
      return;
    }

    if (!occursCheck(superTy, subTy, /* reversed = */ true)) {
      promoteTypeLevels(log, types, superFree->level, superFree->scope,
                        useNewSolver, subTy);

      Widen widen{types, builtinTypes};
      log.replace(superTy, BoundType(widen(subTy)));
    }

    return;
  } else if (subFree) {
    // Normally, if the subtype is free, it should not be bound to any, unknown,
    // or error types. But for bug compatibility, we'll only apply this rule to
    // unknown. Doing this will silence cascading type errors.
    if (log.get<UnknownType>(superTy))
      return;

    // Unification can't change the level of a generic.
    auto superGeneric = log.getMutable<GenericType>(superTy);
    if (superGeneric && !subsumes(useNewSolver, superGeneric, subFree)) {
      // TODO: a more informative error message? CLI-39912
      reportError(location, GenericError{"Generic supertype escaping scope"});
      return;
    }

    if (!occursCheck(subTy, superTy, /* reversed = */ false)) {
      promoteTypeLevels(log, types, subFree->level, subFree->scope,
                        useNewSolver, superTy);
      log.replace(subTy, BoundType(superTy));
    }

    return;
  }

  if (hideousFixMeGenericsAreActuallyFree) {
    auto superGeneric = log.getMutable<GenericType>(superTy);
    auto subGeneric = log.getMutable<GenericType>(subTy);

    if (superGeneric && subGeneric &&
        subsumes(useNewSolver, superGeneric, subGeneric)) {
      if (!occursCheck(subTy, superTy, /* reversed = */ false))
        log.replace(subTy, BoundType(superTy));

      return;
    } else if (superGeneric && subGeneric) {
      if (!occursCheck(superTy, subTy, /* reversed = */ true))
        log.replace(superTy, BoundType(subTy));

      return;
    } else if (superGeneric) {
      if (!occursCheck(superTy, subTy, /* reversed = */ true)) {
        Widen widen{types, builtinTypes};
        log.replace(superTy, BoundType(widen(subTy)));
      }

      return;
    } else if (subGeneric) {
      // Normally, if the subtype is free, it should not be bound to any,
      // unknown, or error types. But for bug compatibility, we'll only apply
      // this rule to unknown. Doing this will silence cascading type errors.
      if (log.get<UnknownType>(superTy))
        return;

      if (!occursCheck(subTy, superTy, /* reversed = */ false))
        log.replace(subTy, BoundType(superTy));

      return;
    }
  }

  if (log.get<AnyType>(superTy))
    return tryUnifyWithAny(subTy, builtinTypes->anyType);

  if (log.get<AnyType>(subTy)) {
    if (normalize) {
      // TODO: there are probably cheaper ways to check if any <: T.
      std::shared_ptr<const NormalizedType> superNorm =
          normalizer->normalize(superTy);

      if (!superNorm)
        return reportError(location, NormalizationTooComplex{});

      if (!log.get<AnyType>(superNorm->tops))
        failure = true;
    } else
      failure = true;
    return tryUnifyWithAny(superTy, builtinTypes->anyType);
  }

  if (log.get<NeverType>(subTy))
    return tryUnifyWithAny(superTy, builtinTypes->neverType);

  auto &cache = sharedState.cachedUnify;

  // What if the types are immutable and we proved their relation before
  bool cacheEnabled =
      !isFunctionCall && !isIntersection && variance == Invariant;

  if (cacheEnabled) {
    if (cache.contains({subTy, superTy}))
      return;

    if (auto error = sharedState.cachedUnifyError.find({subTy, superTy})) {
      reportError(location, *error);
      return;
    }
  }

  // If we have seen this pair of types before, we are currently recursing into
  // cyclic types. Here, we assume that the types unify.  If they do not, we
  // will find out as we roll back the stack.

  if (log.haveSeen(superTy, subTy))
    return;

  log.pushSeen(superTy, subTy);

  size_t errorCount = errors.size();

  if (const UnionType *subUnion = log.getMutable<UnionType>(subTy)) {
    tryUnifyUnionWithType(subTy, subUnion, superTy);
  } else if (const IntersectionType *uv =
                 log.getMutable<IntersectionType>(superTy)) {
    tryUnifyTypeWithIntersection(subTy, superTy, uv);
  } else if (const UnionType *uv = log.getMutable<UnionType>(superTy)) {
    tryUnifyTypeWithUnion(subTy, superTy, uv, cacheEnabled, isFunctionCall);
  } else if (const IntersectionType *uv =
                 log.getMutable<IntersectionType>(subTy)) {
    tryUnifyIntersectionWithType(subTy, uv, superTy, cacheEnabled,
                                 isFunctionCall);
  } else if (log.get<AnyType>(subTy)) {
    tryUnifyWithAny(superTy, builtinTypes->unknownType);
    failure = true;
  } else if (log.get<ErrorType>(subTy) && log.get<ErrorType>(superTy)) {
    // error <: error
  } else if (log.get<ErrorType>(superTy)) {
    tryUnifyWithAny(subTy, builtinTypes->errorType);
    failure = true;
  } else if (log.get<ErrorType>(subTy)) {
    tryUnifyWithAny(superTy, builtinTypes->errorType);
    failure = true;
  } else if (log.get<UnknownType>(superTy)) {
    // At this point, all the supertypes of `error` have been handled,
    // and if `error </: T` then `T <: unknown`.
    tryUnifyWithAny(subTy, builtinTypes->unknownType);
  } else if (log.get<UnknownType>(superTy)) {
    tryUnifyWithAny(subTy, builtinTypes->unknownType);
  } else if (log.getMutable<PrimitiveType>(superTy) &&
             log.getMutable<PrimitiveType>(subTy))
    tryUnifyPrimitives(subTy, superTy);

  else if ((log.getMutable<PrimitiveType>(superTy) ||
            log.getMutable<SingletonType>(superTy)) &&
           log.getMutable<SingletonType>(subTy))
    tryUnifySingletons(subTy, superTy);

  else if (auto ptv = get<PrimitiveType>(superTy);
           ptv && ptv->type == PrimitiveType::Function &&
           get<FunctionType>(subTy)) {
    // Ok.  Do nothing.  forall functions F, F <: function
  }

  else if (isPrim(superTy, PrimitiveType::Table) &&
           (get<TableType>(subTy) || get<MetatableType>(subTy))) {
    // Ok, do nothing: forall tables T, T <: table
  }

  else if (log.getMutable<FunctionType>(superTy) &&
           log.getMutable<FunctionType>(subTy))
    tryUnifyFunctions(subTy, superTy, isFunctionCall);

  else if (auto table = log.get<PrimitiveType>(superTy);
           table && table->type == PrimitiveType::Table)
    tryUnify(subTy, builtinTypes->emptyTableType, isFunctionCall,
             isIntersection);
  else if (auto table = log.get<PrimitiveType>(subTy);
           table && table->type == PrimitiveType::Table)
    tryUnify(builtinTypes->emptyTableType, superTy, isFunctionCall,
             isIntersection);

  else if (log.getMutable<TableType>(superTy) &&
           log.getMutable<TableType>(subTy)) {
    tryUnifyTables(subTy, superTy, isIntersection, literalProperties);
  } else if (log.get<TableType>(superTy) &&
             (log.get<PrimitiveType>(subTy) || log.get<SingletonType>(subTy))) {
    tryUnifyScalarShape(subTy, superTy, /*reversed*/ false);
  } else if (log.get<TableType>(subTy) && (log.get<PrimitiveType>(superTy) ||
                                           log.get<SingletonType>(superTy))) {
    tryUnifyScalarShape(subTy, superTy, /*reversed*/ true);
  }

  // tryUnifyWithMetatable assumes its first argument is a MetatableType. The
  // check is otherwise symmetrical.
  else if (log.getMutable<MetatableType>(superTy))
    tryUnifyWithMetatable(subTy, superTy, /*reversed*/ false);
  else if (log.getMutable<MetatableType>(subTy))
    tryUnifyWithMetatable(superTy, subTy, /*reversed*/ true);

  else if (log.getMutable<ClassType>(superTy))
    tryUnifyWithClass(subTy, superTy, /*reversed*/ false);

  // Unification of nonclasses with classes is almost, but not quite
  // symmetrical. The order in which we perform this test is significant in the
  // case that both types are classes.
  else if (log.getMutable<ClassType>(subTy))
    tryUnifyWithClass(subTy, superTy, /*reversed*/ true);

  else if (log.get<NegationType>(superTy) || log.get<NegationType>(subTy))
    tryUnifyNegations(subTy, superTy);

  // If the normalizer hits resource limits, we can't show it's uninhabited, so,
  // we should error.
  else if (checkInhabited &&
           normalizer->isInhabited(subTy) == NormalizationResult::False) {
  } else
    reportError(location, TypeMismatch{superTy, subTy, mismatchContext()});

  if (cacheEnabled)
    cacheResult(subTy, superTy, errorCount);

  log.popSeen(superTy, subTy);
}

void Unifier::tryUnifyUnionWithType(TypeId subTy, const UnionType *subUnion,
                                    TypeId superTy) {
  // A | B <: T if and only if A <: T and B <: T
  bool failed = false;
  bool errorsSuppressed = true;
  std::optional<TypeError> unificationTooComplex;
  std::optional<TypeError> firstFailedOption;

  std::vector<TxnLog> logs;

  for (TypeId type : subUnion->options) {
    Unifier innerState = makeChildUnifier();
    innerState.tryUnify_(type, superTy);

    if (useNewSolver)
      logs.push_back(std::move(innerState.log));

    if (auto e = hasUnificationTooComplex(innerState.errors))
      unificationTooComplex = e;
    else if (innerState.failure) {
      // If errors were suppressed, we store the log up, so we can commit it if
      // no other option succeeds.
      if (innerState.errors.empty())
        logs.push_back(std::move(innerState.log));
      // 'nil' option is skipped from extended report because we present the
      // type in a special way - 'T?'
      else if (!firstFailedOption && !isNil(type))
        firstFailedOption = {innerState.errors.front()};

      failed = true;
      errorsSuppressed &= innerState.errors.empty();
    }
  }

  if (FFlag::LuauAlwaysCommitInferencesOfFunctionCalls)
    log.concatAsUnion(combineLogsIntoUnion(std::move(logs)), NotNull{types});
  else {
    // even if A | B <: T fails, we want to bind some options of T with A | B
    // iff A | B was a subtype of that option.
    auto tryBind = [this, subTy](TypeId superOption) {
      superOption = log.follow(superOption);

      // just skip if the superOption is not free-ish.
      auto ttv = log.getMutable<TableType>(superOption);
      if (!log.is<FreeType>(superOption) &&
          (!ttv || ttv->state != TableState::Free))
        return;

      // If superOption is already present in subTy, do nothing.  Nothing new
      // has been learned, but the subtype test is successful.
      if (auto subUnion = get<UnionType>(subTy)) {
        if (end(subUnion) !=
            std::find(begin(subUnion), end(subUnion), superOption))
          return;
      }

      // Since we have already checked if S <: T, checking it again will not
      // queue up the type for replacement. So we'll have to do it ourselves. We
      // assume they unified cleanly if they are still in the seen set.
      if (log.haveSeen(subTy, superOption)) {
        // TODO: would it be nice for TxnLog::replace to do this?
        if (log.is<TableType>(superOption))
          log.bindTable(superOption, subTy);
        else
          log.replace(superOption, *subTy);
      }
    };

    if (auto superUnion = log.getMutable<UnionType>(superTy)) {
      for (TypeId ty : superUnion)
        tryBind(ty);
    } else
      tryBind(superTy);
  }

  if (unificationTooComplex)
    reportError(*unificationTooComplex);
  else if (failed) {
    if (firstFailedOption)
      reportError(location,
                  TypeMismatch{superTy, subTy,
                               "Not all union options are compatible.",
                               *firstFailedOption, mismatchContext()});
    else if (!errorsSuppressed)
      reportError(location, TypeMismatch{superTy, subTy, mismatchContext()});
    failure = true;
  }
}

void Unifier::tryUnifyTypeWithUnion(TypeId subTy, TypeId superTy,
                                    const UnionType *uv, bool cacheEnabled,
                                    bool isFunctionCall) {
  // T <: A | B if T <: A or T <: B
  bool found = false;
  bool errorsSuppressed = false;
  std::optional<TypeError> unificationTooComplex;

  size_t failedOptionCount = 0;
  std::optional<TypeError> failedOption;

  bool foundHeuristic = false;
  size_t startIndex = 0;

  if (const std::string *subName = getName(subTy)) {
    for (size_t i = 0; i < uv->options.size(); ++i) {
      const std::string *optionName = getName(uv->options[i]);
      if (optionName && *optionName == *subName) {
        foundHeuristic = true;
        startIndex = i;
        break;
      }
    }
  }

  if (auto subMatchTag = getTableMatchTag(subTy)) {
    for (size_t i = 0; i < uv->options.size(); ++i) {
      auto optionMatchTag = getTableMatchTag(uv->options[i]);
      if (optionMatchTag && optionMatchTag->first == subMatchTag->first &&
          *optionMatchTag->second == *subMatchTag->second) {
        foundHeuristic = true;
        startIndex = i;
        break;
      }
    }
  }

  if (!foundHeuristic) {
    for (size_t i = 0; i < uv->options.size(); ++i) {
      TypeId type = uv->options[i];

      if (subTy == type) {
        foundHeuristic = true;
        startIndex = i;
        break;
      }
    }
  }

  if (!foundHeuristic && cacheEnabled) {
    auto &cache = sharedState.cachedUnify;

    for (size_t i = 0; i < uv->options.size(); ++i) {
      TypeId type = uv->options[i];

      if (cache.contains({subTy, type})) {
        startIndex = i;
        break;
      }
    }
  }

  std::vector<TxnLog> logs;

  for (size_t i = 0; i < uv->options.size(); ++i) {
    TypeId type = uv->options[(i + startIndex) % uv->options.size()];
    Unifier innerState = makeChildUnifier();
    innerState.normalize = false;
    innerState.tryUnify_(subTy, type, isFunctionCall);

    if (!innerState.failure) {
      found = true;
      if (useNewSolver)
        logs.push_back(std::move(innerState.log));
      else {
        log.concat(std::move(innerState.log));
        break;
      }
    } else if (innerState.errors.empty()) {
      errorsSuppressed = true;
    } else if (auto e = hasUnificationTooComplex(innerState.errors)) {
      unificationTooComplex = e;
    } else if (!isNil(type)) {
      failedOptionCount++;

      if (!failedOption)
        failedOption = {innerState.errors.front()};
    }
  }

  if (useNewSolver)
    log.concatAsUnion(combineLogsIntoUnion(std::move(logs)), NotNull{types});

  if (unificationTooComplex) {
    reportError(*unificationTooComplex);
  } else if (!found && normalize) {
    // It is possible that T <: A | B even though T </: A and T </:B
    // for example boolean <: true | false.
    // We deal with this by type normalization.
    Unifier innerState = makeChildUnifier();

    std::shared_ptr<const NormalizedType> subNorm =
        normalizer->normalize(subTy);
    std::shared_ptr<const NormalizedType> superNorm =
        normalizer->normalize(superTy);
    if (!subNorm || !superNorm)
      return reportError(location, NormalizationTooComplex{});
    else if ((failedOptionCount == 1 || foundHeuristic) && failedOption)
      innerState.tryUnifyNormalizedTypes(
          subTy, superTy, *subNorm, *superNorm,
          "None of the union options are compatible. For example:",
          *failedOption);
    else
      innerState.tryUnifyNormalizedTypes(
          subTy, superTy, *subNorm, *superNorm,
          "none of the union options are compatible");

    if (!innerState.failure)
      log.concat(std::move(innerState.log));
    else if (errorsSuppressed || innerState.errors.empty())
      failure = true;
    else
      reportError(std::move(innerState.errors.front()));
  } else if (!found && normalize) {
    // It is possible that T <: A | B even though T </: A and T </:B
    // for example boolean <: true | false.
    // We deal with this by type normalization.
    std::shared_ptr<const NormalizedType> subNorm =
        normalizer->normalize(subTy);
    std::shared_ptr<const NormalizedType> superNorm =
        normalizer->normalize(superTy);
    if (!subNorm || !superNorm)
      reportError(location, NormalizationTooComplex{});
    else if ((failedOptionCount == 1 || foundHeuristic) && failedOption)
      tryUnifyNormalizedTypes(
          subTy, superTy, *subNorm, *superNorm,
          "None of the union options are compatible. For example:",
          *failedOption);
    else
      tryUnifyNormalizedTypes(subTy, superTy, *subNorm, *superNorm,
                              "none of the union options are compatible");
  } else if (!found) {
    if (errorsSuppressed)
      failure = true;
    else if ((failedOptionCount == 1 || foundHeuristic) && failedOption)
      reportError(
          location,
          TypeMismatch{superTy, subTy,
                       "None of the union options are compatible. For example:",
                       *failedOption, mismatchContext()});
    else
      reportError(location,
                  TypeMismatch{superTy, subTy,
                               "none of the union options are compatible",
                               mismatchContext()});
  }
}

void Unifier::tryUnifyTypeWithIntersection(TypeId subTy, TypeId superTy,
                                           const IntersectionType *uv) {
  std::optional<TypeError> unificationTooComplex;
  std::optional<TypeError> firstFailedOption;

  std::vector<TxnLog> logs;

  // T <: A & B if and only if  T <: A and T <: B
  for (TypeId type : uv->parts) {
    Unifier innerState = makeChildUnifier();
    innerState.tryUnify_(subTy, type, /*isFunctionCall*/ false,
                         /*isIntersection*/ true);

    if (auto e = hasUnificationTooComplex(innerState.errors))
      unificationTooComplex = e;
    else if (!innerState.errors.empty()) {
      if (!firstFailedOption)
        firstFailedOption = {innerState.errors.front()};
    }

    if (useNewSolver)
      logs.push_back(std::move(innerState.log));
    else
      log.concat(std::move(innerState.log));
    failure |= innerState.failure;
  }

  if (useNewSolver)
    log.concat(combineLogsIntoIntersection(std::move(logs)));

  if (unificationTooComplex)
    reportError(*unificationTooComplex);
  else if (firstFailedOption)
    reportError(location,
                TypeMismatch{superTy, subTy,
                             "Not all intersection parts are compatible.",
                             *firstFailedOption, mismatchContext()});
}

struct NegationTypeFinder : TypeOnceVisitor {
  bool found = false;

  bool visit(TypeId ty) override { return !found; }

  bool visit(TypeId ty, const NegationType &) override {
    found = true;
    return !found;
  }
};

void Unifier::tryUnifyIntersectionWithType(TypeId subTy,
                                           const IntersectionType *uv,
                                           TypeId superTy, bool cacheEnabled,
                                           bool isFunctionCall) {
  // A & B <: T if A <: T or B <: T
  bool found = false;
  bool errorsSuppressed = false;
  std::optional<TypeError> unificationTooComplex;

  size_t startIndex = 0;

  if (cacheEnabled) {
    auto &cache = sharedState.cachedUnify;

    for (size_t i = 0; i < uv->parts.size(); ++i) {
      TypeId type = uv->parts[i];

      if (cache.contains({type, superTy})) {
        startIndex = i;
        break;
      }
    }
  }

  if (useNewSolver && normalize) {
    // Sometimes a negation type is inside one of the types, e.g. { p: number }
    // & { p: ~number }.
    NegationTypeFinder finder;
    finder.traverse(subTy);

    if (finder.found) {
      // It is possible that A & B <: T even though A </: T and B </: T
      // for example (string?) & ~nil <: string.
      // We deal with this by type normalization.
      std::shared_ptr<const NormalizedType> subNorm =
          normalizer->normalize(subTy);
      std::shared_ptr<const NormalizedType> superNorm =
          normalizer->normalize(superTy);
      if (subNorm && superNorm)
        tryUnifyNormalizedTypes(
            subTy, superTy, *subNorm, *superNorm,
            "none of the intersection parts are compatible");
      else
        reportError(location, NormalizationTooComplex{});

      return;
    }
  }

  std::vector<TxnLog> logs;

  for (size_t i = 0; i < uv->parts.size(); ++i) {
    TypeId type = uv->parts[(i + startIndex) % uv->parts.size()];
    Unifier innerState = makeChildUnifier();
    innerState.normalize = false;
    innerState.tryUnify_(type, superTy, isFunctionCall);

    // TODO: This sets errorSuppressed to true if any of the parts is
    // error-suppressing, in paricular any & T is error-suppressing. Really,
    // errorSuppressed should be true if all of the parts are error-suppressing,
    // but that fails to typecheck lua-apps.
    if (innerState.errors.empty()) {
      found = true;
      errorsSuppressed = innerState.failure;
      if (useNewSolver || innerState.failure)
        logs.push_back(std::move(innerState.log));
      else {
        errorsSuppressed = false;
        log.concat(std::move(innerState.log));
        break;
      }
    } else if (auto e = hasUnificationTooComplex(innerState.errors)) {
      unificationTooComplex = e;
    }
  }

  if (useNewSolver)
    log.concat(combineLogsIntoIntersection(std::move(logs)));
  else if (errorsSuppressed)
    log.concat(std::move(logs.front()));

  if (unificationTooComplex)
    reportError(*unificationTooComplex);
  else if (!found && normalize) {
    // It is possible that A & B <: T even though A </: T and B </: T
    // for example string? & number? <: nil.
    // We deal with this by type normalization.

    std::shared_ptr<const NormalizedType> subNorm =
        normalizer->normalize(subTy);
    std::shared_ptr<const NormalizedType> superNorm =
        normalizer->normalize(superTy);
    if (subNorm && superNorm)
      tryUnifyNormalizedTypes(subTy, superTy, *subNorm, *superNorm,
                              "none of the intersection parts are compatible");
    else
      reportError(location, NormalizationTooComplex{});
  } else if (!found) {
    reportError(location,
                TypeMismatch{superTy, subTy,
                             "none of the intersection parts are compatible",
                             mismatchContext()});
  } else if (errorsSuppressed)
    failure = true;
}

void Unifier::tryUnifyNormalizedTypes(TypeId subTy, TypeId superTy,
                                      const NormalizedType &subNorm,
                                      const NormalizedType &superNorm,
                                      std::string reason,
                                      std::optional<TypeError> error) {
  if (get<AnyType>(superNorm.tops))
    return;
  else if (get<AnyType>(subNorm.tops)) {
    failure = true;
    return;
  }

  if (get<ErrorType>(subNorm.errors))
    if (!get<ErrorType>(superNorm.errors)) {
      failure = true;
      return;
    }

  if (get<UnknownType>(superNorm.tops))
    return;

  if (get<UnknownType>(subNorm.tops))
    return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                              mismatchContext()});

  if (get<PrimitiveType>(subNorm.booleans)) {
    if (!get<PrimitiveType>(superNorm.booleans))
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});
  } else if (const SingletonType *stv = get<SingletonType>(subNorm.booleans)) {
    if (!get<PrimitiveType>(superNorm.booleans) &&
        stv != get<SingletonType>(superNorm.booleans))
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});
  }

  if (get<PrimitiveType>(subNorm.nils))
    if (!get<PrimitiveType>(superNorm.nils))
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});

  if (get<PrimitiveType>(subNorm.numbers))
    if (!get<PrimitiveType>(superNorm.numbers))
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});

  if (!isSubtype(subNorm.strings, superNorm.strings))
    return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                              mismatchContext()});

  if (get<PrimitiveType>(subNorm.threads))
    if (!get<PrimitiveType>(superNorm.errors))
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});

  for (const auto &[subClass, _] : subNorm.classes.classes) {
    bool found = false;
    const ClassType *subCtv = get<ClassType>(subClass);
    LUAU_ASSERT(subCtv);

    for (const auto &[superClass, superNegations] : superNorm.classes.classes) {
      const ClassType *superCtv = get<ClassType>(superClass);
      LUAU_ASSERT(superCtv);

      if (isSubclass(subCtv, superCtv)) {
        found = true;

        for (TypeId negation : superNegations) {
          const ClassType *negationCtv = get<ClassType>(negation);
          LUAU_ASSERT(negationCtv);

          if (isSubclass(subCtv, negationCtv)) {
            found = false;
            break;
          }
        }

        if (found)
          break;
      }
    }

    if (useNewSolver) {
      for (TypeId superTable : superNorm.tables) {
        Unifier innerState = makeChildUnifier();
        innerState.tryUnify(subClass, superTable);

        if (innerState.errors.empty()) {
          found = true;
          log.concat(std::move(innerState.log));
          break;
        } else if (auto e = hasUnificationTooComplex(innerState.errors))
          return reportError(*e);
      }
    }

    if (!found) {
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});
    }
  }

  for (TypeId subTable : subNorm.tables) {
    bool found = false;
    for (TypeId superTable : superNorm.tables) {
      if (isPrim(superTable, PrimitiveType::Table)) {
        found = true;
        break;
      }

      Unifier innerState = makeChildUnifier();

      innerState.tryUnify(subTable, superTable);

      if (innerState.errors.empty()) {
        found = true;
        log.concat(std::move(innerState.log));
        break;
      } else if (auto e = hasUnificationTooComplex(innerState.errors))
        return reportError(*e);
    }
    if (!found)
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});
  }

  if (!subNorm.functions.isNever()) {
    if (superNorm.functions.isNever())
      return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                mismatchContext()});
    for (TypeId superFun : superNorm.functions.parts) {
      Unifier innerState = makeChildUnifier();
      const FunctionType *superFtv = get<FunctionType>(superFun);
      if (!superFtv)
        return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                  mismatchContext()});
      TypePackId tgt = innerState.tryApplyOverloadedFunction(
          subTy, subNorm.functions, superFtv->argTypes);
      innerState.tryUnify_(tgt, superFtv->retTypes);
      if (innerState.errors.empty())
        log.concat(std::move(innerState.log));
      else if (auto e = hasUnificationTooComplex(innerState.errors))
        return reportError(*e);
      else
        return reportError(location, TypeMismatch{superTy, subTy, reason, error,
                                                  mismatchContext()});
    }
  }

  for (auto &[tyvar, subIntersect] : subNorm.tyvars) {
    auto found = superNorm.tyvars.find(tyvar);
    if (found == superNorm.tyvars.end())
      tryUnifyNormalizedTypes(subTy, superTy, *subIntersect, superNorm, reason,
                              error);
    else
      tryUnifyNormalizedTypes(subTy, superTy, *subIntersect, *found->second,
                              reason, error);
    if (!errors.empty())
      return;
  }
}

TypePackId Unifier::tryApplyOverloadedFunction(
    TypeId function, const NormalizedFunctionType &overloads, TypePackId args) {
  if (overloads.isNever()) {
    reportError(location, CannotCallNonFunction{function});
    return builtinTypes->errorRecoveryTypePack();
  }

  std::optional<TypePackId> result;
  const FunctionType *firstFun = nullptr;
  for (TypeId overload : overloads.parts) {
    if (const FunctionType *ftv = get<FunctionType>(overload)) {
      // TODO: instantiate generics?
      if (ftv->generics.empty() && ftv->genericPacks.empty()) {
        if (!firstFun)
          firstFun = ftv;
        Unifier innerState = makeChildUnifier();
        innerState.tryUnify_(args, ftv->argTypes);
        if (innerState.errors.empty()) {
          log.concat(std::move(innerState.log));
          if (result) {
            innerState.log.clear();
            innerState.tryUnify_(*result, ftv->retTypes);
            if (innerState.errors.empty())
              log.concat(std::move(innerState.log));
            // Annoyingly, since we don't support intersection of generic type
            // packs, the intersection may fail. We rather arbitrarily use the
            // first matching overload in that case.
            else if (std::optional<TypePackId> intersect =
                         normalizer->intersectionOfTypePacks(*result,
                                                             ftv->retTypes))
              result = intersect;
          } else
            result = ftv->retTypes;
        } else if (auto e = hasUnificationTooComplex(innerState.errors)) {
          reportError(*e);
          return builtinTypes->errorRecoveryTypePack(args);
        }
      }
    }
  }

  if (result)
    return *result;
  else if (firstFun) {
    // TODO: better error reporting?
    // The logic for error reporting overload resolution
    // is currently over in TypeInfer.cpp, should we move it?
    reportError(location, GenericError{"No matching overload."});
    return builtinTypes->errorRecoveryTypePack(firstFun->retTypes);
  } else {
    reportError(location, CannotCallNonFunction{function});
    return builtinTypes->errorRecoveryTypePack();
  }
}

bool Unifier::canCacheResult(TypeId subTy, TypeId superTy) {
  bool *superTyInfo = sharedState.skipCacheForType.find(superTy);

  if (superTyInfo && *superTyInfo)
    return false;

  bool *subTyInfo = sharedState.skipCacheForType.find(subTy);

  if (subTyInfo && *subTyInfo)
    return false;

  auto skipCacheFor = [this](TypeId ty) {
    SkipCacheForType visitor{sharedState.skipCacheForType, types};
    visitor.traverse(ty);

    sharedState.skipCacheForType[ty] = visitor.result;

    return visitor.result;
  };

  if (!superTyInfo && skipCacheFor(superTy))
    return false;

  if (!subTyInfo && skipCacheFor(subTy))
    return false;

  return true;
}

void Unifier::cacheResult(TypeId subTy, TypeId superTy, size_t prevErrorCount) {
  if (errors.size() == prevErrorCount) {
    if (canCacheResult(subTy, superTy))
      sharedState.cachedUnify.insert({subTy, superTy});
  } else if (errors.size() == prevErrorCount + 1) {
    if (canCacheResult(subTy, superTy))
      sharedState.cachedUnifyError[{subTy, superTy}] = errors.back().data;
  }
}

struct WeirdIter {
  TypePackId packId;
  TxnLog &log;
  TypePack *pack;
  size_t index;
  bool growing;
  TypeLevel level;
  Scope *scope = nullptr;

  WeirdIter(TypePackId packId, TxnLog &log)
      : packId(packId), log(log), pack(log.getMutable<TypePack>(packId)),
        index(0), growing(false) {
    while (pack && pack->head.empty() && pack->tail) {
      packId = *pack->tail;
      pack = log.getMutable<TypePack>(packId);
    }
  }

  WeirdIter(const WeirdIter &) = default;

  TypeId &operator*() {
    LUAU_ASSERT(good());
    return pack->head[index];
  }

  bool good() const { return pack != nullptr && index < pack->head.size(); }

  std::optional<TypePackId> tail() const {
    if (!pack)
      return packId;

    LUAU_ASSERT(index == pack->head.size());
    return pack->tail;
  }

  bool advance() {
    if (!pack)
      return good();

    if (index < pack->head.size())
      ++index;

    if (growing || index < pack->head.size())
      return good();

    if (pack->tail) {
      packId = log.follow(*pack->tail);
      pack = log.getMutable<TypePack>(packId);
      index = 0;
    }

    return good();
  }

  bool canGrow() const {
    return nullptr != log.getMutable<FreeTypePack>(packId);
  }

  void grow(TypePackId newTail) {
    LUAU_ASSERT(canGrow());
    LUAU_ASSERT(log.getMutable<TypePack>(newTail));

    auto freePack = log.getMutable<FreeTypePack>(packId);

    level = freePack->level;
    if (freePack->scope != nullptr)
      scope = freePack->scope;
    log.replace(packId, BoundTypePack(newTail));
    packId = newTail;
    pack = log.getMutable<TypePack>(newTail);
    index = 0;
    growing = true;
  }

  void pushType(TypeId ty) {
    LUAU_ASSERT(pack);
    PendingTypePack *pendingPack = log.queue(packId);
    if (TypePack *pending = getMutable<TypePack>(pendingPack)) {
      pending->head.push_back(ty);
      // We've potentially just replaced the TypePack* that we need to look
      // in. We need to replace pack.
      pack = pending;
    } else {
      LUAU_ASSERT(!"Pending state for this pack was not a TypePack");
    }
  }
};

void Unifier::enableNewSolver() {
  useNewSolver = true;
  log.useScopes = true;
}

ErrorVec Unifier::canUnify(TypeId subTy, TypeId superTy) {
  Unifier s = makeChildUnifier();
  s.tryUnify_(subTy, superTy);

  return s.errors;
}

ErrorVec Unifier::canUnify(TypePackId subTy, TypePackId superTy,
                           bool isFunctionCall) {
  Unifier s = makeChildUnifier();
  s.tryUnify_(subTy, superTy, isFunctionCall);

  return s.errors;
}

void Unifier::tryUnify(TypePackId subTp, TypePackId superTp,
                       bool isFunctionCall) {
  sharedState.counters.iterationCount = 0;

  tryUnify_(subTp, superTp, isFunctionCall);
}

/*
 * This is quite tricky: we are walking two rope-like structures and unifying
 * corresponding elements. If one is longer than the other, but the short end is
 * free, we grow it to the required length.
 */
void Unifier::tryUnify_(TypePackId subTp, TypePackId superTp,
                        bool isFunctionCall) {
  RecursionLimiter _ra(&sharedState.counters.recursionCount,
                       sharedState.counters.recursionLimit);

  ++sharedState.counters.iterationCount;

  if (sharedState.counters.iterationLimit > 0 &&
      sharedState.counters.iterationLimit <
          sharedState.counters.iterationCount) {
    reportError(location, UnificationTooComplex{});
    return;
  }

  superTp = log.follow(superTp);
  subTp = log.follow(subTp);

  while (auto tp = log.getMutable<TypePack>(subTp)) {
    if (tp->head.empty() && tp->tail)
      subTp = log.follow(*tp->tail);
    else
      break;
  }

  while (auto tp = log.getMutable<TypePack>(superTp)) {
    if (tp->head.empty() && tp->tail)
      superTp = log.follow(*tp->tail);
    else
      break;
  }

  if (superTp == subTp)
    return;

  if (log.haveSeen(superTp, subTp))
    return;

  if (isBlocked(log, subTp) && isBlocked(log, superTp)) {
    blockedTypePacks.push_back(subTp);
    blockedTypePacks.push_back(superTp);
  } else if (isBlocked(log, subTp))
    blockedTypePacks.push_back(subTp);
  else if (isBlocked(log, superTp))
    blockedTypePacks.push_back(superTp);

  if (auto superFree = log.getMutable<FreeTypePack>(superTp)) {
    if (!occursCheck(superTp, subTp, /* reversed = */ true)) {
      Widen widen{types, builtinTypes};
      if (useNewSolver)
        promoteTypeLevels(log, types, superFree->level, superFree->scope,
                          /*useScopes*/ true, subTp);
      log.replace(superTp, Unifiable::Bound<TypePackId>(widen(subTp)));
    }
  } else if (auto subFree = log.getMutable<FreeTypePack>(subTp)) {
    if (!occursCheck(subTp, superTp, /* reversed = */ false)) {
      if (useNewSolver)
        promoteTypeLevels(log, types, subFree->level, subFree->scope,
                          /*useScopes*/ true, superTp);
      log.replace(subTp, Unifiable::Bound<TypePackId>(superTp));
    }
  } else if (hideousFixMeGenericsAreActuallyFree &&
             log.getMutable<GenericTypePack>(superTp)) {
    if (!occursCheck(superTp, subTp, /* reversed = */ true)) {
      Widen widen{types, builtinTypes};
      log.replace(superTp, Unifiable::Bound<TypePackId>(widen(subTp)));
    }
  } else if (hideousFixMeGenericsAreActuallyFree &&
             log.getMutable<GenericTypePack>(subTp)) {
    if (!occursCheck(subTp, superTp, /* reversed = */ false)) {
      log.replace(subTp, Unifiable::Bound<TypePackId>(superTp));
    }
  } else if (log.getMutable<Unifiable::Error>(superTp))
    tryUnifyWithAny(subTp, superTp);
  else if (log.getMutable<Unifiable::Error>(subTp))
    tryUnifyWithAny(superTp, subTp);
  else if (log.getMutable<VariadicTypePack>(superTp))
    tryUnifyVariadics(subTp, superTp, false);
  else if (log.getMutable<VariadicTypePack>(subTp))
    tryUnifyVariadics(superTp, subTp, true);
  else if (log.getMutable<TypePack>(superTp) &&
           log.getMutable<TypePack>(subTp)) {
    auto superTpv = log.getMutable<TypePack>(superTp);
    auto subTpv = log.getMutable<TypePack>(subTp);

    // If the size of two heads does not match, but both packs have free tail
    // We set the sentinel variable to say so to avoid growing it forever.
    auto [superTypes, superTail] = flatten(superTp, log);
    auto [subTypes, subTail] = flatten(subTp, log);

    bool noInfiniteGrowth =
        (superTypes.size() != subTypes.size()) &&
        (superTail && log.getMutable<FreeTypePack>(*superTail)) &&
        (subTail && log.getMutable<FreeTypePack>(*subTail));

    auto superIter = WeirdIter(superTp, log);
    auto subIter = WeirdIter(subTp, log);

    superIter.scope = scope.get();
    subIter.scope = scope.get();

    auto mkFreshType = [this](Scope *scope, TypeLevel level) {
      if (FFlag::DebugLuauDeferredConstraintResolution)
        return freshType(NotNull{types}, builtinTypes, scope);
      else
        return types->freshType(scope, level);
    };

    const TypePackId emptyTp = types->addTypePack(TypePack{{}, std::nullopt});

    int loopCount = 0;

    do {
      if (FInt::LuauTypeInferTypePackLoopLimit > 0 &&
          loopCount >= FInt::LuauTypeInferTypePackLoopLimit)
        ice("Detected possibly infinite TypePack growth");

      ++loopCount;

      if (superIter.good() && subIter.growing) {
        subIter.pushType(mkFreshType(subIter.scope, subIter.level));
      }

      if (subIter.good() && superIter.growing) {
        superIter.pushType(mkFreshType(superIter.scope, superIter.level));
      }

      if (superIter.good() && subIter.good()) {
        tryUnify_(*subIter, *superIter);

        if (!errors.empty() && !firstPackErrorPos)
          firstPackErrorPos = loopCount;

        superIter.advance();
        subIter.advance();
        continue;
      }

      // If both are at the end, we're done
      if (!superIter.good() && !subIter.good()) {
        if (useNewSolver) {
          if (subIter.tail() && superIter.tail())
            tryUnify_(*subIter.tail(), *superIter.tail());
          else if (subIter.tail()) {
            const TypePackId subTail = log.follow(*subIter.tail());

            if (log.get<FreeTypePack>(subTail))
              tryUnify_(subTail, emptyTp);
            else if (log.get<GenericTypePack>(subTail))
              reportError(location, TypePackMismatch{subTail, emptyTp});
            else if (log.get<VariadicTypePack>(subTail) ||
                     log.get<ErrorTypePack>(subTail)) {
              // Nothing.  This is ok.
            } else {
              ice("Unexpected subtype tail pack " + toString(subTail),
                  location);
            }
          } else if (superIter.tail()) {
            const TypePackId superTail = log.follow(*superIter.tail());

            if (log.get<FreeTypePack>(superTail))
              tryUnify_(emptyTp, superTail);
            else if (log.get<GenericTypePack>(superTail))
              reportError(location, TypePackMismatch{emptyTp, superTail});
            else if (log.get<VariadicTypePack>(superTail) ||
                     log.get<ErrorTypePack>(superTail)) {
              // Nothing.  This is ok.
            } else {
              ice("Unexpected supertype tail pack " + toString(superTail),
                  location);
            }
          } else {
            // Nothing.  This is ok.
          }
        } else {
          const bool lFreeTail =
              superTpv->tail && log.getMutable<FreeTypePack>(
                                    log.follow(*superTpv->tail)) != nullptr;
          const bool rFreeTail =
              subTpv->tail && log.getMutable<FreeTypePack>(
                                  log.follow(*subTpv->tail)) != nullptr;
          if (lFreeTail && rFreeTail) {
            tryUnify_(*subTpv->tail, *superTpv->tail);
          } else if (lFreeTail) {
            tryUnify_(emptyTp, *superTpv->tail);
          } else if (rFreeTail) {
            tryUnify_(emptyTp, *subTpv->tail);
          } else if (subTpv->tail && superTpv->tail) {
            if (log.getMutable<VariadicTypePack>(superIter.packId))
              tryUnifyVariadics(subIter.packId, superIter.packId, false,
                                int(subIter.index));
            else if (log.getMutable<VariadicTypePack>(subIter.packId))
              tryUnifyVariadics(superIter.packId, subIter.packId, true,
                                int(superIter.index));
            else
              tryUnify_(*subTpv->tail, *superTpv->tail);
          }
        }

        break;
      }

      // If both tails are free, bind one to the other and call it a day
      if (superIter.canGrow() && subIter.canGrow())
        return tryUnify_(*subIter.pack->tail, *superIter.pack->tail);

      // If just one side is free on its tail, grow it to fit the other side.
      // FIXME: The tail-most tail of the growing pack should be the same as the
      // tail-most tail of the non-growing pack.
      if (superIter.canGrow())
        superIter.grow(types->addTypePack(TypePackVar(TypePack{})));
      else if (subIter.canGrow())
        subIter.grow(types->addTypePack(TypePackVar(TypePack{})));
      else {
        // A union type including nil marks an optional argument
        if (superIter.good() && isOptional(*superIter)) {
          superIter.advance();
          continue;
        } else if (subIter.good() && isOptional(*subIter)) {
          subIter.advance();
          continue;
        }

        if (log.getMutable<VariadicTypePack>(superIter.packId)) {
          tryUnifyVariadics(subIter.packId, superIter.packId, false,
                            int(subIter.index));
          return;
        }

        if (log.getMutable<VariadicTypePack>(subIter.packId)) {
          tryUnifyVariadics(superIter.packId, subIter.packId, true,
                            int(superIter.index));
          return;
        }

        if (!isFunctionCall && subIter.good()) {
          // Sometimes it is ok to pass too many arguments
          return;
        }

        // This is a bit weird because we don't actually know expected vs
        // actual.  We just know subtype vs supertype.  If we are checking the
        // values returned by a function, we swap these to produce the expected
        // error message.
        size_t expectedSize = size(superTp);
        size_t actualSize = size(subTp);
        if (ctx == CountMismatch::FunctionResult ||
            ctx == CountMismatch::ExprListResult)
          std::swap(expectedSize, actualSize);
        reportError(location,
                    CountMismatch{expectedSize, std::nullopt, actualSize, ctx});

        while (superIter.good()) {
          tryUnify_(*superIter, builtinTypes->errorRecoveryType());
          superIter.advance();
        }

        while (subIter.good()) {
          tryUnify_(*subIter, builtinTypes->errorRecoveryType());
          subIter.advance();
        }

        return;
      }

    } while (!noInfiniteGrowth);
  } else {
    reportError(location, TypePackMismatch{subTp, superTp});
  }
}

void Unifier::tryUnifyPrimitives(TypeId subTy, TypeId superTy) {
  const PrimitiveType *superPrim = get<PrimitiveType>(superTy);
  const PrimitiveType *subPrim = get<PrimitiveType>(subTy);
  if (!superPrim || !subPrim)
    ice("passed non primitive types to unifyPrimitives");

  if (superPrim->type != subPrim->type)
    reportError(location, TypeMismatch{superTy, subTy, mismatchContext()});
}

void Unifier::tryUnifySingletons(TypeId subTy, TypeId superTy) {
  const PrimitiveType *superPrim = get<PrimitiveType>(superTy);
  const SingletonType *superSingleton = get<SingletonType>(superTy);
  const SingletonType *subSingleton = get<SingletonType>(subTy);

  if ((!superPrim && !superSingleton) || !subSingleton)
    ice("passed non singleton/primitive types to unifySingletons");

  if (superSingleton && *superSingleton == *subSingleton)
    return;

  if (superPrim && superPrim->type == PrimitiveType::Boolean &&
      get<BooleanSingleton>(subSingleton) && variance == Covariant)
    return;

  if (superPrim && superPrim->type == PrimitiveType::String &&
      get<StringSingleton>(subSingleton) && variance == Covariant)
    return;

  reportError(location, TypeMismatch{superTy, subTy, mismatchContext()});
}

void Unifier::tryUnifyFunctions(TypeId subTy, TypeId superTy,
                                bool isFunctionCall) {
  FunctionType *superFunction = log.getMutable<FunctionType>(superTy);
  FunctionType *subFunction = log.getMutable<FunctionType>(subTy);

  if (!superFunction || !subFunction)
    ice("passed non-function types to unifyFunction");

  size_t numGenerics = superFunction->generics.size();
  size_t numGenericPacks = superFunction->genericPacks.size();

  bool shouldInstantiate =
      (numGenerics == 0 && subFunction->generics.size() > 0) ||
      (numGenericPacks == 0 && subFunction->genericPacks.size() > 0);

  // TODO: This is unsound when the context is invariant, but the annotation
  // burden without allowing it and without read-only properties is too high for
  // lua-apps. Read-only properties _should_ resolve their issue by allowing
  // generic methods in tables to be marked read-only.
  if (FFlag::LuauInstantiateInSubtyping && shouldInstantiate) {
    Instantiation instantiation{&log, types, builtinTypes, scope->level, scope};

    std::optional<TypeId> instantiated = instantiation.substitute(subTy);
    if (instantiated.has_value()) {
      subFunction = log.getMutable<FunctionType>(*instantiated);

      if (!subFunction)
        ice("instantiation made a function type into a non-function type in "
            "unifyFunction");

      numGenerics = std::min(superFunction->generics.size(),
                             subFunction->generics.size());
      numGenericPacks = std::min(superFunction->genericPacks.size(),
                                 subFunction->genericPacks.size());
    } else {
      reportError(location, UnificationTooComplex{});
    }
  } else if (numGenerics != subFunction->generics.size()) {
    numGenerics =
        std::min(superFunction->generics.size(), subFunction->generics.size());

    reportError(location,
                TypeMismatch{superTy, subTy,
                             "different number of generic type parameters",
                             mismatchContext()});
  }

  if (numGenericPacks != subFunction->genericPacks.size()) {
    numGenericPacks = std::min(superFunction->genericPacks.size(),
                               subFunction->genericPacks.size());

    reportError(location,
                TypeMismatch{superTy, subTy,
                             "different number of generic type pack parameters",
                             mismatchContext()});
  }

  for (size_t i = 0; i < numGenerics; i++) {
    log.pushSeen(superFunction->generics[i], subFunction->generics[i]);
  }

  for (size_t i = 0; i < numGenericPacks; i++) {
    log.pushSeen(superFunction->genericPacks[i], subFunction->genericPacks[i]);
  }

  CountMismatch::Context context = ctx;

  if (!isFunctionCall) {
    Unifier innerState = makeChildUnifier();

    innerState.ctx = CountMismatch::Arg;
    innerState.tryUnify_(superFunction->argTypes, subFunction->argTypes,
                         isFunctionCall);

    bool reported = !innerState.errors.empty();

    if (auto e = hasUnificationTooComplex(innerState.errors))
      reportError(*e);
    else if (!innerState.errors.empty() && innerState.firstPackErrorPos)
      reportError(location,
                  TypeMismatch{superTy, subTy,
                               format("Argument #%d type is not compatible.",
                                      *innerState.firstPackErrorPos),
                               innerState.errors.front(), mismatchContext()});
    else if (!innerState.errors.empty())
      reportError(location,
                  TypeMismatch{superTy, subTy, "", innerState.errors.front(),
                               mismatchContext()});

    innerState.ctx = CountMismatch::FunctionResult;
    innerState.tryUnify_(subFunction->retTypes, superFunction->retTypes);

    if (!reported) {
      if (auto e = hasUnificationTooComplex(innerState.errors))
        reportError(*e);
      else if (!innerState.errors.empty() &&
               size(superFunction->retTypes) == 1 &&
               finite(superFunction->retTypes))
        reportError(location,
                    TypeMismatch{superTy, subTy,
                                 "Return type is not compatible.",
                                 innerState.errors.front(), mismatchContext()});
      else if (!innerState.errors.empty() && innerState.firstPackErrorPos)
        reportError(location,
                    TypeMismatch{superTy, subTy,
                                 format("Return #%d type is not compatible.",
                                        *innerState.firstPackErrorPos),
                                 innerState.errors.front(), mismatchContext()});
      else if (!innerState.errors.empty())
        reportError(location,
                    TypeMismatch{superTy, subTy, "", innerState.errors.front(),
                                 mismatchContext()});
    }

    log.concat(std::move(innerState.log));
  } else {
    ctx = CountMismatch::Arg;
    tryUnify_(superFunction->argTypes, subFunction->argTypes, isFunctionCall);

    ctx = CountMismatch::FunctionResult;
    tryUnify_(subFunction->retTypes, superFunction->retTypes);
  }

  // Updating the log may have invalidated the function pointers
  superFunction = log.getMutable<FunctionType>(superTy);
  subFunction = log.getMutable<FunctionType>(subTy);

  ctx = context;

  for (int i = int(numGenericPacks) - 1; 0 <= i; i--) {
    log.popSeen(superFunction->genericPacks[i], subFunction->genericPacks[i]);
  }

  for (int i = int(numGenerics) - 1; 0 <= i; i--) {
    log.popSeen(superFunction->generics[i], subFunction->generics[i]);
  }
}

namespace {

struct Resetter {
  explicit Resetter(Variance *variance)
      : oldValue(*variance), variance(variance) {}

  Variance oldValue;
  Variance *variance;

  ~Resetter() { *variance = oldValue; }
};

} // namespace

void Unifier::tryUnifyTables(TypeId subTy, TypeId superTy, bool isIntersection,
                             const LiteralProperties *literalProperties) {
  if (isPrim(log.follow(subTy), PrimitiveType::Table))
    subTy = builtinTypes->emptyTableType;

  if (isPrim(log.follow(superTy), PrimitiveType::Table))
    superTy = builtinTypes->emptyTableType;

  TypeId activeSubTy = subTy;
  TableType *superTable = log.getMutable<TableType>(superTy);
  TableType *subTable = log.getMutable<TableType>(subTy);

  if (!superTable || !subTable)
    ice("passed non-table types to unifyTables");

  std::vector<std::string> missingProperties;
  std::vector<std::string> extraProperties;

  if (FFlag::LuauInstantiateInSubtyping) {
    if (variance == Covariant && subTable->state == TableState::Generic &&
        superTable->state != TableState::Generic) {
      Instantiation instantiation{&log, types, builtinTypes, subTable->level,
                                  scope};

      std::optional<TypeId> instantiated = instantiation.substitute(subTy);
      if (instantiated.has_value()) {
        activeSubTy = *instantiated;
        subTable = log.getMutable<TableType>(activeSubTy);

        if (!subTable)
          ice("instantiation made a table type into a non-table type in "
              "tryUnifyTables");
      } else {
        reportError(location, UnificationTooComplex{});
      }
    }
  }

  // Optimization: First test that the property sets are compatible without
  // doing any recursive unification
  if (!subTable->indexer && subTable->state != TableState::Free) {
    for (const auto &[propName, superProp] : superTable->props) {
      auto subIter = subTable->props.find(propName);

      if (subIter == subTable->props.end() &&
          subTable->state == TableState::Unsealed &&
          !isOptional(superProp.type()))
        missingProperties.push_back(propName);
    }

    if (!missingProperties.empty()) {
      reportError(location, MissingProperties{superTy, subTy,
                                              std::move(missingProperties)});
      return;
    }
  }

  // And vice versa if we're invariant
  if (variance == Invariant && !superTable->indexer &&
      superTable->state != TableState::Unsealed &&
      superTable->state != TableState::Free) {
    for (const auto &[propName, subProp] : subTable->props) {
      auto superIter = superTable->props.find(propName);

      if (superIter == superTable->props.end())
        extraProperties.push_back(propName);
    }

    if (!extraProperties.empty()) {
      reportError(location,
                  MissingProperties{superTy, subTy, std::move(extraProperties),
                                    MissingProperties::Extra});
      return;
    }
  }

  // Width subtyping: any property in the supertype must be in the subtype,
  // and the types must agree.
  for (const auto &[name, prop] : superTable->props) {
    const auto &r = subTable->props.find(name);
    if (r != subTable->props.end()) {
      // TODO: read-only properties don't need invariance
      Resetter resetter{&variance};
      if (!literalProperties || !literalProperties->contains(name))
        variance = Invariant;

      Unifier innerState = makeChildUnifier();
      innerState.tryUnify_(r->second.type(), prop.type());

      checkChildUnifierTypeMismatch(innerState.errors, name, superTy, subTy);

      if (innerState.errors.empty())
        log.concat(std::move(innerState.log));
      failure |= innerState.failure;
    } else if (subTable->indexer && maybeString(subTable->indexer->indexType)) {
      // TODO: read-only indexers don't need invariance
      // TODO: really we should only allow this if prop.type is optional.
      Resetter resetter{&variance};
      if (!literalProperties || !literalProperties->contains(name))
        variance = Invariant;

      Unifier innerState = makeChildUnifier();
      innerState.tryUnify_(subTable->indexer->indexResultType, prop.type());

      checkChildUnifierTypeMismatch(innerState.errors, name, superTy, subTy);

      if (innerState.errors.empty())
        log.concat(std::move(innerState.log));
      failure |= innerState.failure;
    } else if (subTable->state == TableState::Unsealed &&
               isOptional(prop.type()))
    // This is sound because unsealed table types are precise, so `{ p : T } <:
    // { p : T, q : U? }` since if `t : { p : T }` then we are guaranteed that
    // `t.q` is `nil`.
    // TODO: if the supertype is written to, the subtype may no longer be
    // precise (alias analysis?)
    {
    } else if (subTable->state == TableState::Free) {
      PendingType *pendingSub = log.queue(activeSubTy);
      TableType *ttv = getMutable<TableType>(pendingSub);
      LUAU_ASSERT(ttv);
      ttv->props[name] = prop;
      subTable = ttv;
    } else
      missingProperties.push_back(name);

    // Recursive unification can change the txn log, and invalidate the old
    // table. If we detect that this has happened, we start over, with the
    // updated txn log.
    TypeId superTyNew = log.follow(superTy);
    TypeId subTyNew = log.follow(activeSubTy);

    // If one of the types stopped being a table altogether, we need to restart
    // from the top
    if ((superTy != superTyNew || activeSubTy != subTyNew) && errors.empty()) {
      if (FFlag::LuauUnifierRecursionOnRestart) {
        RecursionLimiter _ra(&sharedState.counters.recursionCount,
                             sharedState.counters.recursionLimit);
        tryUnify(subTy, superTy, false, isIntersection);
        return;
      } else {
        return tryUnify(subTy, superTy, false, isIntersection);
      }
    }

    // Otherwise, restart only the table unification
    TableType *newSuperTable = log.getMutable<TableType>(superTyNew);
    TableType *newSubTable = log.getMutable<TableType>(subTyNew);

    if (superTable != newSuperTable || subTable != newSubTable) {
      if (errors.empty()) {
        RecursionLimiter _ra(&sharedState.counters.recursionCount,
                             sharedState.counters.recursionLimit);
        tryUnifyTables(subTy, superTy, isIntersection);
      }

      return;
    }
  }

  for (const auto &[name, prop] : subTable->props) {
    if (superTable->props.count(name)) {
      // If both lt and rt contain the property, then
      // we're done since we already unified them above
    } else if (superTable->indexer &&
               maybeString(superTable->indexer->indexType)) {
      // TODO: read-only indexers don't need invariance
      // TODO: really we should only allow this if prop.type is optional.
      Resetter resetter{&variance};
      if (!literalProperties || !literalProperties->contains(name))
        variance = Invariant;

      Unifier innerState = makeChildUnifier();
      if (useNewSolver || FFlag::LuauFixIndexerSubtypingOrdering)
        innerState.tryUnify_(prop.type(), superTable->indexer->indexResultType);
      else {
        // Incredibly, the old solver depends on this bug somehow.
        innerState.tryUnify_(superTable->indexer->indexResultType, prop.type());
      }

      checkChildUnifierTypeMismatch(innerState.errors, name, superTy, subTy);

      if (innerState.errors.empty())
        log.concat(std::move(innerState.log));
      failure |= innerState.failure;
    } else if (superTable->state == TableState::Unsealed) {
      // TODO: this case is unsound when variance is Invariant, but without it
      // lua-apps fails to typecheck.
      // TODO: file a JIRA
      // TODO: hopefully readonly/writeonly properties will fix this.
      Property clone = prop;
      clone.setType(deeplyOptional(clone.type()));

      PendingType *pendingSuper = log.queue(superTy);
      TableType *pendingSuperTtv = getMutable<TableType>(pendingSuper);
      pendingSuperTtv->props[name] = clone;
      superTable = pendingSuperTtv;
    } else if (variance == Covariant) {
    } else if (superTable->state == TableState::Free) {
      PendingType *pendingSuper = log.queue(superTy);
      TableType *pendingSuperTtv = getMutable<TableType>(pendingSuper);
      pendingSuperTtv->props[name] = prop;
      superTable = pendingSuperTtv;
    } else
      extraProperties.push_back(name);

    TypeId superTyNew = log.follow(superTy);
    TypeId subTyNew = log.follow(activeSubTy);

    // If one of the types stopped being a table altogether, we need to restart
    // from the top
    if ((superTy != superTyNew || activeSubTy != subTyNew) && errors.empty()) {
      if (FFlag::LuauUnifierRecursionOnRestart) {
        RecursionLimiter _ra(&sharedState.counters.recursionCount,
                             sharedState.counters.recursionLimit);
        tryUnify(subTy, superTy, false, isIntersection);
        return;
      } else {
        return tryUnify(subTy, superTy, false, isIntersection);
      }
    }

    // Recursive unification can change the txn log, and invalidate the old
    // table. If we detect that this has happened, we start over, with the
    // updated txn log.
    TableType *newSuperTable = log.getMutable<TableType>(superTyNew);
    TableType *newSubTable = log.getMutable<TableType>(subTyNew);

    if (superTable != newSuperTable || subTable != newSubTable) {
      if (errors.empty()) {
        RecursionLimiter _ra(&sharedState.counters.recursionCount,
                             sharedState.counters.recursionLimit);
        tryUnifyTables(subTy, superTy, isIntersection);
      }

      return;
    }
  }

  // Unify indexers
  if (superTable->indexer && subTable->indexer) {
    // TODO: read-only indexers don't need invariance
    Resetter resetter{&variance};
    variance = Invariant;

    Unifier innerState = makeChildUnifier();

    innerState.tryUnify_(subTable->indexer->indexType,
                         superTable->indexer->indexType);

    bool reported = !innerState.errors.empty();

    checkChildUnifierTypeMismatch(innerState.errors, "[indexer key]", superTy,
                                  subTy);

    innerState.tryUnify_(subTable->indexer->indexResultType,
                         superTable->indexer->indexResultType);

    if (!reported)
      checkChildUnifierTypeMismatch(innerState.errors, "[indexer value]",
                                    superTy, subTy);

    if (innerState.errors.empty())
      log.concat(std::move(innerState.log));
    failure |= innerState.failure;
  } else if (superTable->indexer) {
    if (subTable->state == TableState::Unsealed ||
        subTable->state == TableState::Free) {
      // passing/assigning a table without an indexer to something that has one
      // e.g. table.insert(t, 1) where t is a non-sealed table and doesn't have
      // an indexer.
      // TODO: we only need to do this if the supertype's indexer is read/write
      // since that can add indexed elements.
      log.changeIndexer(subTy, superTable->indexer);
    }
  } else if (subTable->indexer && variance == Invariant) {
    // Symmetric if we are invariant
    if (superTable->state == TableState::Unsealed ||
        superTable->state == TableState::Free) {
      log.changeIndexer(superTy, subTable->indexer);
    }
  }

  // Changing the indexer can invalidate the table pointers.
  superTable = log.getMutable<TableType>(log.follow(superTy));
  subTable = log.getMutable<TableType>(log.follow(activeSubTy));

  if (!superTable || !subTable)
    return;

  if (!missingProperties.empty()) {
    reportError(location, MissingProperties{superTy, subTy,
                                            std::move(missingProperties)});
    return;
  }

  if (!extraProperties.empty()) {
    reportError(location,
                MissingProperties{superTy, subTy, std::move(extraProperties),
                                  MissingProperties::Extra});
    return;
  }

  /*
   * Types are commonly cyclic, so it is entirely possible
   * for unifying a property of a table to change the table itself!
   * We need to check for this and start over if we notice this occurring.
   *
   * I believe this is guaranteed to terminate eventually because this will
   * only happen when a free table is bound to another table.
   */
  if (superTable->boundTo || subTable->boundTo)
    return tryUnify_(subTy, superTy);

  if (superTable->state == TableState::Free) {
    log.bindTable(superTy, subTy);
  } else if (subTable->state == TableState::Free) {
    log.bindTable(subTy, superTy);
  }
}

void Unifier::tryUnifyScalarShape(TypeId subTy, TypeId superTy, bool reversed) {
  TypeId osubTy = subTy;
  TypeId osuperTy = superTy;

  // If the normalizer hits resource limits, we can't show it's uninhabited, so,
  // we should continue.
  if (checkInhabited &&
      normalizer->isInhabited(subTy) == NormalizationResult::False)
    return;

  if (reversed)
    std::swap(subTy, superTy);

  TableType *superTable = log.getMutable<TableType>(superTy);

  if (!superTable || superTable->state != TableState::Free)
    return reportError(location,
                       TypeMismatch{osuperTy, osubTy, mismatchContext()});

  auto fail = [&](std::optional<TypeError> e) {
    std::string reason =
        "The former's metatable does not satisfy the requirements.";
    if (e)
      reportError(location, TypeMismatch{osuperTy, osubTy, reason, *e,
                                         mismatchContext()});
    else
      reportError(location,
                  TypeMismatch{osuperTy, osubTy, reason, mismatchContext()});
  };

  // Given t1 where t1 = { lower: (t1) -> (a, b...) }
  // It should be the case that `string <: t1` iff `(subtype's
  // metatable).__index <: t1`
  if (auto metatable = getMetatable(subTy, builtinTypes)) {
    auto mttv = log.get<TableType>(*metatable);
    if (!mttv)
      fail(std::nullopt);

    if (auto it = mttv->props.find("__index"); it != mttv->props.end()) {
      TypeId ty = it->second.type();
      Unifier child = makeChildUnifier();
      child.tryUnify_(ty, superTy);

      // To perform subtype <: free table unification, we have tried to unify
      // (subtype's metatable) <: free table There is a chance that it was
      // unified with the origial subtype, but then, (subtype's metatable) <:
      // subtype could've failed Here we check if we have a new supertype
      // instead of the original free table and try original subtype <: new
      // supertype check
      TypeId newSuperTy = child.log.follow(superTy);

      if (superTy != newSuperTy && canUnify(subTy, newSuperTy).empty()) {
        log.replace(superTy, BoundType{subTy});
        return;
      }

      if (auto e = hasUnificationTooComplex(child.errors))
        reportError(*e);
      else if (!child.errors.empty())
        fail(child.errors.front());

      log.concat(std::move(child.log));

      // To perform subtype <: free table unification, we have tried to unify
      // (subtype's metatable) <: free table We return success because subtype
      // <: free table which means that correct unification is to replace free
      // table with the subtype
      if (child.errors.empty())
        log.replace(superTy, BoundType{subTy});

      return;
    } else {
      return fail(std::nullopt);
    }
  }

  reportError(location, TypeMismatch{osuperTy, osubTy, mismatchContext()});
  return;
}

TypeId Unifier::deeplyOptional(TypeId ty,
                               std::unordered_map<TypeId, TypeId> seen) {
  ty = follow(ty);
  if (isOptional(ty))
    return ty;
  else if (const TableType *ttv = get<TableType>(ty)) {
    TypeId &result = seen[ty];
    if (result)
      return result;
    result = types->addType(*ttv);
    TableType *resultTtv = getMutable<TableType>(result);
    for (auto &[name, prop] : resultTtv->props)
      prop.setType(deeplyOptional(prop.type(), seen));
    return types->addType(UnionType{{builtinTypes->nilType, result}});
  } else
    return types->addType(UnionType{{builtinTypes->nilType, ty}});
}

void Unifier::tryUnifyWithMetatable(TypeId subTy, TypeId superTy,
                                    bool reversed) {
  const MetatableType *superMetatable = get<MetatableType>(superTy);
  if (!superMetatable)
    ice("tryUnifyMetatable invoked with non-metatable Type");

  TypeError mismatchError = TypeError{
      location, TypeMismatch{reversed ? subTy : superTy,
                             reversed ? superTy : subTy, mismatchContext()}};

  if (const MetatableType *subMetatable =
          log.getMutable<MetatableType>(subTy)) {
    Unifier innerState = makeChildUnifier();
    innerState.tryUnify_(subMetatable->table, superMetatable->table);
    innerState.tryUnify_(subMetatable->metatable, superMetatable->metatable);

    if (auto e = hasUnificationTooComplex(innerState.errors))
      reportError(*e);
    else if (!innerState.errors.empty())
      reportError(location,
                  TypeMismatch{reversed ? subTy : superTy,
                               reversed ? superTy : subTy, "",
                               innerState.errors.front(), mismatchContext()});

    log.concat(std::move(innerState.log));
    failure |= innerState.failure;
  } else if (TableType *subTable = log.getMutable<TableType>(subTy)) {
    switch (subTable->state) {
    case TableState::Free: {
      if (useNewSolver) {
        Unifier innerState = makeChildUnifier();
        bool missingProperty = false;

        for (const auto &[propName, prop] : subTable->props) {
          if (std::optional<TypeId> mtPropTy =
                  findTablePropertyRespectingMeta(superTy, propName)) {
            innerState.tryUnify(prop.type(), *mtPropTy);
          } else {
            reportError(mismatchError);
            missingProperty = true;
            break;
          }
        }

        if (const TableType *superTable =
                log.get<TableType>(log.follow(superMetatable->table))) {
          // TODO: Unify indexers.
        }

        if (auto e = hasUnificationTooComplex(innerState.errors))
          reportError(*e);
        else if (!innerState.errors.empty())
          reportError(
              TypeError{location, TypeMismatch{reversed ? subTy : superTy,
                                               reversed ? superTy : subTy, "",
                                               innerState.errors.front(),
                                               mismatchContext()}});
        else if (!missingProperty) {
          log.concat(std::move(innerState.log));
          log.bindTable(subTy, superTy);
          failure |= innerState.failure;
        }
      } else {
        tryUnify_(subTy, superMetatable->table);
        log.bindTable(subTy, superTy);
      }

      break;
    }
    // We know the shape of sealed, unsealed, and generic tables; you can't add
    // a metatable on to any of these.
    case TableState::Sealed:
    case TableState::Unsealed:
    case TableState::Generic:
      reportError(mismatchError);
    }
  } else if (log.getMutable<AnyType>(subTy) ||
             log.getMutable<ErrorType>(subTy)) {
  } else {
    reportError(mismatchError);
  }
}

// Class unification is almost, but not quite symmetrical.  We use the
// 'reversed' boolean to indicate which scenario we are evaluating.
void Unifier::tryUnifyWithClass(TypeId subTy, TypeId superTy, bool reversed) {
  if (reversed)
    std::swap(superTy, subTy);

  auto fail = [&]() {
    if (!reversed)
      reportError(location, TypeMismatch{superTy, subTy, mismatchContext()});
    else
      reportError(location, TypeMismatch{subTy, superTy, mismatchContext()});
  };

  const ClassType *superClass = get<ClassType>(superTy);
  if (!superClass)
    ice("tryUnifyClass invoked with non-class Type");

  if (const ClassType *subClass = get<ClassType>(subTy)) {
    switch (variance) {
    case Covariant:
      if (!isSubclass(subClass, superClass))
        return fail();
      return;
    case Invariant:
      if (subClass != superClass)
        return fail();
      return;
    }
    ice("Illegal variance setting!");
  } else if (TableType *subTable = getMutable<TableType>(subTy)) {
    /**
     * A free table is something whose shape we do not exactly know yet.
     * Thus, it is entirely reasonable that we might discover that it is being
     * used as some class type. In this case, the free table must indeed be that
     * exact class. For this to hold, the table must not have any properties
     * that the class does not. Further, all properties of the table should
     * unify cleanly with the matching class properties.
     * TODO: What does it mean for the table to have an indexer? (probably
     * failure?)
     *
     * Tables that are not free are known to be actual tables.
     */
    if (subTable->state != TableState::Free)
      return fail();

    bool ok = true;

    for (const auto &[propName, prop] : subTable->props) {
      const Property *classProp = lookupClassProp(superClass, propName);
      if (!classProp) {
        ok = false;
        reportError(location, UnknownProperty{superTy, propName});
      } else {
        Unifier innerState = makeChildUnifier();
        innerState.tryUnify_(classProp->type(), prop.type());

        checkChildUnifierTypeMismatch(innerState.errors, propName,
                                      reversed ? subTy : superTy,
                                      reversed ? superTy : subTy);

        if (innerState.errors.empty()) {
          log.concat(std::move(innerState.log));
          failure |= innerState.failure;
        } else {
          ok = false;
        }
      }
    }

    if (subTable->indexer) {
      ok = false;
      std::string msg =
          "Class " + superClass->name + " does not have an indexer";
      reportError(location, GenericError{msg});
    }

    if (!ok)
      return;

    log.bindTable(subTy, superTy);
  } else
    return fail();
}

void Unifier::tryUnifyNegations(TypeId subTy, TypeId superTy) {
  if (!log.get<NegationType>(subTy) && !log.get<NegationType>(superTy))
    ice("tryUnifyNegations superTy or subTy must be a negation type");

  std::shared_ptr<const NormalizedType> subNorm = normalizer->normalize(subTy);
  std::shared_ptr<const NormalizedType> superNorm =
      normalizer->normalize(superTy);
  if (!subNorm || !superNorm)
    return reportError(location, NormalizationTooComplex{});

  // T </: ~U iff T <: U
  Unifier state = makeChildUnifier();
  state.tryUnifyNormalizedTypes(subTy, superTy, *subNorm, *superNorm, "");
  if (state.errors.empty())
    reportError(location, TypeMismatch{superTy, subTy, mismatchContext()});
}

static void queueTypePack(std::vector<TypeId> &queue,
                          DenseHashSet<TypePackId> &seenTypePacks,
                          Unifier &state, TypePackId a,
                          TypePackId anyTypePack) {
  while (true) {
    a = state.log.follow(a);

    if (seenTypePacks.find(a))
      break;
    seenTypePacks.insert(a);

    if (state.log.getMutable<FreeTypePack>(a)) {
      state.log.replace(a, BoundTypePack{anyTypePack});
    } else if (auto tp = state.log.getMutable<TypePack>(a)) {
      queue.insert(queue.end(), tp->head.begin(), tp->head.end());
      if (tp->tail)
        a = *tp->tail;
      else
        break;
    }
  }
}

void Unifier::tryUnifyVariadics(TypePackId subTp, TypePackId superTp,
                                bool reversed, int subOffset) {
  const VariadicTypePack *superVariadic =
      log.getMutable<VariadicTypePack>(superTp);
  const TypeId variadicTy = follow(superVariadic->ty);

  if (!superVariadic)
    ice("passed non-variadic pack to tryUnifyVariadics");

  if (const VariadicTypePack *subVariadic = log.get<VariadicTypePack>(subTp)) {
    tryUnify_(reversed ? variadicTy : subVariadic->ty,
              reversed ? subVariadic->ty : variadicTy);
  } else if (log.get<TypePack>(subTp)) {
    TypePackIterator subIter = begin(subTp, &log);
    TypePackIterator subEnd = end(subTp);

    std::advance(subIter, subOffset);

    while (subIter != subEnd) {
      tryUnify_(reversed ? variadicTy : *subIter,
                reversed ? *subIter : variadicTy);
      ++subIter;
    }

    if (std::optional<TypePackId> maybeTail = subIter.tail()) {
      TypePackId tail = follow(*maybeTail);

      if (isBlocked(log, tail)) {
        blockedTypePacks.push_back(tail);
      } else if (get<FreeTypePack>(tail)) {
        log.replace(tail, BoundTypePack(superTp));
      } else if (const VariadicTypePack *vtp = get<VariadicTypePack>(tail)) {
        tryUnify_(vtp->ty, variadicTy);
      } else if (get<GenericTypePack>(tail)) {
        if (!hideousFixMeGenericsAreActuallyFree)
          reportError(location,
                      GenericError{"Cannot unify variadic and generic packs"});
        else
          log.replace(tail, BoundTypePack{superTp});
      } else if (get<Unifiable::Error>(tail)) {
        // Nothing to do here.
      } else {
        ice("Unknown TypePack kind");
      }
    }
  } else if (get<AnyType>(variadicTy) && log.get<GenericTypePack>(subTp)) {
    // Nothing to do.  This is ok.
  } else {
    reportError(location, GenericError{"Failed to unify variadic packs"});
  }
}

static void tryUnifyWithAny(std::vector<TypeId> &queue, Unifier &state,
                            DenseHashSet<TypeId> &seen,
                            DenseHashSet<TypePackId> &seenTypePacks,
                            const TypeArena *typeArena, TypeId anyType,
                            TypePackId anyTypePack) {
  while (!queue.empty()) {
    TypeId ty = state.log.follow(queue.back());
    queue.pop_back();

    // Types from other modules don't have free types
    if (ty->owningArena != typeArena)
      continue;

    if (seen.find(ty))
      continue;

    seen.insert(ty);

    if (state.log.getMutable<FreeType>(ty)) {
      // TODO: Only bind if the anyType isn't any, unknown, or error (?)
      state.log.replace(ty, BoundType{anyType});
    } else if (auto fun = state.log.getMutable<FunctionType>(ty)) {
      queueTypePack(queue, seenTypePacks, state, fun->argTypes, anyTypePack);
      queueTypePack(queue, seenTypePacks, state, fun->retTypes, anyTypePack);
    } else if (auto table = state.log.getMutable<TableType>(ty)) {
      for (const auto &[_name, prop] : table->props)
        queue.push_back(prop.type());

      if (table->indexer) {
        queue.push_back(table->indexer->indexType);
        queue.push_back(table->indexer->indexResultType);
      }
    } else if (auto mt = state.log.getMutable<MetatableType>(ty)) {
      queue.push_back(mt->table);
      queue.push_back(mt->metatable);
    } else if (state.log.getMutable<ClassType>(ty)) {
      // ClassTypes never contain free types.
    } else if (auto union_ = state.log.getMutable<UnionType>(ty))
      queue.insert(queue.end(), union_->options.begin(), union_->options.end());
    else if (auto intersection = state.log.getMutable<IntersectionType>(ty))
      queue.insert(queue.end(), intersection->parts.begin(),
                   intersection->parts.end());
    else {
    } // Primitives, any, errors, and generics are left untouched.
  }
}

void Unifier::tryUnifyWithAny(TypeId subTy, TypeId anyTy) {
  LUAU_ASSERT(get<AnyType>(anyTy) || get<ErrorType>(anyTy) ||
              get<UnknownType>(anyTy) || get<NeverType>(anyTy));

  // These types are not visited in general loop below
  if (log.get<PrimitiveType>(subTy) || log.get<AnyType>(subTy) ||
      log.get<ClassType>(subTy))
    return;

  TypePackId anyTp = types->addTypePack(TypePackVar{VariadicTypePack{anyTy}});

  std::vector<TypeId> queue = {subTy};

  sharedState.tempSeenTy.clear();
  sharedState.tempSeenTp.clear();

  Luau::tryUnifyWithAny(queue, *this, sharedState.tempSeenTy,
                        sharedState.tempSeenTp, types, anyTy, anyTp);
}

void Unifier::tryUnifyWithAny(TypePackId subTy, TypePackId anyTp) {
  LUAU_ASSERT(get<Unifiable::Error>(anyTp));

  const TypeId anyTy = builtinTypes->errorRecoveryType();

  std::vector<TypeId> queue;

  sharedState.tempSeenTy.clear();
  sharedState.tempSeenTp.clear();

  queueTypePack(queue, sharedState.tempSeenTp, *this, subTy, anyTp);

  Luau::tryUnifyWithAny(queue, *this, sharedState.tempSeenTy,
                        sharedState.tempSeenTp, types, anyTy, anyTp);
}

std::optional<TypeId> Unifier::findTablePropertyRespectingMeta(TypeId lhsType,
                                                               Name name) {
  return Luau::findTablePropertyRespectingMeta(builtinTypes, errors, lhsType,
                                               name, location);
}

TxnLog Unifier::combineLogsIntoIntersection(std::vector<TxnLog> logs) {
  LUAU_ASSERT(useNewSolver);
  TxnLog result(useNewSolver);
  for (TxnLog &log : logs)
    result.concatAsIntersections(std::move(log), NotNull{types});
  return result;
}

TxnLog Unifier::combineLogsIntoUnion(std::vector<TxnLog> logs) {
  TxnLog result(useNewSolver);
  for (TxnLog &log : logs)
    result.concatAsUnion(std::move(log), NotNull{types});
  return result;
}

bool Unifier::occursCheck(TypeId needle, TypeId haystack, bool reversed) {
  sharedState.tempSeenTy.clear();

  bool occurs = occursCheck(sharedState.tempSeenTy, needle, haystack);

  if (occurs) {
    Unifier innerState = makeChildUnifier();
    if (const UnionType *ut = get<UnionType>(haystack)) {
      if (reversed)
        innerState.tryUnifyUnionWithType(haystack, ut, needle);
      else
        innerState.tryUnifyTypeWithUnion(needle, haystack, ut,
                                         /* cacheEnabled = */ false,
                                         /* isFunction = */ false);
    } else if (const IntersectionType *it = get<IntersectionType>(haystack)) {
      if (reversed)
        innerState.tryUnifyIntersectionWithType(haystack, it, needle,
                                                /* cacheEnabled = */ false,
                                                /* isFunction = */ false);
      else
        innerState.tryUnifyTypeWithIntersection(needle, haystack, it);
    } else {
      innerState.failure = true;
    }

    if (innerState.failure) {
      reportError(location, OccursCheckFailed{});
      log.replace(needle, BoundType{builtinTypes->errorRecoveryType()});
    }
  }

  return occurs;
}

bool Unifier::occursCheck(DenseHashSet<TypeId> &seen, TypeId needle,
                          TypeId haystack) {
  RecursionLimiter _ra(&sharedState.counters.recursionCount,
                       sharedState.counters.recursionLimit);

  bool occurrence = false;

  auto check = [&](TypeId tv) {
    if (occursCheck(seen, needle, tv))
      occurrence = true;
  };

  needle = log.follow(needle);
  haystack = log.follow(haystack);

  if (seen.find(haystack))
    return false;

  seen.insert(haystack);

  if (log.getMutable<ErrorType>(needle))
    return false;

  if (!log.getMutable<FreeType>(needle) &&
      !(hideousFixMeGenericsAreActuallyFree && log.is<GenericType>(needle)))
    ice("Expected needle to be free");

  if (needle == haystack)
    return true;

  if (log.getMutable<FreeType>(haystack) ||
      (hideousFixMeGenericsAreActuallyFree && log.is<GenericType>(haystack)))
    return false;
  else if (auto a = log.getMutable<UnionType>(haystack)) {
    for (TypeId ty : a->options)
      check(ty);
  } else if (auto a = log.getMutable<IntersectionType>(haystack)) {
    for (TypeId ty : a->parts)
      check(ty);
  }

  return occurrence;
}

bool Unifier::occursCheck(TypePackId needle, TypePackId haystack,
                          bool reversed) {
  sharedState.tempSeenTp.clear();

  bool occurs = occursCheck(sharedState.tempSeenTp, needle, haystack);

  if (occurs) {
    reportError(location, OccursCheckFailed{});
    if (FFlag::LuauUnifierShouldNotCopyError)
      log.replace(needle, BoundTypePack{builtinTypes->errorRecoveryTypePack()});
    else
      log.replace(needle, *builtinTypes->errorRecoveryTypePack());
  }

  return occurs;
}

bool Unifier::occursCheck(DenseHashSet<TypePackId> &seen, TypePackId needle,
                          TypePackId haystack) {
  needle = log.follow(needle);
  haystack = log.follow(haystack);

  if (seen.find(haystack))
    return false;

  seen.insert(haystack);

  if (log.getMutable<ErrorTypePack>(needle))
    return false;

  if (!log.getMutable<FreeTypePack>(needle) &&
      !(hideousFixMeGenericsAreActuallyFree && log.is<GenericTypePack>(needle)))
    ice("Expected needle pack to be free");

  RecursionLimiter _ra(&sharedState.counters.recursionCount,
                       sharedState.counters.recursionLimit);

  while (!log.getMutable<ErrorType>(haystack)) {
    if (needle == haystack)
      return true;

    if (auto a = get<TypePack>(haystack); a && a->tail) {
      haystack = log.follow(*a->tail);
      continue;
    }

    break;
  }

  return false;
}

Unifier Unifier::makeChildUnifier() {
  Unifier u = Unifier{normalizer, scope, location, variance, &log};
  u.normalize = normalize;
  u.checkInhabited = checkInhabited;

  if (useNewSolver)
    u.enableNewSolver();

  return u;
}

// A utility function that appends the given error to the unifier's error log.
// This allows setting a breakpoint wherever the unifier reports an error.
//
// Note: report error accepts its arguments by value intentionally to reduce the
// stack usage of functions which call `reportError`.
void Unifier::reportError(Location location, TypeErrorData data) {
  errors.emplace_back(std::move(location), std::move(data));
  failure = true;
}

// A utility function that appends the given error to the unifier's error log.
// This allows setting a breakpoint wherever the unifier reports an error.
//
// Note: to conserve stack space in calling functions it is generally preferred
// to call `Unifier::reportError(Location location, TypeErrorData data)` instead
// of this method.
void Unifier::reportError(TypeError err) {
  errors.push_back(std::move(err));
  failure = true;
}

void Unifier::checkChildUnifierTypeMismatch(const ErrorVec &innerErrors,
                                            TypeId wantedType,
                                            TypeId givenType) {
  if (auto e = hasUnificationTooComplex(innerErrors))
    reportError(*e);
  else if (!innerErrors.empty())
    reportError(location,
                TypeMismatch{wantedType, givenType, mismatchContext()});
}

void Unifier::checkChildUnifierTypeMismatch(const ErrorVec &innerErrors,
                                            const std::string &prop,
                                            TypeId wantedType,
                                            TypeId givenType) {
  if (auto e = hasUnificationTooComplex(innerErrors))
    reportError(*e);
  else if (!innerErrors.empty())
    reportError(TypeError{
        location,
        TypeMismatch{wantedType, givenType,
                     format("Property '%s' is not compatible.", prop.c_str()),
                     innerErrors.front(), mismatchContext()}});
}

void Unifier::ice(const std::string &message, const Location &location) {
  sharedState.iceHandler->ice(message, location);
}

void Unifier::ice(const std::string &message) {
  sharedState.iceHandler->ice(message);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// DONE : was aleready inlined <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : was already included! <stdexcept>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

namespace Luau {

FreeTypePack::FreeTypePack(TypeLevel level)
    : index(Unifiable::freshIndex()), level(level), scope(nullptr) {}

FreeTypePack::FreeTypePack(Scope *scope)
    : index(Unifiable::freshIndex()), level{}, scope(scope) {}

FreeTypePack::FreeTypePack(Scope *scope, TypeLevel level)
    : index(Unifiable::freshIndex()), level(level), scope(scope) {}

GenericTypePack::GenericTypePack()
    : index(Unifiable::freshIndex()), name("g" + std::to_string(index)) {}

GenericTypePack::GenericTypePack(TypeLevel level)
    : index(Unifiable::freshIndex()), level(level),
      name("g" + std::to_string(index)) {}

GenericTypePack::GenericTypePack(const Name &name)
    : index(Unifiable::freshIndex()), name(name), explicitName(true) {}

GenericTypePack::GenericTypePack(Scope *scope)
    : index(Unifiable::freshIndex()), scope(scope) {}

GenericTypePack::GenericTypePack(TypeLevel level, const Name &name)
    : index(Unifiable::freshIndex()), level(level), name(name),
      explicitName(true) {}

GenericTypePack::GenericTypePack(Scope *scope, const Name &name)
    : index(Unifiable::freshIndex()), scope(scope), name(name),
      explicitName(true) {}

BlockedTypePack::BlockedTypePack() : index(++nextIndex) {}

size_t BlockedTypePack::nextIndex = 0;

TypePackVar::TypePackVar(const TypePackVariant &tp) : ty(tp) {}

TypePackVar::TypePackVar(TypePackVariant &&tp) : ty(std::move(tp)) {}

TypePackVar::TypePackVar(TypePackVariant &&tp, bool persistent)
    : ty(std::move(tp)), persistent(persistent) {}

bool TypePackVar::operator==(const TypePackVar &rhs) const {
  SeenSet seen;
  return areEqual(seen, *this, rhs);
}

TypePackVar &TypePackVar::operator=(TypePackVariant &&tp) {
  ty = std::move(tp);
  return *this;
}

TypePackVar &TypePackVar::operator=(const TypePackVar &rhs) {
  LUAU_ASSERT(owningArena == rhs.owningArena);
  LUAU_ASSERT(!rhs.persistent);

  reassign(rhs);

  return *this;
}

TypePackIterator::TypePackIterator(TypePackId typePack)
    : TypePackIterator(typePack, TxnLog::empty()) {}

TypePackIterator::TypePackIterator(TypePackId typePack, const TxnLog *log)
    : currentTypePack(log->follow(typePack)),
      tp(log->get<TypePack>(currentTypePack)), currentIndex(0), log(log) {
  while (tp && tp->head.empty()) {
    currentTypePack = tp->tail ? log->follow(*tp->tail) : nullptr;
    tp = currentTypePack ? log->getMutable<TypePack>(currentTypePack) : nullptr;
  }
}

TypePackIterator &TypePackIterator::operator++() {
  LUAU_ASSERT(tp);

  ++currentIndex;
  while (tp && currentIndex >= tp->head.size()) {
    currentTypePack = tp->tail ? log->follow(*tp->tail) : nullptr;
    tp = currentTypePack ? log->getMutable<TypePack>(currentTypePack) : nullptr;

    currentIndex = 0;
  }

  return *this;
}

TypePackIterator TypePackIterator::operator++(int) {
  TypePackIterator copy = *this;
  ++*this;
  return copy;
}

bool TypePackIterator::operator!=(const TypePackIterator &rhs) {
  return !(*this == rhs);
}

bool TypePackIterator::operator==(const TypePackIterator &rhs) {
  return tp == rhs.tp && currentIndex == rhs.currentIndex;
}

const TypeId &TypePackIterator::operator*() {
  LUAU_ASSERT(tp);
  return tp->head[currentIndex];
}

std::optional<TypePackId> TypePackIterator::tail() {
  LUAU_ASSERT(!tp);
  return currentTypePack ? std::optional<TypePackId>{currentTypePack}
                         : std::nullopt;
}

TypePackIterator begin(TypePackId tp) { return TypePackIterator{tp}; }

TypePackIterator begin(TypePackId tp, const TxnLog *log) {
  return TypePackIterator{tp, log};
}

TypePackIterator end(TypePackId tp) { return TypePackIterator{}; }

bool areEqual(SeenSet &seen, const TypePackVar &lhs, const TypePackVar &rhs) {
  TypePackId lhsId = const_cast<TypePackId>(&lhs);
  TypePackId rhsId = const_cast<TypePackId>(&rhs);
  TypePackIterator lhsIter = begin(lhsId);
  TypePackIterator rhsIter = begin(rhsId);
  TypePackIterator lhsEnd = end(lhsId);
  TypePackIterator rhsEnd = end(rhsId);
  while (lhsIter != lhsEnd && rhsIter != rhsEnd) {
    if (!areEqual(seen, **lhsIter, **rhsIter))
      return false;
    ++lhsIter;
    ++rhsIter;
  }

  if (lhsIter != lhsEnd || rhsIter != rhsEnd)
    return false;

  if (!lhsIter.tail() && !rhsIter.tail())
    return true;
  if (!lhsIter.tail() || !rhsIter.tail())
    return false;

  TypePackId lhsTail = *lhsIter.tail();
  TypePackId rhsTail = *rhsIter.tail();

  {
    const FreeTypePack *lf = get_if<FreeTypePack>(&lhsTail->ty);
    const FreeTypePack *rf = get_if<FreeTypePack>(&rhsTail->ty);
    if (lf && rf)
      return lf->index == rf->index;
  }

  {
    const Unifiable::Bound<TypePackId> *lb =
        get_if<Unifiable::Bound<TypePackId>>(&lhsTail->ty);
    const Unifiable::Bound<TypePackId> *rb =
        get_if<Unifiable::Bound<TypePackId>>(&rhsTail->ty);
    if (lb && rb)
      return areEqual(seen, *lb->boundTo, *rb->boundTo);
  }

  {
    const GenericTypePack *lg = get_if<GenericTypePack>(&lhsTail->ty);
    const GenericTypePack *rg = get_if<GenericTypePack>(&rhsTail->ty);
    if (lg && rg)
      return lg->index == rg->index;
  }

  {
    const VariadicTypePack *lv = get_if<VariadicTypePack>(&lhsTail->ty);
    const VariadicTypePack *rv = get_if<VariadicTypePack>(&rhsTail->ty);
    if (lv && rv)
      return areEqual(seen, *lv->ty, *rv->ty);
  }

  return false;
}

TypePackId follow(TypePackId tp) {
  return follow(tp, nullptr, [](const void *, TypePackId t) { return t; });
}

TypePackId follow(TypePackId tp, const void *context,
                  TypePackId (*mapper)(const void *, TypePackId)) {
  auto advance = [context, mapper](TypePackId ty) -> std::optional<TypePackId> {
    TypePackId mapped = mapper(context, ty);

    if (const Unifiable::Bound<TypePackId> *btv =
            get<Unifiable::Bound<TypePackId>>(mapped))
      return btv->boundTo;
    else if (const TypePack *tp = get<TypePack>(mapped); tp && tp->head.empty())
      return tp->tail;
    else
      return std::nullopt;
  };

  TypePackId cycleTester =
      tp; // Null once we've determined that there is no cycle
  if (auto a = advance(cycleTester))
    cycleTester = *a;
  else
    return tp;

  if (!advance(cycleTester)) // Short circuit traversal for the rather common
                             // case when advance(advance(t)) == null
    return cycleTester;

  while (true) {
    auto a1 = advance(tp);
    if (a1)
      tp = *a1;
    else
      return tp;

    if (nullptr != cycleTester) {
      auto a2 = advance(cycleTester);
      if (a2) {
        auto a3 = advance(*a2);
        if (a3)
          cycleTester = *a3;
        else
          cycleTester = nullptr;
      } else
        cycleTester = nullptr;

      if (tp == cycleTester)
        throw InternalCompilerError("Luau::follow detected a Type cycle!!");
    }
  }
}

size_t size(TypePackId tp, TxnLog *log) {
  tp = log ? log->follow(tp) : follow(tp);
  if (auto pack = get<TypePack>(tp))
    return size(*pack, log);
  else
    return 0;
}

bool finite(TypePackId tp, TxnLog *log) {
  tp = log ? log->follow(tp) : follow(tp);

  if (auto pack = get<TypePack>(tp))
    return pack->tail ? finite(*pack->tail, log) : true;

  if (get<VariadicTypePack>(tp))
    return false;

  return true;
}

size_t size(const TypePack &tp, TxnLog *log) {
  size_t result = tp.head.size();
  if (tp.tail) {
    const TypePack *tail =
        get<TypePack>(log ? log->follow(*tp.tail) : follow(*tp.tail));
    if (tail)
      result += size(*tail, log);
  }
  return result;
}

std::optional<TypeId> first(TypePackId tp, bool ignoreHiddenVariadics) {
  auto it = begin(tp);
  auto endIter = end(tp);

  if (it != endIter)
    return *it;

  if (auto tail = it.tail()) {
    if (auto vtp = get<VariadicTypePack>(*tail);
        vtp && (!vtp->hidden || !ignoreHiddenVariadics))
      return vtp->ty;
  }

  return std::nullopt;
}

TypePackVar *asMutable(TypePackId tp) { return const_cast<TypePackVar *>(tp); }

TypePack *asMutable(const TypePack *tp) { return const_cast<TypePack *>(tp); }

bool isEmpty(TypePackId tp) {
  tp = follow(tp);
  if (auto tpp = get<TypePack>(tp)) {
    return tpp->head.empty() && (!tpp->tail || isEmpty(*tpp->tail));
  }

  return false;
}

std::pair<std::vector<TypeId>, std::optional<TypePackId>>
flatten(TypePackId tp) {
  std::vector<TypeId> res;

  auto iter = begin(tp);
  auto endIter = end(tp);
  while (iter != endIter) {
    res.push_back(*iter);
    ++iter;
  }

  return {res, iter.tail()};
}

std::pair<std::vector<TypeId>, std::optional<TypePackId>>
flatten(TypePackId tp, const TxnLog &log) {
  tp = log.follow(tp);

  std::vector<TypeId> flattened;
  std::optional<TypePackId> tail = std::nullopt;

  TypePackIterator it(tp, &log);

  for (; it != end(tp); ++it) {
    flattened.push_back(*it);
  }

  tail = it.tail();

  return {flattened, tail};
}

bool isVariadic(TypePackId tp) { return isVariadic(tp, *TxnLog::empty()); }

bool isVariadic(TypePackId tp, const TxnLog &log) {
  std::optional<TypePackId> tail = flatten(tp, log).second;

  if (!tail)
    return false;

  return isVariadicTail(*tail, log);
}

bool isVariadicTail(TypePackId tp, const TxnLog &log,
                    bool includeHiddenVariadics) {
  if (log.get<GenericTypePack>(tp))
    return true;

  if (auto vtp = log.get<VariadicTypePack>(tp);
      vtp && (includeHiddenVariadics || !vtp->hidden))
    return true;

  return false;
}

bool containsNever(TypePackId tp) {
  auto it = begin(tp);
  auto endIt = end(tp);

  while (it != endIt) {
    if (get<NeverType>(follow(*it)))
      return true;
    ++it;
  }

  if (auto tail = it.tail()) {
    if (auto vtp = get<VariadicTypePack>(*tail);
        vtp && get<NeverType>(follow(vtp->ty)))
      return true;
  }

  return false;
}

template <>
LUAU_NOINLINE Unifiable::Bound<TypePackId> *
emplaceTypePack<BoundTypePack>(TypePackVar *ty, TypePackId &tyArg) {
  LUAU_ASSERT(ty != follow(tyArg));
  return &ty->ty.emplace<BoundTypePack>(tyArg);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// DONE : was aleready inlined <Luau/ApplyTypeFunction.h>

// DONE : was aleready inlined <Luau/Cancellation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ModuleResolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// DONE : was aleready inlined <Luau/Quantify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// DONE : was aleready inlined <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TimeTrace.h>

// DONE : was aleready inlined <Luau/TopoSortStatements.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <iterator>

LUAU_FASTFLAGVARIABLE(DebugLuauMagicTypes, false)
LUAU_FASTINTVARIABLE(LuauTypeInferRecursionLimit, 165)
LUAU_FASTINTVARIABLE(LuauTypeInferIterationLimit, 20000)
LUAU_FASTINTVARIABLE(LuauTypeInferTypePackLoopLimit, 5000)
LUAU_FASTINTVARIABLE(LuauCheckRecursionLimit, 300)
LUAU_FASTINTVARIABLE(LuauVisitRecursionLimit, 500)
LUAU_FASTFLAG(LuauKnowsTheDataModel3)
LUAU_FASTFLAGVARIABLE(DebugLuauFreezeDuringUnification, false)
LUAU_FASTFLAGVARIABLE(DebugLuauSharedSelf, false)
LUAU_FASTFLAG(LuauInstantiateInSubtyping)
LUAU_FASTFLAGVARIABLE(LuauTinyControlFlowAnalysis, false)
LUAU_FASTFLAGVARIABLE(LuauAlwaysCommitInferencesOfFunctionCalls, false)
LUAU_FASTFLAGVARIABLE(LuauRemoveBadRelationalOperatorWarning, false)
LUAU_FASTFLAGVARIABLE(LuauOkWithIteratingOverTableProperties, false)
LUAU_FASTFLAGVARIABLE(LuauReusableSubstitutions, false)
LUAU_FASTFLAG(LuauDeclarationExtraPropData)

namespace Luau {

static bool typeCouldHaveMetatable(TypeId ty) {
  return get<TableType>(follow(ty)) || get<ClassType>(follow(ty)) ||
         get<MetatableType>(follow(ty));
}

static void defaultLuauPrintLine(const std::string &s) {
  printf("%s\n", s.c_str());
}

PrintLineProc luauPrintLine = &defaultLuauPrintLine;

void setPrintLine(PrintLineProc pl) { luauPrintLine = pl; }

void resetPrintLine() { luauPrintLine = &defaultLuauPrintLine; }

bool doesCallError(const AstExprCall *call) {
  const AstExprGlobal *global = call->func->as<AstExprGlobal>();
  if (!global)
    return false;

  if (global->name == "error")
    return true;
  else if (global->name == "assert") {
    // assert() will error because it is missing the first argument
    if (call->args.size == 0)
      return true;

    if (AstExprConstantBool *expr =
            call->args.data[0]->as<AstExprConstantBool>())
      if (!expr->value)
        return true;
  }

  return false;
}

bool hasBreak(AstStat *node) {
  if (AstStatBlock *stat = node->as<AstStatBlock>()) {
    for (size_t i = 0; i < stat->body.size; ++i) {
      if (hasBreak(stat->body.data[i]))
        return true;
    }

    return false;
  } else if (node->is<AstStatBreak>()) {
    return true;
  } else if (AstStatIf *stat = node->as<AstStatIf>()) {
    if (hasBreak(stat->thenbody))
      return true;

    if (stat->elsebody && hasBreak(stat->elsebody))
      return true;

    return false;
  } else {
    return false;
  }
}

// returns the last statement before the block exits, or nullptr if the block
// never exits
const AstStat *getFallthrough(const AstStat *node) {
  if (const AstStatBlock *stat = node->as<AstStatBlock>()) {
    if (stat->body.size == 0)
      return stat;

    for (size_t i = 0; i < stat->body.size - 1; ++i) {
      if (getFallthrough(stat->body.data[i]) == nullptr)
        return nullptr;
    }

    return getFallthrough(stat->body.data[stat->body.size - 1]);
  } else if (const AstStatIf *stat = node->as<AstStatIf>()) {
    if (const AstStat *thenf = getFallthrough(stat->thenbody))
      return thenf;

    if (stat->elsebody) {
      if (const AstStat *elsef = getFallthrough(stat->elsebody))
        return elsef;

      return nullptr;
    } else {
      return stat;
    }
  } else if (node->is<AstStatReturn>()) {
    return nullptr;
  } else if (const AstStatExpr *stat = node->as<AstStatExpr>()) {
    if (AstExprCall *call = stat->expr->as<AstExprCall>()) {
      if (doesCallError(call))
        return nullptr;
    }

    return stat;
  } else if (const AstStatWhile *stat = node->as<AstStatWhile>()) {
    if (AstExprConstantBool *expr =
            stat->condition->as<AstExprConstantBool>()) {
      if (expr->value && !hasBreak(stat->body))
        return nullptr;
    }

    return node;
  } else if (const AstStatRepeat *stat = node->as<AstStatRepeat>()) {
    if (AstExprConstantBool *expr =
            stat->condition->as<AstExprConstantBool>()) {
      if (!expr->value && !hasBreak(stat->body))
        return nullptr;
    }

    if (getFallthrough(stat->body) == nullptr)
      return nullptr;

    return node;
  } else {
    return node;
  }
}

static bool isMetamethod(const Name &name) {
  return name == "__index" || name == "__newindex" || name == "__call" ||
         name == "__concat" || name == "__unm" || name == "__add" ||
         name == "__sub" || name == "__mul" || name == "__div" ||
         name == "__mod" || name == "__pow" || name == "__tostring" ||
         name == "__metatable" || name == "__eq" || name == "__lt" ||
         name == "__le" || name == "__mode" || name == "__iter" ||
         name == "__len" || name == "__idiv";
}

size_t HashBoolNamePair::operator()(const std::pair<bool, Name> &pair) const {
  return std::hash<bool>()(pair.first) ^ std::hash<Name>()(pair.second);
}

TypeChecker::TypeChecker(const ScopePtr &globalScope, ModuleResolver *resolver,
                         NotNull<BuiltinTypes> builtinTypes,
                         InternalErrorReporter *iceHandler)
    : globalScope(globalScope), resolver(resolver), builtinTypes(builtinTypes),
      iceHandler(iceHandler), unifierState(iceHandler),
      normalizer(nullptr, builtinTypes, NotNull{&unifierState}),
      reusableInstantiation(TxnLog::empty(), nullptr, builtinTypes, {},
                            nullptr),
      nilType(builtinTypes->nilType), numberType(builtinTypes->numberType),
      stringType(builtinTypes->stringType),
      booleanType(builtinTypes->booleanType),
      threadType(builtinTypes->threadType),
      bufferType(builtinTypes->bufferType), anyType(builtinTypes->anyType),
      unknownType(builtinTypes->unknownType),
      neverType(builtinTypes->neverType),
      anyTypePack(builtinTypes->anyTypePack),
      neverTypePack(builtinTypes->neverTypePack),
      uninhabitableTypePack(builtinTypes->uninhabitableTypePack),
      duplicateTypeAliases{{false, {}}} {}

ModulePtr TypeChecker::check(const SourceModule &module, Mode mode,
                             std::optional<ScopePtr> environmentScope) {
  try {
    return checkWithoutRecursionCheck(module, mode, environmentScope);
  } catch (const RecursionLimitException &) {
    reportErrorCodeTooComplex(module.root->location);
    return std::move(currentModule);
  }
}

ModulePtr TypeChecker::checkWithoutRecursionCheck(
    const SourceModule &module, Mode mode,
    std::optional<ScopePtr> environmentScope) {
  LUAU_TIMETRACE_SCOPE("TypeChecker::check", "TypeChecker");
  LUAU_TIMETRACE_ARGUMENT("module", module.name.c_str());
  LUAU_TIMETRACE_ARGUMENT("name", module.humanReadableName.c_str());

  currentModule.reset(new Module);
  currentModule->name = module.name;
  currentModule->humanReadableName = module.humanReadableName;
  currentModule->internalTypes.owningModule = currentModule.get();
  currentModule->interfaceTypes.owningModule = currentModule.get();
  currentModule->type = module.type;
  currentModule->allocator = module.allocator;
  currentModule->names = module.names;

  iceHandler->moduleName = module.name;
  normalizer.arena = &currentModule->internalTypes;

  unifierState.counters.recursionLimit = FInt::LuauTypeInferRecursionLimit;
  unifierState.counters.iterationLimit =
      unifierIterationLimit ? *unifierIterationLimit
                            : FInt::LuauTypeInferIterationLimit;

  ScopePtr parentScope = environmentScope.value_or(globalScope);
  ScopePtr moduleScope = std::make_shared<Scope>(parentScope);

  if (module.cyclic)
    moduleScope->returnType = addTypePack(TypePack{{anyType}, std::nullopt});
  else
    moduleScope->returnType = freshTypePack(moduleScope);

  moduleScope->varargPack = anyTypePack;

  currentModule->scopes.push_back(
      std::make_pair(module.root->location, moduleScope));
  currentModule->mode = mode;

  if (prepareModuleScope)
    prepareModuleScope(currentModule->name, currentModule->getModuleScope());

  try {
    checkBlock(moduleScope, *module.root);
  } catch (const TimeLimitError &) {
    currentModule->timeout = true;
  } catch (const UserCancelError &) {
    currentModule->cancelled = true;
  }

  if (FFlag::DebugLuauSharedSelf) {
    for (auto &[ty, scope] : deferredQuantification)
      Luau::quantify(ty, scope->level);
    deferredQuantification.clear();
  }

  if (get<FreeTypePack>(follow(moduleScope->returnType)))
    moduleScope->returnType = addTypePack(TypePack{{}, std::nullopt});
  else
    moduleScope->returnType =
        anyify(moduleScope, moduleScope->returnType, Location{});

  moduleScope->returnType =
      anyifyModuleReturnTypePackGenerics(moduleScope->returnType);

  for (auto &[_, typeFun] : moduleScope->exportedTypeBindings)
    typeFun.type = anyify(moduleScope, typeFun.type, Location{});

  prepareErrorsForDisplay(currentModule->errors);

  // Clear the normalizer caches, since they contain types from the internal
  // type surface
  normalizer.clearCaches();
  normalizer.arena = nullptr;

  currentModule->clonePublicInterface(builtinTypes, *iceHandler);
  freeze(currentModule->internalTypes);
  freeze(currentModule->interfaceTypes);

  // Clear unifier cache since it's keyed off internal types that get
  // deallocated This avoids fake cross-module cache hits and keeps cache size
  // at bay when typechecking large module graphs.
  unifierState.cachedUnify.clear();
  unifierState.cachedUnifyError.clear();
  unifierState.skipCacheForType.clear();

  duplicateTypeAliases.clear();
  incorrectClassDefinitions.clear();

  return std::move(currentModule);
}

ControlFlow TypeChecker::check(const ScopePtr &scope, const AstStat &program) {
  if (finishTime && TimeTrace::getClock() > *finishTime)
    throwTimeLimitError();
  if (cancellationToken && cancellationToken->requested())
    throwUserCancelError();

  if (auto block = program.as<AstStatBlock>())
    return check(scope, *block);
  else if (auto if_ = program.as<AstStatIf>())
    return check(scope, *if_);
  else if (auto while_ = program.as<AstStatWhile>())
    return check(scope, *while_);
  else if (auto repeat = program.as<AstStatRepeat>())
    return check(scope, *repeat);
  else if (program.is<AstStatBreak>())
    return FFlag::LuauTinyControlFlowAnalysis ? ControlFlow::Breaks
                                              : ControlFlow::None;
  else if (program.is<AstStatContinue>())
    return FFlag::LuauTinyControlFlowAnalysis ? ControlFlow::Continues
                                              : ControlFlow::None;
  else if (auto return_ = program.as<AstStatReturn>())
    return check(scope, *return_);
  else if (auto expr = program.as<AstStatExpr>()) {
    checkExprPack(scope, *expr->expr);

    if (FFlag::LuauTinyControlFlowAnalysis) {
      if (auto call = expr->expr->as<AstExprCall>();
          call && doesCallError(call))
        return ControlFlow::Throws;
    }

    return ControlFlow::None;
  } else if (auto local = program.as<AstStatLocal>())
    return check(scope, *local);
  else if (auto for_ = program.as<AstStatFor>())
    return check(scope, *for_);
  else if (auto forIn = program.as<AstStatForIn>())
    return check(scope, *forIn);
  else if (auto assign = program.as<AstStatAssign>())
    return check(scope, *assign);
  else if (auto assign = program.as<AstStatCompoundAssign>())
    return check(scope, *assign);
  else if (program.is<AstStatFunction>())
    ice("Should not be calling two-argument check() on a function statement",
        program.location);
  else if (program.is<AstStatLocalFunction>())
    ice("Should not be calling two-argument check() on a function statement",
        program.location);
  else if (auto typealias = program.as<AstStatTypeAlias>())
    return check(scope, *typealias);
  else if (auto global = program.as<AstStatDeclareGlobal>()) {
    TypeId globalType = resolveType(scope, *global->type);
    Name globalName(global->name.value);

    currentModule->declaredGlobals[globalName] = globalType;
    currentModule->getModuleScope()->bindings[global->name] =
        Binding{globalType, global->location};

    return ControlFlow::None;
  } else if (auto global = program.as<AstStatDeclareFunction>())
    return check(scope, *global);
  else if (auto global = program.as<AstStatDeclareClass>())
    return check(scope, *global);
  else if (auto errorStatement = program.as<AstStatError>()) {
    const size_t oldSize = currentModule->errors.size();

    for (AstStat *s : errorStatement->statements)
      check(scope, *s);

    for (AstExpr *expr : errorStatement->expressions)
      checkExpr(scope, *expr);

    // HACK: We want to run typechecking on the contents of the AstStatError,
    // but we don't think the type errors will be useful most of the time.
    currentModule->errors.resize(oldSize);

    return ControlFlow::None;
  } else
    ice("Unknown AstStat");
}

// This particular overload is for do...end. If you need to not increase the
// scope level, use checkBlock directly.
ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatBlock &block) {
  ScopePtr child = childScope(scope, block.location);

  ControlFlow flow = checkBlock(child, block);
  scope->inheritRefinements(child);

  return flow;
}

ControlFlow TypeChecker::checkBlock(const ScopePtr &scope,
                                    const AstStatBlock &block) {
  RecursionCounter _rc(&checkRecursionCount);
  if (FInt::LuauCheckRecursionLimit > 0 &&
      checkRecursionCount >= FInt::LuauCheckRecursionLimit) {
    reportErrorCodeTooComplex(block.location);
    return ControlFlow::None;
  }
  try {
    return checkBlockWithoutRecursionCheck(scope, block);
  } catch (const RecursionLimitException &) {
    reportErrorCodeTooComplex(block.location);
    return ControlFlow::None;
  }
}

struct InplaceDemoter : TypeOnceVisitor {
  TypeLevel newLevel;
  TypeArena *arena;

  InplaceDemoter(TypeLevel level, TypeArena *arena)
      : TypeOnceVisitor(/* skipBoundTypes= */ true), newLevel(level),
        arena(arena) {}

  bool demote(TypeId ty) {
    if (auto level = getMutableLevel(ty)) {
      if (level->subsumesStrict(newLevel)) {
        *level = newLevel;
        return true;
      }
    }

    return false;
  }

  bool visit(TypeId ty) override {
    if (ty->owningArena != arena)
      return false;
    return demote(ty);
  }

  bool visit(TypePackId tp, const FreeTypePack &ftpRef) override {
    if (tp->owningArena != arena)
      return false;

    FreeTypePack *ftp = &const_cast<FreeTypePack &>(ftpRef);
    if (ftp->level.subsumesStrict(newLevel)) {
      ftp->level = newLevel;
      return true;
    }

    return false;
  }
};

ControlFlow
TypeChecker::checkBlockWithoutRecursionCheck(const ScopePtr &scope,
                                             const AstStatBlock &block) {
  int subLevel = 0;

  std::vector<AstStat *> sorted(block.body.data,
                                block.body.data + block.body.size);
  toposort(sorted);

  for (const auto &stat : sorted) {
    if (const auto &typealias = stat->as<AstStatTypeAlias>()) {
      prototype(scope, *typealias, subLevel);
      ++subLevel;
    } else if (const auto &declaredClass = stat->as<AstStatDeclareClass>()) {
      prototype(scope, *declaredClass);
    }
  }

  auto protoIter = sorted.begin();
  auto checkIter = sorted.begin();

  std::unordered_map<AstStat *, std::pair<TypeId, ScopePtr>> functionDecls;

  auto checkBody = [&](AstStat *stat) {
    if (auto fun = stat->as<AstStatFunction>()) {
      LUAU_ASSERT(functionDecls.count(stat));
      auto [funTy, funScope] = functionDecls[stat];
      check(scope, funTy, funScope, *fun);
    } else if (auto fun = stat->as<AstStatLocalFunction>()) {
      LUAU_ASSERT(functionDecls.count(stat));
      auto [funTy, funScope] = functionDecls[stat];
      check(scope, funTy, funScope, *fun);
    }
  };

  std::optional<ControlFlow> firstFlow;
  while (protoIter != sorted.end()) {
    // protoIter walks forward
    //      If it contains a function call (function bodies don't count), walk
    //      checkIter forward until it catches up with protoIter
    //          For each element checkIter sees, check function bodies and unify
    //          the computed type with the prototype
    //      If it is a function definition, add its prototype to the environment
    //      If it is anything else, check it.

    // A subtlety is caused by mutually recursive functions, e.g.
    // ```
    // function f(x) return g(x) end
    // function g(x) return f(x) end
    // ```
    // These both call each other, so `f` will be ordered before `g`, so the
    // call to `g` is typechecked before `g` has had its body checked. For this
    // reason, there's three types for each function: before its body is
    // checked, during checking its body, and after its body is checked.
    //
    // We currently treat the before-type and the during-type as the same,
    // which can result in some oddness, as the before-type is usually a
    // monotype, and the after-type is often a polytype. For example:
    //
    // ```
    // function f(x) local x: number = g(37) return x end
    // function g(x) return f(x) end
    // ```
    // The before-type of g is `(X)->Y...` but during type-checking of `f` we
    // will unify that with `(number)->number`. The types end up being
    // ```
    // function f<a>(x:a):a local x: number = g(37) return x end
    // function g(x:number):number return f(x) end
    // ```
    if (containsFunctionCallOrReturn(**protoIter)) {
      while (checkIter != protoIter) {
        checkBody(*checkIter);
        ++checkIter;
      }

      // We do check the current element, so advance checkIter beyond it.
      ++checkIter;
      ControlFlow flow = check(scope, **protoIter);
      if (flow != ControlFlow::None && !firstFlow)
        firstFlow = flow;
    } else if (auto fun = (*protoIter)->as<AstStatFunction>()) {
      std::optional<TypeId> selfType;
      std::optional<TypeId> expectedType;

      if (FFlag::DebugLuauSharedSelf) {
        if (auto name = fun->name->as<AstExprIndexName>()) {
          TypeId baseTy = checkExpr(scope, *name->expr).type;
          tablify(baseTy);

          if (!fun->func->self)
            expectedType = getIndexTypeFromType(
                scope, baseTy, name->index.value, name->indexLocation,
                /* addErrors= */ false);
          else if (auto ttv = getMutableTableType(baseTy)) {
            if (!baseTy->persistent && ttv->state != TableState::Sealed &&
                !ttv->selfTy) {
              ttv->selfTy = anyIfNonstrict(freshType(ttv->level));
              deferredQuantification.push_back({baseTy, scope});
            }

            selfType = ttv->selfTy;
          }
        }
      } else {
        if (!fun->func->self) {
          if (auto name = fun->name->as<AstExprIndexName>()) {
            TypeId exprTy = checkExpr(scope, *name->expr).type;
            expectedType = getIndexTypeFromType(
                scope, exprTy, name->index.value, name->indexLocation,
                /* addErrors= */ false);
          }
        }
      }

      auto pair =
          checkFunctionSignature(scope, subLevel, *fun->func,
                                 fun->name->location, selfType, expectedType);
      auto [funTy, funScope] = pair;

      functionDecls[*protoIter] = pair;
      ++subLevel;

      TypeId leftType =
          follow(checkFunctionName(scope, *fun->name, funScope->level));

      unify(funTy, leftType, scope, fun->location);
    } else if (auto fun = (*protoIter)->as<AstStatLocalFunction>()) {
      auto pair = checkFunctionSignature(scope, subLevel, *fun->func,
                                         fun->name->location, std::nullopt,
                                         std::nullopt);
      auto [funTy, funScope] = pair;

      functionDecls[*protoIter] = pair;
      ++subLevel;

      scope->bindings[fun->name] = {funTy, fun->name->location};
    } else {
      ControlFlow flow = check(scope, **protoIter);
      if (flow != ControlFlow::None && !firstFlow)
        firstFlow = flow;
    }

    ++protoIter;
  }

  while (checkIter != sorted.end()) {
    checkBody(*checkIter);
    ++checkIter;
  }

  checkBlockTypeAliases(scope, sorted);

  return firstFlow.value_or(ControlFlow::None);
}

LUAU_NOINLINE void
TypeChecker::checkBlockTypeAliases(const ScopePtr &scope,
                                   std::vector<AstStat *> &sorted) {
  for (const auto &stat : sorted) {
    if (const auto &typealias = stat->as<AstStatTypeAlias>()) {
      if (typealias->name == kParseNameError || typealias->name == "typeof")
        continue;

      auto &bindings = typealias->exported ? scope->exportedTypeBindings
                                           : scope->privateTypeBindings;

      Name name = typealias->name.value;

      if (duplicateTypeAliases.contains({typealias->exported, name}))
        continue;

      TypeId type = follow(bindings[name].type);
      if (get<FreeType>(type)) {
        asMutable(type)->ty.emplace<BoundType>(errorRecoveryType(anyType));

        reportError(TypeError{typealias->location, OccursCheckFailed{}});
      }
    }
  }
}

static std::optional<Predicate>
tryGetTypeGuardPredicate(const AstExprBinary &expr) {
  if (expr.op != AstExprBinary::Op::CompareEq &&
      expr.op != AstExprBinary::Op::CompareNe)
    return std::nullopt;

  AstExpr *left = expr.left;
  AstExpr *right = expr.right;

  if (left->as<AstExprConstantString>())
    std::swap(left, right);

  AstExprConstantString *str = right->as<AstExprConstantString>();
  if (!str)
    return std::nullopt;

  AstExprCall *call = left->as<AstExprCall>();
  if (!call)
    return std::nullopt;

  AstExprGlobal *callee = call->func->as<AstExprGlobal>();
  if (!callee)
    return std::nullopt;

  if (callee->name != "type" && callee->name != "typeof")
    return std::nullopt;

  if (call->args.size != 1)
    return std::nullopt;

  // If ssval is not a valid constant string, we'll find out later when
  // resolving predicate.
  Name ssval(str->value.data, str->value.size);
  bool isTypeof = callee->name == "typeof";

  std::optional<LValue> lvalue = tryGetLValue(*call->args.data[0]);
  if (!lvalue)
    return std::nullopt;

  Predicate predicate{
      TypeGuardPredicate{std::move(*lvalue), expr.location, ssval, isTypeof}};
  if (expr.op == AstExprBinary::Op::CompareNe)
    return NotPredicate{{std::move(predicate)}};

  return predicate;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatIf &statement) {
  WithPredicate<TypeId> result = checkExpr(scope, *statement.condition);

  ScopePtr thenScope = childScope(scope, statement.thenbody->location);
  resolve(result.predicates, thenScope, true);

  if (FFlag::LuauTinyControlFlowAnalysis) {
    ScopePtr elseScope =
        childScope(scope, statement.elsebody ? statement.elsebody->location
                                             : statement.location);
    resolve(result.predicates, elseScope, false);

    ControlFlow thencf = check(thenScope, *statement.thenbody);
    ControlFlow elsecf = ControlFlow::None;
    if (statement.elsebody)
      elsecf = check(elseScope, *statement.elsebody);

    if (thencf != ControlFlow::None && elsecf == ControlFlow::None)
      scope->inheritRefinements(elseScope);
    else if (thencf == ControlFlow::None && elsecf != ControlFlow::None)
      scope->inheritRefinements(thenScope);

    if (FFlag::LuauTinyControlFlowAnalysis && thencf == elsecf)
      return thencf;
    else if (matches(thencf, ControlFlow::Returns | ControlFlow::Throws) &&
             matches(elsecf, ControlFlow::Returns | ControlFlow::Throws))
      return ControlFlow::Returns;
    else
      return ControlFlow::None;
  } else {
    check(thenScope, *statement.thenbody);

    if (statement.elsebody) {
      ScopePtr elseScope = childScope(scope, statement.elsebody->location);
      resolve(result.predicates, elseScope, false);
      check(elseScope, *statement.elsebody);
    }

    return ControlFlow::None;
  }
}

template <typename Id>
ErrorVec TypeChecker::canUnify_(Id subTy, Id superTy, const ScopePtr &scope,
                                const Location &location) {
  Unifier state = mkUnifier(scope, location);
  return state.canUnify(subTy, superTy);
}

ErrorVec TypeChecker::canUnify(TypeId subTy, TypeId superTy,
                               const ScopePtr &scope,
                               const Location &location) {
  return canUnify_(subTy, superTy, scope, location);
}

ErrorVec TypeChecker::canUnify(TypePackId subTy, TypePackId superTy,
                               const ScopePtr &scope,
                               const Location &location) {
  return canUnify_(subTy, superTy, scope, location);
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatWhile &statement) {
  WithPredicate<TypeId> result = checkExpr(scope, *statement.condition);

  ScopePtr whileScope = childScope(scope, statement.body->location);
  resolve(result.predicates, whileScope, true);
  check(whileScope, *statement.body);

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatRepeat &statement) {
  ScopePtr repScope = childScope(scope, statement.location);

  checkBlock(repScope, *statement.body);

  checkExpr(repScope, *statement.condition);

  return ControlFlow::None;
}

struct Demoter : Substitution {
  Demoter(TypeArena *arena) : Substitution(TxnLog::empty(), arena) {}

  bool isDirty(TypeId ty) override { return get<FreeType>(ty); }

  bool isDirty(TypePackId tp) override { return get<FreeTypePack>(tp); }

  bool ignoreChildren(TypeId ty) override {
    if (get<ClassType>(ty))
      return true;

    return false;
  }

  TypeId clean(TypeId ty) override {
    auto ftv = get<FreeType>(ty);
    LUAU_ASSERT(ftv);
    return addType(FreeType{demotedLevel(ftv->level)});
  }

  TypePackId clean(TypePackId tp) override {
    auto ftp = get<FreeTypePack>(tp);
    LUAU_ASSERT(ftp);
    return addTypePack(TypePackVar{FreeTypePack{demotedLevel(ftp->level)}});
  }

  TypeLevel demotedLevel(TypeLevel level) {
    return TypeLevel{level.level + 5000, level.subLevel};
  }

  void demote(std::vector<std::optional<TypeId>> &expectedTypes) {
    for (std::optional<TypeId> &ty : expectedTypes) {
      if (ty)
        ty = substitute(*ty);
    }
  }
};

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatReturn &return_) {
  std::vector<std::optional<TypeId>> expectedTypes;
  expectedTypes.reserve(return_.list.size);

  TypePackIterator expectedRetCurr = begin(scope->returnType);
  TypePackIterator expectedRetEnd = end(scope->returnType);

  for (size_t i = 0; i < return_.list.size; ++i) {
    if (expectedRetCurr != expectedRetEnd) {
      expectedTypes.push_back(*expectedRetCurr);
      ++expectedRetCurr;
    } else if (auto expectedArgsTail = expectedRetCurr.tail()) {
      if (const VariadicTypePack *vtp =
              get<VariadicTypePack>(follow(*expectedArgsTail)))
        expectedTypes.push_back(vtp->ty);
    }
  }

  Demoter demoter{&currentModule->internalTypes};
  demoter.demote(expectedTypes);

  TypePackId retPack = checkExprList(scope, return_.location, return_.list,
                                     false, {}, expectedTypes)
                           .type;

  // HACK: Nonstrict mode gets a bit too smart and strict for us when we
  // start typechecking everything across module boundaries.
  if (isNonstrictMode() &&
      follow(scope->returnType) ==
          follow(currentModule->getModuleScope()->returnType)) {
    ErrorVec errors =
        tryUnify(retPack, scope->returnType, scope, return_.location);

    if (!errors.empty())
      currentModule->getModuleScope()->returnType = addTypePack({anyType});

    return FFlag::LuauTinyControlFlowAnalysis ? ControlFlow::Returns
                                              : ControlFlow::None;
  }

  unify(retPack, scope->returnType, scope, return_.location,
        CountMismatch::Context::Return);

  return FFlag::LuauTinyControlFlowAnalysis ? ControlFlow::Returns
                                            : ControlFlow::None;
}

template <typename Id>
ErrorVec TypeChecker::tryUnify_(Id subTy, Id superTy, const ScopePtr &scope,
                                const Location &location) {
  Unifier state = mkUnifier(scope, location);

  if (FFlag::DebugLuauFreezeDuringUnification)
    freeze(currentModule->internalTypes);

  state.tryUnify(subTy, superTy);

  if (FFlag::DebugLuauFreezeDuringUnification)
    unfreeze(currentModule->internalTypes);

  if (state.errors.empty())
    state.log.commit();

  return state.errors;
}

ErrorVec TypeChecker::tryUnify(TypeId subTy, TypeId superTy,
                               const ScopePtr &scope,
                               const Location &location) {
  return tryUnify_(subTy, superTy, scope, location);
}

ErrorVec TypeChecker::tryUnify(TypePackId subTy, TypePackId superTy,
                               const ScopePtr &scope,
                               const Location &location) {
  return tryUnify_(subTy, superTy, scope, location);
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatAssign &assign) {
  std::vector<std::optional<TypeId>> expectedTypes;
  expectedTypes.reserve(assign.vars.size);

  ScopePtr moduleScope = currentModule->getModuleScope();

  for (size_t i = 0; i < assign.vars.size; ++i) {
    AstExpr *dest = assign.vars.data[i];

    if (auto a = dest->as<AstExprLocal>()) {
      // AstExprLocal l-values will have to be checked again because their type
      // might have been mutated during checkExprList later
      expectedTypes.push_back(scope->lookup(a->local));
    } else if (auto a = dest->as<AstExprGlobal>()) {
      // AstExprGlobal l-values lookup is inlined here to avoid creating a
      // global binding before checkExprList
      if (auto it = moduleScope->bindings.find(a->name);
          it != moduleScope->bindings.end())
        expectedTypes.push_back(it->second.typeId);
      else
        expectedTypes.push_back(std::nullopt);
    } else {
      expectedTypes.push_back(checkLValue(scope, *dest, ValueContext::LValue));
    }
  }

  TypePackId valuePack = checkExprList(scope, assign.location, assign.values,
                                       false, {}, expectedTypes)
                             .type;

  auto valueIter = begin(valuePack);
  auto valueEnd = end(valuePack);

  TypePack *growingPack = nullptr;

  for (size_t i = 0; i < assign.vars.size; ++i) {
    AstExpr *dest = assign.vars.data[i];
    TypeId left = nullptr;

    if (dest->is<AstExprLocal>() || dest->is<AstExprGlobal>())
      left = checkLValue(scope, *dest, ValueContext::LValue);
    else
      left = *expectedTypes[i];

    TypeId right = nullptr;

    Location loc = 0 == assign.values.size ? assign.location
                   : i < assign.values.size
                       ? assign.values.data[i]->location
                       : assign.values.data[assign.values.size - 1]->location;

    if (valueIter != valueEnd) {
      right = follow(*valueIter);
      ++valueIter;
    } else if (growingPack) {
      growingPack->head.push_back(left);
      continue;
    } else if (auto tail = valueIter.tail()) {
      TypePackId tailPack = follow(*tail);
      if (get<Unifiable::Error>(tailPack))
        right = errorRecoveryType(scope);
      else if (auto vtp = get<VariadicTypePack>(tailPack))
        right = vtp->ty;
      else if (get<FreeTypePack>(tailPack)) {
        *asMutable(tailPack) = TypePack{{left}};
        growingPack = getMutable<TypePack>(tailPack);
      }
    }

    if (right) {
      if (!FFlag::LuauInstantiateInSubtyping) {
        if (!maybeGeneric(left) && isGeneric(right))
          right = instantiate(scope, right, loc);
      }

      // Setting a table entry to nil doesn't mean nil is the type of the
      // indexer, it is just deleting the entry
      const TableType *destTableTypeReceivingNil = nullptr;
      if (auto indexExpr = dest->as<AstExprIndexExpr>();
          isNil(right) && indexExpr)
        destTableTypeReceivingNil =
            getTableType(checkExpr(scope, *indexExpr->expr).type);

      if (!destTableTypeReceivingNil || !destTableTypeReceivingNil->indexer) {
        // In nonstrict mode, any assignments where the lhs is free and rhs
        // isn't a function, we give it any type.
        if (isNonstrictMode() && get<FreeType>(follow(left)) &&
            !get<FunctionType>(follow(right)))
          unify(anyType, left, scope, loc);
        else
          unify(right, left, scope, loc);
      }
    }
  }

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatCompoundAssign &assign) {
  AstExprBinary expr(assign.location, assign.op, assign.var, assign.value);

  TypeId left = checkExpr(scope, *expr.left).type;
  TypeId right = checkExpr(scope, *expr.right).type;

  TypeId result = checkBinaryOperation(scope, expr, left, right);

  unify(result, left, scope, assign.location);

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatLocal &local) {
  // Important subtlety: A local variable is not in scope while its initializer
  // is being evaluated. For instance, you cannot do this:
  //     local a = function() return a end

  AstLocal **vars = local.vars.data;

  std::vector<std::pair<AstLocal *, Binding>> varBindings;
  varBindings.reserve(local.vars.size);

  std::vector<TypeId> variableTypes;
  variableTypes.reserve(local.vars.size);

  std::vector<std::optional<TypeId>> expectedTypes;
  expectedTypes.reserve(local.vars.size);

  std::vector<bool> instantiateGenerics;

  for (size_t i = 0; i < local.vars.size; ++i) {
    const AstType *annotation = vars[i]->annotation;
    const bool rhsIsTable =
        local.values.size > i && local.values.data[i]->as<AstExprTable>();

    TypeId ty = nullptr;

    if (annotation) {
      ty = resolveType(scope, *annotation);

      // If the annotation type has an error, treat it as if there was no
      // annotation
      if (get<ErrorType>(follow(ty)))
        ty = nullptr;
    }

    if (!ty)
      ty = rhsIsTable          ? freshType(scope)
           : isNonstrictMode() ? anyType
                               : freshType(scope);

    varBindings.emplace_back(vars[i], Binding{ty, vars[i]->location});

    variableTypes.push_back(ty);
    expectedTypes.push_back(ty);

    // with FFlag::LuauInstantiateInSubtyping enabled, we shouldn't need to
    // produce instantiateGenerics at all.
    if (!FFlag::LuauInstantiateInSubtyping)
      instantiateGenerics.push_back(annotation != nullptr && !maybeGeneric(ty));
  }

  if (local.values.size > 0) {
    TypePackId variablePack = addTypePack(variableTypes, freshTypePack(scope));
    TypePackId valuePack = checkExprList(scope, local.location, local.values,
                                         /* substituteFreeForNil= */ true,
                                         instantiateGenerics, expectedTypes)
                               .type;

    // If the expression list only contains one expression and it's a function
    // call or is otherwise within parentheses, use FunctionResult. Otherwise,
    // we'll want to use ExprListResult to make the error messaging more
    // general.
    CountMismatch::Context ctx = CountMismatch::ExprListResult;
    if (local.values.size == 1) {
      AstExpr *e = local.values.data[0];
      while (auto group = e->as<AstExprGroup>())
        e = group->expr;
      if (e->is<AstExprCall>())
        ctx = CountMismatch::FunctionResult;
    }

    Unifier state = mkUnifier(scope, local.location);
    state.ctx = ctx;
    state.tryUnify(valuePack, variablePack);
    reportErrors(state.errors);

    state.log.commit();

    // In the code 'local T = {}', we wish to ascribe the name 'T' to the type
    // of the table for error-reporting purposes. We also want to do this for
    // 'local T = setmetatable(...)'.
    if (local.vars.size == 1 && local.values.size == 1) {
      const AstExpr *rhs = local.values.data[0];
      std::optional<TypeId> ty = first(valuePack);

      if (ty) {
        if (rhs->is<AstExprTable>()) {
          TableType *ttv = getMutable<TableType>(follow(*ty));
          if (ttv && !ttv->name && scope == currentModule->getModuleScope())
            ttv->syntheticName = vars[0]->name.value;
        } else if (const AstExprCall *call = rhs->as<AstExprCall>()) {
          if (const AstExprGlobal *global = call->func->as<AstExprGlobal>();
              global && global->name == "setmetatable") {
            MetatableType *mtv = getMutable<MetatableType>(follow(*ty));
            if (mtv)
              mtv->syntheticName = vars[0]->name.value;
          }
        }
      }
    }

    // Handle 'require' calls, we need to import exported type bindings into the
    // variable 'namespace' and to update binding type in non-strict mode
    for (size_t i = 0; i < local.values.size && i < local.vars.size; ++i) {
      const AstExprCall *call = local.values.data[i]->as<AstExprCall>();
      if (!call)
        continue;

      if (auto maybeRequire = matchRequire(*call)) {
        AstExpr *require = *maybeRequire;

        if (auto moduleInfo =
                resolver->resolveModuleInfo(currentModule->name, *require)) {
          const Name name{local.vars.data[i]->name.value};

          if (ModulePtr module = resolver->getModule(moduleInfo->name)) {
            scope->importedTypeBindings[name] = module->exportedTypeBindings;
            scope->importedModules[name] = moduleInfo->name;

            // Imported types of requires that transitively refer to current
            // module have to be replaced with 'any'
            for (const auto &[location, path] : requireCycles) {
              if (!path.empty() && path.front() == moduleInfo->name) {
                for (auto &[name, tf] : scope->importedTypeBindings[name])
                  tf = TypeFun{{}, {}, anyType};
              }
            }
          }

          // In non-strict mode we force the module type on the variable, in
          // strict mode it is already unified
          if (isNonstrictMode()) {
            auto [types, tail] = flatten(valuePack);

            if (i < types.size())
              varBindings[i].second.typeId = types[i];
          }
        }
      }
    }
  }

  for (const auto &[local, binding] : varBindings)
    scope->bindings[local] = binding;

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope, const AstStatFor &expr) {
  ScopePtr loopScope = childScope(scope, expr.location);

  TypeId loopVarType = numberType;
  if (expr.var->annotation)
    unify(loopVarType, resolveType(scope, *expr.var->annotation), scope,
          expr.location);

  loopScope->bindings[expr.var] = {loopVarType, expr.var->location};

  if (!expr.from)
    ice("Bad AstStatFor has no from expr");

  if (!expr.to)
    ice("Bad AstStatFor has no to expr");

  unify(checkExpr(loopScope, *expr.from).type, loopVarType, scope,
        expr.from->location);
  unify(checkExpr(loopScope, *expr.to).type, loopVarType, scope,
        expr.to->location);

  if (expr.step)
    unify(checkExpr(loopScope, *expr.step).type, loopVarType, scope,
          expr.step->location);

  check(loopScope, *expr.body);

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatForIn &forin) {
  ScopePtr loopScope = childScope(scope, forin.location);

  AstLocal **vars = forin.vars.data;

  std::vector<TypeId> varTypes;
  varTypes.reserve(forin.vars.size);

  for (size_t i = 0; i < forin.vars.size; ++i) {
    AstType *ann = vars[i]->annotation;
    TypeId ty =
        ann ? resolveType(scope, *ann) : anyIfNonstrict(freshType(loopScope));

    loopScope->bindings[vars[i]] = {ty, vars[i]->location};
    varTypes.push_back(ty);
  }

  AstExpr **values = forin.values.data;
  AstExpr *firstValue = forin.values.data[0];

  // next is a function that takes Table<K, V> and an optional index of type K
  //      next<K, V>(t: Table<K, V>, index: K | nil) -> (K?, V)
  // however, pairs and ipairs are quite messy, but they both share the same
  // types pairs returns 'next, t, nil', thus the type would be
  //      pairs<K, V>(t: Table<K, V>) -> ((Table<K, V>, K | nil) -> (K?, V),
  //      Table<K, V>, K | nil)
  // ipairs returns 'next, t, 0', thus ipairs will also share the same type as
  // pairs, except K = number
  //
  // we can also define our own custom iterators by by returning a wrapped
  // coroutine that calls coroutine.yield and most custom iterators does not
  // return a table state, or returns a function that takes no additional
  // arguments, making it optional so we up with this catch-all type constraint
  // that works for all use cases
  //      <K, V, R>(free) -> ((free) -> R, Table<K, V> | nil, K | nil)

  if (!firstValue)
    ice("expected at least an iterator function value, but we parsed nothing");

  TypeId iterTy = nullptr;
  TypePackId callRetPack = nullptr;

  if (forin.values.size == 1 && firstValue->is<AstExprCall>()) {
    AstExprCall *exprCall = firstValue->as<AstExprCall>();
    callRetPack = checkExprPack(scope, *exprCall).type;
    callRetPack = follow(callRetPack);

    if (get<FreeTypePack>(callRetPack)) {
      iterTy = freshType(scope);
      unify(callRetPack, addTypePack({{iterTy}, freshTypePack(scope)}), scope,
            forin.location);
    } else if (get<Unifiable::Error>(callRetPack) || !first(callRetPack)) {
      for (TypeId var : varTypes)
        unify(errorRecoveryType(scope), var, scope, forin.location);

      return check(loopScope, *forin.body);
    } else {
      iterTy = *first(callRetPack);
      iterTy = instantiate(scope, iterTy, exprCall->location);
    }
  } else {
    iterTy = instantiate(scope, checkExpr(scope, *firstValue).type,
                         firstValue->location);
  }

  iterTy = stripFromNilAndReport(iterTy, firstValue->location);

  if (std::optional<TypeId> iterMM = findMetatableEntry(
          iterTy, "__iter", firstValue->location, /* addErrors= */ true)) {
    // if __iter metamethod is present, it will be called and the results are
    // going to be called as if they are functions
    // TODO: this needs to typecheck all returned values by __iter as if they
    // were for loop arguments the structure of the function makes it difficult
    // to do this especially since we don't have actual expressions, only types
    for (TypeId var : varTypes)
      unify(anyType, var, scope, forin.location);

    return check(loopScope, *forin.body);
  }

  if (const TableType *iterTable = get<TableType>(iterTy)) {
    // TODO: note that this doesn't cleanly handle iteration over mixed tables
    // and tables without an indexer this behavior is more or less consistent
    // with what we do for pairs(), but really both are pretty wrong and need
    // revisiting
    if (iterTable->indexer) {
      if (varTypes.size() > 0)
        unify(iterTable->indexer->indexType, varTypes[0], scope,
              forin.location);

      if (varTypes.size() > 1)
        unify(iterTable->indexer->indexResultType, varTypes[1], scope,
              forin.location);

      for (size_t i = 2; i < varTypes.size(); ++i)
        unify(nilType, varTypes[i], scope, forin.location);
    } else if (isNonstrictMode() ||
               FFlag::LuauOkWithIteratingOverTableProperties) {
      for (TypeId var : varTypes)
        unify(unknownType, var, scope, forin.location);
    } else {
      TypeId varTy = errorRecoveryType(loopScope);

      for (TypeId var : varTypes)
        unify(varTy, var, scope, forin.location);

      reportError(firstValue->location,
                  GenericError{"Cannot iterate over a table without indexer"});
    }

    return check(loopScope, *forin.body);
  }

  const FunctionType *iterFunc = get<FunctionType>(iterTy);
  if (!iterFunc) {
    TypeId varTy =
        get<AnyType>(iterTy) ? anyType : errorRecoveryType(loopScope);

    for (TypeId var : varTypes)
      unify(varTy, var, scope, forin.location);

    if (!get<ErrorType>(iterTy) && !get<AnyType>(iterTy) &&
        !get<FreeType>(iterTy) && !get<NeverType>(iterTy))
      reportError(firstValue->location, CannotCallNonFunction{iterTy});

    return check(loopScope, *forin.body);
  }

  if (forin.values.size == 1) {
    TypePackId argPack = nullptr;
    if (firstValue->is<AstExprCall>()) {
      // Extract the remaining return values of the call
      // and check them against the parameter types of the iterator function.
      auto [types, tail] = flatten(callRetPack);
      std::vector<TypeId> argTypes =
          std::vector<TypeId>(types.begin() + 1, types.end());
      argPack = addTypePack(TypePackVar{TypePack{std::move(argTypes), tail}});
    } else {
      // Check if iterator function accepts 0 arguments
      argPack = addTypePack(TypePack{});
    }

    Unifier state = mkUnifier(loopScope, firstValue->location);
    checkArgumentList(loopScope, *firstValue, state, argPack,
                      iterFunc->argTypes, /*argLocations*/ {});

    state.log.commit();

    reportErrors(state.errors);
  }

  TypePackId retPack = iterFunc->retTypes;

  if (forin.values.size >= 2) {
    AstArray<AstExpr *> arguments{forin.values.data + 1, forin.values.size - 1};

    Position start = firstValue->location.begin;
    Position end = values[forin.values.size - 1]->location.end;
    AstExprCall exprCall{Location(start, end), firstValue, arguments,
                         /* self= */ false, Location()};

    retPack = checkExprPack(scope, exprCall).type;
  }

  // We need to remove 'nil' from the set of options of the first return value
  // Because for loop stops when it gets 'nil', this result is never actually
  // assigned to the first variable
  if (std::optional<TypeId> fty = first(retPack); fty && !varTypes.empty()) {
    TypeId keyTy = follow(*fty);

    if (get<UnionType>(keyTy)) {
      if (std::optional<TypeId> ty = tryStripUnionFromNil(keyTy))
        keyTy = *ty;
    }

    unify(keyTy, varTypes.front(), scope, forin.location);

    // We have already handled the first variable type, make it match in the
    // pack check
    varTypes.front() = *fty;
  }

  TypePackId varPack =
      addTypePack(TypePackVar{TypePack{varTypes, freshTypePack(scope)}});

  unify(retPack, varPack, scope, forin.location);

  check(loopScope, *forin.body);

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope, TypeId ty,
                               const ScopePtr &funScope,
                               const AstStatFunction &function) {
  if (auto exprName = function.name->as<AstExprGlobal>()) {
    auto &globalBindings = currentModule->getModuleScope()->bindings;
    Symbol name = exprName->name;
    Name globalName = exprName->name.value;

    Binding oldBinding;
    bool previouslyDefined = isNonstrictMode() && globalBindings.count(name);

    if (previouslyDefined) {
      oldBinding = globalBindings[name];
    }

    globalBindings[name] = {ty, exprName->location};
    checkFunctionBody(funScope, ty, *function.func);

    // If in nonstrict mode and allowing redefinition of global function,
    // restore the previous definition type in case this function has a
    // differing signature. The signature discrepancy will be caught in
    // checkBlock.
    if (previouslyDefined)
      globalBindings[name] = oldBinding;
    else
      globalBindings[name] = {quantify(funScope, ty, exprName->location),
                              exprName->location};
  } else if (auto name = function.name->as<AstExprLocal>()) {
    scope->bindings[name->local] = {ty, name->local->location};

    checkFunctionBody(funScope, ty, *function.func);

    scope->bindings[name->local] = {
        anyIfNonstrict(quantify(funScope, ty, name->local->location)),
        name->local->location};
  } else if (auto name = function.name->as<AstExprIndexName>()) {
    TypeId exprTy = checkExpr(scope, *name->expr).type;
    TableType *ttv = getMutableTableType(exprTy);

    if (!getIndexTypeFromType(scope, exprTy, name->index.value,
                              name->indexLocation, /* addErrors= */ false)) {
      if (ttv || isTableIntersection(exprTy))
        reportError(
            TypeError{function.location,
                      CannotExtendTable{exprTy, CannotExtendTable::Property,
                                        name->index.value}});
      else
        reportError(
            TypeError{function.location, OnlyTablesCanHaveMethods{exprTy}});
    }

    ty = follow(ty);

    if (ttv && ttv->state != TableState::Sealed)
      ttv->props[name->index.value] = {
          ty, /* deprecated */ false, {}, name->indexLocation};

    if (function.func->self) {
      const FunctionType *funTy = get<FunctionType>(ty);
      if (!funTy)
        ice("Methods should be functions");

      std::optional<TypeId> arg0 = first(funTy->argTypes);
      if (!arg0)
        ice("Methods should always have at least 1 argument (self)");
    }

    checkFunctionBody(funScope, ty, *function.func);

    InplaceDemoter demoter{funScope->level, &currentModule->internalTypes};
    demoter.traverse(ty);

    if (ttv && ttv->state != TableState::Sealed)
      ttv->props[name->index.value] = {
          follow(quantify(funScope, ty, name->indexLocation)),
          /* deprecated */ false,
          {},
          name->indexLocation};
  } else {
    LUAU_ASSERT(function.name->is<AstExprError>());

    ty = follow(ty);

    checkFunctionBody(funScope, ty, *function.func);
  }

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope, TypeId ty,
                               const ScopePtr &funScope,
                               const AstStatLocalFunction &function) {
  Name name = function.name->name.value;

  scope->bindings[function.name] = {ty, function.location};

  checkFunctionBody(funScope, ty, *function.func);

  scope->bindings[function.name] = {
      quantify(funScope, ty, function.name->location), function.name->location};

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatTypeAlias &typealias) {
  Name name = typealias.name.value;

  // If the alias is missing a name, we can't do anything with it.  Ignore it.
  if (name == kParseNameError)
    return ControlFlow::None;

  if (name == "typeof") {
    reportError(typealias.location,
                GenericError{"Type aliases cannot be named typeof"});
    return ControlFlow::None;
  }

  std::optional<TypeFun> binding;
  if (auto it = scope->exportedTypeBindings.find(name);
      it != scope->exportedTypeBindings.end())
    binding = it->second;
  else if (auto it = scope->privateTypeBindings.find(name);
           it != scope->privateTypeBindings.end())
    binding = it->second;

  auto &bindingsMap = typealias.exported ? scope->exportedTypeBindings
                                         : scope->privateTypeBindings;

  // If the first pass failed (this should mean a duplicate definition), the
  // second pass isn't going to be interesting.
  if (duplicateTypeAliases.find({typealias.exported, name}))
    return ControlFlow::None;

  // By now this alias must have been `prototype()`d first.
  if (!binding)
    ice("Not predeclared");

  ScopePtr aliasScope = childScope(scope, typealias.location);
  aliasScope->level = scope->level.incr();

  for (auto param : binding->typeParams) {
    auto generic = get<GenericType>(param.ty);
    LUAU_ASSERT(generic);
    aliasScope->privateTypeBindings[generic->name] = TypeFun{{}, param.ty};
  }

  for (auto param : binding->typePackParams) {
    auto generic = get<GenericTypePack>(param.tp);
    LUAU_ASSERT(generic);
    aliasScope->privateTypePackBindings[generic->name] = param.tp;
  }

  TypeId ty = resolveType(aliasScope, *typealias.type);
  if (auto ttv = getMutable<TableType>(follow(ty))) {
    // If the table is already named and we want to rename the type function, we
    // have to bind new alias to a copy Additionally, we can't modify types that
    // come from other modules
    if (ttv->name || follow(ty)->owningArena != &currentModule->internalTypes) {
      bool sameTys =
          std::equal(ttv->instantiatedTypeParams.begin(),
                     ttv->instantiatedTypeParams.end(),
                     binding->typeParams.begin(), binding->typeParams.end(),
                     [](auto &&itp, auto &&tp) { return itp == tp.ty; });
      bool sameTps = std::equal(
          ttv->instantiatedTypePackParams.begin(),
          ttv->instantiatedTypePackParams.end(),
          binding->typePackParams.begin(), binding->typePackParams.end(),
          [](auto &&itpp, auto &&tpp) { return itpp == tpp.tp; });

      // Copy can be skipped if this is an identical alias
      if (!ttv->name || ttv->name != name || !sameTys || !sameTps) {
        // This is a shallow clone, original recursive links to self are not
        // updated
        TableType clone =
            TableType{ttv->props, ttv->indexer, ttv->level, ttv->state};
        clone.definitionModuleName = ttv->definitionModuleName;
        clone.definitionLocation = ttv->definitionLocation;
        clone.name = name;

        for (auto param : binding->typeParams)
          clone.instantiatedTypeParams.push_back(param.ty);

        for (auto param : binding->typePackParams)
          clone.instantiatedTypePackParams.push_back(param.tp);

        ty = addType(std::move(clone));
      }
    } else {
      ttv->name = name;

      ttv->instantiatedTypeParams.clear();
      for (auto param : binding->typeParams)
        ttv->instantiatedTypeParams.push_back(param.ty);

      ttv->instantiatedTypePackParams.clear();
      for (auto param : binding->typePackParams)
        ttv->instantiatedTypePackParams.push_back(param.tp);
    }
  } else if (auto mtv = getMutable<MetatableType>(follow(ty))) {
    // We can't modify types that come from other modules
    if (follow(ty)->owningArena == &currentModule->internalTypes)
      mtv->syntheticName = name;
  }

  TypeId &bindingType = bindingsMap[name].type;

  unify(ty, bindingType, aliasScope, typealias.location);

  // It is possible for this unification to succeed but for
  // `bindingType` still to be free For example, in
  // `type T = T|T`, we generate a fresh free type `X`, and then
  // unify `X` with `X|X`, which succeeds without binding `X` to
  // anything, since `X <: X|X`
  if (bindingType->ty.get_if<FreeType>()) {
    ty = errorRecoveryType(aliasScope);
    unify(ty, bindingType, aliasScope, typealias.location);
    reportError(TypeError{typealias.location, OccursCheckFailed{}});
  }

  bindingType = ty;
  return ControlFlow::None;
}

void TypeChecker::prototype(const ScopePtr &scope,
                            const AstStatTypeAlias &typealias, int subLevel) {
  Name name = typealias.name.value;

  // If the alias is missing a name, we can't do anything with it.  Ignore it.
  // Also, typeof is not a valid type alias name.  We will report an error for
  // this in check()
  if (name == kParseNameError || name == "typeof")
    return;

  std::optional<TypeFun> binding;
  if (auto it = scope->exportedTypeBindings.find(name);
      it != scope->exportedTypeBindings.end())
    binding = it->second;
  else if (auto it = scope->privateTypeBindings.find(name);
           it != scope->privateTypeBindings.end())
    binding = it->second;

  auto &bindingsMap = typealias.exported ? scope->exportedTypeBindings
                                         : scope->privateTypeBindings;

  if (binding) {
    Location location = scope->typeAliasLocations[name];
    reportError(
        TypeError{typealias.location, DuplicateTypeDefinition{name, location}});

    duplicateTypeAliases.insert({typealias.exported, name});
  } else {
    if (globalScope->builtinTypeNames.contains(name)) {
      reportError(typealias.location, DuplicateTypeDefinition{name});
      duplicateTypeAliases.insert({typealias.exported, name});
    } else {
      ScopePtr aliasScope = childScope(scope, typealias.location);
      aliasScope->level = scope->level.incr();
      aliasScope->level.subLevel = subLevel;

      auto [generics, genericPacks] = createGenericTypes(
          aliasScope, scope->level, typealias, typealias.generics,
          typealias.genericPacks, /* useCache = */ true);

      TypeId ty = freshType(aliasScope);
      FreeType *ftv = getMutable<FreeType>(ty);
      LUAU_ASSERT(ftv);
      ftv->forwardedTypeAlias = true;
      bindingsMap[name] = {std::move(generics), std::move(genericPacks), ty};

      scope->typeAliasLocations[name] = typealias.location;
      scope->typeAliasNameLocations[name] = typealias.nameLocation;
    }
  }
}

void TypeChecker::prototype(const ScopePtr &scope,
                            const AstStatDeclareClass &declaredClass) {
  std::optional<TypeId> superTy = std::make_optional(builtinTypes->classType);
  if (declaredClass.superName) {
    Name superName = Name(declaredClass.superName->value);
    std::optional<TypeFun> lookupType = scope->lookupType(superName);

    if (!lookupType) {
      reportError(declaredClass.location,
                  UnknownSymbol{superName, UnknownSymbol::Type});
      incorrectClassDefinitions.insert(&declaredClass);
      return;
    }

    // We don't have generic classes, so this assertion _should_ never be hit.
    LUAU_ASSERT(lookupType->typeParams.size() == 0 &&
                lookupType->typePackParams.size() == 0);
    superTy = lookupType->type;

    if (!get<ClassType>(follow(*superTy))) {
      reportError(
          declaredClass.location,
          GenericError{format(
              "Cannot use non-class type '%s' as a superclass of class '%s'",
              superName.c_str(), declaredClass.name.value)});
      incorrectClassDefinitions.insert(&declaredClass);
      return;
    }
  }

  Name className(declaredClass.name.value);

  TypeId classTy = addType(ClassType(className, {}, superTy, std::nullopt, {},
                                     {}, currentModule->name));
  ClassType *ctv = getMutable<ClassType>(classTy);
  TypeId metaTy = addType(TableType{TableState::Sealed, scope->level});

  ctv->metatable = metaTy;
  scope->exportedTypeBindings[className] = TypeFun{{}, classTy};
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatDeclareClass &declaredClass) {
  Name className(declaredClass.name.value);

  // Don't bother checking if the class definition was incorrect
  if (incorrectClassDefinitions.find(&declaredClass))
    return ControlFlow::None;

  std::optional<TypeFun> binding;
  if (auto it = scope->exportedTypeBindings.find(className);
      it != scope->exportedTypeBindings.end())
    binding = it->second;

  // This class definition must have been `prototype()`d first.
  if (!binding)
    ice("Class not predeclared");

  TypeId classTy = binding->type;
  ClassType *ctv = getMutable<ClassType>(classTy);

  if (!ctv->metatable)
    ice("No metatable for declared class");

  if (const auto &indexer = declaredClass.indexer)
    ctv->indexer = TableIndexer(resolveType(scope, *indexer->indexType),
                                resolveType(scope, *indexer->resultType));

  TableType *metatable = getMutable<TableType>(*ctv->metatable);
  for (const AstDeclaredClassProp &prop : declaredClass.props) {
    Name propName(prop.name.value);
    TypeId propTy = resolveType(scope, *prop.ty);

    bool assignToMetatable = isMetamethod(propName);
    Luau::ClassType::Props &assignTo =
        assignToMetatable ? metatable->props : ctv->props;

    // Function types always take 'self', but this isn't reflected in the
    // parsed annotation. Add it here.
    if (prop.isMethod) {
      if (FunctionType *ftv = getMutable<FunctionType>(propTy)) {
        ftv->argNames.insert(ftv->argNames.begin(),
                             FunctionArgument{"self", {}});
        ftv->argTypes = addTypePack(TypePack{{classTy}, ftv->argTypes});
        ftv->hasSelf = true;

        if (FFlag::LuauDeclarationExtraPropData) {
          FunctionDefinition defn;

          defn.definitionModuleName = currentModule->name;
          defn.definitionLocation = prop.location;
          // No data is preserved for varargLocation
          defn.originalNameLocation = prop.nameLocation;

          ftv->definition = defn;
        }
      }
    }

    if (assignTo.count(propName) == 0) {
      if (FFlag::LuauDeclarationExtraPropData)
        assignTo[propName] = {propTy, /*deprecated*/ false,
                              /*deprecatedSuggestion*/ "", prop.location};
      else
        assignTo[propName] = {propTy};
    } else if (FFlag::LuauDeclarationExtraPropData) {
      Luau::Property &prop = assignTo[propName];
      TypeId currentTy = prop.type();

      // We special-case this logic to keep the intersection flat; otherwise we
      // would create a ton of nested intersection types.
      if (const IntersectionType *itv = get<IntersectionType>(currentTy)) {
        std::vector<TypeId> options = itv->parts;
        options.push_back(propTy);
        TypeId newItv = addType(IntersectionType{std::move(options)});

        prop.readTy = newItv;
        prop.writeTy = newItv;
      } else if (get<FunctionType>(currentTy)) {
        TypeId intersection = addType(IntersectionType{{currentTy, propTy}});

        prop.readTy = intersection;
        prop.writeTy = intersection;
      } else {
        reportError(declaredClass.location,
                    GenericError{
                        format("Cannot overload non-function class member '%s'",
                               propName.c_str())});
      }
    } else {
      TypeId currentTy = assignTo[propName].type();

      // We special-case this logic to keep the intersection flat; otherwise we
      // would create a ton of nested intersection types.
      if (const IntersectionType *itv = get<IntersectionType>(currentTy)) {
        std::vector<TypeId> options = itv->parts;
        options.push_back(propTy);
        TypeId newItv = addType(IntersectionType{std::move(options)});

        assignTo[propName] = {newItv};
      } else if (get<FunctionType>(currentTy)) {
        TypeId intersection = addType(IntersectionType{{currentTy, propTy}});

        assignTo[propName] = {intersection};
      } else {
        reportError(declaredClass.location,
                    GenericError{
                        format("Cannot overload non-function class member '%s'",
                               propName.c_str())});
      }
    }
  }

  return ControlFlow::None;
}

ControlFlow TypeChecker::check(const ScopePtr &scope,
                               const AstStatDeclareFunction &global) {
  ScopePtr funScope = childFunctionScope(scope, global.location);

  auto [generics, genericPacks] = createGenericTypes(
      funScope, std::nullopt, global, global.generics, global.genericPacks);

  std::vector<TypeId> genericTys;
  genericTys.reserve(generics.size());
  std::transform(generics.begin(), generics.end(),
                 std::back_inserter(genericTys),
                 [](auto &&el) { return el.ty; });

  std::vector<TypePackId> genericTps;
  genericTps.reserve(genericPacks.size());
  std::transform(genericPacks.begin(), genericPacks.end(),
                 std::back_inserter(genericTps),
                 [](auto &&el) { return el.tp; });

  TypePackId argPack = resolveTypePack(funScope, global.params);
  TypePackId retPack = resolveTypePack(funScope, global.retTypes);

  FunctionDefinition defn;

  if (FFlag::LuauDeclarationExtraPropData) {
    defn.definitionModuleName = currentModule->name;
    defn.definitionLocation = global.location;
    defn.varargLocation = global.vararg
                              ? std::make_optional(global.varargLocation)
                              : std::nullopt;
    defn.originalNameLocation = global.nameLocation;
  }

  TypeId fnType =
      addType(FunctionType{funScope->level, std::move(genericTys),
                           std::move(genericTps), argPack, retPack, defn});
  FunctionType *ftv = getMutable<FunctionType>(fnType);

  ftv->argNames.reserve(global.paramNames.size);
  for (const auto &el : global.paramNames)
    ftv->argNames.push_back(FunctionArgument{el.first.value, el.second});

  Name fnName(global.name.value);

  currentModule->declaredGlobals[fnName] = fnType;
  currentModule->getModuleScope()->bindings[global.name] =
      Binding{fnType, global.location};

  return ControlFlow::None;
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExpr &expr,
                                             std::optional<TypeId> expectedType,
                                             bool forceSingleton) {
  RecursionCounter _rc(&checkRecursionCount);
  if (FInt::LuauCheckRecursionLimit > 0 &&
      checkRecursionCount >= FInt::LuauCheckRecursionLimit) {
    reportErrorCodeTooComplex(expr.location);
    return WithPredicate{errorRecoveryType(scope)};
  }

  WithPredicate<TypeId> result;

  if (auto a = expr.as<AstExprGroup>())
    result = checkExpr(scope, *a->expr, expectedType);
  else if (expr.is<AstExprConstantNil>())
    result = WithPredicate{nilType};
  else if (const AstExprConstantBool *bexpr = expr.as<AstExprConstantBool>()) {
    if (forceSingleton || (expectedType && maybeSingleton(*expectedType)))
      result = WithPredicate{singletonType(bexpr->value)};
    else
      result = WithPredicate{booleanType};
  } else if (const AstExprConstantString *sexpr =
                 expr.as<AstExprConstantString>()) {
    if (forceSingleton || (expectedType && maybeSingleton(*expectedType)))
      result = WithPredicate{
          singletonType(std::string(sexpr->value.data, sexpr->value.size))};
    else
      result = WithPredicate{stringType};
  } else if (expr.is<AstExprConstantNumber>())
    result = WithPredicate{numberType};
  else if (auto a = expr.as<AstExprLocal>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprGlobal>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprVarargs>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprCall>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprIndexName>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprIndexExpr>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprFunction>())
    result = checkExpr(scope, *a, expectedType);
  else if (auto a = expr.as<AstExprTable>())
    result = checkExpr(scope, *a, expectedType);
  else if (auto a = expr.as<AstExprUnary>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprBinary>())
    result = checkExpr(scope, *a, expectedType);
  else if (auto a = expr.as<AstExprTypeAssertion>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprError>())
    result = checkExpr(scope, *a);
  else if (auto a = expr.as<AstExprIfElse>())
    result = checkExpr(scope, *a, expectedType);
  else if (auto a = expr.as<AstExprInterpString>())
    result = checkExpr(scope, *a);
  else
    ice("Unhandled AstExpr?");

  result.type = follow(result.type);

  if (!currentModule->astTypes.find(&expr))
    currentModule->astTypes[&expr] = result.type;

  if (expectedType)
    currentModule->astExpectedTypes[&expr] = *expectedType;

  return result;
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprLocal &expr) {
  std::optional<LValue> lvalue = tryGetLValue(expr);
  LUAU_ASSERT(
      lvalue); // Guaranteed to not be nullopt - AstExprLocal is an LValue.

  if (std::optional<TypeId> ty = resolveLValue(scope, *lvalue))
    return {*ty, {TruthyPredicate{std::move(*lvalue), expr.location}}};

  // TODO: tempting to ice here, but this breaks very often because our toposort
  // doesn't enforce this constraint ice("AstExprLocal exists but no binding
  // definition for it?", expr.location);
  reportError(TypeError{expr.location, UnknownSymbol{expr.local->name.value,
                                                     UnknownSymbol::Binding}});
  return WithPredicate{errorRecoveryType(scope)};
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprGlobal &expr) {
  std::optional<LValue> lvalue = tryGetLValue(expr);
  LUAU_ASSERT(
      lvalue); // Guaranteed to not be nullopt - AstExprGlobal is an LValue.

  if (std::optional<TypeId> ty = resolveLValue(scope, *lvalue))
    return {*ty, {TruthyPredicate{std::move(*lvalue), expr.location}}};

  reportError(TypeError{
      expr.location, UnknownSymbol{expr.name.value, UnknownSymbol::Binding}});
  return WithPredicate{errorRecoveryType(scope)};
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprVarargs &expr) {
  TypePackId varargPack = checkExprPack(scope, expr).type;

  if (get<TypePack>(varargPack)) {
    if (std::optional<TypeId> ty = first(varargPack))
      return WithPredicate{*ty};

    return WithPredicate{nilType};
  } else if (get<FreeTypePack>(varargPack)) {
    TypeId head = freshType(scope);
    TypePackId tail = freshTypePack(scope);
    *asMutable(varargPack) = TypePack{{head}, tail};
    return WithPredicate{head};
  }
  if (get<ErrorType>(varargPack))
    return WithPredicate{errorRecoveryType(scope)};
  else if (auto vtp = get<VariadicTypePack>(varargPack))
    return WithPredicate{vtp->ty};
  else if (get<GenericTypePack>(varargPack)) {
    // TODO: Better error?
    reportError(
        expr.location,
        GenericError{"Trying to get a type from a variadic type parameter"});
    return WithPredicate{errorRecoveryType(scope)};
  } else
    ice("Unknown TypePack type in checkExpr(AstExprVarargs)!");
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprCall &expr) {
  WithPredicate<TypePackId> result = checkExprPack(scope, expr);
  TypePackId retPack = follow(result.type);

  if (auto pack = get<TypePack>(retPack)) {
    return {pack->head.empty() ? nilType : pack->head[0],
            std::move(result.predicates)};
  } else if (const FreeTypePack *ftp = get<FreeTypePack>(retPack)) {
    TypeId head = freshType(scope->level);
    TypePackId pack =
        addTypePack(TypePackVar{TypePack{{head}, freshTypePack(scope->level)}});
    unify(pack, retPack, scope, expr.location);
    return {head, std::move(result.predicates)};
  }
  if (get<Unifiable::Error>(retPack))
    return {errorRecoveryType(scope), std::move(result.predicates)};
  else if (auto vtp = get<VariadicTypePack>(retPack))
    return {vtp->ty, std::move(result.predicates)};
  else if (get<GenericTypePack>(retPack))
    return {anyType, std::move(result.predicates)};
  else
    ice("Unknown TypePack type!", expr.location);
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprIndexName &expr) {
  Name name = expr.index.value;

  // Redundant call if we find a refined lvalue, but this function must be
  // called in order to recursively populate astTypes.
  TypeId lhsType = checkExpr(scope, *expr.expr).type;

  if (std::optional<LValue> lvalue = tryGetLValue(expr))
    if (std::optional<TypeId> ty = resolveLValue(scope, *lvalue))
      return {*ty, {TruthyPredicate{std::move(*lvalue), expr.location}}};

  lhsType = stripFromNilAndReport(lhsType, expr.expr->location);

  if (std::optional<TypeId> ty = getIndexTypeFromType(
          scope, lhsType, name, expr.location, /* addErrors= */ true))
    return WithPredicate{*ty};

  return WithPredicate{errorRecoveryType(scope)};
}

std::optional<TypeId> TypeChecker::findTablePropertyRespectingMeta(
    TypeId lhsType, Name name, const Location &location, bool addErrors) {
  ErrorVec errors;
  auto result = Luau::findTablePropertyRespectingMeta(builtinTypes, errors,
                                                      lhsType, name, location);
  if (addErrors)
    reportErrors(errors);
  return result;
}

std::optional<TypeId> TypeChecker::findMetatableEntry(TypeId type,
                                                      std::string entry,
                                                      const Location &location,
                                                      bool addErrors) {
  ErrorVec errors;
  auto result =
      Luau::findMetatableEntry(builtinTypes, errors, type, entry, location);
  if (addErrors)
    reportErrors(errors);
  return result;
}

std::optional<TypeId>
TypeChecker::getIndexTypeFromType(const ScopePtr &scope, TypeId type,
                                  const Name &name, const Location &location,
                                  bool addErrors) {
  size_t errorCount = currentModule->errors.size();

  std::optional<TypeId> result =
      getIndexTypeFromTypeImpl(scope, type, name, location, addErrors);

  if (!addErrors)
    LUAU_ASSERT(errorCount == currentModule->errors.size());

  return result;
}

std::optional<TypeId> TypeChecker::getIndexTypeFromTypeImpl(
    const ScopePtr &scope, TypeId type, const Name &name,
    const Location &location, bool addErrors) {
  type = follow(type);

  if (get<ErrorType>(type) || get<AnyType>(type) || get<NeverType>(type))
    return type;

  tablify(type);

  if (isString(type)) {
    std::optional<TypeId> mtIndex =
        findMetatableEntry(stringType, "__index", location, addErrors);
    LUAU_ASSERT(mtIndex);
    type = *mtIndex;
  }

  if (TableType *tableType = getMutableTableType(type)) {
    if (auto it = tableType->props.find(name); it != tableType->props.end())
      return it->second.type();
    else if (auto indexer = tableType->indexer) {
      // TODO: Property lookup should work with string singletons or unions
      // thereof as the indexer key type.
      ErrorVec errors =
          tryUnify(stringType, indexer->indexType, scope, location);

      if (errors.empty())
        return indexer->indexResultType;

      if (addErrors)
        reportError(location, UnknownProperty{type, name});

      return std::nullopt;
    } else if (tableType->state == TableState::Free) {
      TypeId result = freshType(tableType->level);
      tableType->props[name] = {result};
      return result;
    }

    if (auto found =
            findTablePropertyRespectingMeta(type, name, location, addErrors))
      return *found;
  } else if (const ClassType *cls = get<ClassType>(type)) {
    const Property *prop = lookupClassProp(cls, name);
    if (prop)
      return prop->type();

    if (auto indexer = cls->indexer) {
      // TODO: Property lookup should work with string singletons or unions
      // thereof as the indexer key type.
      ErrorVec errors =
          tryUnify(stringType, indexer->indexType, scope, location);

      if (errors.empty())
        return indexer->indexResultType;

      if (addErrors)
        reportError(location, UnknownProperty{type, name});

      return std::nullopt;
    }
  } else if (const UnionType *utv = get<UnionType>(type)) {
    std::vector<TypeId> goodOptions;
    std::vector<TypeId> badOptions;

    for (TypeId t : utv) {
      RecursionLimiter _rl(&recursionCount, FInt::LuauTypeInferRecursionLimit);

      // Not needed when we normalize types.
      if (get<AnyType>(follow(t)))
        return t;

      if (std::optional<TypeId> ty = getIndexTypeFromType(
              scope, t, name, location, /* addErrors= */ false))
        goodOptions.push_back(*ty);
      else
        badOptions.push_back(t);
    }

    if (!badOptions.empty()) {
      if (addErrors) {
        if (goodOptions.empty())
          reportError(location, UnknownProperty{type, name});
        else
          reportError(location, MissingUnionProperty{type, badOptions, name});
      }
      return std::nullopt;
    }

    std::vector<TypeId> result = reduceUnion(goodOptions);
    if (result.empty())
      return neverType;

    if (result.size() == 1)
      return result[0];

    return addType(UnionType{std::move(result)});
  } else if (const IntersectionType *itv = get<IntersectionType>(type)) {
    std::vector<TypeId> parts;

    for (TypeId t : itv->parts) {
      RecursionLimiter _rl(&recursionCount, FInt::LuauTypeInferRecursionLimit);

      if (std::optional<TypeId> ty = getIndexTypeFromType(
              scope, t, name, location, /* addErrors= */ false))
        parts.push_back(*ty);
    }

    // If no parts of the intersection had the property we looked up for, it
    // never existed at all.
    if (parts.empty()) {
      if (addErrors)
        reportError(location, UnknownProperty{type, name});
      return std::nullopt;
    }

    if (parts.size() == 1)
      return parts[0];

    return addType(IntersectionType{std::move(parts)}); // Not at all correct.
  }

  if (addErrors)
    reportError(location, UnknownProperty{type, name});

  return std::nullopt;
}

std::optional<TypeId> TypeChecker::tryStripUnionFromNil(TypeId ty) {
  if (const UnionType *utv = get<UnionType>(ty)) {
    if (!std::any_of(begin(utv), end(utv), isNil))
      return ty;

    std::vector<TypeId> result;

    for (TypeId option : utv) {
      if (!isNil(option))
        result.push_back(option);
    }

    if (result.empty())
      return std::nullopt;

    return result.size() == 1 ? result[0]
                              : addType(UnionType{std::move(result)});
  }

  return std::nullopt;
}

TypeId TypeChecker::stripFromNilAndReport(TypeId ty, const Location &location) {
  ty = follow(ty);

  if (auto utv = get<UnionType>(ty)) {
    if (!std::any_of(begin(utv), end(utv), isNil))
      return ty;
  }

  if (std::optional<TypeId> strippedUnion = tryStripUnionFromNil(ty)) {
    reportError(location, OptionalValueAccess{ty});
    return follow(*strippedUnion);
  }

  return ty;
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprIndexExpr &expr) {
  TypeId ty = checkLValue(scope, expr, ValueContext::RValue);

  if (std::optional<LValue> lvalue = tryGetLValue(expr))
    if (std::optional<TypeId> refiTy = resolveLValue(scope, *lvalue))
      return {*refiTy, {TruthyPredicate{std::move(*lvalue), expr.location}}};

  return WithPredicate{ty};
}

WithPredicate<TypeId>
TypeChecker::checkExpr(const ScopePtr &scope, const AstExprFunction &expr,
                       std::optional<TypeId> expectedType) {
  auto [funTy, funScope] = checkFunctionSignature(scope, 0, expr, std::nullopt,
                                                  std::nullopt, expectedType);

  checkFunctionBody(funScope, funTy, expr);

  return WithPredicate{quantify(funScope, funTy, expr.location)};
}

TypeId TypeChecker::checkExprTable(
    const ScopePtr &scope, const AstExprTable &expr,
    const std::vector<std::pair<TypeId, TypeId>> &fieldTypes,
    std::optional<TypeId> expectedType) {
  TableType::Props props;
  std::optional<TableIndexer> indexer;

  const TableType *expectedTable = nullptr;

  if (expectedType) {
    if (auto ttv = get<TableType>(follow(*expectedType))) {
      if (ttv->state == TableState::Sealed)
        expectedTable = ttv;
    }
  }

  for (size_t i = 0; i < expr.items.size; ++i) {
    const AstExprTable::Item &item = expr.items.data[i];

    AstExpr *k = item.key;
    AstExpr *value = item.value;

    auto [keyType, valueType] = fieldTypes[i];

    if (item.kind == AstExprTable::Item::List) {
      if (expectedTable && !indexer)
        indexer = expectedTable->indexer;

      if (indexer) {
        unify(numberType, indexer->indexType, scope, value->location);
        unify(valueType, indexer->indexResultType, scope, value->location);
      } else
        indexer = TableIndexer{numberType, anyIfNonstrict(valueType)};
    } else if (item.kind == AstExprTable::Item::Record ||
               item.kind == AstExprTable::Item::General) {
      if (auto key = k->as<AstExprConstantString>()) {
        TypeId exprType = follow(valueType);
        if (isNonstrictMode() && !getTableType(exprType) &&
            !get<FunctionType>(exprType))
          exprType = anyType;

        if (expectedTable) {
          auto it = expectedTable->props.find(key->value.data);
          if (it != expectedTable->props.end()) {
            Property expectedProp = it->second;
            ErrorVec errors =
                tryUnify(exprType, expectedProp.type(), scope, k->location);
            if (errors.empty())
              exprType = expectedProp.type();
          } else if (expectedTable->indexer &&
                     maybeString(expectedTable->indexer->indexType)) {
            ErrorVec errors =
                tryUnify(exprType, expectedTable->indexer->indexResultType,
                         scope, k->location);
            if (errors.empty())
              exprType = expectedTable->indexer->indexResultType;
          }
        }

        props[key->value.data] = {
            exprType, /* deprecated */ false, {}, k->location};
      } else {
        if (expectedTable && !indexer)
          indexer = expectedTable->indexer;

        if (indexer) {
          unify(keyType, indexer->indexType, scope, k->location);
          unify(valueType, indexer->indexResultType, scope, value->location);
        } else if (isNonstrictMode()) {
          indexer = TableIndexer{anyType, anyType};
        } else {
          indexer = TableIndexer{keyType, valueType};
        }
      }
    }
  }

  TableState state = TableState::Unsealed;
  TableType table = TableType{std::move(props), indexer, scope->level, state};
  table.definitionModuleName = currentModule->name;
  table.definitionLocation = expr.location;
  return addType(table);
}

WithPredicate<TypeId>
TypeChecker::checkExpr(const ScopePtr &scope, const AstExprTable &expr,
                       std::optional<TypeId> expectedType) {
  RecursionCounter _rc(&checkRecursionCount);
  if (FInt::LuauCheckRecursionLimit > 0 &&
      checkRecursionCount >= FInt::LuauCheckRecursionLimit) {
    reportErrorCodeTooComplex(expr.location);
    return WithPredicate{errorRecoveryType(scope)};
  }

  std::vector<std::pair<TypeId, TypeId>> fieldTypes(expr.items.size);

  const TableType *expectedTable = nullptr;
  const UnionType *expectedUnion = nullptr;
  std::optional<TypeId> expectedIndexType;
  std::optional<TypeId> expectedIndexResultType;

  if (expectedType) {
    if (auto ttv = get<TableType>(follow(*expectedType))) {
      if (ttv->state == TableState::Sealed) {
        expectedTable = ttv;

        if (ttv->indexer) {
          expectedIndexType = ttv->indexer->indexType;
          expectedIndexResultType = ttv->indexer->indexResultType;
        }
      }
    } else if (const UnionType *utv = get<UnionType>(follow(*expectedType)))
      expectedUnion = utv;
  }

  for (size_t i = 0; i < expr.items.size; ++i) {
    AstExprTable::Item &item = expr.items.data[i];
    std::optional<TypeId> expectedResultType;
    bool isIndexedItem = false;

    if (item.kind == AstExprTable::Item::List) {
      expectedResultType = expectedIndexResultType;
      isIndexedItem = true;
    } else if (item.kind == AstExprTable::Item::Record ||
               item.kind == AstExprTable::Item::General) {
      if (auto key = item.key->as<AstExprConstantString>()) {
        if (expectedTable) {
          if (auto prop = expectedTable->props.find(key->value.data);
              prop != expectedTable->props.end())
            expectedResultType = prop->second.type();
          else if (expectedIndexType && maybeString(*expectedIndexType))
            expectedResultType = expectedIndexResultType;
        } else if (expectedUnion) {
          std::vector<TypeId> expectedResultTypes;
          for (TypeId expectedOption : expectedUnion) {
            if (const TableType *ttv = get<TableType>(follow(expectedOption))) {
              if (auto prop = ttv->props.find(key->value.data);
                  prop != ttv->props.end())
                expectedResultTypes.push_back(prop->second.type());
              else if (ttv->indexer && maybeString(ttv->indexer->indexType))
                expectedResultTypes.push_back(ttv->indexer->indexResultType);
            }
          }

          if (expectedResultTypes.size() == 1)
            expectedResultType = expectedResultTypes[0];
          else if (expectedResultTypes.size() > 1)
            expectedResultType = addType(UnionType{expectedResultTypes});
        }
      } else {
        expectedResultType = expectedIndexResultType;
        isIndexedItem = true;
      }
    }

    fieldTypes[i].first =
        item.key ? checkExpr(scope, *item.key, expectedIndexType).type
                 : nullptr;
    fieldTypes[i].second =
        checkExpr(scope, *item.value, expectedResultType).type;

    // Indexer keys after the first are unified with the first one
    // If we don't have an expected indexer type yet, take this first item type
    if (isIndexedItem && !expectedIndexResultType)
      expectedIndexResultType = fieldTypes[i].second;
  }

  return WithPredicate{checkExprTable(scope, expr, fieldTypes, expectedType)};
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprUnary &expr) {
  WithPredicate<TypeId> result = checkExpr(scope, *expr.expr);
  TypeId operandType = follow(result.type);

  switch (expr.op) {
  case AstExprUnary::Not:
    return {booleanType, {NotPredicate{std::move(result.predicates)}}};
  case AstExprUnary::Minus: {
    const bool operandIsAny = get<AnyType>(operandType) ||
                              get<ErrorType>(operandType) ||
                              get<NeverType>(operandType);

    if (operandIsAny)
      return WithPredicate{operandType};

    if (typeCouldHaveMetatable(operandType)) {
      if (auto fnt = findMetatableEntry(operandType, "__unm", expr.location,
                                        /* addErrors= */ true)) {
        TypeId actualFunctionType = instantiate(scope, *fnt, expr.location);
        TypePackId arguments = addTypePack({operandType});
        TypePackId retTypePack = freshTypePack(scope);
        TypeId expectedFunctionType =
            addType(FunctionType(scope->level, arguments, retTypePack));

        Unifier state = mkUnifier(scope, expr.location);
        state.tryUnify(actualFunctionType, expectedFunctionType,
                       /*isFunctionCall*/ true);
        state.log.commit();

        reportErrors(state.errors);

        TypeId retType = first(retTypePack).value_or(nilType);
        if (!state.errors.empty())
          retType = errorRecoveryType(retType);

        return WithPredicate{retType};
      }

      reportError(
          expr.location,
          GenericError{format("Unary operator '%s' not supported by type '%s'",
                              toString(expr.op).c_str(),
                              toString(operandType).c_str())});
      return WithPredicate{errorRecoveryType(scope)};
    }

    reportErrors(tryUnify(operandType, numberType, scope, expr.location));
    return WithPredicate{numberType};
  }
  case AstExprUnary::Len: {
    tablify(operandType);

    operandType = stripFromNilAndReport(operandType, expr.location);

    // # operator is guaranteed to return number
    if (get<AnyType>(operandType) || get<ErrorType>(operandType) ||
        get<NeverType>(operandType))
      return WithPredicate{numberType};

    DenseHashSet<TypeId> seen{nullptr};

    if (typeCouldHaveMetatable(operandType)) {
      if (auto fnt = findMetatableEntry(operandType, "__len", expr.location,
                                        /* addErrors= */ true)) {
        TypeId actualFunctionType = instantiate(scope, *fnt, expr.location);
        TypePackId arguments = addTypePack({operandType});
        TypePackId retTypePack = addTypePack({numberType});
        TypeId expectedFunctionType =
            addType(FunctionType(scope->level, arguments, retTypePack));

        Unifier state = mkUnifier(scope, expr.location);
        state.tryUnify(actualFunctionType, expectedFunctionType,
                       /*isFunctionCall*/ true);
        state.log.commit();

        reportErrors(state.errors);
      }
    }

    if (!hasLength(operandType, seen, &recursionCount))
      reportError(TypeError{expr.location, NotATable{operandType}});

    return WithPredicate{numberType};
  }
  default:
    ice("Unknown AstExprUnary " + std::to_string(int(expr.op)));
  }
}

std::string opToMetaTableEntry(const AstExprBinary::Op &op) {
  switch (op) {
  case AstExprBinary::CompareNe:
  case AstExprBinary::CompareEq:
    return "__eq";
  case AstExprBinary::CompareLt:
  case AstExprBinary::CompareGe:
    return "__lt";
  case AstExprBinary::CompareLe:
  case AstExprBinary::CompareGt:
    return "__le";
  case AstExprBinary::Add:
    return "__add";
  case AstExprBinary::Sub:
    return "__sub";
  case AstExprBinary::Mul:
    return "__mul";
  case AstExprBinary::Div:
    return "__div";
  case AstExprBinary::FloorDiv:
    return "__idiv";
  case AstExprBinary::Mod:
    return "__mod";
  case AstExprBinary::Pow:
    return "__pow";
  case AstExprBinary::Concat:
    return "__concat";
  default:
    return "";
  }
}

TypeId TypeChecker::unionOfTypes(TypeId a, TypeId b, const ScopePtr &scope,
                                 const Location &location,
                                 bool unifyFreeTypes) {
  a = follow(a);
  b = follow(b);

  if (unifyFreeTypes && (get<FreeType>(a) || get<FreeType>(b))) {
    if (unify(b, a, scope, location))
      return a;

    return errorRecoveryType(anyType);
  }

  if (*a == *b)
    return a;

  std::vector<TypeId> types = reduceUnion({a, b});
  if (types.empty())
    return neverType;

  if (types.size() == 1)
    return types[0];

  return addType(UnionType{types});
}

static std::optional<std::string> getIdentifierOfBaseVar(AstExpr *node) {
  if (AstExprGlobal *expr = node->as<AstExprGlobal>())
    return expr->name.value;

  if (AstExprLocal *expr = node->as<AstExprLocal>())
    return expr->local->name.value;

  if (AstExprIndexExpr *expr = node->as<AstExprIndexExpr>())
    return getIdentifierOfBaseVar(expr->expr);

  if (AstExprIndexName *expr = node->as<AstExprIndexName>())
    return getIdentifierOfBaseVar(expr->expr);

  return std::nullopt;
}

/** Return true if comparison between the types a and b should be permitted with
 * the == or ~= operators.
 *
 * Two types are considered eligible for equality testing if it is possible for
 * the test to ever succeed.  In other words, we test to see whether the two
 * types have any overlap at all.
 *
 * In order to make things work smoothly with the greedy solver, this function
 * exempts any and FreeTypes from this requirement.
 *
 * This function does not (yet?) take into account extra Lua restrictions like
 * that two tables can only be compared if they have the same metatable.  That
 * is presently handled by the caller.
 *
 * @return True if the types are comparable.  False if they are not.
 *
 * If an internal recursion limit is reached while performing this test, the
 * function returns std::nullopt.
 */
static std::optional<bool> areEqComparable(NotNull<TypeArena> arena,
                                           NotNull<Normalizer> normalizer,
                                           TypeId a, TypeId b) {
  a = follow(a);
  b = follow(b);

  auto isExempt = [](TypeId t) { return isNil(t) || get<FreeType>(t); };

  if (isExempt(a) || isExempt(b))
    return true;

  NormalizationResult nr;

  TypeId c = arena->addType(IntersectionType{{a, b}});
  std::shared_ptr<const NormalizedType> n = normalizer->normalize(c);
  if (!n)
    return std::nullopt;

  nr = normalizer->isInhabited(n.get());

  switch (nr) {
  case NormalizationResult::HitLimits:
    return std::nullopt;
  case NormalizationResult::False:
    return false;
  case NormalizationResult::True:
    return true;
  }

  // n.b. msvc can never figure this stuff out.
  LUAU_UNREACHABLE();
}

TypeId TypeChecker::checkRelationalOperation(const ScopePtr &scope,
                                             const AstExprBinary &expr,
                                             TypeId lhsType, TypeId rhsType,
                                             const PredicateVec &predicates) {
  auto stripNil = [this](TypeId ty, bool isOrOp = false) {
    ty = follow(ty);
    if (!isNonstrictMode() && !isOrOp)
      return ty;

    if (get<UnionType>(ty)) {
      std::optional<TypeId> cleaned = tryStripUnionFromNil(ty);

      // If there is no union option without 'nil'
      if (!cleaned)
        return nilType;

      return follow(*cleaned);
    }

    return follow(ty);
  };

  bool isEquality = expr.op == AstExprBinary::CompareEq ||
                    expr.op == AstExprBinary::CompareNe;

  lhsType = stripNil(lhsType, expr.op == AstExprBinary::Or);
  rhsType = stripNil(rhsType);

  // If we know nothing at all about the lhs type, we can usually say nothing
  // about the result. The notable exception to this is the equality and
  // inequality operators, which always produce a boolean.
  const bool lhsIsAny = get<AnyType>(lhsType) || get<ErrorType>(lhsType) ||
                        get<NeverType>(lhsType);

  // Peephole check for `cond and a or b -> type(a)|type(b)`
  // TODO: Kill this when singleton types arrive. :(
  if (AstExprBinary *subexp = expr.left->as<AstExprBinary>()) {
    if (expr.op == AstExprBinary::Or && subexp->op == AstExprBinary::And) {
      ScopePtr subScope = childScope(scope, subexp->location);
      resolve(predicates, subScope, true);
      return unionOfTypes(
          rhsType, stripNil(checkExpr(subScope, *subexp->right).type, true),
          subScope, expr.location);
    }
  }

  // Lua casts the results of these to boolean
  switch (expr.op) {
  case AstExprBinary::CompareNe:
  case AstExprBinary::CompareEq: {
    if (isNonstrictMode() && (isNil(lhsType) || isNil(rhsType)))
      return booleanType;

    const bool rhsIsAny = get<AnyType>(rhsType) || get<ErrorType>(rhsType) ||
                          get<NeverType>(rhsType);
    if (lhsIsAny || rhsIsAny)
      return booleanType;

    // Fallthrough here is intentional
  }
  case AstExprBinary::CompareLt:
  case AstExprBinary::CompareGt:
  case AstExprBinary::CompareGe:
  case AstExprBinary::CompareLe: {
    // If one of the operand is never, it doesn't make sense to unify these.
    if (get<NeverType>(lhsType) || get<NeverType>(rhsType))
      return booleanType;

    if (isEquality) {
      // Unless either type is free or any, an equality comparison is only
      // valid when the intersection of the two operands is non-empty.
      //
      // eg it is okay to compare string? == number? because the two types
      // have nil in common, but string == number is not allowed.
      std::optional<bool> eqTestResult =
          areEqComparable(NotNull{&currentModule->internalTypes},
                          NotNull{&normalizer}, lhsType, rhsType);
      if (!eqTestResult) {
        reportErrorCodeTooComplex(expr.location);
        return errorRecoveryType(booleanType);
      }

      if (!*eqTestResult) {
        reportError(expr.location,
                    GenericError{format("Type %s cannot be compared with %s",
                                        toString(lhsType).c_str(),
                                        toString(rhsType).c_str())});
        return errorRecoveryType(booleanType);
      }
    }

    /* Subtlety here:
     * We need to do this unification first, but there are situations where we
     * don't actually want to report any problems that might have been surfaced
     * as a result of this step because we might already have a better, more
     * descriptive error teed up.
     */
    Unifier state = mkUnifier(scope, expr.location);
    if (!isEquality) {
      state.tryUnify(rhsType, lhsType);
      state.log.commit();
    }

    const bool needsMetamethod = !isEquality;

    TypeId leftType = follow(lhsType);
    if (get<PrimitiveType>(leftType) || get<AnyType>(leftType) ||
        get<ErrorType>(leftType) || get<UnionType>(leftType)) {
      reportErrors(state.errors);

      if (FFlag::LuauRemoveBadRelationalOperatorWarning) {
        // The original version of this check also produced this error when we
        // had a union type. However, the old solver does not readily have the
        // ability to discern if the union is comparable. This is the case when
        // the lhs is e.g. a union of singletons and the rhs is the combined
        // type. The new solver has much more powerful logic for resolving
        // relational operators, but for now, we need to be conservative in the
        // old solver to deliver a reasonable developer experience.
        if (!isEquality && state.errors.empty() && isBoolean(leftType)) {
          reportError(
              expr.location,
              GenericError{format(
                  "Type '%s' cannot be compared with relational operator %s",
                  toString(leftType).c_str(), toString(expr.op).c_str())});
        }
      } else {
        if (!isEquality && state.errors.empty() &&
            (get<UnionType>(leftType) || isBoolean(leftType))) {
          reportError(
              expr.location,
              GenericError{format(
                  "Type '%s' cannot be compared with relational operator %s",
                  toString(leftType).c_str(), toString(expr.op).c_str())});
        }
      }

      return booleanType;
    }

    std::string metamethodName = opToMetaTableEntry(expr.op);

    std::optional<TypeId> stringNoMT =
        std::nullopt; // works around gcc false positive "maybe uninitialized"
                      // warnings
    std::optional<TypeId> leftMetatable =
        isString(lhsType) ? stringNoMT
                          : getMetatable(follow(lhsType), builtinTypes);
    std::optional<TypeId> rightMetatable =
        isString(rhsType) ? stringNoMT
                          : getMetatable(follow(rhsType), builtinTypes);

    if (leftMetatable != rightMetatable) {
      bool matches = false;
      if (isEquality) {
        if (const UnionType *utv = get<UnionType>(leftType);
            utv && rightMetatable) {
          for (TypeId leftOption : utv) {
            if (getMetatable(follow(leftOption), builtinTypes) ==
                rightMetatable) {
              matches = true;
              break;
            }
          }
        }

        if (!matches) {
          if (const UnionType *utv = get<UnionType>(rhsType);
              utv && leftMetatable) {
            for (TypeId rightOption : utv) {
              if (getMetatable(follow(rightOption), builtinTypes) ==
                  leftMetatable) {
                matches = true;
                break;
              }
            }
          }
        }
      }

      if (!matches) {
        reportError(expr.location,
                    GenericError{format(
                        "Types %s and %s cannot be compared with %s because "
                        "they do not have the same metatable",
                        toString(lhsType).c_str(), toString(rhsType).c_str(),
                        toString(expr.op).c_str())});
        return errorRecoveryType(booleanType);
      }
    }

    if (leftMetatable) {
      std::optional<TypeId> metamethod = findMetatableEntry(
          lhsType, metamethodName, expr.location, /* addErrors= */ true);
      if (metamethod) {
        if (const FunctionType *ftv = get<FunctionType>(*metamethod)) {
          if (isEquality) {
            Unifier state = mkUnifier(scope, expr.location);
            state.tryUnify(addTypePack({booleanType}), ftv->retTypes);

            if (!state.errors.empty()) {
              reportError(expr.location,
                          GenericError{format(
                              "Metamethod '%s' must return type 'boolean'",
                              metamethodName.c_str())});
              return errorRecoveryType(booleanType);
            }

            state.log.commit();
          }
        }

        reportErrors(state.errors);

        TypeId actualFunctionType =
            addType(FunctionType(scope->level, addTypePack({lhsType, rhsType}),
                                 addTypePack({booleanType})));
        state.tryUnify(instantiate(scope, actualFunctionType, expr.location),
                       instantiate(scope, *metamethod, expr.location),
                       /*isFunctionCall*/ true);

        state.log.commit();

        reportErrors(state.errors);
        return booleanType;
      } else if (needsMetamethod) {
        reportError(expr.location,
                    GenericError{format("Table %s does not offer metamethod %s",
                                        toString(lhsType).c_str(),
                                        metamethodName.c_str())});
        return errorRecoveryType(booleanType);
      }
    }

    if (get<FreeType>(follow(lhsType)) && !isEquality) {
      auto name = getIdentifierOfBaseVar(expr.left);
      reportError(expr.location,
                  CannotInferBinaryOperation{
                      expr.op, name, CannotInferBinaryOperation::Comparison});
      return errorRecoveryType(booleanType);
    }

    if (needsMetamethod) {
      reportError(
          expr.location,
          GenericError{format(
              "Type %s cannot be compared with %s because it has no metatable",
              toString(lhsType).c_str(), toString(expr.op).c_str())});
      return errorRecoveryType(booleanType);
    }

    return booleanType;
  }

  case AstExprBinary::And:
    if (lhsIsAny) {
      return lhsType;
    } else {
      // If lhs is free, we can't tell which 'falsy' components it has, if any
      if (get<FreeType>(lhsType))
        return unionOfTypes(addType(UnionType{{nilType, singletonType(false)}}),
                            rhsType, scope, expr.location, false);

      auto [oty, notNever] = pickTypesFromSense(
          lhsType, false, neverType); // Filter out falsy types

      if (notNever) {
        LUAU_ASSERT(oty);

        // Perform a limited form of type reduction for booleans
        if (isPrim(*oty, PrimitiveType::Boolean) &&
            get<BooleanSingleton>(get<SingletonType>(follow(rhsType))))
          return booleanType;
        if (isPrim(rhsType, PrimitiveType::Boolean) &&
            get<BooleanSingleton>(get<SingletonType>(follow(*oty))))
          return booleanType;

        return unionOfTypes(*oty, rhsType, scope, expr.location, false);
      } else {
        return rhsType;
      }
    }
  case AstExprBinary::Or:
    if (lhsIsAny) {
      return lhsType;
    } else {
      auto [oty, notNever] = pickTypesFromSense(
          lhsType, true, neverType); // Filter out truthy types

      if (notNever) {
        LUAU_ASSERT(oty);

        // Perform a limited form of type reduction for booleans
        if (isPrim(*oty, PrimitiveType::Boolean) &&
            get<BooleanSingleton>(get<SingletonType>(follow(rhsType))))
          return booleanType;
        if (isPrim(rhsType, PrimitiveType::Boolean) &&
            get<BooleanSingleton>(get<SingletonType>(follow(*oty))))
          return booleanType;

        return unionOfTypes(*oty, rhsType, scope, expr.location);
      } else {
        return rhsType;
      }
    }
  default:
    LUAU_ASSERT(0);
    ice(format("checkRelationalOperation called with incorrect binary "
               "expression '%s'",
               toString(expr.op).c_str()),
        expr.location);
  }
}

TypeId TypeChecker::checkBinaryOperation(const ScopePtr &scope,
                                         const AstExprBinary &expr,
                                         TypeId lhsType, TypeId rhsType,
                                         const PredicateVec &predicates) {
  switch (expr.op) {
  case AstExprBinary::CompareNe:
  case AstExprBinary::CompareEq:
  case AstExprBinary::CompareLt:
  case AstExprBinary::CompareGt:
  case AstExprBinary::CompareGe:
  case AstExprBinary::CompareLe:
  case AstExprBinary::And:
  case AstExprBinary::Or:
    return checkRelationalOperation(scope, expr, lhsType, rhsType, predicates);
  default:
    break;
  }

  lhsType = follow(lhsType);
  rhsType = follow(rhsType);

  if (!isNonstrictMode() && get<FreeType>(lhsType)) {
    auto name = getIdentifierOfBaseVar(expr.left);
    reportError(expr.location,
                CannotInferBinaryOperation{
                    expr.op, name, CannotInferBinaryOperation::Operation});
    // We will fall-through to the `return anyType` check below.
  }

  // If we know nothing at all about the lhs type, we can usually say nothing
  // about the result. The notable exception to this is the equality and
  // inequality operators, which always produce a boolean.
  const bool lhsIsAny = get<AnyType>(lhsType) || get<ErrorType>(lhsType) ||
                        get<NeverType>(lhsType);
  const bool rhsIsAny = get<AnyType>(rhsType) || get<ErrorType>(rhsType) ||
                        get<NeverType>(rhsType);

  if (lhsIsAny)
    return lhsType;
  if (rhsIsAny)
    return rhsType;

  if (get<FreeType>(lhsType)) {
    // Inferring this accurately will get a bit weird.
    // If the lhs type is not known, it could be assumed that it is a table or
    // class that has a metatable that defines the required method, but we don't
    // know which. For now, we'll give up and hope for the best.
    return anyType;
  }

  if (get<FreeType>(rhsType))
    unify(rhsType, lhsType, scope, expr.location);

  if (typeCouldHaveMetatable(lhsType) || typeCouldHaveMetatable(rhsType)) {
    auto checkMetatableCall = [this, &scope, &expr](TypeId fnt, TypeId lhst,
                                                    TypeId rhst) -> TypeId {
      TypeId actualFunctionType = instantiate(scope, fnt, expr.location);
      TypePackId arguments = addTypePack({lhst, rhst});
      TypePackId retTypePack = freshTypePack(scope);
      TypeId expectedFunctionType =
          addType(FunctionType(scope->level, arguments, retTypePack));

      Unifier state = mkUnifier(scope, expr.location);
      state.tryUnify(actualFunctionType, expectedFunctionType,
                     /*isFunctionCall*/ true);

      reportErrors(state.errors);
      bool hasErrors = !state.errors.empty();

      if (hasErrors) {
        // If there are unification errors, the return type may still be unknown
        // so we loosen the argument types to see if that helps.
        TypePackId fallbackArguments = freshTypePack(scope);
        TypeId fallbackFunctionType =
            addType(FunctionType(scope->level, fallbackArguments, retTypePack));
        state.errors.clear();
        state.log.clear();

        state.tryUnify(actualFunctionType, fallbackFunctionType,
                       /*isFunctionCall*/ true);

        if (state.errors.empty())
          state.log.commit();
      } else {
        state.log.commit();
      }

      TypeId retType = first(retTypePack).value_or(nilType);
      if (hasErrors)
        retType = errorRecoveryType(retType);

      return retType;
    };

    std::string op = opToMetaTableEntry(expr.op);
    if (auto fnt = findMetatableEntry(lhsType, op, expr.location,
                                      /* addErrors= */ true))
      return checkMetatableCall(*fnt, lhsType, rhsType);
    if (auto fnt = findMetatableEntry(rhsType, op, expr.location,
                                      /* addErrors= */ true)) {
      // Note the intentionally reversed arguments here.
      return checkMetatableCall(*fnt, rhsType, lhsType);
    }

    reportError(expr.location,
                GenericError{format(
                    "Binary operator '%s' not supported by types '%s' and '%s'",
                    toString(expr.op).c_str(), toString(lhsType).c_str(),
                    toString(rhsType).c_str())});

    return errorRecoveryType(scope);
  }

  switch (expr.op) {
  case AstExprBinary::Concat:
    reportErrors(tryUnify(lhsType, addType(UnionType{{stringType, numberType}}),
                          scope, expr.left->location));
    reportErrors(tryUnify(rhsType, addType(UnionType{{stringType, numberType}}),
                          scope, expr.right->location));
    return stringType;
  case AstExprBinary::Add:
  case AstExprBinary::Sub:
  case AstExprBinary::Mul:
  case AstExprBinary::Div:
  case AstExprBinary::FloorDiv:
  case AstExprBinary::Mod:
  case AstExprBinary::Pow:
    reportErrors(tryUnify(lhsType, numberType, scope, expr.left->location));
    reportErrors(tryUnify(rhsType, numberType, scope, expr.right->location));
    return numberType;
  default:
    // These should have been handled with checkRelationalOperation
    LUAU_ASSERT(0);
    return anyType;
  }
}

WithPredicate<TypeId>
TypeChecker::checkExpr(const ScopePtr &scope, const AstExprBinary &expr,
                       std::optional<TypeId> expectedType) {
  if (expr.op == AstExprBinary::And) {
    auto [lhsTy, lhsPredicates] = checkExpr(scope, *expr.left, expectedType);

    ScopePtr innerScope = childScope(scope, expr.location);
    resolve(lhsPredicates, innerScope, true);

    auto [rhsTy, rhsPredicates] =
        checkExpr(innerScope, *expr.right, expectedType);

    return {checkBinaryOperation(scope, expr, lhsTy, rhsTy),
            {AndPredicate{std::move(lhsPredicates), std::move(rhsPredicates)}}};
  } else if (expr.op == AstExprBinary::Or) {
    auto [lhsTy, lhsPredicates] = checkExpr(scope, *expr.left, expectedType);

    ScopePtr innerScope = childScope(scope, expr.location);
    resolve(lhsPredicates, innerScope, false);

    auto [rhsTy, rhsPredicates] =
        checkExpr(innerScope, *expr.right, expectedType);

    // Because of C++, I'm not sure if lhsPredicates was not moved out by the
    // time we call checkBinaryOperation.
    TypeId result =
        checkBinaryOperation(scope, expr, lhsTy, rhsTy, lhsPredicates);
    return {result,
            {OrPredicate{std::move(lhsPredicates), std::move(rhsPredicates)}}};
  } else if (expr.op == AstExprBinary::CompareEq ||
             expr.op == AstExprBinary::CompareNe) {
    // For these, passing expectedType is worse than simply forcing them,
    // because their implementation may inadvertently check if expectedTypes
    // exist first and use it, instead of forceSingleton first.
    WithPredicate<TypeId> lhs =
        checkExpr(scope, *expr.left, std::nullopt, /*forceSingleton=*/true);
    WithPredicate<TypeId> rhs =
        checkExpr(scope, *expr.right, std::nullopt, /*forceSingleton=*/true);

    if (auto predicate = tryGetTypeGuardPredicate(expr))
      return {booleanType, {std::move(*predicate)}};

    PredicateVec predicates;

    if (auto lvalue = tryGetLValue(*expr.left))
      predicates.push_back(
          EqPredicate{std::move(*lvalue), rhs.type, expr.location});

    if (auto lvalue = tryGetLValue(*expr.right))
      predicates.push_back(
          EqPredicate{std::move(*lvalue), lhs.type, expr.location});

    if (!predicates.empty() && expr.op == AstExprBinary::CompareNe)
      predicates = {NotPredicate{std::move(predicates)}};

    return {checkBinaryOperation(scope, expr, lhs.type, rhs.type),
            std::move(predicates)};
  } else {
    // Expected types are not useful for other binary operators.
    WithPredicate<TypeId> lhs = checkExpr(scope, *expr.left);
    WithPredicate<TypeId> rhs = checkExpr(scope, *expr.right);

    // Intentionally discarding predicates with other operators.
    return WithPredicate{
        checkBinaryOperation(scope, expr, lhs.type, rhs.type, lhs.predicates)};
  }
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprTypeAssertion &expr) {
  TypeId annotationType = resolveType(scope, *expr.annotation);
  WithPredicate<TypeId> result = checkExpr(scope, *expr.expr, annotationType);

  // Note: As an optimization, we try 'number <: number | string' first, as that
  // is the more likely case.
  if (canUnify(annotationType, result.type, scope, expr.location).empty())
    return {annotationType, std::move(result.predicates)};

  if (canUnify(result.type, annotationType, scope, expr.location).empty())
    return {annotationType, std::move(result.predicates)};

  reportError(expr.location, TypesAreUnrelated{result.type, annotationType});
  return {errorRecoveryType(annotationType), std::move(result.predicates)};
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprError &expr) {
  const size_t oldSize = currentModule->errors.size();

  for (AstExpr *expr : expr.expressions)
    checkExpr(scope, *expr);

  // HACK: We want to check the contents of the AstExprError, but
  // any type errors that may arise from it are going to be useless.
  currentModule->errors.resize(oldSize);

  return WithPredicate{errorRecoveryType(scope)};
}

WithPredicate<TypeId>
TypeChecker::checkExpr(const ScopePtr &scope, const AstExprIfElse &expr,
                       std::optional<TypeId> expectedType) {
  WithPredicate<TypeId> result = checkExpr(scope, *expr.condition);

  ScopePtr trueScope = childScope(scope, expr.trueExpr->location);
  resolve(result.predicates, trueScope, true);
  WithPredicate<TypeId> trueType =
      checkExpr(trueScope, *expr.trueExpr, expectedType);

  ScopePtr falseScope = childScope(scope, expr.falseExpr->location);
  resolve(result.predicates, falseScope, false);
  WithPredicate<TypeId> falseType =
      checkExpr(falseScope, *expr.falseExpr, expectedType);

  if (falseType.type == trueType.type)
    return WithPredicate{trueType.type};

  std::vector<TypeId> types = reduceUnion({trueType.type, falseType.type});
  if (types.empty())
    return WithPredicate{neverType};
  return WithPredicate{
      types.size() == 1 ? types[0] : addType(UnionType{std::move(types)})};
}

WithPredicate<TypeId> TypeChecker::checkExpr(const ScopePtr &scope,
                                             const AstExprInterpString &expr) {
  for (AstExpr *expr : expr.expressions)
    checkExpr(scope, *expr);

  return WithPredicate{stringType};
}

TypeId TypeChecker::checkLValue(const ScopePtr &scope, const AstExpr &expr,
                                ValueContext ctx) {
  return checkLValueBinding(scope, expr, ctx);
}

TypeId TypeChecker::checkLValueBinding(const ScopePtr &scope,
                                       const AstExpr &expr, ValueContext ctx) {
  if (auto a = expr.as<AstExprLocal>())
    return checkLValueBinding(scope, *a);
  else if (auto a = expr.as<AstExprGlobal>())
    return checkLValueBinding(scope, *a);
  else if (auto a = expr.as<AstExprIndexName>())
    return checkLValueBinding(scope, *a, ctx);
  else if (auto a = expr.as<AstExprIndexExpr>())
    return checkLValueBinding(scope, *a, ctx);
  else if (auto a = expr.as<AstExprError>()) {
    for (AstExpr *expr : a->expressions)
      checkExpr(scope, *expr);
    return errorRecoveryType(scope);
  } else
    ice("Unexpected AST node in checkLValue", expr.location);
}

TypeId TypeChecker::checkLValueBinding(const ScopePtr &scope,
                                       const AstExprLocal &expr) {
  if (std::optional<TypeId> ty = scope->lookup(expr.local)) {
    ty = follow(*ty);
    return get<NeverType>(*ty) ? unknownType : *ty;
  }

  reportError(expr.location,
              UnknownSymbol{expr.local->name.value, UnknownSymbol::Binding});
  return errorRecoveryType(scope);
}

TypeId TypeChecker::checkLValueBinding(const ScopePtr &scope,
                                       const AstExprGlobal &expr) {
  Name name = expr.name.value;
  ScopePtr moduleScope = currentModule->getModuleScope();

  const auto it = moduleScope->bindings.find(expr.name);

  if (it != moduleScope->bindings.end()) {
    TypeId ty = follow(it->second.typeId);
    return get<NeverType>(ty) ? unknownType : ty;
  }

  TypeId result = freshType(scope);
  Binding &binding = moduleScope->bindings[expr.name];
  binding = {result, expr.location};

  // If we're in strict mode, we want to report defining a global as an error,
  // but still add it to the bindings, so that autocomplete includes it in
  // completions.
  if (!isNonstrictMode())
    reportError(
        TypeError{expr.location, UnknownSymbol{name, UnknownSymbol::Binding}});

  return result;
}

TypeId TypeChecker::checkLValueBinding(const ScopePtr &scope,
                                       const AstExprIndexName &expr,
                                       ValueContext ctx) {
  TypeId lhs = checkExpr(scope, *expr.expr).type;

  if (get<ErrorType>(lhs) || get<AnyType>(lhs))
    return lhs;

  if (get<NeverType>(lhs))
    return unknownType;

  tablify(lhs);

  Name name = expr.index.value;

  lhs = stripFromNilAndReport(lhs, expr.expr->location);

  if (TableType *lhsTable = getMutableTableType(lhs)) {
    const auto &it = lhsTable->props.find(name);
    if (it != lhsTable->props.end()) {
      return it->second.type();
    } else if ((ctx == ValueContext::LValue &&
                lhsTable->state == TableState::Unsealed) ||
               lhsTable->state == TableState::Free) {
      TypeId theType = freshType(scope);
      Property &property = lhsTable->props[name];
      property.setType(theType);
      property.location = expr.indexLocation;
      return theType;
    } else if (auto indexer = lhsTable->indexer) {
      Unifier state = mkUnifier(scope, expr.location);
      state.tryUnify(stringType, indexer->indexType);
      TypeId retType = indexer->indexResultType;
      if (!state.errors.empty()) {

        reportError(expr.location, UnknownProperty{lhs, name});
        retType = errorRecoveryType(retType);
      } else
        state.log.commit();

      return retType;
    } else if (lhsTable->state == TableState::Sealed) {
      reportError(
          TypeError{expr.location,
                    CannotExtendTable{lhs, CannotExtendTable::Property, name}});
      return errorRecoveryType(scope);
    } else {
      reportError(TypeError{
          expr.location,
          GenericError{"Internal error: generic tables are not lvalues"}});
      return errorRecoveryType(scope);
    }
  } else if (const ClassType *lhsClass = get<ClassType>(lhs)) {
    if (const Property *prop = lookupClassProp(lhsClass, name)) {
      return prop->type();
    }

    if (auto indexer = lhsClass->indexer) {
      Unifier state = mkUnifier(scope, expr.location);
      state.tryUnify(stringType, indexer->indexType);
      if (state.errors.empty()) {
        state.log.commit();
        return indexer->indexResultType;
      }
    }

    reportError(TypeError{expr.location, UnknownProperty{lhs, name}});
    return errorRecoveryType(scope);
  } else if (get<IntersectionType>(lhs)) {
    if (std::optional<TypeId> ty = getIndexTypeFromType(
            scope, lhs, name, expr.location, /* addErrors= */ false))
      return *ty;

    // If intersection has a table part, report that it cannot be extended just
    // as a sealed table
    if (isTableIntersection(lhs)) {
      reportError(
          TypeError{expr.location,
                    CannotExtendTable{lhs, CannotExtendTable::Property, name}});
      return errorRecoveryType(scope);
    }
  }

  reportError(TypeError{expr.location, NotATable{lhs}});
  return errorRecoveryType(scope);
}

TypeId TypeChecker::checkLValueBinding(const ScopePtr &scope,
                                       const AstExprIndexExpr &expr,
                                       ValueContext ctx) {
  TypeId exprType = checkExpr(scope, *expr.expr).type;
  tablify(exprType);

  exprType = stripFromNilAndReport(exprType, expr.expr->location);

  TypeId indexType = checkExpr(scope, *expr.index).type;

  exprType = follow(exprType);

  if (get<AnyType>(exprType) || get<ErrorType>(exprType))
    return exprType;

  if (get<NeverType>(exprType))
    return unknownType;

  AstExprConstantString *value = expr.index->as<AstExprConstantString>();

  if (value) {
    if (const ClassType *exprClass = get<ClassType>(exprType)) {
      if (const Property *prop =
              lookupClassProp(exprClass, value->value.data)) {
        return prop->type();
      }

      if (auto indexer = exprClass->indexer) {
        unify(stringType, indexer->indexType, scope, expr.index->location);
        return indexer->indexResultType;
      }

      reportError(TypeError{expr.location,
                            UnknownProperty{exprType, value->value.data}});
      return errorRecoveryType(scope);
    } else if (get<IntersectionType>(exprType)) {
      Name name = std::string(value->value.data, value->value.size);

      if (std::optional<TypeId> ty = getIndexTypeFromType(
              scope, exprType, name, expr.location, /* addErrors= */ false))
        return *ty;

      // If intersection has a table part, report that it cannot be extended
      // just as a sealed table
      if (isTableIntersection(exprType)) {
        reportError(TypeError{
            expr.location,
            CannotExtendTable{exprType, CannotExtendTable::Property, name}});
        return errorRecoveryType(scope);
      }
    }
  } else {
    if (const ClassType *exprClass = get<ClassType>(exprType)) {
      if (auto indexer = exprClass->indexer) {
        unify(indexType, indexer->indexType, scope, expr.index->location);
        return indexer->indexResultType;
      }
    }

    if (const ClassType *exprClass = get<ClassType>(exprType)) {
      if (isNonstrictMode())
        return unknownType;
      reportError(TypeError{expr.location,
                            DynamicPropertyLookupOnClassesUnsafe{exprType}});
      return errorRecoveryType(scope);
    }
  }

  TableType *exprTable = getMutableTableType(exprType);

  if (!exprTable) {
    reportError(TypeError{expr.expr->location, NotATable{exprType}});
    return errorRecoveryType(scope);
  }

  if (value) {
    const auto &it = exprTable->props.find(value->value.data);
    if (it != exprTable->props.end()) {
      return it->second.type();
    } else if ((ctx == ValueContext::LValue &&
                exprTable->state == TableState::Unsealed) ||
               exprTable->state == TableState::Free) {
      TypeId resultType = freshType(scope);
      Property &property = exprTable->props[value->value.data];
      property.setType(resultType);
      property.location = expr.index->location;
      return resultType;
    }
  }

  if (exprTable->indexer) {
    const TableIndexer &indexer = *exprTable->indexer;
    unify(indexType, indexer.indexType, scope, expr.index->location);
    return indexer.indexResultType;
  } else if ((ctx == ValueContext::LValue &&
              exprTable->state == TableState::Unsealed) ||
             exprTable->state == TableState::Free) {
    TypeId indexerType = freshType(exprTable->level);
    unify(indexType, indexerType, scope, expr.location);
    TypeId indexResultType = freshType(exprTable->level);

    exprTable->indexer = TableIndexer{anyIfNonstrict(indexerType),
                                      anyIfNonstrict(indexResultType)};
    return indexResultType;
  } else {
    /*
     * If we use [] indexing to fetch a property from a sealed table that
     * has no indexer, we have no idea if it will work so we just return any
     * and hope for the best.
     */
    return anyType;
  }
}

// Answers the question: "Can I define another function with this name?"
// Primarily about detecting duplicates.
TypeId TypeChecker::checkFunctionName(const ScopePtr &scope, AstExpr &funName,
                                      TypeLevel level) {
  auto freshTy = [&]() { return freshType(level); };

  if (auto globalName = funName.as<AstExprGlobal>()) {
    const ScopePtr &moduleScope = currentModule->getModuleScope();
    Symbol name = globalName->name;
    if (moduleScope->bindings.count(name)) {
      if (isNonstrictMode())
        return moduleScope->bindings[name].typeId;

      return errorRecoveryType(scope);
    } else {
      TypeId ty = freshTy();
      moduleScope->bindings[name] = {ty, funName.location};
      return ty;
    }
  } else if (auto localName = funName.as<AstExprLocal>()) {
    Symbol name = localName->local;
    Binding &binding = scope->bindings[name];
    if (binding.typeId == nullptr)
      binding = {freshTy(), funName.location};

    return binding.typeId;
  } else if (auto indexName = funName.as<AstExprIndexName>()) {
    TypeId lhsType = checkExpr(scope, *indexName->expr).type;
    TableType *ttv = getMutableTableType(lhsType);

    if (!ttv || ttv->state == TableState::Sealed) {
      if (auto ty = getIndexTypeFromType(scope, lhsType, indexName->index.value,
                                         indexName->indexLocation,
                                         /* addErrors= */ false))
        return *ty;

      return errorRecoveryType(scope);
    }

    Name name = indexName->index.value;

    if (ttv->props.count(name))
      return ttv->props[name].type();

    Property &property = ttv->props[name];
    property.setType(freshTy());
    property.location = indexName->indexLocation;
    return property.type();
  } else if (funName.is<AstExprError>())
    return errorRecoveryType(scope);
  else {
    ice("Unexpected AST node type", funName.location);
  }
}

// This returns a pair `[funType, funScope]` where
// - funType is the prototype type of the function
// - funScope is the scope for the function, which is a child scope with
// bindings added for
//   parameters (and generic types if there were explicit generic annotations).
//
// The function type is a prototype, in that it may be missing some generic
// types which can only be inferred from type inference after typechecking the
// function body. For example the function `function id(x) return x end` has
// prototype
// `(X) -> Y...`, but after typechecking the body, we cam unify `Y...` with `X`
// to get type `(X) -> X`, then we quantify the free types to get the final
// generic type `<a>(a) -> a`.
std::pair<TypeId, ScopePtr> TypeChecker::checkFunctionSignature(
    const ScopePtr &scope, int subLevel, const AstExprFunction &expr,
    std::optional<Location> originalName, std::optional<TypeId> selfType,
    std::optional<TypeId> expectedType) {
  ScopePtr funScope = childFunctionScope(scope, expr.location, subLevel);

  const FunctionType *expectedFunctionType = nullptr;

  if (expectedType) {
    LUAU_ASSERT(!expr.self);

    if (auto ftv = get<FunctionType>(follow(*expectedType))) {
      expectedFunctionType = ftv;
    } else if (auto utv = get<UnionType>(follow(*expectedType))) {
      // Look for function type in a union. Other types can be ignored since
      // current expression is a function
      for (auto option : utv) {
        if (auto ftv = get<FunctionType>(follow(option))) {
          if (!expectedFunctionType) {
            expectedFunctionType = ftv;
          } else {
            // Do not infer argument types when multiple overloads are expected
            expectedFunctionType = nullptr;
            break;
          }
        }
      }
    }
  }

  auto [generics, genericPacks] = createGenericTypes(
      funScope, std::nullopt, expr, expr.generics, expr.genericPacks);

  TypePackId retPack;
  if (expr.returnAnnotation)
    retPack = resolveTypePack(funScope, *expr.returnAnnotation);
  else if (isNonstrictMode())
    retPack = anyTypePack;
  else if (expectedFunctionType && expectedFunctionType->generics.empty() &&
           expectedFunctionType->genericPacks.empty()) {
    auto [head, tail] = flatten(expectedFunctionType->retTypes);

    // Do not infer 'nil' as function return type
    if (!tail && head.size() == 1 && isNil(head[0]))
      retPack = freshTypePack(funScope);
    else
      retPack = addTypePack(head, tail);
  } else
    retPack = freshTypePack(funScope);

  if (expr.vararg) {
    if (expr.varargAnnotation)
      funScope->varargPack = resolveTypePack(funScope, *expr.varargAnnotation);
    else {
      if (expectedFunctionType && !isNonstrictMode()) {
        auto [head, tail] = flatten(expectedFunctionType->argTypes);

        if (expr.args.size <= head.size()) {
          head.erase(head.begin(), head.begin() + expr.args.size);

          funScope->varargPack = addTypePack(head, tail);
        } else if (tail) {
          if (get<VariadicTypePack>(follow(*tail)))
            funScope->varargPack = addTypePack({}, tail);
        } else {
          funScope->varargPack = addTypePack({});
        }
      }

      // TODO: should this be a free type pack? CLI-39910
      if (!funScope->varargPack)
        funScope->varargPack = anyTypePack;
    }
  }

  std::vector<TypeId> argTypes;

  funScope->returnType = retPack;

  if (FFlag::DebugLuauSharedSelf) {
    if (expr.self) {
      // TODO: generic self types: CLI-39906
      TypeId selfTy =
          anyIfNonstrict(selfType ? *selfType : freshType(funScope));
      funScope->bindings[expr.self] = {selfTy, expr.self->location};
      argTypes.push_back(selfTy);
    }
  } else {
    if (expr.self) {
      // TODO: generic self types: CLI-39906
      TypeId selfType = anyIfNonstrict(freshType(funScope));
      funScope->bindings[expr.self] = {selfType, expr.self->location};
      argTypes.push_back(selfType);
    }
  }

  // Prepare expected argument type iterators if we have an expected function
  // type
  TypePackIterator expectedArgsCurr, expectedArgsEnd;

  if (expectedFunctionType && !isNonstrictMode()) {
    expectedArgsCurr = begin(expectedFunctionType->argTypes);
    expectedArgsEnd = end(expectedFunctionType->argTypes);
  }

  for (AstLocal *local : expr.args) {
    TypeId argType = nullptr;

    if (local->annotation) {
      argType = resolveType(funScope, *local->annotation);

      // If the annotation type has an error, treat it as if there was no
      // annotation
      if (get<ErrorType>(follow(argType)))
        argType = anyIfNonstrict(freshType(funScope));
    } else {
      if (expectedFunctionType && !isNonstrictMode()) {
        if (expectedArgsCurr != expectedArgsEnd) {
          argType = *expectedArgsCurr;
        } else if (auto expectedArgsTail = expectedArgsCurr.tail()) {
          if (const VariadicTypePack *vtp =
                  get<VariadicTypePack>(follow(*expectedArgsTail)))
            argType = vtp->ty;
        }
      }

      if (!argType)
        argType = anyIfNonstrict(freshType(funScope));
    }

    funScope->bindings[local] = {argType, local->location};
    argTypes.push_back(argType);

    if (expectedArgsCurr != expectedArgsEnd)
      ++expectedArgsCurr;
  }

  TypePackId argPack =
      addTypePack(TypePackVar(TypePack{argTypes, funScope->varargPack}));

  FunctionDefinition defn;
  defn.definitionModuleName = currentModule->name;
  defn.definitionLocation = expr.location;
  defn.varargLocation =
      expr.vararg ? std::make_optional(expr.varargLocation) : std::nullopt;
  defn.originalNameLocation =
      originalName.value_or(Location(expr.location.begin, 0));

  std::vector<TypeId> genericTys;
  // if we have a generic expected function type and no generics, we should use
  // the expected ones.
  if (expectedFunctionType && generics.empty()) {
    genericTys = expectedFunctionType->generics;
  } else {
    genericTys.reserve(generics.size());
    for (const GenericTypeDefinition &generic : generics)
      genericTys.push_back(generic.ty);
  }

  std::vector<TypePackId> genericTps;
  // if we have a generic expected function type and no generic typepacks, we
  // should use the expected ones.
  if (expectedFunctionType && genericPacks.empty()) {
    genericTps = expectedFunctionType->genericPacks;
  } else {
    genericTps.reserve(genericPacks.size());
    for (const GenericTypePackDefinition &generic : genericPacks)
      genericTps.push_back(generic.tp);
  }

  TypeId funTy = addType(FunctionType(funScope->level, std::move(genericTys),
                                      std::move(genericTps), argPack, retPack,
                                      std::move(defn), bool(expr.self)));

  FunctionType *ftv = getMutable<FunctionType>(funTy);

  ftv->argNames.reserve(expr.args.size + (expr.self ? 1 : 0));

  if (expr.self)
    ftv->argNames.push_back(FunctionArgument{"self", {}});

  for (AstLocal *local : expr.args)
    ftv->argNames.push_back(
        FunctionArgument{local->name.value, local->location});

  return std::make_pair(funTy, funScope);
}

static bool allowsNoReturnValues(const TypePackId tp) {
  for (TypeId ty : tp) {
    if (!get<ErrorType>(follow(ty))) {
      return false;
    }
  }

  return true;
}

static Location getEndLocation(const AstExprFunction &function) {
  Location loc = function.location;
  if (loc.begin.line != loc.end.line) {
    Position begin = loc.end;
    begin.column = std::max(0u, begin.column - 3);
    loc = Location(begin, 3);
  }

  return loc;
}

void TypeChecker::checkFunctionBody(const ScopePtr &scope, TypeId ty,
                                    const AstExprFunction &function) {
  LUAU_TIMETRACE_SCOPE("TypeChecker::checkFunctionBody", "TypeChecker");

  if (function.debugname.value)
    LUAU_TIMETRACE_ARGUMENT("name", function.debugname.value);
  else
    LUAU_TIMETRACE_ARGUMENT(
        "line", std::to_string(function.location.begin.line).c_str());

  if (FunctionType *funTy = getMutable<FunctionType>(ty)) {
    check(scope, *function.body);

    // We explicitly don't follow here to check if we have a 'true' free type
    // instead of bound one
    if (get_if<FreeTypePack>(&funTy->retTypes->ty))
      *asMutable(funTy->retTypes) = TypePack{{}, std::nullopt};

    bool reachesImplicitReturn = getFallthrough(function.body) != nullptr;

    if (reachesImplicitReturn &&
        !allowsNoReturnValues(follow(funTy->retTypes))) {
      // If we're in nonstrict mode we want to only report this missing return
      // statement if there are type annotations on the function. In strict mode
      // we report it regardless.
      if (!isNonstrictMode() || function.returnAnnotation) {
        reportError(getEndLocation(function),
                    FunctionExitsWithoutReturning{funTy->retTypes});
      }
    }

    if (!currentModule->astTypes.find(&function))
      currentModule->astTypes[&function] = ty;
  } else
    ice("Checking non functional type");
}

WithPredicate<TypePackId> TypeChecker::checkExprPack(const ScopePtr &scope,
                                                     const AstExpr &expr) {
  WithPredicate<TypePackId> result = checkExprPackHelper(scope, expr);
  if (containsNever(result.type))
    return WithPredicate{uninhabitableTypePack};
  return result;
}

WithPredicate<TypePackId>
TypeChecker::checkExprPackHelper(const ScopePtr &scope, const AstExpr &expr) {
  if (auto a = expr.as<AstExprCall>())
    return checkExprPackHelper(scope, *a);
  else if (expr.is<AstExprVarargs>()) {
    if (!scope->varargPack)
      return WithPredicate{errorRecoveryTypePack(scope)};

    return WithPredicate{*scope->varargPack};
  } else {
    TypeId type = checkExpr(scope, expr).type;
    return WithPredicate{addTypePack({type})};
  }
}

void TypeChecker::checkArgumentList(const ScopePtr &scope,
                                    const AstExpr &funName, Unifier &state,
                                    TypePackId argPack, TypePackId paramPack,
                                    const std::vector<Location> &argLocations) {
  /* Important terminology refresher:
   * A function requires parameters.
   * To call a function, you supply arguments.
   */
  TypePackIterator argIter = begin(argPack, &state.log);
  TypePackIterator paramIter = begin(paramPack, &state.log);
  TypePackIterator endIter = end(
      argPack); // Important subtlety: All end TypePackIterators are equivalent

  size_t paramIndex = 0;

  auto reportCountMismatchError = [&state, &argLocations, paramPack, argPack,
                                   &funName]() {
    // For this case, we want the error span to cover every errant extra
    // parameter
    Location location = state.location;
    if (!argLocations.empty())
      location = {state.location.begin, argLocations.back().end};

    std::string namePath;

    if (std::optional<std::string> path = getFunctionNameAsString(funName))
      namePath = *path;

    auto [minParams, optMaxParams] = getParameterExtents(&state.log, paramPack);
    state.reportError(TypeError{
        location, CountMismatch{minParams, optMaxParams,
                                std::distance(begin(argPack), end(argPack)),
                                CountMismatch::Context::Arg, false, namePath}});
  };

  while (true) {
    state.location = paramIndex < argLocations.size() ? argLocations[paramIndex]
                                                      : state.location;

    if (argIter == endIter && paramIter == endIter) {
      std::optional<TypePackId> argTail = argIter.tail();
      std::optional<TypePackId> paramTail = paramIter.tail();

      // If we hit the end of both type packs simultaneously, we have to unify
      // them. But if one side has a free tail and the other has none at all, we
      // create an empty pack and bind the free tail to that.

      if (argTail) {
        if (state.log.getMutable<FreeTypePack>(state.log.follow(*argTail))) {
          if (paramTail)
            state.tryUnify(*paramTail, *argTail);
          else
            state.log.replace(*argTail, TypePackVar(TypePack{{}}));
        } else if (paramTail) {
          state.tryUnify(*argTail, *paramTail);
        }
      } else if (paramTail) {
        // argTail is definitely empty
        if (state.log.getMutable<FreeTypePack>(state.log.follow(*paramTail)))
          state.log.replace(*paramTail, TypePackVar(TypePack{{}}));
      }

      return;
    } else if (argIter == endIter) {
      // Not enough arguments.

      // Might be ok if we are forwarding a vararg along.  This is a common
      // thing to occur in nonstrict mode.
      if (argIter.tail()) {
        TypePackId tail = *argIter.tail();
        if (state.log.getMutable<Unifiable::Error>(tail)) {
          // Unify remaining parameters so we don't leave any free-types hanging
          // around.
          while (paramIter != endIter) {
            state.tryUnify(errorRecoveryType(anyType), *paramIter);
            ++paramIter;
          }
          return;
        } else if (auto vtp = state.log.getMutable<VariadicTypePack>(tail)) {
          // Function is variadic and requires that all subsequent parameters
          // be compatible with a type.
          while (paramIter != endIter) {
            state.tryUnify(vtp->ty, *paramIter);
            ++paramIter;
          }

          return;
        } else if (state.log.getMutable<FreeTypePack>(tail)) {
          std::vector<TypeId> rest;
          rest.reserve(std::distance(paramIter, endIter));
          while (paramIter != endIter) {
            rest.push_back(*paramIter);
            ++paramIter;
          }

          TypePackId varPack =
              addTypePack(TypePackVar{TypePack{rest, paramIter.tail()}});
          state.tryUnify(tail, varPack);
          return;
        }
      }

      // If any remaining unfulfilled parameters are nonoptional, this is a
      // problem.
      while (paramIter != endIter) {
        TypeId t = state.log.follow(*paramIter);
        if (isOptional(t)) {
        } // ok
        else if (state.log.getMutable<ErrorType>(t)) {
        } // ok
        else {
          auto [minParams, optMaxParams] =
              getParameterExtents(&state.log, paramPack);

          std::optional<TypePackId> tail = flatten(paramPack, state.log).second;
          bool isVariadic = tail && Luau::isVariadic(*tail);

          std::string namePath;

          if (std::optional<std::string> path =
                  getFunctionNameAsString(funName))
            namePath = *path;

          state.reportError(
              TypeError{funName.location,
                        CountMismatch{minParams, optMaxParams, paramIndex,
                                      CountMismatch::Context::Arg, isVariadic,
                                      namePath}});
          return;
        }
        ++paramIter;
      }
    } else if (paramIter == endIter) {
      // too many parameters passed
      if (!paramIter.tail()) {
        while (argIter != endIter) {
          // The use of unify here is deliberate. We don't want this unification
          // to be undoable.
          unify(errorRecoveryType(scope), *argIter, scope, state.location);
          ++argIter;
        }
        reportCountMismatchError();
        return;
      }
      TypePackId tail = state.log.follow(*paramIter.tail());

      if (state.log.getMutable<Unifiable::Error>(tail)) {
        // Function is variadic.  Ok.
        return;
      } else if (auto vtp = state.log.getMutable<VariadicTypePack>(tail)) {
        // Function is variadic and requires that all subsequent parameters
        // be compatible with a type.
        size_t argIndex = paramIndex;
        while (argIter != endIter) {
          Location location = state.location;

          if (argIndex < argLocations.size())
            location = argLocations[argIndex];

          state.location = location;
          state.tryUnify(*argIter, vtp->ty);

          ++argIter;
          ++argIndex;
        }

        return;
      } else if (state.log.getMutable<FreeTypePack>(tail)) {
        // Create a type pack out of the remaining argument types
        // and unify it with the tail.
        std::vector<TypeId> rest;
        rest.reserve(std::distance(argIter, endIter));
        while (argIter != endIter) {
          rest.push_back(*argIter);
          ++argIter;
        }

        TypePackId varPack =
            addTypePack(TypePackVar{TypePack{rest, argIter.tail()}});
        state.tryUnify(varPack, tail);

        return;
      } else if (state.log.getMutable<FreeTypePack>(tail)) {
        state.log.replace(tail, TypePackVar(TypePack{{}}));
        return;
      } else if (state.log.getMutable<GenericTypePack>(tail)) {
        reportCountMismatchError();
        return;
      }
    } else {
      if (FFlag::LuauInstantiateInSubtyping)
        state.tryUnify(*argIter, *paramIter, /*isFunctionCall*/ false);
      else
        unifyWithInstantiationIfNeeded(*argIter, *paramIter, scope, state);
      ++argIter;
      ++paramIter;
    }

    ++paramIndex;
  }
}

WithPredicate<TypePackId>
TypeChecker::checkExprPackHelper(const ScopePtr &scope,
                                 const AstExprCall &expr) {
  // evaluate type of function
  // decompose an intersection into its component overloads
  // Compute types of parameters
  // For each overload
  //     Compare parameter and argument types
  //     Report any errors (also speculate dot vs colon warnings!)
  //     Return the resulting return type (even if there are errors)
  // If there are no matching overloads, unify with (a...) -> (b...) and return
  // b...

  TypeId selfType = nullptr;
  TypeId functionType = nullptr;
  TypeId actualFunctionType = nullptr;

  if (expr.self) {
    AstExprIndexName *indexExpr = expr.func->as<AstExprIndexName>();
    if (!indexExpr)
      ice("method call expression has no 'self'");

    selfType = checkExpr(scope, *indexExpr->expr).type;
    selfType = stripFromNilAndReport(selfType, expr.func->location);

    if (std::optional<TypeId> propTy =
            getIndexTypeFromType(scope, selfType, indexExpr->index.value,
                                 expr.location, /* addErrors= */ true)) {
      functionType = *propTy;
      actualFunctionType =
          instantiate(scope, functionType, expr.func->location);
    } else {
      functionType = errorRecoveryType(scope);
      actualFunctionType = functionType;
    }
  } else {
    functionType = checkExpr(scope, *expr.func).type;
    actualFunctionType = instantiate(scope, functionType, expr.func->location);
  }

  TypePackId retPack;
  if (auto free = get<FreeType>(actualFunctionType)) {
    retPack = freshTypePack(free->level);
    TypePackId freshArgPack = freshTypePack(free->level);
    emplaceType<FunctionType>(asMutable(actualFunctionType), free->level,
                              freshArgPack, retPack);
  } else
    retPack = freshTypePack(scope->level);

  // We break this function up into a lambda here to limit our stack footprint.
  // The vectors used by this function aren't allocated until the lambda is
  // actually called.
  auto the_rest = [&]() -> WithPredicate<TypePackId> {
    // checkExpr will log the pre-instantiated type of the function.
    // That's not nearly as interesting as the instantiated type, which will
    // include details about how generic functions are being instantiated for
    // this particular callsite.
    currentModule->astOriginalCallTypes[expr.func] = follow(functionType);
    currentModule->astTypes[expr.func] = actualFunctionType;

    std::vector<TypeId> overloads = flattenIntersection(actualFunctionType);

    std::vector<std::optional<TypeId>> expectedTypes =
        getExpectedTypesForCall(overloads, expr.args.size, expr.self);

    WithPredicate<TypePackId> argListResult = checkExprList(
        scope, expr.location, expr.args, false, {}, expectedTypes);
    TypePackId argPack = argListResult.type;

    if (get<Unifiable::Error>(argPack))
      return WithPredicate{errorRecoveryTypePack(scope)};

    TypePack *args = nullptr;
    if (expr.self) {
      argPack = addTypePack(TypePack{{selfType}, argPack});
      argListResult.type = argPack;
    }
    args = getMutable<TypePack>(argPack);
    LUAU_ASSERT(args);

    std::vector<Location> argLocations;
    argLocations.reserve(expr.args.size + 1);
    if (expr.self)
      argLocations.push_back(expr.func->as<AstExprIndexName>()->expr->location);
    for (AstExpr *arg : expr.args)
      argLocations.push_back(arg->location);

    std::vector<OverloadErrorEntry>
        errors; // errors encountered for each overload

    std::vector<TypeId> overloadsThatMatchArgCount;
    std::vector<TypeId> overloadsThatDont;

    for (TypeId fn : overloads) {
      fn = follow(fn);

      if (auto ret = checkCallOverload(scope, expr, fn, retPack, argPack, args,
                                       &argLocations, argListResult,
                                       overloadsThatMatchArgCount,
                                       overloadsThatDont, errors))
        return *ret;
    }

    if (handleSelfCallMismatch(scope, expr, args, argLocations, errors))
      return WithPredicate{retPack};

    reportOverloadResolutionError(scope, expr, retPack, argPack, argLocations,
                                  overloads, overloadsThatMatchArgCount,
                                  errors);

    const FunctionType *overload = nullptr;
    if (!overloadsThatMatchArgCount.empty())
      overload = get<FunctionType>(overloadsThatMatchArgCount[0]);
    if (!overload && !overloadsThatDont.empty())
      overload = get<FunctionType>(overloadsThatDont[0]);
    if (overload)
      return WithPredicate{errorRecoveryTypePack(overload->retTypes)};

    return WithPredicate{errorRecoveryTypePack(retPack)};
  };

  return the_rest();
}

std::vector<std::optional<TypeId>>
TypeChecker::getExpectedTypesForCall(const std::vector<TypeId> &overloads,
                                     size_t argumentCount, bool selfCall) {
  std::vector<std::optional<TypeId>> expectedTypes;

  auto assignOption = [this, &expectedTypes](size_t index, TypeId ty) {
    if (index == expectedTypes.size()) {
      expectedTypes.push_back(ty);
    } else if (ty) {
      auto &el = expectedTypes[index];

      if (!el) {
        el = ty;
      } else {
        std::vector<TypeId> result = reduceUnion({*el, ty});
        if (result.empty())
          el = neverType;
        else
          el = result.size() == 1 ? result[0]
                                  : addType(UnionType{std::move(result)});
      }
    }
  };

  for (const TypeId overload : overloads) {
    if (const FunctionType *ftv = get<FunctionType>(overload)) {
      auto [argsHead, argsTail] = flatten(ftv->argTypes);

      size_t start = selfCall ? 1 : 0;
      size_t index = 0;

      for (size_t i = start; i < argsHead.size(); ++i)
        assignOption(index++, argsHead[i]);

      if (argsTail) {
        argsTail = follow(*argsTail);
        if (const VariadicTypePack *vtp = get<VariadicTypePack>(*argsTail)) {
          while (index < argumentCount)
            assignOption(index++, vtp->ty);
        }
      }
    }
  }

  Demoter demoter{&currentModule->internalTypes};
  demoter.demote(expectedTypes);

  return expectedTypes;
}

/*
 * Note: We return a std::unique_ptr here rather than an optional to manage our
 * stack consumption. If this was an optional, callers would have to pay the
 * stack cost for the result.  This is problematic for functions that need to
 * support recursion up to 600 levels deep.
 */
std::unique_ptr<WithPredicate<TypePackId>>
TypeChecker::checkCallOverload(const ScopePtr &scope, const AstExprCall &expr,
                               TypeId fn, TypePackId retPack,
                               TypePackId argPack, TypePack *args,
                               const std::vector<Location> *argLocations,
                               const WithPredicate<TypePackId> &argListResult,
                               std::vector<TypeId> &overloadsThatMatchArgCount,
                               std::vector<TypeId> &overloadsThatDont,
                               std::vector<OverloadErrorEntry> &errors) {
  LUAU_ASSERT(argLocations);

  fn = stripFromNilAndReport(fn, expr.func->location);

  if (get<AnyType>(fn)) {
    unify(anyTypePack, argPack, scope, expr.location);
    return std::make_unique<WithPredicate<TypePackId>>(anyTypePack);
  }

  if (get<ErrorType>(fn)) {
    return std::make_unique<WithPredicate<TypePackId>>(
        errorRecoveryTypePack(scope));
  }

  if (get<NeverType>(fn))
    return std::make_unique<WithPredicate<TypePackId>>(uninhabitableTypePack);

  if (auto ftv = get<FreeType>(fn)) {
    // fn is one of the overloads of actualFunctionType, which
    // has been instantiated, so is a monotype. We can therefore
    // unify it with a monomorphic function.
    TypeId r = addType(FunctionType(scope->level, argPack, retPack));

    UnifierOptions options;
    options.isFunctionCall = true;
    unify(r, fn, scope, expr.location, options);

    return std::make_unique<WithPredicate<TypePackId>>(retPack);
  }

  std::vector<Location> metaArgLocations;

  // Might be a callable table or class
  std::optional<TypeId> callTy = std::nullopt;
  if (const MetatableType *mttv = get<MetatableType>(fn)) {
    callTy = getIndexTypeFromType(scope, mttv->metatable, "__call",
                                  expr.func->location, /* addErrors= */ false);
  } else if (const ClassType *ctv = get<ClassType>(fn); ctv && ctv->metatable) {
    callTy = getIndexTypeFromType(scope, *ctv->metatable, "__call",
                                  expr.func->location, /* addErrors= */ false);
  }

  if (callTy) {
    // Construct arguments with 'self' added in front
    TypePackId metaCallArgPack =
        addTypePack(TypePackVar(TypePack{args->head, args->tail}));

    TypePack *metaCallArgs = getMutable<TypePack>(metaCallArgPack);
    metaCallArgs->head.insert(metaCallArgs->head.begin(), fn);

    metaArgLocations = *argLocations;
    metaArgLocations.insert(metaArgLocations.begin(), expr.func->location);

    fn = instantiate(scope, *callTy, expr.func->location);

    argPack = metaCallArgPack;
    args = metaCallArgs;
    argLocations = &metaArgLocations;
  }

  const FunctionType *ftv = get<FunctionType>(fn);
  if (!ftv) {
    reportError(TypeError{expr.func->location, CannotCallNonFunction{fn}});
    unify(errorRecoveryTypePack(scope), retPack, scope, expr.func->location);
    return std::make_unique<WithPredicate<TypePackId>>(
        errorRecoveryTypePack(retPack));
  }

  // When this function type has magic functions and did return something, we
  // select that overload instead.
  // TODO: pass in a Unifier object to the magic functions? This will allow the
  // magic functions to cooperate with overload resolution.
  if (ftv->magicFunction) {
    // TODO: We're passing in the wrong TypePackId. Should be argPack, but a
    // unit test fails otherwise. CLI-40458
    if (std::optional<WithPredicate<TypePackId>> ret =
            ftv->magicFunction(*this, scope, expr, argListResult))
      return std::make_unique<WithPredicate<TypePackId>>(std::move(*ret));
  }

  Unifier state = mkUnifier(scope, expr.location);

  // Unify return types
  checkArgumentList(scope, *expr.func, state, retPack, ftv->retTypes,
                    /*argLocations*/ {});
  if (!state.errors.empty()) {
    return nullptr;
  }

  checkArgumentList(scope, *expr.func, state, argPack, ftv->argTypes,
                    *argLocations);

  if (!state.errors.empty()) {
    bool argMismatch = false;
    for (auto error : state.errors) {
      CountMismatch *cm = get<CountMismatch>(error);
      if (!cm)
        continue;

      if (cm->context == CountMismatch::Arg) {
        argMismatch = true;
        break;
      }
    }

    if (!argMismatch)
      overloadsThatMatchArgCount.push_back(fn);
    else
      overloadsThatDont.push_back(fn);

    errors.push_back(OverloadErrorEntry{
        std::move(state.log),
        std::move(state.errors),
        args->head,
        ftv,
    });
  } else {
    state.log.commit();

    currentModule->astOverloadResolvedTypes[&expr] = fn;

    // We select this overload
    return std::make_unique<WithPredicate<TypePackId>>(retPack);
  }

  return nullptr;
}

bool TypeChecker::handleSelfCallMismatch(
    const ScopePtr &scope, const AstExprCall &expr, TypePack *args,
    const std::vector<Location> &argLocations,
    const std::vector<OverloadErrorEntry> &errors) {
  // No overloads succeeded: Scan for one that would have worked had the user
  // used a.b() rather than a:b() or vice versa.
  for (const auto &e : errors) {
    // Did you write foo:bar() when you should have written foo.bar()?
    if (expr.self) {
      std::vector<Location> editedArgLocations(argLocations.begin() + 1,
                                               argLocations.end());

      std::vector<TypeId> editedParamList(args->head.begin() + 1,
                                          args->head.end());
      TypePackId editedArgPack = addTypePack(TypePack{editedParamList});

      Unifier editedState = mkUnifier(scope, expr.location);
      checkArgumentList(scope, *expr.func, editedState, editedArgPack,
                        e.fnTy->argTypes, editedArgLocations);

      if (editedState.errors.empty()) {
        editedState.log.commit();

        reportError(TypeError{expr.location, FunctionDoesNotTakeSelf{}});
        // This is a little bit suspect: If this overload would work with a .
        // replaced by a : we eagerly assume that that's what you actually meant
        // and we commit to it. This could be incorrect if the function has an
        // additional overload that actually works. checkArgumentList(scope,
        // editedState, retPack, ftv->retTypes, retLocations,
        // CountMismatch::Return);
        return true;
      }
    } else if (e.fnTy->hasSelf) {
      // Did you write foo.bar() when you should have written foo:bar()?
      if (AstExprIndexName *indexName = expr.func->as<AstExprIndexName>()) {
        std::vector<Location> editedArgLocations;
        editedArgLocations.reserve(argLocations.size() + 1);
        editedArgLocations.push_back(indexName->expr->location);
        editedArgLocations.insert(editedArgLocations.end(),
                                  argLocations.begin(), argLocations.end());

        std::vector<TypeId> editedArgList(args->head);
        editedArgList.insert(editedArgList.begin(),
                             checkExpr(scope, *indexName->expr).type);
        TypePackId editedArgPack = addTypePack(TypePack{editedArgList});

        Unifier editedState = mkUnifier(scope, expr.location);

        checkArgumentList(scope, *expr.func, editedState, editedArgPack,
                          e.fnTy->argTypes, editedArgLocations);

        if (editedState.errors.empty()) {
          editedState.log.commit();

          reportError(TypeError{expr.location, FunctionRequiresSelf{}});
          // This is a little bit suspect: If this overload would work with a :
          // replaced by a . we eagerly assume that that's what you actually
          // meant and we commit to it. This could be incorrect if the function
          // has an additional overload that actually works.
          // checkArgumentList(scope, editedState, retPack, ftv->retTypes,
          // retLocations, CountMismatch::Return);
          return true;
        }
      }
    }
  }

  return false;
}

void TypeChecker::reportOverloadResolutionError(
    const ScopePtr &scope, const AstExprCall &expr, TypePackId retPack,
    TypePackId argPack, const std::vector<Location> &argLocations,
    const std::vector<TypeId> &overloads,
    const std::vector<TypeId> &overloadsThatMatchArgCount,
    std::vector<OverloadErrorEntry> &errors) {
  if (overloads.size() == 1) {
    if (FFlag::LuauAlwaysCommitInferencesOfFunctionCalls)
      errors.front().log.commit();

    reportErrors(errors.front().errors);
    return;
  }

  std::vector<TypeId> overloadTypes = overloadsThatMatchArgCount;
  if (overloadsThatMatchArgCount.size() == 0) {
    reportError(
        TypeError{expr.location,
                  GenericError{"No overload for function accepts " +
                               std::to_string(size(argPack)) + " arguments."}});
    // If no overloads match argument count, just list all overloads.
    overloadTypes = overloads;
  } else {
    // Report errors of the first argument-count-matching, but failing overload
    TypeId overload = overloadsThatMatchArgCount[0];

    // Remove the overload we are reporting errors about, from the list of
    // alternative
    overloadTypes.erase(
        std::remove(overloadTypes.begin(), overloadTypes.end(), overload),
        overloadTypes.end());

    const FunctionType *ftv = get<FunctionType>(overload);

    auto error = std::find_if(
        errors.begin(), errors.end(),
        [ftv](const OverloadErrorEntry &e) { return ftv == e.fnTy; });

    LUAU_ASSERT(error != errors.end());

    if (FFlag::LuauAlwaysCommitInferencesOfFunctionCalls)
      error->log.commit();

    reportErrors(error->errors);

    // If only one overload matched, we don't need this error because we
    // provided the previous errors.
    if (overloadsThatMatchArgCount.size() == 1)
      return;
  }

  std::string s;
  for (size_t i = 0; i < overloadTypes.size(); ++i) {
    TypeId overload = follow(overloadTypes[i]);
    Unifier state = mkUnifier(scope, expr.location);

    // Unify return types
    if (const FunctionType *ftv = get<FunctionType>(overload)) {
      checkArgumentList(scope, *expr.func, state, retPack, ftv->retTypes, {});
      checkArgumentList(scope, *expr.func, state, argPack, ftv->argTypes,
                        argLocations);
    }

    if (state.errors.empty())
      state.log.commit();

    if (i > 0)
      s += "; ";

    if (i > 0 && i == overloadTypes.size() - 1)
      s += "and ";

    s += toString(overload);
  }

  if (overloadsThatMatchArgCount.size() == 0)
    reportError(expr.func->location,
                ExtraInformation{"Available overloads: " + s});
  else
    reportError(expr.func->location,
                ExtraInformation{"Other overloads are also not viable: " + s});

  // No viable overload
  return;
}

WithPredicate<TypePackId> TypeChecker::checkExprList(
    const ScopePtr &scope, const Location &location,
    const AstArray<AstExpr *> &exprs, bool substituteFreeForNil,
    const std::vector<bool> &instantiateGenerics,
    const std::vector<std::optional<TypeId>> &expectedTypes) {
  bool uninhabitable = false;
  TypePackId pack = addTypePack(TypePack{});
  PredicateVec
      predicates; // At the moment we will be pushing all predicate sets into
                  // this. Do we need some way to split them up?

  auto insert = [&predicates](PredicateVec &vec) {
    for (Predicate &c : vec)
      predicates.push_back(std::move(c));
  };

  if (exprs.size == 0)
    return WithPredicate{pack};

  TypePack *tp = getMutable<TypePack>(pack);

  size_t lastIndex = exprs.size - 1;
  tp->head.reserve(lastIndex);

  Unifier state = mkUnifier(scope, location);

  std::vector<TxnLog> inverseLogs;

  for (size_t i = 0; i < exprs.size; ++i) {
    AstExpr *expr = exprs.data[i];
    std::optional<TypeId> expectedType =
        i < expectedTypes.size() ? expectedTypes[i] : std::nullopt;

    if (i == lastIndex &&
        (expr->is<AstExprCall>() || expr->is<AstExprVarargs>())) {
      auto [typePack, exprPredicates] = checkExprPack(scope, *expr);
      insert(exprPredicates);

      if (containsNever(typePack)) {
        // f(), g() where f() returns (never, string) or (string, never) means
        // this whole TypePackId is uninhabitable, so return (never,
        // ...never)
        uninhabitable = true;
        continue;
      } else if (std::optional<TypeId> firstTy = first(typePack)) {
        if (!currentModule->astTypes.find(expr))
          currentModule->astTypes[expr] = follow(*firstTy);
      }

      if (expectedType)
        currentModule->astExpectedTypes[expr] = *expectedType;

      tp->tail = typePack;
    } else {
      auto [type, exprPredicates] = checkExpr(scope, *expr, expectedType);
      insert(exprPredicates);

      if (get<NeverType>(type)) {
        // f(), g() where f() returns (never, string) or (string, never) means
        // this whole TypePackId is uninhabitable, so return (never,
        // ...never)
        uninhabitable = true;
        continue;
      }

      TypeId actualType = substituteFreeForNil && expr->is<AstExprConstantNil>()
                              ? freshType(scope)
                              : type;

      if (!FFlag::LuauInstantiateInSubtyping) {
        if (instantiateGenerics.size() > i && instantiateGenerics[i])
          actualType = instantiate(scope, actualType, expr->location);
      }

      if (expectedType) {
        state.tryUnify(actualType, *expectedType);

        // Ugly: In future iterations of the loop, we might need the state of
        // the unification we just performed. There's not a great way to pass
        // that into checkExpr. Instead, we store the inverse of the current
        // log, and commit it. When we're done, we'll commit all the inverses.
        // This isn't optimal, and a better solution is welcome here.
        inverseLogs.push_back(state.log.inverse());
        state.log.commit();
      }

      tp->head.push_back(actualType);
    }
  }

  for (TxnLog &log : inverseLogs)
    log.commit();

  if (uninhabitable)
    return WithPredicate{uninhabitableTypePack};
  return {pack, predicates};
}

std::optional<AstExpr *> TypeChecker::matchRequire(const AstExprCall &call) {
  const char *require = "require";

  if (call.args.size != 1)
    return std::nullopt;

  const AstExprGlobal *funcAsGlobal = call.func->as<AstExprGlobal>();
  if (!funcAsGlobal || funcAsGlobal->name != require)
    return std::nullopt;

  if (call.args.size != 1)
    return std::nullopt;

  return call.args.data[0];
}

TypeId TypeChecker::checkRequire(const ScopePtr &scope,
                                 const ModuleInfo &moduleInfo,
                                 const Location &location) {
  LUAU_TIMETRACE_SCOPE("TypeChecker::checkRequire", "TypeChecker");
  LUAU_TIMETRACE_ARGUMENT("moduleInfo", moduleInfo.name.c_str());

  if (moduleInfo.name.empty()) {
    if (currentModule->mode == Mode::Strict) {
      reportError(TypeError{location, UnknownRequire{}});
      return errorRecoveryType(anyType);
    }

    return anyType;
  }

  // Types of requires that transitively refer to current module have to be
  // replaced with 'any'
  for (const auto &[location, path] : requireCycles) {
    if (!path.empty() && path.front() == moduleInfo.name)
      return anyType;
  }

  ModulePtr module = resolver->getModule(moduleInfo.name);
  if (!module) {
    // There are two reasons why we might fail to find the module:
    // either the file does not exist or there's a cycle. If there's a cycle
    // we will already have reported the error.
    if (!resolver->moduleExists(moduleInfo.name) && !moduleInfo.optional)
      reportError(TypeError{location,
                            UnknownRequire{resolver->getHumanReadableModuleName(
                                moduleInfo.name)}});

    return errorRecoveryType(scope);
  }

  if (module->type != SourceCode::Module) {
    reportError(location,
                IllegalRequire{
                    module->humanReadableName,
                    "Module is not a ModuleScript.  It cannot be required."});
    return errorRecoveryType(scope);
  }

  TypePackId modulePack = module->returnType;

  if (get<Unifiable::Error>(modulePack))
    return errorRecoveryType(scope);

  std::optional<TypeId> moduleType = first(modulePack);
  if (!moduleType) {
    reportError(
        location,
        IllegalRequire{
            module->humanReadableName,
            "Module does not return exactly 1 value.  It cannot be required."});
    return errorRecoveryType(scope);
  }

  return *moduleType;
}

void TypeChecker::tablify(TypeId type) {
  type = follow(type);

  if (auto f = get<FreeType>(type))
    *asMutable(type) = TableType{TableState::Free, f->level};
}

TypeId TypeChecker::anyIfNonstrict(TypeId ty) const {
  if (isNonstrictMode())
    return anyType;
  else
    return ty;
}

bool TypeChecker::unify(TypeId subTy, TypeId superTy, const ScopePtr &scope,
                        const Location &location) {
  UnifierOptions options;
  return unify(subTy, superTy, scope, location, options);
}

bool TypeChecker::unify(TypeId subTy, TypeId superTy, const ScopePtr &scope,
                        const Location &location,
                        const UnifierOptions &options) {
  Unifier state = mkUnifier(scope, location);
  state.tryUnify(subTy, superTy, options.isFunctionCall);

  state.log.commit();

  reportErrors(state.errors);

  return state.errors.empty();
}

bool TypeChecker::unify(TypePackId subTy, TypePackId superTy,
                        const ScopePtr &scope, const Location &location,
                        CountMismatch::Context ctx) {
  Unifier state = mkUnifier(scope, location);
  state.ctx = ctx;
  state.tryUnify(subTy, superTy);

  state.log.commit();

  reportErrors(state.errors);

  return state.errors.empty();
}

bool TypeChecker::unifyWithInstantiationIfNeeded(TypeId subTy, TypeId superTy,
                                                 const ScopePtr &scope,
                                                 const Location &location) {
  Unifier state = mkUnifier(scope, location);
  unifyWithInstantiationIfNeeded(subTy, superTy, scope, state);

  state.log.commit();

  reportErrors(state.errors);

  return state.errors.empty();
}

void TypeChecker::unifyWithInstantiationIfNeeded(TypeId subTy, TypeId superTy,
                                                 const ScopePtr &scope,
                                                 Unifier &state) {
  LUAU_ASSERT(!FFlag::LuauInstantiateInSubtyping);

  if (!maybeGeneric(subTy))
    // Quick check to see if we definitely can't instantiate
    state.tryUnify(subTy, superTy, /*isFunctionCall*/ false);
  else if (!maybeGeneric(superTy) && isGeneric(subTy)) {
    // Quick check to see if we definitely have to instantiate
    TypeId instantiated = instantiate(scope, subTy, state.location);
    state.tryUnify(instantiated, superTy, /*isFunctionCall*/ false);
  } else {
    // First try unifying with the original uninstantiated type
    // but if that fails, try the instantiated one.
    Unifier child = state.makeChildUnifier();
    child.tryUnify(subTy, superTy, /*isFunctionCall*/ false);
    if (!child.errors.empty()) {
      TypeId instantiated =
          instantiate(scope, subTy, state.location, &child.log);
      if (subTy == instantiated) {
        // Instantiating the argument made no difference, so just report any
        // child errors
        state.log.concat(std::move(child.log));

        state.errors.insert(state.errors.end(), child.errors.begin(),
                            child.errors.end());
      } else {
        state.tryUnify(instantiated, superTy, /*isFunctionCall*/ false);
      }
    } else {
      state.log.concat(std::move(child.log));
    }
  }
}

TypeId TypeChecker::quantify(const ScopePtr &scope, TypeId ty,
                             Location location) {
  ty = follow(ty);

  if (FFlag::DebugLuauSharedSelf) {
    if (auto ftv = get<FunctionType>(ty))
      Luau::quantify(ty, scope->level);
    else if (auto ttv = getTableType(ty); ttv && ttv->selfTy)
      Luau::quantify(ty, scope->level);
  } else {
    const FunctionType *ftv = get<FunctionType>(ty);

    if (ftv)
      Luau::quantify(ty, scope->level);
  }

  return ty;
}

TypeId TypeChecker::instantiate(const ScopePtr &scope, TypeId ty,
                                Location location, const TxnLog *log) {
  ty = follow(ty);

  const FunctionType *ftv = get<FunctionType>(ty);
  if (ftv && ftv->hasNoFreeOrGenericTypes)
    return ty;

  std::optional<TypeId> instantiated;

  if (FFlag::LuauReusableSubstitutions) {
    reusableInstantiation.resetState(log, &currentModule->internalTypes,
                                     builtinTypes, scope->level,
                                     /*scope*/ nullptr);

    if (instantiationChildLimit)
      reusableInstantiation.childLimit = *instantiationChildLimit;

    instantiated = reusableInstantiation.substitute(ty);
  } else {
    Instantiation instantiation{log, &currentModule->internalTypes,
                                builtinTypes, scope->level, /*scope*/ nullptr};

    if (instantiationChildLimit)
      instantiation.childLimit = *instantiationChildLimit;

    instantiated = instantiation.substitute(ty);
  }

  if (instantiated.has_value())
    return *instantiated;
  else {
    reportError(location, UnificationTooComplex{});
    return errorRecoveryType(scope);
  }
}

TypeId TypeChecker::anyify(const ScopePtr &scope, TypeId ty,
                           Location location) {
  Anyification anyification{&currentModule->internalTypes,
                            scope,
                            builtinTypes,
                            iceHandler,
                            anyType,
                            anyTypePack};
  std::optional<TypeId> any = anyification.substitute(ty);
  if (anyification.normalizationTooComplex)
    reportError(location, NormalizationTooComplex{});
  if (any.has_value())
    return *any;
  else {
    reportError(location, UnificationTooComplex{});
    return errorRecoveryType(anyType);
  }
}

TypePackId TypeChecker::anyify(const ScopePtr &scope, TypePackId ty,
                               Location location) {
  Anyification anyification{&currentModule->internalTypes,
                            scope,
                            builtinTypes,
                            iceHandler,
                            anyType,
                            anyTypePack};
  std::optional<TypePackId> any = anyification.substitute(ty);
  if (any.has_value())
    return *any;
  else {
    reportError(location, UnificationTooComplex{});
    return errorRecoveryTypePack(anyTypePack);
  }
}

TypePackId TypeChecker::anyifyModuleReturnTypePackGenerics(TypePackId tp) {
  tp = follow(tp);

  if (const VariadicTypePack *vtp = get<VariadicTypePack>(tp)) {
    TypeId ty = follow(vtp->ty);
    return get<GenericType>(ty) ? anyTypePack : tp;
  }

  if (!get<TypePack>(follow(tp)))
    return tp;

  std::vector<TypeId> resultTypes;
  std::optional<TypePackId> resultTail;

  TypePackIterator it = begin(tp);

  for (TypePackIterator e = end(tp); it != e; ++it) {
    TypeId ty = follow(*it);
    resultTypes.push_back(get<GenericType>(ty) ? anyType : ty);
  }

  if (std::optional<TypePackId> tail = it.tail())
    resultTail = anyifyModuleReturnTypePackGenerics(*tail);

  return addTypePack(resultTypes, resultTail);
}

void TypeChecker::reportError(const TypeError &error) {
  if (currentModule->mode == Mode::NoCheck)
    return;
  currentModule->errors.push_back(error);
  currentModule->errors.back().moduleName = currentModule->name;
}

void TypeChecker::reportError(const Location &location,
                              TypeErrorData errorData) {
  return reportError(TypeError{location, std::move(errorData)});
}

void TypeChecker::reportErrors(const ErrorVec &errors) {
  for (const auto &err : errors)
    reportError(err);
}

LUAU_NOINLINE void TypeChecker::ice(const std::string &message,
                                    const Location &location) {
  iceHandler->ice(message, location);
}

LUAU_NOINLINE void TypeChecker::ice(const std::string &message) {
  iceHandler->ice(message);
}

LUAU_NOINLINE void TypeChecker::throwTimeLimitError() {
  throw TimeLimitError(iceHandler->moduleName);
}

LUAU_NOINLINE void TypeChecker::throwUserCancelError() {
  throw UserCancelError(iceHandler->moduleName);
}

void TypeChecker::prepareErrorsForDisplay(ErrorVec &errVec) {
  // Remove errors with names that were generated by recovery from a parse error
  errVec.erase(
      std::remove_if(errVec.begin(), errVec.end(),
                     [](auto &err) { return containsParseErrorName(err); }),
      errVec.end());

  for (auto &err : errVec) {
    if (auto utk = get<UnknownProperty>(err))
      diagnoseMissingTableKey(utk, err.data);
  }
}

void TypeChecker::diagnoseMissingTableKey(UnknownProperty *utk,
                                          TypeErrorData &data) {
  std::string_view sv(utk->key);
  std::set<Name> candidates;

  auto accumulate = [&](const TableType::Props &props) {
    for (const auto &[name, ty] : props) {
      if (sv != name && equalsLower(sv, name))
        candidates.insert(name);
    }
  };

  if (auto ttv = getTableType(utk->table))
    accumulate(ttv->props);
  else if (auto ctv = get<ClassType>(follow(utk->table))) {
    while (ctv) {
      accumulate(ctv->props);

      if (!ctv->parent)
        break;

      ctv = get<ClassType>(*ctv->parent);
      LUAU_ASSERT(ctv);
    }
  }

  if (!candidates.empty())
    data = TypeErrorData(
        UnknownPropButFoundLikeProp{utk->table, utk->key, candidates});
}

LUAU_NOINLINE void
TypeChecker::reportErrorCodeTooComplex(const Location &location) {
  reportError(TypeError{location, CodeTooComplex{}});
}

// Creates a new Scope but without carrying forward the varargs from the parent.
ScopePtr TypeChecker::childFunctionScope(const ScopePtr &parent,
                                         const Location &location,
                                         int subLevel) {
  ScopePtr scope = std::make_shared<Scope>(parent, subLevel);
  currentModule->scopes.push_back(std::make_pair(location, scope));
  return scope;
}

// Creates a new Scope and carries forward the varargs from the parent.
ScopePtr TypeChecker::childScope(const ScopePtr &parent,
                                 const Location &location) {
  ScopePtr scope = std::make_shared<Scope>(parent);
  scope->level = parent->level;
  scope->varargPack = parent->varargPack;

  currentModule->scopes.push_back(std::make_pair(location, scope));
  return scope;
}

void TypeChecker::merge(RefinementMap &l, const RefinementMap &r) {
  Luau::merge(l, r, [this](TypeId a, TypeId b) {
    // TODO: normalize(UnionType{{a, b}})
    std::unordered_set<TypeId> set;

    if (auto utv = get<UnionType>(follow(a)))
      set.insert(begin(utv), end(utv));
    else
      set.insert(a);

    if (auto utv = get<UnionType>(follow(b)))
      set.insert(begin(utv), end(utv));
    else
      set.insert(b);

    std::vector<TypeId> options(set.begin(), set.end());
    if (set.size() == 1)
      return options[0];
    return addType(UnionType{std::move(options)});
  });
}

Unifier TypeChecker::mkUnifier(const ScopePtr &scope,
                               const Location &location) {
  return Unifier{NotNull{&normalizer}, NotNull{scope.get()}, location,
                 Variance::Covariant};
}

TypeId TypeChecker::freshType(const ScopePtr &scope) {
  return freshType(scope->level);
}

TypeId TypeChecker::freshType(TypeLevel level) {
  return currentModule->internalTypes.addType(Type(FreeType(level)));
}

TypeId TypeChecker::singletonType(bool value) {
  return value ? builtinTypes->trueType : builtinTypes->falseType;
}

TypeId TypeChecker::singletonType(std::string value) {
  // TODO: cache singleton types
  return currentModule->internalTypes.addType(
      Type(SingletonType(StringSingleton{std::move(value)})));
}

TypeId TypeChecker::errorRecoveryType(const ScopePtr &scope) {
  return builtinTypes->errorRecoveryType();
}

TypeId TypeChecker::errorRecoveryType(TypeId guess) {
  return builtinTypes->errorRecoveryType(guess);
}

TypePackId TypeChecker::errorRecoveryTypePack(const ScopePtr &scope) {
  return builtinTypes->errorRecoveryTypePack();
}

TypePackId TypeChecker::errorRecoveryTypePack(TypePackId guess) {
  return builtinTypes->errorRecoveryTypePack(guess);
}

TypeIdPredicate TypeChecker::mkTruthyPredicate(bool sense, TypeId emptySetTy) {
  return [this, sense, emptySetTy](TypeId ty) -> std::optional<TypeId> {
    // any/error/free gets a special pass unconditionally because they can't be
    // decided.
    if (get<AnyType>(ty) || get<ErrorType>(ty) || get<FreeType>(ty))
      return ty;

    // maps boolean primitive to the corresponding singleton equal to sense
    if (isPrim(ty, PrimitiveType::Boolean))
      return singletonType(sense);

    // if we have boolean singleton, eliminate it if the sense doesn't match
    // with that singleton
    if (auto boolean = get<BooleanSingleton>(get<SingletonType>(ty)))
      return boolean->value == sense ? std::optional<TypeId>(ty) : std::nullopt;

    // if we have nil, eliminate it if sense is true, otherwise take it
    if (isNil(ty))
      return sense ? std::nullopt : std::optional<TypeId>(ty);

    // at this point, anything else is kept if sense is true, or replaced by nil
    return sense ? ty : emptySetTy;
  };
}

std::optional<TypeId> TypeChecker::filterMapImpl(TypeId type,
                                                 TypeIdPredicate predicate) {
  std::vector<TypeId> types = Luau::filterMap(type, predicate);
  if (!types.empty())
    return types.size() == 1 ? types[0] : addType(UnionType{std::move(types)});
  return std::nullopt;
}

std::pair<std::optional<TypeId>, bool>
TypeChecker::filterMap(TypeId type, TypeIdPredicate predicate) {
  TypeId ty = filterMapImpl(type, predicate).value_or(neverType);
  return {ty, !bool(get<NeverType>(ty))};
}

std::pair<std::optional<TypeId>, bool>
TypeChecker::pickTypesFromSense(TypeId type, bool sense, TypeId emptySetTy) {
  return filterMap(type, mkTruthyPredicate(sense, emptySetTy));
}

TypeId TypeChecker::addTV(Type &&tv) {
  return currentModule->internalTypes.addType(std::move(tv));
}

TypePackId TypeChecker::addTypePack(TypePackVar &&tv) {
  return currentModule->internalTypes.addTypePack(std::move(tv));
}

TypePackId TypeChecker::addTypePack(TypePack &&tp) {
  return addTypePack(TypePackVar(std::move(tp)));
}

TypePackId TypeChecker::addTypePack(const std::vector<TypeId> &ty) {
  return addTypePack(ty, std::nullopt);
}

TypePackId TypeChecker::addTypePack(const std::vector<TypeId> &ty,
                                    std::optional<TypePackId> tail) {
  return addTypePack(TypePackVar(TypePack{ty, tail}));
}

TypePackId TypeChecker::addTypePack(std::initializer_list<TypeId> &&ty) {
  return addTypePack(TypePackVar(
      TypePack{std::vector<TypeId>(begin(ty), end(ty)), std::nullopt}));
}

TypePackId TypeChecker::freshTypePack(const ScopePtr &scope) {
  return freshTypePack(scope->level);
}

TypePackId TypeChecker::freshTypePack(TypeLevel level) {
  return addTypePack(TypePackVar(FreeTypePack(level)));
}

TypeId TypeChecker::resolveType(const ScopePtr &scope,
                                const AstType &annotation) {
  TypeId ty = resolveTypeWorker(scope, annotation);
  currentModule->astResolvedTypes[&annotation] = ty;
  return ty;
}

TypeId TypeChecker::resolveTypeWorker(const ScopePtr &scope,
                                      const AstType &annotation) {
  if (const auto &lit = annotation.as<AstTypeReference>()) {
    std::optional<TypeFun> tf;
    if (lit->prefix)
      tf = scope->lookupImportedType(lit->prefix->value, lit->name.value);

    else if (FFlag::DebugLuauMagicTypes && lit->name == "_luau_ice")
      ice("_luau_ice encountered", lit->location);

    else if (FFlag::DebugLuauMagicTypes && lit->name == "_luau_print") {
      if (lit->parameters.size != 1 || !lit->parameters.data[0].type) {
        reportError(TypeError{
            annotation.location,
            GenericError{"_luau_print requires one generic parameter"}});
        return errorRecoveryType(anyType);
      }

      ToStringOptions opts;
      opts.exhaustive = true;
      opts.maxTableLength = 0;
      opts.useLineBreaks = true;

      TypeId param = resolveType(scope, *lit->parameters.data[0].type);
      luauPrintLine(format("_luau_print\t%s\t|\t%s",
                           toString(param, opts).c_str(),
                           toString(lit->location).c_str()));
      return param;
    }

    else
      tf = scope->lookupType(lit->name.value);

    if (!tf) {
      if (lit->name == kParseNameError)
        return errorRecoveryType(scope);

      std::string typeName;
      if (lit->prefix)
        typeName = std::string(lit->prefix->value) + ".";
      typeName += lit->name.value;

      if (scope->lookupPack(typeName))
        reportError(
            TypeError{annotation.location,
                      SwappedGenericTypeParameter{
                          typeName, SwappedGenericTypeParameter::Type}});
      else
        reportError(TypeError{annotation.location,
                              UnknownSymbol{typeName, UnknownSymbol::Type}});

      return errorRecoveryType(scope);
    }

    if (lit->parameters.size == 0 && tf->typeParams.empty() &&
        tf->typePackParams.empty())
      return tf->type;

    bool parameterCountErrorReported = false;
    bool hasDefaultTypes =
        std::any_of(tf->typeParams.begin(), tf->typeParams.end(),
                    [](auto &&el) { return el.defaultValue.has_value(); });
    bool hasDefaultPacks =
        std::any_of(tf->typePackParams.begin(), tf->typePackParams.end(),
                    [](auto &&el) { return el.defaultValue.has_value(); });

    if (!lit->hasParameterList) {
      if ((!tf->typeParams.empty() && !hasDefaultTypes) ||
          (!tf->typePackParams.empty() && !hasDefaultPacks)) {
        reportError(TypeError{annotation.location,
                              GenericError{"Type parameter list is required"}});
        parameterCountErrorReported = true;
      }
    }

    std::vector<TypeId> typeParams;
    std::vector<TypeId> extraTypes;
    std::vector<TypePackId> typePackParams;

    for (size_t i = 0; i < lit->parameters.size; ++i) {
      if (AstType *type = lit->parameters.data[i].type) {
        TypeId ty = resolveType(scope, *type);

        if (typeParams.size() < tf->typeParams.size() ||
            tf->typePackParams.empty())
          typeParams.push_back(ty);
        else if (typePackParams.empty())
          extraTypes.push_back(ty);
        else
          reportError(TypeError{
              annotation.location,
              GenericError{
                  "Type parameters must come before type pack parameters"}});
      } else if (AstTypePack *typePack = lit->parameters.data[i].typePack) {
        TypePackId tp = resolveTypePack(scope, *typePack);

        // If we have collected an implicit type pack, materialize it
        if (typePackParams.empty() && !extraTypes.empty())
          typePackParams.push_back(addTypePack(extraTypes));

        // If we need more regular types, we can use single element type packs
        // to fill those in
        if (typeParams.size() < tf->typeParams.size() && size(tp) == 1 &&
            finite(tp) && first(tp))
          typeParams.push_back(*first(tp));
        else
          typePackParams.push_back(tp);
      }
    }

    // If we still haven't meterialized an implicit type pack, do it now
    if (typePackParams.empty() && !extraTypes.empty())
      typePackParams.push_back(addTypePack(extraTypes));

    size_t typesProvided = typeParams.size();
    size_t typesRequired = tf->typeParams.size();

    size_t packsProvided = typePackParams.size();
    size_t packsRequired = tf->typePackParams.size();

    bool notEnoughParameters =
        (typesProvided < typesRequired && packsProvided == 0) ||
        (typesProvided == typesRequired && packsProvided < packsRequired);
    bool hasDefaultParameters = hasDefaultTypes || hasDefaultPacks;

    // Add default type and type pack parameters if that's required and it's
    // possible
    if (notEnoughParameters && hasDefaultParameters) {
      // 'applyTypeFunction' is used to substitute default types that reference
      // previous generic types
      ApplyTypeFunction applyTypeFunction{&currentModule->internalTypes};

      for (size_t i = 0; i < typesProvided; ++i)
        applyTypeFunction.typeArguments[tf->typeParams[i].ty] = typeParams[i];

      if (typesProvided < typesRequired) {
        for (size_t i = typesProvided; i < typesRequired; ++i) {
          TypeId defaultTy = tf->typeParams[i].defaultValue.value_or(nullptr);

          if (!defaultTy)
            break;

          std::optional<TypeId> maybeInstantiated =
              applyTypeFunction.substitute(defaultTy);

          if (!maybeInstantiated.has_value()) {
            reportError(annotation.location, UnificationTooComplex{});
            maybeInstantiated = errorRecoveryType(scope);
          }

          applyTypeFunction.typeArguments[tf->typeParams[i].ty] =
              *maybeInstantiated;
          typeParams.push_back(*maybeInstantiated);
        }
      }

      for (size_t i = 0; i < packsProvided; ++i)
        applyTypeFunction.typePackArguments[tf->typePackParams[i].tp] =
            typePackParams[i];

      if (packsProvided < packsRequired) {
        for (size_t i = packsProvided; i < packsRequired; ++i) {
          TypePackId defaultTp =
              tf->typePackParams[i].defaultValue.value_or(nullptr);

          if (!defaultTp)
            break;

          std::optional<TypePackId> maybeInstantiated =
              applyTypeFunction.substitute(defaultTp);

          if (!maybeInstantiated.has_value()) {
            reportError(annotation.location, UnificationTooComplex{});
            maybeInstantiated = errorRecoveryTypePack(scope);
          }

          applyTypeFunction.typePackArguments[tf->typePackParams[i].tp] =
              *maybeInstantiated;
          typePackParams.push_back(*maybeInstantiated);
        }
      }
    }

    // If we didn't combine regular types into a type pack and we're still one
    // type pack short, provide an empty type pack
    if (extraTypes.empty() &&
        typePackParams.size() + 1 == tf->typePackParams.size())
      typePackParams.push_back(addTypePack({}));

    if (typeParams.size() != tf->typeParams.size() ||
        typePackParams.size() != tf->typePackParams.size()) {
      if (!parameterCountErrorReported)
        reportError(TypeError{annotation.location,
                              IncorrectGenericParameterCount{
                                  lit->name.value, *tf, typeParams.size(),
                                  typePackParams.size()}});

      // Pad the types out with error recovery types
      while (typeParams.size() < tf->typeParams.size())
        typeParams.push_back(errorRecoveryType(scope));
      while (typePackParams.size() < tf->typePackParams.size())
        typePackParams.push_back(errorRecoveryTypePack(scope));
    }

    bool sameTys =
        std::equal(typeParams.begin(), typeParams.end(), tf->typeParams.begin(),
                   tf->typeParams.end(),
                   [](auto &&itp, auto &&tp) { return itp == tp.ty; });
    bool sameTps =
        std::equal(typePackParams.begin(), typePackParams.end(),
                   tf->typePackParams.begin(), tf->typePackParams.end(),
                   [](auto &&itpp, auto &&tpp) { return itpp == tpp.tp; });

    // If the generic parameters and the type arguments are the same, we are
    // about to perform an identity substitution, which we can just
    // short-circuit.
    if (sameTys && sameTps)
      return tf->type;

    return instantiateTypeFun(scope, *tf, typeParams, typePackParams,
                              annotation.location);
  } else if (const auto &table = annotation.as<AstTypeTable>()) {
    TableType::Props props;
    std::optional<TableIndexer> tableIndexer;

    for (const auto &prop : table->props) {
      if (prop.access == AstTableAccess::Read)
        reportError(prop.accessLocation.value_or(Location{}),
                    GenericError{"read keyword is illegal here"});
      else if (prop.access == AstTableAccess::Write)
        reportError(prop.accessLocation.value_or(Location{}),
                    GenericError{"write keyword is illegal here"});
      else if (prop.access == AstTableAccess::ReadWrite)
        props[prop.name.value] = {resolveType(scope, *prop.type),
                                  /* deprecated: */ false,
                                  {},
                                  std::nullopt,
                                  {},
                                  std::nullopt,
                                  prop.location};
      else
        ice("Unexpected property access " + std::to_string(int(prop.access)));
    }

    if (const auto &indexer = table->indexer) {
      if (indexer->access == AstTableAccess::Read)
        reportError(indexer->accessLocation.value_or(Location{}),
                    GenericError{"read keyword is illegal here"});
      else if (indexer->access == AstTableAccess::Write)
        reportError(indexer->accessLocation.value_or(Location{}),
                    GenericError{"write keyword is illegal here"});
      else if (indexer->access == AstTableAccess::ReadWrite)
        tableIndexer = TableIndexer(resolveType(scope, *indexer->indexType),
                                    resolveType(scope, *indexer->resultType));
      else
        ice("Unexpected property access " +
            std::to_string(int(indexer->access)));
    }

    TableType ttv{props, tableIndexer, scope->level, TableState::Sealed};
    ttv.definitionModuleName = currentModule->name;
    ttv.definitionLocation = annotation.location;
    return addType(std::move(ttv));
  } else if (const auto &func = annotation.as<AstTypeFunction>()) {
    ScopePtr funcScope = childScope(scope, func->location);
    funcScope->level = scope->level.incr();

    auto [generics, genericPacks] =
        createGenericTypes(funcScope, std::nullopt, annotation, func->generics,
                           func->genericPacks);

    TypePackId argTypes = resolveTypePack(funcScope, func->argTypes);
    TypePackId retTypes = resolveTypePack(funcScope, func->returnTypes);

    std::vector<TypeId> genericTys;
    genericTys.reserve(generics.size());
    std::transform(generics.begin(), generics.end(),
                   std::back_inserter(genericTys),
                   [](auto &&el) { return el.ty; });

    std::vector<TypePackId> genericTps;
    genericTps.reserve(genericPacks.size());
    std::transform(genericPacks.begin(), genericPacks.end(),
                   std::back_inserter(genericTps),
                   [](auto &&el) { return el.tp; });

    TypeId fnType =
        addType(FunctionType{funcScope->level, std::move(genericTys),
                             std::move(genericTps), argTypes, retTypes});

    FunctionType *ftv = getMutable<FunctionType>(fnType);

    ftv->argNames.reserve(func->argNames.size);
    for (const auto &el : func->argNames) {
      if (el)
        ftv->argNames.push_back(FunctionArgument{el->first.value, el->second});
      else
        ftv->argNames.push_back(std::nullopt);
    }

    return fnType;
  } else if (auto typeOf = annotation.as<AstTypeTypeof>()) {
    TypeId ty = checkExpr(scope, *typeOf->expr).type;
    return ty;
  } else if (const auto &un = annotation.as<AstTypeUnion>()) {
    std::vector<TypeId> types;
    for (AstType *ann : un->types)
      types.push_back(resolveType(scope, *ann));

    return addType(UnionType{types});
  } else if (const auto &un = annotation.as<AstTypeIntersection>()) {
    std::vector<TypeId> types;
    for (AstType *ann : un->types)
      types.push_back(resolveType(scope, *ann));

    return addType(IntersectionType{types});
  } else if (const auto &tsb = annotation.as<AstTypeSingletonBool>()) {
    return singletonType(tsb->value);
  } else if (const auto &tss = annotation.as<AstTypeSingletonString>()) {
    return singletonType(std::string(tss->value.data, tss->value.size));
  } else if (annotation.is<AstTypeError>())
    return errorRecoveryType(scope);
  else {
    reportError(TypeError{annotation.location,
                          GenericError{"Unknown type annotation?"}});
    return errorRecoveryType(scope);
  }
}

TypePackId TypeChecker::resolveTypePack(const ScopePtr &scope,
                                        const AstTypeList &types) {
  if (types.types.size == 0 && types.tailType) {
    return resolveTypePack(scope, *types.tailType);
  } else if (types.types.size > 0) {
    std::vector<TypeId> head;
    for (AstType *ann : types.types)
      head.push_back(resolveType(scope, *ann));

    std::optional<TypePackId> tail =
        types.tailType
            ? std::optional<TypePackId>(resolveTypePack(scope, *types.tailType))
            : std::nullopt;
    return addTypePack(TypePack{head, tail});
  }

  return addTypePack(TypePack{});
}

TypePackId TypeChecker::resolveTypePack(const ScopePtr &scope,
                                        const AstTypePack &annotation) {
  TypePackId result;
  if (const AstTypePackVariadic *variadic =
          annotation.as<AstTypePackVariadic>()) {
    result = addTypePack(TypePackVar{
        VariadicTypePack{resolveType(scope, *variadic->variadicType)}});
  } else if (const AstTypePackGeneric *generic =
                 annotation.as<AstTypePackGeneric>()) {
    Name genericName = Name(generic->genericName.value);
    std::optional<TypePackId> genericTy = scope->lookupPack(genericName);

    if (!genericTy) {
      if (scope->lookupType(genericName))
        reportError(
            TypeError{generic->location,
                      SwappedGenericTypeParameter{
                          genericName, SwappedGenericTypeParameter::Pack}});
      else
        reportError(TypeError{generic->location,
                              UnknownSymbol{genericName, UnknownSymbol::Type}});

      result = errorRecoveryTypePack(scope);
    } else {
      result = *genericTy;
    }
  } else if (const AstTypePackExplicit *explicitTp =
                 annotation.as<AstTypePackExplicit>()) {
    std::vector<TypeId> types;

    for (auto type : explicitTp->typeList.types)
      types.push_back(resolveType(scope, *type));

    if (auto tailType = explicitTp->typeList.tailType)
      result = addTypePack(types, resolveTypePack(scope, *tailType));
    else
      result = addTypePack(types);
  } else {
    ice("Unknown AstTypePack kind");
  }

  currentModule->astResolvedTypePacks[&annotation] = result;
  return result;
}

TypeId
TypeChecker::instantiateTypeFun(const ScopePtr &scope, const TypeFun &tf,
                                const std::vector<TypeId> &typeParams,
                                const std::vector<TypePackId> &typePackParams,
                                const Location &location) {
  if (tf.typeParams.empty() && tf.typePackParams.empty())
    return tf.type;

  ApplyTypeFunction applyTypeFunction{&currentModule->internalTypes};

  for (size_t i = 0; i < tf.typeParams.size(); ++i)
    applyTypeFunction.typeArguments[tf.typeParams[i].ty] = typeParams[i];

  for (size_t i = 0; i < tf.typePackParams.size(); ++i)
    applyTypeFunction.typePackArguments[tf.typePackParams[i].tp] =
        typePackParams[i];

  std::optional<TypeId> maybeInstantiated =
      applyTypeFunction.substitute(tf.type);
  if (!maybeInstantiated.has_value()) {
    reportError(location, UnificationTooComplex{});
    return errorRecoveryType(scope);
  }
  if (applyTypeFunction.encounteredForwardedType) {
    reportError(TypeError{
        location,
        GenericError{"Recursive type being used with different parameters"}});
    return errorRecoveryType(scope);
  }

  TypeId instantiated = *maybeInstantiated;

  TypeId target = follow(instantiated);
  const TableType *tfTable = getTableType(tf.type);
  bool needsClone = follow(tf.type) == target ||
                    (tfTable != nullptr && tfTable == getTableType(target));
  bool shouldMutate = getTableType(tf.type);
  TableType *ttv = getMutableTableType(target);

  if (shouldMutate && ttv && needsClone) {
    // Substitution::clone is a shallow clone. If this is a metatable type, we
    // want to mutate its table, so we need to explicitly clone that table as
    // well. If we don't, we will mutate another module's type surface and cause
    // a use-after-free.
    if (get<MetatableType>(target)) {
      instantiated = applyTypeFunction.clone(tf.type);
      MetatableType *mtv = getMutable<MetatableType>(instantiated);
      mtv->table = applyTypeFunction.clone(mtv->table);
      ttv = getMutable<TableType>(mtv->table);
    }
    if (get<TableType>(target)) {
      instantiated = applyTypeFunction.clone(tf.type);
      ttv = getMutable<TableType>(instantiated);
    }
  }

  if (shouldMutate && ttv) {
    ttv->instantiatedTypeParams = typeParams;
    ttv->instantiatedTypePackParams = typePackParams;
    ttv->definitionModuleName = currentModule->name;
    ttv->definitionLocation = location;
  }

  return instantiated;
}

GenericTypeDefinitions TypeChecker::createGenericTypes(
    const ScopePtr &scope, std::optional<TypeLevel> levelOpt,
    const AstNode &node, const AstArray<AstGenericType> &genericNames,
    const AstArray<AstGenericTypePack> &genericPackNames, bool useCache) {
  LUAU_ASSERT(scope->parent);

  const TypeLevel level = levelOpt.value_or(scope->level);

  std::vector<GenericTypeDefinition> generics;

  for (const AstGenericType &generic : genericNames) {
    std::optional<TypeId> defaultValue;

    if (generic.defaultValue)
      defaultValue = resolveType(scope, *generic.defaultValue);

    Name n = generic.name.value;

    // These generics are the only thing that will ever be added to scope, so we
    // can be certain that a collision can only occur when two generic types
    // have the same name.
    if (scope->privateTypeBindings.count(n) ||
        scope->privateTypePackBindings.count(n)) {
      // TODO(jhuelsman): report the exact span of the generic type parameter
      // whose name is a duplicate.
      reportError(TypeError{node.location, DuplicateGenericParameter{n}});
    }

    TypeId g;
    if (useCache) {
      TypeId &cached = scope->parent->typeAliasTypeParameters[n];
      if (!cached)
        cached = addType(GenericType{level, n});
      g = cached;
    } else {
      g = addType(GenericType{level, n});
    }

    generics.push_back({g, defaultValue});
    scope->privateTypeBindings[n] = TypeFun{{}, g};
  }

  std::vector<GenericTypePackDefinition> genericPacks;

  for (const AstGenericTypePack &genericPack : genericPackNames) {
    std::optional<TypePackId> defaultValue;

    if (genericPack.defaultValue)
      defaultValue = resolveTypePack(scope, *genericPack.defaultValue);

    Name n = genericPack.name.value;

    // These generics are the only thing that will ever be added to scope, so we
    // can be certain that a collision can only occur when two generic types
    // have the same name.
    if (scope->privateTypePackBindings.count(n) ||
        scope->privateTypeBindings.count(n)) {
      // TODO(jhuelsman): report the exact span of the generic type parameter
      // whose name is a duplicate.
      reportError(TypeError{node.location, DuplicateGenericParameter{n}});
    }

    TypePackId &cached = scope->parent->typeAliasTypePackParameters[n];
    if (!cached)
      cached = addTypePack(TypePackVar{GenericTypePack{level, n}});

    genericPacks.push_back({cached, defaultValue});
    scope->privateTypePackBindings[n] = cached;
  }

  return {generics, genericPacks};
}

void TypeChecker::refineLValue(const LValue &lvalue, RefinementMap &refis,
                               const ScopePtr &scope,
                               TypeIdPredicate predicate) {
  const LValue *target = &lvalue;
  std::optional<LValue>
      key; // If set, we know we took the base of the lvalue path and should be
           // walking down each option of the base's type.

  auto ty = resolveLValue(scope, *target);
  if (!ty)
    return; // Do nothing. An error was already reported.

  // If the provided lvalue is a local or global, then that's without a doubt
  // the target. However, if there is a base lvalue, then we'll want that to be
  // the target iff the base is a union type.
  if (auto base = baseof(lvalue)) {
    std::optional<TypeId> baseTy = resolveLValue(scope, *base);
    if (baseTy && get<UnionType>(follow(*baseTy))) {
      ty = baseTy;
      target = base;
      key = lvalue;
    }
  }

  // If we do not have a key, it means we're not trying to discriminate
  // anything, so it's a simple matter of just filtering for a subset.
  if (!key) {
    auto [result, ok] = filterMap(*ty, predicate);
    addRefinement(refis, *target, *result);
    return;
  }

  // Otherwise, we'll want to walk each option of ty, get its index type, and
  // filter that.
  auto utv = get<UnionType>(follow(*ty));
  LUAU_ASSERT(utv);

  std::unordered_set<TypeId> viableTargetOptions;
  std::unordered_set<TypeId>
      viableChildOptions; // There may be additional refinements that apply. We
                          // add those here too.

  for (TypeId option : utv) {
    std::optional<TypeId> discriminantTy;
    if (auto field = Luau::get<Field>(
            *key)) // need to fully qualify Luau::get because of ADL.
      discriminantTy = getIndexTypeFromType(scope, option, field->key,
                                            Location(), /* addErrors= */ false);
    else
      LUAU_ASSERT(!"Unhandled LValue alternative?");

    if (!discriminantTy)
      return; // Do nothing. An error was already reported, as per usual.

    auto [result, ok] = filterMap(*discriminantTy, predicate);
    if (!get<NeverType>(*result)) {
      viableTargetOptions.insert(option);
      viableChildOptions.insert(*result);
    }
  }

  auto intoType =
      [this](const std::unordered_set<TypeId> &s) -> std::optional<TypeId> {
    if (s.empty())
      return std::nullopt;

    // TODO: allocate UnionType and just normalize.
    std::vector<TypeId> options(s.begin(), s.end());
    if (options.size() == 1)
      return options[0];

    return addType(UnionType{std::move(options)});
  };

  if (std::optional<TypeId> viableTargetType = intoType(viableTargetOptions))
    addRefinement(refis, *target, *viableTargetType);

  if (std::optional<TypeId> viableChildType = intoType(viableChildOptions))
    addRefinement(refis, lvalue, *viableChildType);
}

std::optional<TypeId> TypeChecker::resolveLValue(const ScopePtr &scope,
                                                 const LValue &lvalue) {
  // We want to be walking the Scope parents.
  // We'll also want to walk up the LValue path. As we do this, we need to save
  // each LValue because we must walk back. For example:
  //  There exists an entry t.x.
  //  We are asked to look for t.x.y.
  //  We need to search in the provided Scope. Find t.x.y first.
  //  We fail to find t.x.y. Try t.x. We found it. Now we must return the type
  //  of the property y from the mapped-to type of t.x. If we completely fail to
  //  find the Symbol t but the Scope has that entry, then we should walk that
  //  all the way through and terminate.
  const Symbol symbol = getBaseSymbol(lvalue);

  ScopePtr currentScope = scope;
  while (currentScope) {
    std::optional<TypeId> found;

    const LValue *topLValue = nullptr;

    for (topLValue = &lvalue; topLValue; topLValue = baseof(*topLValue)) {
      if (auto it = currentScope->refinements.find(*topLValue);
          it != currentScope->refinements.end()) {
        found = it->second;
        break;
      }
    }

    if (!found) {
      // Should not be using scope->lookup. This is already recursive.
      if (auto it = currentScope->bindings.find(symbol);
          it != currentScope->bindings.end())
        found = it->second.typeId;
      else {
        // Nothing exists in this Scope. Just skip and try the parent one.
        currentScope = currentScope->parent;
        continue;
      }
    }

    // We need to walk the l-value path in reverse, so we collect components
    // into a vector
    std::vector<const LValue *> childKeys;

    for (const LValue *curr = &lvalue; curr != topLValue; curr = baseof(*curr))
      childKeys.push_back(curr);

    for (auto it = childKeys.rbegin(); it != childKeys.rend(); ++it) {
      const LValue &key = **it;

      // Symbol can happen. Skip.
      if (get<Symbol>(key))
        continue;
      else if (auto field = get<Field>(key)) {
        found = getIndexTypeFromType(scope, *found, field->key, Location(),
                                     /* addErrors= */ false);
        if (!found)
          return std::nullopt; // Turns out this type doesn't have the property
                               // at all. We're done.
      } else
        LUAU_ASSERT(!"New LValue alternative not handled here.");
    }

    return found;
  }

  // No entry for it at all. Can happen when LValue root is a global.
  return std::nullopt;
}

std::optional<TypeId> TypeChecker::resolveLValue(const RefinementMap &refis,
                                                 const ScopePtr &scope,
                                                 const LValue &lvalue) {
  if (auto it = refis.find(lvalue); it != refis.end())
    return it->second;
  else
    return resolveLValue(scope, lvalue);
}

// Only should be used for refinements!
// This can probably go away once we have something that can limit a free type's
// type domain.
static bool isUndecidable(TypeId ty) {
  ty = follow(ty);
  return get<AnyType>(ty) || get<ErrorType>(ty) || get<FreeType>(ty);
}

void TypeChecker::resolve(const PredicateVec &predicates, const ScopePtr &scope,
                          bool sense) {
  resolve(predicates, scope->refinements, scope, sense);
}

void TypeChecker::resolve(const PredicateVec &predicates, RefinementMap &refis,
                          const ScopePtr &scope, bool sense, bool fromOr) {
  for (const Predicate &c : predicates)
    resolve(c, refis, scope, sense, fromOr);
}

void TypeChecker::resolve(const Predicate &predicate, RefinementMap &refis,
                          const ScopePtr &scope, bool sense, bool fromOr) {
  if (auto truthyP = get<TruthyPredicate>(predicate))
    resolve(*truthyP, refis, scope, sense, fromOr);
  else if (auto andP = get<AndPredicate>(predicate))
    resolve(*andP, refis, scope, sense);
  else if (auto orP = get<OrPredicate>(predicate))
    resolve(*orP, refis, scope, sense);
  else if (auto notP = get<NotPredicate>(predicate))
    resolve(notP->predicates, refis, scope, !sense, fromOr);
  else if (auto isaP = get<IsAPredicate>(predicate))
    resolve(*isaP, refis, scope, sense);
  else if (auto typeguardP = get<TypeGuardPredicate>(predicate))
    resolve(*typeguardP, refis, scope, sense);
  else if (auto eqP = get<EqPredicate>(predicate))
    resolve(*eqP, refis, scope, sense);
  else
    ice("Unhandled predicate kind");
}

void TypeChecker::resolve(const TruthyPredicate &truthyP, RefinementMap &refis,
                          const ScopePtr &scope, bool sense, bool fromOr) {
  std::optional<TypeId> ty = resolveLValue(refis, scope, truthyP.lvalue);
  if (ty && fromOr)
    return addRefinement(refis, truthyP.lvalue, *ty);

  refineLValue(truthyP.lvalue, refis, scope, mkTruthyPredicate(sense, nilType));
}

void TypeChecker::resolve(const AndPredicate &andP, RefinementMap &refis,
                          const ScopePtr &scope, bool sense) {
  if (!sense) {
    OrPredicate orP{
        {NotPredicate{std::move(andP.lhs)}},
        {NotPredicate{std::move(andP.rhs)}},
    };

    return resolve(orP, refis, scope, !sense);
  }

  resolve(andP.lhs, refis, scope, sense);
  resolve(andP.rhs, refis, scope, sense);
}

void TypeChecker::resolve(const OrPredicate &orP, RefinementMap &refis,
                          const ScopePtr &scope, bool sense) {
  if (!sense) {
    AndPredicate andP{
        {NotPredicate{std::move(orP.lhs)}},
        {NotPredicate{std::move(orP.rhs)}},
    };

    return resolve(andP, refis, scope, !sense);
  }

  RefinementMap leftRefis;
  resolve(orP.lhs, leftRefis, scope, sense);

  RefinementMap rightRefis;
  resolve(orP.lhs, rightRefis, scope, !sense);
  resolve(orP.rhs, rightRefis, scope, sense, true); // :(

  merge(refis, leftRefis);
  merge(refis, rightRefis);
}

void TypeChecker::resolve(const IsAPredicate &isaP, RefinementMap &refis,
                          const ScopePtr &scope, bool sense) {
  auto predicate = [&](TypeId option) -> std::optional<TypeId> {
    // This by itself is not truly enough to determine that A is stronger than B
    // or vice versa.
    bool optionIsSubtype =
        canUnify(option, isaP.ty, scope, isaP.location).empty();
    bool targetIsSubtype =
        canUnify(isaP.ty, option, scope, isaP.location).empty();

    // If A is a superset of B, then if sense is true, we promote A to B,
    // otherwise we keep A.
    if (!optionIsSubtype && targetIsSubtype)
      return sense ? isaP.ty : option;

    // If A is a subset of B, then if sense is true we pick A, otherwise we
    // eliminate A.
    if (optionIsSubtype && !targetIsSubtype)
      return sense ? std::optional<TypeId>(option) : std::nullopt;

    // If neither has any relationship, we only return A if sense is false.
    if (!optionIsSubtype && !targetIsSubtype)
      return sense ? std::nullopt : std::optional<TypeId>(option);

    // If both are subtypes, then we're in one of the two situations:
    //   1. Instance <: Instance  Instance <: Instance
    //   2. any <: Instance  Instance <: any
    // Right now, we have to look at the types to see if they were undecidables.
    // By this point, we also know free tables are also subtypes and supertypes.
    if (optionIsSubtype && targetIsSubtype) {
      // We can only have (any, Instance) because the rhs is never undecidable
      // right now. So we can just return the right hand side immediately.

      // typeof(x) == "Instance" where x : any
      auto ttv = get<TableType>(option);
      if (isUndecidable(option) || (ttv && ttv->state == TableState::Free))
        return sense ? isaP.ty : option;

      // typeof(x) == "Instance" where x : Instance
      if (sense)
        return isaP.ty;
    }

    // local variable works around an odd gcc 9.3 warning: <anonymous> may be
    // used uninitialized
    std::optional<TypeId> res = std::nullopt;
    return res;
  };

  refineLValue(isaP.lvalue, refis, scope, predicate);
}

void TypeChecker::resolve(const TypeGuardPredicate &typeguardP,
                          RefinementMap &refis, const ScopePtr &scope,
                          bool sense) {
  // Rewrite the predicate 'type(foo) == "vector"' to be 'typeof(foo) ==
  // "Vector3"'. They're exactly identical. This allows us to avoid writing in
  // edge cases.
  if (!typeguardP.isTypeof && typeguardP.kind == "vector")
    return resolve(TypeGuardPredicate{std::move(typeguardP.lvalue),
                                      typeguardP.location, "Vector3", true},
                   refis, scope, sense);

  std::optional<TypeId> ty = resolveLValue(refis, scope, typeguardP.lvalue);
  if (!ty)
    return;

  // In certain cases, the value may actually be nil, but Luau doesn't know
  // about it. So we whitelist this.
  if (sense && typeguardP.kind == "nil") {
    addRefinement(refis, typeguardP.lvalue, nilType);
    return;
  }

  auto refine = [this, &lvalue = typeguardP.lvalue, &refis, &scope,
                 sense](bool(f)(TypeId),
                        std::optional<TypeId> mapsTo = std::nullopt) {
    TypeIdPredicate predicate = [f, mapsTo,
                                 sense](TypeId ty) -> std::optional<TypeId> {
      if (sense && get<UnknownType>(ty))
        return mapsTo.value_or(ty);

      if (f(ty) == sense)
        return ty;

      if (isUndecidable(ty))
        return mapsTo.value_or(ty);

      return std::nullopt;
    };

    refineLValue(lvalue, refis, scope, predicate);
  };

  // Note: "vector" never happens here at this point, so we don't have to write
  // something for it.
  if (typeguardP.kind == "nil")
    return refine(isNil, nilType); // This can still happen when sense is false!
  else if (typeguardP.kind == "string")
    return refine(isString, stringType);
  else if (typeguardP.kind == "number")
    return refine(isNumber, numberType);
  else if (typeguardP.kind == "boolean")
    return refine(isBoolean, booleanType);
  else if (typeguardP.kind == "thread")
    return refine(isThread, threadType);
  else if (typeguardP.kind == "buffer")
    return refine(isBuffer, bufferType);
  else if (typeguardP.kind == "table") {
    return refine([](TypeId ty) -> bool {
      return isTableIntersection(ty) || get<TableType>(ty) ||
             get<MetatableType>(ty);
    });
  } else if (typeguardP.kind == "function") {
    return refine([](TypeId ty) -> bool {
      return isOverloadedFunction(ty) || get<FunctionType>(ty);
    });
  } else if (typeguardP.kind == "userdata") {
    // For now, we don't really care about being accurate with userdata if the
    // typeguard was using typeof.
    return refine([](TypeId ty) -> bool { return get<ClassType>(ty); });
  }

  if (!typeguardP.isTypeof)
    return addRefinement(refis, typeguardP.lvalue, errorRecoveryType(scope));

  auto typeFun = globalScope->lookupType(typeguardP.kind);
  if (!typeFun || !typeFun->typeParams.empty() ||
      !typeFun->typePackParams.empty())
    return addRefinement(refis, typeguardP.lvalue, errorRecoveryType(scope));

  TypeId type = follow(typeFun->type);

  // You cannot refine to the top class type.
  if (type == builtinTypes->classType) {
    return addRefinement(refis, typeguardP.lvalue, errorRecoveryType(scope));
  }

  // We're only interested in the root class of any classes.
  if (auto ctv = get<ClassType>(type);
      !ctv || ctv->parent != builtinTypes->classType)
    return addRefinement(refis, typeguardP.lvalue, errorRecoveryType(scope));

  // This probably hints at breaking out type filtering functions from the
  // predicate solver so that typeof is not tightly coupled with IsA. Until
  // then, we rewrite this to be the same as using IsA.
  return resolve(
      IsAPredicate{std::move(typeguardP.lvalue), typeguardP.location, type},
      refis, scope, sense);
}

void TypeChecker::resolve(const EqPredicate &eqP, RefinementMap &refis,
                          const ScopePtr &scope, bool sense) {
  // This refinement will require success typing to do everything correctly. For
  // now, we can get most of the way there.
  auto options = [](TypeId ty) -> std::vector<TypeId> {
    if (auto utv = get<UnionType>(follow(ty)))
      return std::vector<TypeId>(begin(utv), end(utv));
    return {ty};
  };

  std::vector<TypeId> rhs = options(eqP.type);

  if (sense && std::any_of(rhs.begin(), rhs.end(), isUndecidable))
    return; // Optimization: the other side has unknown types, so there's
            // probably an overlap. Refining is no-op here.

  auto predicate = [&](TypeId option) -> std::optional<TypeId> {
    if (!sense && isNil(eqP.type))
      return (isUndecidable(option) || !isNil(option))
                 ? std::optional<TypeId>(option)
                 : std::nullopt;

    if (maybeSingleton(eqP.type)) {
      bool optionIsSubtype =
          canUnify(option, eqP.type, scope, eqP.location).empty();
      bool targetIsSubtype =
          canUnify(eqP.type, option, scope, eqP.location).empty();

      // terminology refresher:
      // - option is the type of the expression `x`, and
      // - eqP.type is the type of the expression `"hello"`
      //
      // "hello" == x where
      // x : "hello" | "world" -> x : "hello"
      // x : number | string   -> x : "hello"
      // x : number            -> x : never
      //
      // "hello" ~= x where
      // x : "hello" | "world" -> x : "world"
      // x : number | string   -> x : number | string
      // x : number            -> x : number

      // local variable works around an odd gcc 9.3 warning: <anonymous> may be
      // used uninitialized
      std::optional<TypeId> nope = std::nullopt;

      if (sense) {
        if (optionIsSubtype && !targetIsSubtype)
          return option;
        else if (!optionIsSubtype && targetIsSubtype)
          return follow(eqP.type);
        else if (!optionIsSubtype && !targetIsSubtype)
          return nope;
        else if (optionIsSubtype && targetIsSubtype)
          return follow(eqP.type);
      } else {
        bool isOptionSingleton = get<SingletonType>(option);
        if (!isOptionSingleton)
          return option;
        else if (optionIsSubtype && targetIsSubtype)
          return nope;
      }
    }

    return option;
  };

  refineLValue(eqP.lvalue, refis, scope, predicate);
}

bool TypeChecker::isNonstrictMode() const {
  return (currentModule->mode == Mode::Nonstrict) ||
         (currentModule->mode == Mode::NoCheck);
}

std::vector<TypeId> TypeChecker::unTypePack(const ScopePtr &scope,
                                            TypePackId tp,
                                            size_t expectedLength,
                                            const Location &location) {
  TypePackId expectedTypePack = addTypePack({});
  TypePack *expectedPack = getMutable<TypePack>(expectedTypePack);
  LUAU_ASSERT(expectedPack);
  for (size_t i = 0; i < expectedLength; ++i)
    expectedPack->head.push_back(freshType(scope));

  size_t oldErrorsSize = currentModule->errors.size();

  unify(tp, expectedTypePack, scope, location);

  // HACK: tryUnify would undo the changes to the expectedTypePack if the length
  // mismatches, but we want to tie up free types to be error types, so we do
  // this instead.
  currentModule->errors.resize(oldErrorsSize);

  for (TypeId &tp : expectedPack->head)
    tp = follow(tp);

  return expectedPack->head;
}

std::vector<std::pair<Location, ScopePtr>> TypeChecker::getScopes() const {
  return currentModule->scopes;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// DONE : was aleready inlined <Luau/Clone.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// DONE : was aleready inlined <Luau/FileResolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <stdexcept>

// @@@ PACK.lua : not found, likely and std header
#include <string>

// @@@@@ PACK.LUA : was already included! <type_traits>

// @@@ PACK.lua : not found, likely and std header
#include <unordered_set>

LUAU_FASTINTVARIABLE(LuauIndentTypeMismatchMaxTypeLength, 10)

LUAU_DYNAMIC_FASTFLAGVARIABLE(LuauImproveNonFunctionCallError, false)

static std::string wrongNumberOfArgsString(size_t expectedCount,
                                           std::optional<size_t> maximumCount,
                                           size_t actualCount,
                                           const char *argPrefix = nullptr,
                                           bool isVariadic = false) {
  std::string s = "expects ";

  if (isVariadic)
    s += "at least ";

  s += std::to_string(expectedCount) + " ";

  if (maximumCount && expectedCount != *maximumCount)
    s += "to " + std::to_string(*maximumCount) + " ";

  if (argPrefix)
    s += std::string(argPrefix) + " ";

  s += "argument";
  if ((maximumCount ? *maximumCount : expectedCount) != 1)
    s += "s";

  s += ", but ";

  if (actualCount == 0) {
    s += "none";
  } else {
    if (actualCount < expectedCount)
      s += "only ";

    s += std::to_string(actualCount);
  }

  s += (actualCount == 1) ? " is" : " are";

  s += " specified";

  return s;
}

namespace Luau {

// this list of binary operator type functions is used for better
// stringification of type functions errors
static const std::unordered_map<std::string, const char *> kBinaryOps{
    {"add", "+"},      {"sub", "-"}, {"mul", "*"},      {"div", "/"},
    {"idiv", "//"},    {"pow", "^"}, {"mod", "%"},      {"concat", ".."},
    {"and", "and"},    {"or", "or"}, {"lt", "< or >="}, {"le", "<= or >"},
    {"eq", "== or ~="}};

// this list of unary operator type functions is used for better stringification
// of type functions errors
static const std::unordered_map<std::string, const char *> kUnaryOps{
    {"unm", "-"}, {"len", "#"}, {"not", "not"}};

// this list of type functions will receive a special error indicating that the
// user should file a bug on the GitHub repository putting a type function in
// this list indicates that it is expected to _always_ reduce
static const std::unordered_set<std::string> kUnreachableTypeFunctions{
    "refine", "singleton", "union", "intersect"};

struct ErrorConverter {
  FileResolver *fileResolver = nullptr;

  std::string operator()(const Luau::TypeMismatch &tm) const {
    std::string givenTypeName = Luau::toString(tm.givenType);
    std::string wantedTypeName = Luau::toString(tm.wantedType);

    std::string result;

    auto quote = [&](std::string s) { return "'" + s + "'"; };

    auto constructErrorMessage =
        [&](std::string givenType, std::string wantedType,
            std::optional<std::string> givenModule,
            std::optional<std::string> wantedModule) -> std::string {
      std::string given =
          givenModule ? quote(givenType) + " from " + quote(*givenModule)
                      : quote(givenType);
      std::string wanted =
          wantedModule ? quote(wantedType) + " from " + quote(*wantedModule)
                       : quote(wantedType);
      size_t luauIndentTypeMismatchMaxTypeLength =
          size_t(FInt::LuauIndentTypeMismatchMaxTypeLength);
      if (givenType.length() <= luauIndentTypeMismatchMaxTypeLength ||
          wantedType.length() <= luauIndentTypeMismatchMaxTypeLength)
        return "Type " + given + " could not be converted into " + wanted;
      return "Type\n    " + given + "\ncould not be converted into\n    " +
             wanted;
    };

    if (givenTypeName == wantedTypeName) {
      if (auto givenDefinitionModule = getDefinitionModuleName(tm.givenType)) {
        if (auto wantedDefinitionModule =
                getDefinitionModuleName(tm.wantedType)) {
          if (fileResolver != nullptr) {
            std::string givenModuleName =
                fileResolver->getHumanReadableModuleName(
                    *givenDefinitionModule);
            std::string wantedModuleName =
                fileResolver->getHumanReadableModuleName(
                    *wantedDefinitionModule);
            result = constructErrorMessage(givenTypeName, wantedTypeName,
                                           givenModuleName, wantedModuleName);
          } else {
            result = constructErrorMessage(givenTypeName, wantedTypeName,
                                           *givenDefinitionModule,
                                           *wantedDefinitionModule);
          }
        }
      }
    }

    if (result.empty())
      result = constructErrorMessage(givenTypeName, wantedTypeName,
                                     std::nullopt, std::nullopt);

    if (tm.error) {
      result += "\ncaused by:\n  ";

      if (!tm.reason.empty())
        result += tm.reason + "\n";

      result +=
          Luau::toString(*tm.error, TypeErrorToStringOptions{fileResolver});
    } else if (!tm.reason.empty()) {
      result += "; " + tm.reason;
    } else if (tm.context == TypeMismatch::InvariantContext) {
      result += " in an invariant context";
    }

    return result;
  }

  std::string operator()(const Luau::UnknownSymbol &e) const {
    switch (e.context) {
    case UnknownSymbol::Binding:
      return "Unknown global '" + e.name + "'";
    case UnknownSymbol::Type:
      return "Unknown type '" + e.name + "'";
    }

    LUAU_ASSERT(!"Unexpected context for UnknownSymbol");
    return "";
  }

  std::string operator()(const Luau::UnknownProperty &e) const {
    TypeId t = follow(e.table);
    if (get<TableType>(t))
      return "Key '" + e.key + "' not found in table '" + Luau::toString(t) +
             "'";
    else if (get<ClassType>(t))
      return "Key '" + e.key + "' not found in class '" + Luau::toString(t) +
             "'";
    else
      return "Type '" + Luau::toString(e.table) + "' does not have key '" +
             e.key + "'";
  }

  std::string operator()(const Luau::NotATable &e) const {
    return "Expected type table, got '" + Luau::toString(e.ty) + "' instead";
  }

  std::string operator()(const Luau::CannotExtendTable &e) const {
    switch (e.context) {
    case Luau::CannotExtendTable::Property:
      return "Cannot add property '" + e.prop + "' to table '" +
             Luau::toString(e.tableType) + "'";
    case Luau::CannotExtendTable::Metatable:
      return "Cannot add metatable to table '" + Luau::toString(e.tableType) +
             "'";
    case Luau::CannotExtendTable::Indexer:
      return "Cannot add indexer to table '" + Luau::toString(e.tableType) +
             "'";
    }

    LUAU_ASSERT(!"Unknown context");
    return "";
  }

  std::string operator()(const Luau::OnlyTablesCanHaveMethods &e) const {
    return "Cannot add method to non-table type '" +
           Luau::toString(e.tableType) + "'";
  }

  std::string operator()(const Luau::DuplicateTypeDefinition &e) const {
    std::string s = "Redefinition of type '" + e.name + "'";
    if (e.previousLocation)
      s += ", previously defined at line " +
           std::to_string(e.previousLocation->begin.line + 1);
    return s;
  }

  std::string operator()(const Luau::CountMismatch &e) const {
    const std::string expectedS = e.expected == 1 ? "" : "s";
    const std::string actualS = e.actual == 1 ? "" : "s";
    const std::string actualVerb = e.actual == 1 ? "is" : "are";

    switch (e.context) {
    case CountMismatch::Return:
      return "Expected to return " + std::to_string(e.expected) + " value" +
             expectedS + ", but " + std::to_string(e.actual) + " " +
             actualVerb + " returned here";
    case CountMismatch::FunctionResult:
      // It is alright if right hand side produces more values than the
      // left hand side accepts. In this context consider only the opposite
      // case.
      return "Function only returns " + std::to_string(e.expected) + " value" +
             expectedS + ", but " + std::to_string(e.actual) + " " +
             actualVerb + " required here";
    case CountMismatch::ExprListResult:
      return "Expression list has " + std::to_string(e.expected) + " value" +
             expectedS + ", but " + std::to_string(e.actual) + " " +
             actualVerb + " required here";
    case CountMismatch::Arg:
      if (!e.function.empty())
        return "Argument count mismatch. Function '" + e.function + "' " +
               wrongNumberOfArgsString(e.expected, e.maximum, e.actual,
                                       /*argPrefix*/ nullptr, e.isVariadic);
      else
        return "Argument count mismatch. Function " +
               wrongNumberOfArgsString(e.expected, e.maximum, e.actual,
                                       /*argPrefix*/ nullptr, e.isVariadic);
    }

    LUAU_ASSERT(!"Unknown context");
    return "";
  }

  std::string operator()(const Luau::FunctionDoesNotTakeSelf &) const {
    return std::string("This function does not take self. Did you mean to use "
                       "a dot instead of a colon?");
  }

  std::string operator()(const Luau::FunctionRequiresSelf &e) const {
    return "This function must be called with self. Did you mean to use a "
           "colon instead of a dot?";
  }

  std::string operator()(const Luau::OccursCheckFailed &) const {
    return "Type contains a self-recursive construct that cannot be resolved";
  }

  std::string operator()(const Luau::UnknownRequire &e) const {
    if (e.modulePath.empty())
      return "Unknown require: unsupported path";
    else
      return "Unknown require: " + e.modulePath;
  }

  std::string operator()(const Luau::IncorrectGenericParameterCount &e) const {
    std::string name = e.name;
    if (!e.typeFun.typeParams.empty() || !e.typeFun.typePackParams.empty()) {
      name += "<";
      bool first = true;
      for (auto param : e.typeFun.typeParams) {
        if (first)
          first = false;
        else
          name += ", ";

        name += toString(param.ty);
      }

      for (auto param : e.typeFun.typePackParams) {
        if (first)
          first = false;
        else
          name += ", ";

        name += toString(param.tp);
      }

      name += ">";
    }

    if (e.typeFun.typeParams.size() != e.actualParameters)
      return "Generic type '" + name + "' " +
             wrongNumberOfArgsString(e.typeFun.typeParams.size(), std::nullopt,
                                     e.actualParameters, "type",
                                     !e.typeFun.typePackParams.empty());

    return "Generic type '" + name + "' " +
           wrongNumberOfArgsString(e.typeFun.typePackParams.size(),
                                   std::nullopt, e.actualPackParameters,
                                   "type pack", /*isVariadic*/ false);
  }

  std::string operator()(const Luau::SyntaxError &e) const { return e.message; }

  std::string operator()(const Luau::CodeTooComplex &) const {
    return "Code is too complex to typecheck! Consider simplifying the code "
           "around this area";
  }

  std::string operator()(const Luau::UnificationTooComplex &) const {
    return "Internal error: Code is too complex to typecheck! Consider adding "
           "type annotations around this area";
  }

  std::string operator()(const Luau::UnknownPropButFoundLikeProp &e) const {
    std::string candidatesSuggestion = "Did you mean ";
    if (e.candidates.size() != 1)
      candidatesSuggestion += "one of ";

    bool first = true;
    for (Name name : e.candidates) {
      if (first)
        first = false;
      else
        candidatesSuggestion += ", ";

      candidatesSuggestion += "'" + name + "'";
    }

    std::string s = "Key '" + e.key + "' not found in ";

    TypeId t = follow(e.table);
    if (get<ClassType>(t))
      s += "class";
    else
      s += "table";

    s += " '" + toString(e.table) + "'.  " + candidatesSuggestion + "?";
    return s;
  }

  std::string operator()(const Luau::GenericError &e) const {
    return e.message;
  }

  std::string operator()(const Luau::InternalError &e) const {
    return e.message;
  }

  std::optional<TypeId> findCallMetamethod(TypeId type) const {
    type = follow(type);

    std::optional<TypeId> metatable;
    if (const MetatableType *mtType = get<MetatableType>(type))
      metatable = mtType->metatable;
    else if (const ClassType *classType = get<ClassType>(type))
      metatable = classType->metatable;

    if (!metatable)
      return std::nullopt;

    TypeId unwrapped = follow(*metatable);

    if (get<AnyType>(unwrapped))
      return unwrapped;

    const TableType *mtt = getTableType(unwrapped);
    if (!mtt)
      return std::nullopt;

    auto it = mtt->props.find("__call");
    if (it != mtt->props.end())
      return it->second.type();
    else
      return std::nullopt;
  }

  std::string operator()(const Luau::CannotCallNonFunction &e) const {
    if (DFFlag::LuauImproveNonFunctionCallError) {
      if (auto unionTy = get<UnionType>(follow(e.ty))) {
        std::string err = "Cannot call a value of the union type:";

        for (auto option : unionTy) {
          option = follow(option);

          if (get<FunctionType>(option) || findCallMetamethod(option)) {
            err += "\n  | " + toString(option);
            continue;
          }

          // early-exit if we find something that isn't callable in the union.
          return "Cannot call a value of type " + toString(option) +
                 " in union:\n  " + toString(e.ty);
        }

        err += "\nWe are unable to determine the appropriate result type for "
               "such a call.";

        return err;
      }

      return "Cannot call a value of type " + toString(e.ty);
    }

    return "Cannot call non-function " + toString(e.ty);
  }
  std::string operator()(const Luau::ExtraInformation &e) const {
    return e.message;
  }

  std::string operator()(const Luau::DeprecatedApiUsed &e) const {
    return "The property ." + e.symbol + " is deprecated.  Use ." +
           e.useInstead + " instead.";
  }

  std::string operator()(const Luau::ModuleHasCyclicDependency &e) const {
    if (e.cycle.empty())
      return "Cyclic module dependency detected";

    std::string s = "Cyclic module dependency: ";

    bool first = true;
    for (const ModuleName &name : e.cycle) {
      if (first)
        first = false;
      else
        s += " -> ";

      if (fileResolver != nullptr)
        s += fileResolver->getHumanReadableModuleName(name);
      else
        s += name;
    }

    return s;
  }

  std::string operator()(const Luau::FunctionExitsWithoutReturning &e) const {
    return "Not all codepaths in this function return '" +
           toString(e.expectedReturnType) + "'.";
  }

  std::string operator()(const Luau::IllegalRequire &e) const {
    return "Cannot require module " + e.moduleName + ": " + e.reason;
  }

  std::string operator()(const Luau::MissingProperties &e) const {
    std::string s = "Table type '" + toString(e.subType) +
                    "' not compatible with type '" + toString(e.superType) +
                    "' because the former";

    switch (e.context) {
    case MissingProperties::Missing:
      s += " is missing field";
      break;
    case MissingProperties::Extra:
      s += " has extra field";
      break;
    }

    if (e.properties.size() > 1)
      s += "s";

    s += " ";

    for (size_t i = 0; i < e.properties.size(); ++i) {
      if (i > 0)
        s += ", ";

      if (i > 0 && i == e.properties.size() - 1)
        s += "and ";

      s += "'" + e.properties[i] + "'";
    }

    return s;
  }

  std::string operator()(const Luau::DuplicateGenericParameter &e) const {
    return "Duplicate type parameter '" + e.parameterName + "'";
  }

  std::string operator()(const Luau::CannotInferBinaryOperation &e) const {
    std::string ss = "Unknown type used in " + toString(e.op);

    switch (e.kind) {
    case Luau::CannotInferBinaryOperation::Comparison:
      ss += " comparison";
      break;
    case Luau::CannotInferBinaryOperation::Operation:
      ss += " operation";
    }

    if (e.suggestedToAnnotate)
      ss += "; consider adding a type annotation to '" +
            *e.suggestedToAnnotate + "'";

    return ss;
  }

  std::string operator()(const Luau::SwappedGenericTypeParameter &e) const {
    switch (e.kind) {
    case Luau::SwappedGenericTypeParameter::Type:
      return "Variadic type parameter '" + e.name +
             "...' is used as a regular generic type; consider changing '" +
             e.name + "...' to '" + e.name + "' in the generic argument list";
    case Luau::SwappedGenericTypeParameter::Pack:
      return "Generic type '" + e.name +
             "' is used as a variadic type parameter; consider changing '" +
             e.name + "' to '" + e.name + "...' in the generic argument list";
    default:
      LUAU_ASSERT(!"Unknown kind");
      return "";
    }
  }

  std::string operator()(const Luau::OptionalValueAccess &e) const {
    return "Value of type '" + toString(e.optional) + "' could be nil";
  }

  std::string operator()(const Luau::MissingUnionProperty &e) const {
    std::string ss = "Key '" + e.key + "' is missing from ";

    bool first = true;
    for (auto ty : e.missing) {
      if (first)
        first = false;
      else
        ss += ", ";

      ss += "'" + toString(ty) + "'";
    }

    return ss + " in the type '" + toString(e.type) + "'";
  }

  std::string operator()(const TypesAreUnrelated &e) const {
    return "Cannot cast '" + toString(e.left) + "' into '" + toString(e.right) +
           "' because the types are unrelated";
  }

  std::string operator()(const NormalizationTooComplex &) const {
    return "Code is too complex to typecheck! Consider simplifying the code "
           "around this area";
  }

  std::string operator()(const TypePackMismatch &e) const {
    std::string ss = "Type pack '" + toString(e.givenTp) +
                     "' could not be converted into '" + toString(e.wantedTp) +
                     "'";

    if (!e.reason.empty())
      ss += "; " + e.reason;

    return ss;
  }

  std::string operator()(const DynamicPropertyLookupOnClassesUnsafe &e) const {
    return "Attempting a dynamic property access on type '" +
           Luau::toString(e.ty) +
           "' is unsafe and may cause exceptions at runtime";
  }

  std::string operator()(const UninhabitedTypeFunction &e) const {
    auto tfit = get<TypeFunctionInstanceType>(e.ty);
    LUAU_ASSERT(tfit); // Luau analysis has actually done something wrong if
                       // this type is not a type function.
    if (!tfit)
      return "Unexpected type " + Luau::toString(e.ty) +
             " flagged as an uninhabited type function.";

    // unary operators
    if (auto unaryString = kUnaryOps.find(tfit->family->name);
        unaryString != kUnaryOps.end()) {
      std::string result = "Operator '" + std::string(unaryString->second) +
                           "' could not be applied to ";

      if (tfit->typeArguments.size() == 1 && tfit->packArguments.empty()) {
        result += "operand of type " + Luau::toString(tfit->typeArguments[0]);

        if (tfit->family->name != "not")
          result += "; there is no corresponding overload for __" +
                    tfit->family->name;
      } else {
        // if it's not the expected case, we ought to add a specialization
        // later, but this is a sane default.
        result += "operands of types ";

        bool isFirst = true;
        for (auto arg : tfit->typeArguments) {
          if (!isFirst)
            result += ", ";

          result += Luau::toString(arg);
          isFirst = false;
        }

        for (auto packArg : tfit->packArguments)
          result += ", " + Luau::toString(packArg);
      }

      return result;
    }

    // binary operators
    if (auto binaryString = kBinaryOps.find(tfit->family->name);
        binaryString != kBinaryOps.end()) {
      std::string result = "Operator '" + std::string(binaryString->second) +
                           "' could not be applied to operands of types ";

      if (tfit->typeArguments.size() == 2 && tfit->packArguments.empty()) {
        // this is the expected case.
        result += Luau::toString(tfit->typeArguments[0]) + " and " +
                  Luau::toString(tfit->typeArguments[1]);
      } else {
        // if it's not the expected case, we ought to add a specialization
        // later, but this is a sane default.

        bool isFirst = true;
        for (auto arg : tfit->typeArguments) {
          if (!isFirst)
            result += ", ";

          result += Luau::toString(arg);
          isFirst = false;
        }

        for (auto packArg : tfit->packArguments)
          result += ", " + Luau::toString(packArg);
      }

      result +=
          "; there is no corresponding overload for __" + tfit->family->name;

      return result;
    }

    // miscellaneous

    if ("keyof" == tfit->family->name || "rawkeyof" == tfit->family->name) {
      if (tfit->typeArguments.size() == 1 && tfit->packArguments.empty())
        return "Type '" + toString(tfit->typeArguments[0]) +
               "' does not have keys, so '" + Luau::toString(e.ty) +
               "' is invalid";
      else
        return "Type function instance " + Luau::toString(e.ty) +
               " is ill-formed, and thus invalid";
    }

    if ("index" == tfit->family->name || "rawget" == tfit->family->name) {
      if (tfit->typeArguments.size() != 2)
        return "Type function instance " + Luau::toString(e.ty) +
               " is ill-formed, and thus invalid";

      if (auto errType = get<ErrorType>(
              tfit->typeArguments[1])) // Second argument to (index |
                                       // rawget)<_,_> is not a type
        return "Second argument to " + tfit->family->name + "<" +
               Luau::toString(tfit->typeArguments[0]) +
               ", _> is not a valid index type";
      else // Property `indexer` does not exist on type `indexee`
        return "Property '" + Luau::toString(tfit->typeArguments[1]) +
               "' does not exist on type '" +
               Luau::toString(tfit->typeArguments[0]) + "'";
    }

    if (kUnreachableTypeFunctions.count(tfit->family->name)) {
      return "Type function instance " + Luau::toString(e.ty) +
             " is uninhabited\n" +
             "This is likely to be a bug, please report it at "
             "https://github.com/luau-lang/luau/issues";
    }

    // Everything should be specialized above to report a more descriptive error
    // that hopefully does not mention "type functions" explicitly. If we
    // produce this message, it's an indication that we've missed a
    // specialization and it should be fixed!
    return "Type function instance " + Luau::toString(e.ty) + " is uninhabited";
  }

  std::string operator()(const ExplicitFunctionAnnotationRecommended &r) const {
    std::string toReturn = toString(r.recommendedReturn);
    std::string argAnnotations;
    for (auto [arg, type] : r.recommendedArgs) {
      argAnnotations += arg + ": " + toString(type) + ", ";
    }
    if (argAnnotations.length() >= 2) {
      argAnnotations.pop_back();
      argAnnotations.pop_back();
    }

    if (argAnnotations.empty())
      return "Consider annotating the return with " + toReturn;

    return "Consider placing the following annotations on the arguments: " +
           argAnnotations + " or instead annotating the return as " + toReturn;
  }

  std::string operator()(const UninhabitedTypePackFunction &e) const {
    return "Type pack family instance " + Luau::toString(e.tp) +
           " is uninhabited";
  }

  std::string operator()(const WhereClauseNeeded &e) const {
    return "Type function instance " + Luau::toString(e.ty) +
           " depends on generic function parameters but does not appear in the "
           "function signature; this construct cannot be type-checked at this "
           "time";
  }

  std::string operator()(const PackWhereClauseNeeded &e) const {
    return "Type pack family instance " + Luau::toString(e.tp) +
           " depends on generic function parameters but does not appear in the "
           "function signature; this construct cannot be type-checked at this "
           "time";
  }

  std::string operator()(const CheckedFunctionCallError &e) const {
    // TODO: What happens if checkedFunctionName cannot be found??
    return "Function '" + e.checkedFunctionName + "' expects '" +
           toString(e.expected) + "' at argument #" +
           std::to_string(e.argumentIndex) + ", but got '" +
           Luau::toString(e.passed) + "'";
  }

  std::string operator()(const NonStrictFunctionDefinitionError &e) const {
    return "Argument " + e.argument + " with type '" +
           toString(e.argumentType) + "' in function '" + e.functionName +
           "' is used in a way that will run time error";
  }

  std::string operator()(const PropertyAccessViolation &e) const {
    const std::string stringKey =
        isIdentifier(e.key) ? e.key : "\"" + e.key + "\"";
    switch (e.context) {
    case PropertyAccessViolation::CannotRead:
      return "Property " + stringKey + " of table '" + toString(e.table) +
             "' is write-only";
    case PropertyAccessViolation::CannotWrite:
      return "Property " + stringKey + " of table '" + toString(e.table) +
             "' is read-only";
    }

    LUAU_UNREACHABLE();
    return "<Invalid PropertyAccessViolation>";
  }

  std::string operator()(const CheckedFunctionIncorrectArgs &e) const {
    return "Checked Function " + e.functionName + " expects " +
           std::to_string(e.expected) + " arguments, but received " +
           std::to_string(e.actual);
  }

  std::string operator()(const UnexpectedTypeInSubtyping &e) const {
    return "Encountered an unexpected type in subtyping: " + toString(e.ty);
  }

  std::string operator()(const UnexpectedTypePackInSubtyping &e) const {
    return "Encountered an unexpected type pack in subtyping: " +
           toString(e.tp);
  }

  std::string operator()(const CannotAssignToNever &e) const {
    std::string result = "Cannot assign a value of type " +
                         toString(e.rhsType) + " to a field of type never";

    switch (e.reason) {
    case CannotAssignToNever::Reason::PropertyNarrowed:
      if (!e.cause.empty()) {
        result += "\ncaused by the property being given the following "
                  "incompatible types:\n";
        for (auto ty : e.cause)
          result += "    " + toString(ty) + "\n";
        result += "There are no values that could safely satisfy all of these "
                  "types at once.";
      }
    }

    return result;
  }
};

struct InvalidNameChecker {
  std::string invalidName = "%error-id%";

  bool operator()(const Luau::UnknownProperty &e) const {
    return e.key == invalidName;
  }
  bool operator()(const Luau::CannotExtendTable &e) const {
    return e.prop == invalidName;
  }
  bool operator()(const Luau::DuplicateTypeDefinition &e) const {
    return e.name == invalidName;
  }

  template <typename T> bool operator()(const T &other) const { return false; }
};

TypeMismatch::TypeMismatch(TypeId wantedType, TypeId givenType)
    : wantedType(wantedType), givenType(givenType) {}

TypeMismatch::TypeMismatch(TypeId wantedType, TypeId givenType,
                           std::string reason)
    : wantedType(wantedType), givenType(givenType), reason(reason) {}

TypeMismatch::TypeMismatch(TypeId wantedType, TypeId givenType,
                           std::string reason, std::optional<TypeError> error)
    : wantedType(wantedType), givenType(givenType), reason(reason),
      error(error ? std::make_shared<TypeError>(std::move(*error)) : nullptr) {}

TypeMismatch::TypeMismatch(TypeId wantedType, TypeId givenType,
                           TypeMismatch::Context context)
    : wantedType(wantedType), givenType(givenType), context(context) {}

TypeMismatch::TypeMismatch(TypeId wantedType, TypeId givenType,
                           std::string reason, TypeMismatch::Context context)
    : wantedType(wantedType), givenType(givenType), context(context),
      reason(reason) {}

TypeMismatch::TypeMismatch(TypeId wantedType, TypeId givenType,
                           std::string reason, std::optional<TypeError> error,
                           TypeMismatch::Context context)
    : wantedType(wantedType), givenType(givenType), context(context),
      reason(reason),
      error(error ? std::make_shared<TypeError>(std::move(*error)) : nullptr) {}

bool TypeMismatch::operator==(const TypeMismatch &rhs) const {
  if (!!error != !!rhs.error)
    return false;

  if (error && !(*error == *rhs.error))
    return false;

  return *wantedType == *rhs.wantedType && *givenType == *rhs.givenType &&
         reason == rhs.reason && context == rhs.context;
}

bool UnknownSymbol::operator==(const UnknownSymbol &rhs) const {
  return name == rhs.name;
}

bool UnknownProperty::operator==(const UnknownProperty &rhs) const {
  return *table == *rhs.table && key == rhs.key;
}

bool PropertyAccessViolation::operator==(
    const PropertyAccessViolation &rhs) const {
  return *table == *rhs.table && key == rhs.key && context == rhs.context;
}

bool NotATable::operator==(const NotATable &rhs) const { return ty == rhs.ty; }

bool CannotExtendTable::operator==(const CannotExtendTable &rhs) const {
  return *tableType == *rhs.tableType && prop == rhs.prop &&
         context == rhs.context;
}

bool OnlyTablesCanHaveMethods::operator==(
    const OnlyTablesCanHaveMethods &rhs) const {
  return *tableType == *rhs.tableType;
}

bool DuplicateTypeDefinition::operator==(
    const DuplicateTypeDefinition &rhs) const {
  return name == rhs.name && previousLocation == rhs.previousLocation;
}

bool CountMismatch::operator==(const CountMismatch &rhs) const {
  return expected == rhs.expected && maximum == rhs.maximum &&
         actual == rhs.actual && context == rhs.context &&
         function == rhs.function;
}

bool FunctionDoesNotTakeSelf::operator==(
    const FunctionDoesNotTakeSelf &) const {
  return true;
}

bool FunctionRequiresSelf::operator==(const FunctionRequiresSelf &e) const {
  return true;
}

bool OccursCheckFailed::operator==(const OccursCheckFailed &) const {
  return true;
}

bool UnknownRequire::operator==(const UnknownRequire &rhs) const {
  return modulePath == rhs.modulePath;
}

bool IncorrectGenericParameterCount::operator==(
    const IncorrectGenericParameterCount &rhs) const {
  if (name != rhs.name)
    return false;

  if (typeFun.type != rhs.typeFun.type)
    return false;

  if (typeFun.typeParams.size() != rhs.typeFun.typeParams.size())
    return false;

  if (typeFun.typePackParams.size() != rhs.typeFun.typePackParams.size())
    return false;

  for (size_t i = 0; i < typeFun.typeParams.size(); ++i) {
    if (typeFun.typeParams[i].ty != rhs.typeFun.typeParams[i].ty)
      return false;
  }

  for (size_t i = 0; i < typeFun.typePackParams.size(); ++i) {
    if (typeFun.typePackParams[i].tp != rhs.typeFun.typePackParams[i].tp)
      return false;
  }

  return true;
}

bool SyntaxError::operator==(const SyntaxError &rhs) const {
  return message == rhs.message;
}

bool CodeTooComplex::operator==(const CodeTooComplex &) const { return true; }

bool UnificationTooComplex::operator==(const UnificationTooComplex &) const {
  return true;
}

bool UnknownPropButFoundLikeProp::operator==(
    const UnknownPropButFoundLikeProp &rhs) const {
  return *table == *rhs.table && key == rhs.key &&
         candidates.size() == rhs.candidates.size() &&
         std::equal(candidates.begin(), candidates.end(),
                    rhs.candidates.begin());
}

bool GenericError::operator==(const GenericError &rhs) const {
  return message == rhs.message;
}

bool InternalError::operator==(const InternalError &rhs) const {
  return message == rhs.message;
}

bool CannotCallNonFunction::operator==(const CannotCallNonFunction &rhs) const {
  return ty == rhs.ty;
}

bool ExtraInformation::operator==(const ExtraInformation &rhs) const {
  return message == rhs.message;
}

bool DeprecatedApiUsed::operator==(const DeprecatedApiUsed &rhs) const {
  return symbol == rhs.symbol && useInstead == rhs.useInstead;
}

bool FunctionExitsWithoutReturning::operator==(
    const FunctionExitsWithoutReturning &rhs) const {
  return expectedReturnType == rhs.expectedReturnType;
}

int TypeError::code() const { return minCode() + int(data.index()); }

int TypeError::minCode() { return 1000; }

TypeErrorSummary TypeError::summary() const {
  return TypeErrorSummary{location, moduleName, code()};
}

bool TypeError::operator==(const TypeError &rhs) const {
  return location == rhs.location && data == rhs.data;
}

bool ModuleHasCyclicDependency::operator==(
    const ModuleHasCyclicDependency &rhs) const {
  return cycle.size() == rhs.cycle.size() &&
         std::equal(cycle.begin(), cycle.end(), rhs.cycle.begin());
}

bool IllegalRequire::operator==(const IllegalRequire &rhs) const {
  return moduleName == rhs.moduleName && reason == rhs.reason;
}

bool MissingProperties::operator==(const MissingProperties &rhs) const {
  return *superType == *rhs.superType && *subType == *rhs.subType &&
         properties.size() == rhs.properties.size() &&
         std::equal(properties.begin(), properties.end(),
                    rhs.properties.begin()) &&
         context == rhs.context;
}

bool DuplicateGenericParameter::operator==(
    const DuplicateGenericParameter &rhs) const {
  return parameterName == rhs.parameterName;
}

bool CannotInferBinaryOperation::operator==(
    const CannotInferBinaryOperation &rhs) const {
  return op == rhs.op && suggestedToAnnotate == rhs.suggestedToAnnotate &&
         kind == rhs.kind;
}

bool SwappedGenericTypeParameter::operator==(
    const SwappedGenericTypeParameter &rhs) const {
  return name == rhs.name && kind == rhs.kind;
}

bool OptionalValueAccess::operator==(const OptionalValueAccess &rhs) const {
  return *optional == *rhs.optional;
}

bool MissingUnionProperty::operator==(const MissingUnionProperty &rhs) const {
  if (missing.size() != rhs.missing.size())
    return false;

  for (size_t i = 0; i < missing.size(); ++i) {
    if (*missing[i] != *rhs.missing[i])
      return false;
  }

  return *type == *rhs.type && key == rhs.key;
}

bool TypesAreUnrelated::operator==(const TypesAreUnrelated &rhs) const {
  return left == rhs.left && right == rhs.right;
}

bool TypePackMismatch::operator==(const TypePackMismatch &rhs) const {
  return *wantedTp == *rhs.wantedTp && *givenTp == *rhs.givenTp;
}

bool DynamicPropertyLookupOnClassesUnsafe::operator==(
    const DynamicPropertyLookupOnClassesUnsafe &rhs) const {
  return ty == rhs.ty;
}

bool UninhabitedTypeFunction::operator==(
    const UninhabitedTypeFunction &rhs) const {
  return ty == rhs.ty;
}

bool ExplicitFunctionAnnotationRecommended::operator==(
    const ExplicitFunctionAnnotationRecommended &rhs) const {
  return recommendedReturn == rhs.recommendedReturn &&
         recommendedArgs == rhs.recommendedArgs;
}

bool UninhabitedTypePackFunction::operator==(
    const UninhabitedTypePackFunction &rhs) const {
  return tp == rhs.tp;
}

bool WhereClauseNeeded::operator==(const WhereClauseNeeded &rhs) const {
  return ty == rhs.ty;
}

bool PackWhereClauseNeeded::operator==(const PackWhereClauseNeeded &rhs) const {
  return tp == rhs.tp;
}

bool CheckedFunctionCallError::operator==(
    const CheckedFunctionCallError &rhs) const {
  return *expected == *rhs.expected && *passed == *rhs.passed &&
         checkedFunctionName == rhs.checkedFunctionName &&
         argumentIndex == rhs.argumentIndex;
}

bool NonStrictFunctionDefinitionError::operator==(
    const NonStrictFunctionDefinitionError &rhs) const {
  return functionName == rhs.functionName && argument == rhs.argument &&
         argumentType == rhs.argumentType;
}

bool CheckedFunctionIncorrectArgs::operator==(
    const CheckedFunctionIncorrectArgs &rhs) const {
  return functionName == rhs.functionName && expected == rhs.expected &&
         actual == rhs.actual;
}

bool UnexpectedTypeInSubtyping::operator==(
    const UnexpectedTypeInSubtyping &rhs) const {
  return ty == rhs.ty;
}

bool UnexpectedTypePackInSubtyping::operator==(
    const UnexpectedTypePackInSubtyping &rhs) const {
  return tp == rhs.tp;
}

bool CannotAssignToNever::operator==(const CannotAssignToNever &rhs) const {
  if (cause.size() != rhs.cause.size())
    return false;

  for (size_t i = 0; i < cause.size(); ++i) {
    if (*cause[i] != *rhs.cause[i])
      return false;
  }

  return *rhsType == *rhs.rhsType && reason == rhs.reason;
}

std::string toString(const TypeError &error) {
  return toString(error, TypeErrorToStringOptions{});
}

std::string toString(const TypeError &error, TypeErrorToStringOptions options) {
  ErrorConverter converter{options.fileResolver};
  return Luau::visit(converter, error.data);
}

bool containsParseErrorName(const TypeError &error) {
  return Luau::visit(InvalidNameChecker{}, error.data);
}

template <typename T>
void copyError(T &e, TypeArena &destArena, CloneState &cloneState) {
  auto clone = [&](auto &&ty) {
    return ::Luau::clone(ty, destArena, cloneState);
  };

  auto visitErrorData = [&](auto &&e) { copyError(e, destArena, cloneState); };

  if constexpr (false) {
  } else if constexpr (std::is_same_v<T, TypeMismatch>) {
    e.wantedType = clone(e.wantedType);
    e.givenType = clone(e.givenType);

    if (e.error)
      visit(visitErrorData, e.error->data);
  } else if constexpr (std::is_same_v<T, UnknownSymbol>) {
  } else if constexpr (std::is_same_v<T, UnknownProperty>) {
    e.table = clone(e.table);
  } else if constexpr (std::is_same_v<T, NotATable>) {
    e.ty = clone(e.ty);
  } else if constexpr (std::is_same_v<T, CannotExtendTable>) {
    e.tableType = clone(e.tableType);
  } else if constexpr (std::is_same_v<T, OnlyTablesCanHaveMethods>) {
    e.tableType = clone(e.tableType);
  } else if constexpr (std::is_same_v<T, DuplicateTypeDefinition>) {
  } else if constexpr (std::is_same_v<T, CountMismatch>) {
  } else if constexpr (std::is_same_v<T, FunctionDoesNotTakeSelf>) {
  } else if constexpr (std::is_same_v<T, FunctionRequiresSelf>) {
  } else if constexpr (std::is_same_v<T, OccursCheckFailed>) {
  } else if constexpr (std::is_same_v<T, UnknownRequire>) {
  } else if constexpr (std::is_same_v<T, IncorrectGenericParameterCount>) {
    e.typeFun = clone(e.typeFun);
  } else if constexpr (std::is_same_v<T, SyntaxError>) {
  } else if constexpr (std::is_same_v<T, CodeTooComplex>) {
  } else if constexpr (std::is_same_v<T, UnificationTooComplex>) {
  } else if constexpr (std::is_same_v<T, UnknownPropButFoundLikeProp>) {
    e.table = clone(e.table);
  } else if constexpr (std::is_same_v<T, GenericError>) {
  } else if constexpr (std::is_same_v<T, InternalError>) {
  } else if constexpr (std::is_same_v<T, CannotCallNonFunction>) {
    e.ty = clone(e.ty);
  } else if constexpr (std::is_same_v<T, ExtraInformation>) {
  } else if constexpr (std::is_same_v<T, DeprecatedApiUsed>) {
  } else if constexpr (std::is_same_v<T, ModuleHasCyclicDependency>) {
  } else if constexpr (std::is_same_v<T, IllegalRequire>) {
  } else if constexpr (std::is_same_v<T, FunctionExitsWithoutReturning>) {
    e.expectedReturnType = clone(e.expectedReturnType);
  } else if constexpr (std::is_same_v<T, DuplicateGenericParameter>) {
  } else if constexpr (std::is_same_v<T, CannotInferBinaryOperation>) {
  } else if constexpr (std::is_same_v<T, MissingProperties>) {
    e.superType = clone(e.superType);
    e.subType = clone(e.subType);
  } else if constexpr (std::is_same_v<T, SwappedGenericTypeParameter>) {
  } else if constexpr (std::is_same_v<T, OptionalValueAccess>) {
    e.optional = clone(e.optional);
  } else if constexpr (std::is_same_v<T, MissingUnionProperty>) {
    e.type = clone(e.type);

    for (auto &ty : e.missing)
      ty = clone(ty);
  } else if constexpr (std::is_same_v<T, TypesAreUnrelated>) {
    e.left = clone(e.left);
    e.right = clone(e.right);
  } else if constexpr (std::is_same_v<T, NormalizationTooComplex>) {
  } else if constexpr (std::is_same_v<T, TypePackMismatch>) {
    e.wantedTp = clone(e.wantedTp);
    e.givenTp = clone(e.givenTp);
  } else if constexpr (std::is_same_v<T, DynamicPropertyLookupOnClassesUnsafe>)
    e.ty = clone(e.ty);
  else if constexpr (std::is_same_v<T, UninhabitedTypeFunction>)
    e.ty = clone(e.ty);
  else if constexpr (std::is_same_v<T, ExplicitFunctionAnnotationRecommended>) {
    e.recommendedReturn = clone(e.recommendedReturn);
    for (auto &[_, t] : e.recommendedArgs)
      t = clone(t);
  } else if constexpr (std::is_same_v<T, UninhabitedTypePackFunction>)
    e.tp = clone(e.tp);
  else if constexpr (std::is_same_v<T, WhereClauseNeeded>)
    e.ty = clone(e.ty);
  else if constexpr (std::is_same_v<T, PackWhereClauseNeeded>)
    e.tp = clone(e.tp);
  else if constexpr (std::is_same_v<T, CheckedFunctionCallError>) {
    e.expected = clone(e.expected);
    e.passed = clone(e.passed);
  } else if constexpr (std::is_same_v<T, NonStrictFunctionDefinitionError>) {
    e.argumentType = clone(e.argumentType);
  } else if constexpr (std::is_same_v<T, PropertyAccessViolation>)
    e.table = clone(e.table);
  else if constexpr (std::is_same_v<T, CheckedFunctionIncorrectArgs>) {
  } else if constexpr (std::is_same_v<T, UnexpectedTypeInSubtyping>)
    e.ty = clone(e.ty);
  else if constexpr (std::is_same_v<T, UnexpectedTypePackInSubtyping>)
    e.tp = clone(e.tp);
  else if constexpr (std::is_same_v<T, CannotAssignToNever>) {
    e.rhsType = clone(e.rhsType);

    for (auto &ty : e.cause)
      ty = clone(ty);
  } else
    static_assert(always_false_v<T>, "Non-exhaustive type switch");
}

void copyErrors(ErrorVec &errors, TypeArena &destArena,
                NotNull<BuiltinTypes> builtinTypes) {
  CloneState cloneState{builtinTypes};

  auto visitErrorData = [&](auto &&e) { copyError(e, destArena, cloneState); };

  LUAU_ASSERT(!destArena.types.isFrozen());
  LUAU_ASSERT(!destArena.typePacks.isFrozen());

  for (TypeError &error : errors)
    visit(visitErrorData, error.data);
}

void InternalErrorReporter::ice(const std::string &message,
                                const Location &location) const {
  InternalCompilerError error(message, moduleName, location);

  if (onInternalError)
    onInternalError(error.what());

  throw error;
}

void InternalErrorReporter::ice(const std::string &message) const {
  InternalCompilerError error(message, moduleName);

  if (onInternalError)
    onInternalError(error.what());

  throw error;
}

const char *InternalCompilerError::what() const throw() {
  return this->message.data();
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Clone.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Set.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifier.h>

LUAU_FASTFLAGVARIABLE(DebugLuauCheckNormalizeInvariant, false)
LUAU_FASTFLAGVARIABLE(LuauNormalizeAwayUninhabitableTables, false)
LUAU_FASTFLAGVARIABLE(LuauNormalizeNotUnknownIntersection, false);
LUAU_FASTFLAGVARIABLE(LuauFixReduceStackPressure, false);
LUAU_FASTFLAGVARIABLE(LuauFixCyclicTablesBlowingStack, false);

// This could theoretically be 2000 on amd64, but x86 requires this.
LUAU_FASTINTVARIABLE(LuauNormalizeIterationLimit, 1200);
LUAU_FASTINTVARIABLE(LuauNormalizeCacheLimit, 100000);
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

static bool fixReduceStackPressure() {
  return FFlag::LuauFixReduceStackPressure ||
         FFlag::DebugLuauDeferredConstraintResolution;
}

static bool fixCyclicTablesBlowingStack() {
  return FFlag::LuauFixCyclicTablesBlowingStack ||
         FFlag::DebugLuauDeferredConstraintResolution;
}

namespace Luau {

// helper to make `FFlag::LuauNormalizeAwayUninhabitableTables` not explicitly
// required when DCR is enabled.
static bool normalizeAwayUninhabitableTables() {
  return FFlag::LuauNormalizeAwayUninhabitableTables ||
         FFlag::DebugLuauDeferredConstraintResolution;
}

static bool shouldEarlyExit(NormalizationResult res) {
  // if res is hit limits, return control flow
  if (res == NormalizationResult::HitLimits ||
      res == NormalizationResult::False)
    return true;
  return false;
}

TypeIds::TypeIds(std::initializer_list<TypeId> tys) {
  for (TypeId ty : tys)
    insert(ty);
}

void TypeIds::insert(TypeId ty) {
  ty = follow(ty);

  // get a reference to the slot for `ty` in `types`
  bool &entry = types[ty];

  // if `ty` is fresh, we can set it to `true`, add it to the order and hash and
  // be done.
  if (!entry) {
    entry = true;
    order.push_back(ty);
    hash ^= std::hash<TypeId>{}(ty);
  }
}

void TypeIds::clear() {
  order.clear();
  types.clear();
  hash = 0;
}

TypeId TypeIds::front() const { return order.at(0); }

TypeIds::iterator TypeIds::begin() { return order.begin(); }

TypeIds::iterator TypeIds::end() { return order.end(); }

TypeIds::const_iterator TypeIds::begin() const { return order.begin(); }

TypeIds::const_iterator TypeIds::end() const { return order.end(); }

TypeIds::iterator TypeIds::erase(TypeIds::const_iterator it) {
  TypeId ty = *it;
  types[ty] = false;
  hash ^= std::hash<TypeId>{}(ty);
  return order.erase(it);
}

size_t TypeIds::size() const { return order.size(); }

bool TypeIds::empty() const { return order.empty(); }

size_t TypeIds::count(TypeId ty) const {
  ty = follow(ty);
  const bool *val = types.find(ty);
  return (val && *val) ? 1 : 0;
}

void TypeIds::retain(const TypeIds &there) {
  for (auto it = begin(); it != end();) {
    if (there.count(*it))
      it++;
    else
      it = erase(it);
  }
}

size_t TypeIds::getHash() const { return hash; }

bool TypeIds::isNever() const {
  return std::all_of(begin(), end(), [&](TypeId i) {
    // If each typeid is never, then I guess typeid's is also never?
    return get<NeverType>(i) != nullptr;
  });
}

bool TypeIds::operator==(const TypeIds &there) const {
  // we can early return if the hashes don't match.
  if (hash != there.hash)
    return false;

  // we have to check equality of the sets themselves if not.

  // if the sets are unequal sizes, then they cannot possibly be equal.
  // it is important to use `order` here and not `types` since the mappings
  // may have different sizes since removal is not possible, and so erase
  // simply writes `false` into the map.
  if (order.size() != there.order.size())
    return false;

  // otherwise, we'll need to check that every element we have here is in
  // `there`.
  for (auto ty : order) {
    // if it's not, we'll return `false`
    if (there.count(ty) == 0)
      return false;
  }

  // otherwise, we've proven the two equal!
  return true;
}

NormalizedStringType::NormalizedStringType() {}

NormalizedStringType::NormalizedStringType(
    bool isCofinite, std::map<std::string, TypeId> singletons)
    : isCofinite(isCofinite), singletons(std::move(singletons)) {}

void NormalizedStringType::resetToString() {
  isCofinite = true;
  singletons.clear();
}

void NormalizedStringType::resetToNever() {
  isCofinite = false;
  singletons.clear();
}

bool NormalizedStringType::isNever() const {
  return !isCofinite && singletons.empty();
}

bool NormalizedStringType::isString() const {
  return isCofinite && singletons.empty();
}

bool NormalizedStringType::isUnion() const { return !isCofinite; }

bool NormalizedStringType::isIntersection() const { return isCofinite; }

bool NormalizedStringType::includes(const std::string &str) const {
  if (isString())
    return true;
  else if (isUnion() && singletons.count(str))
    return true;
  else if (isIntersection() && !singletons.count(str))
    return true;
  else
    return false;
}

const NormalizedStringType NormalizedStringType::never;

bool isSubtype(const NormalizedStringType &subStr,
               const NormalizedStringType &superStr) {
  if (subStr.isUnion() && (superStr.isUnion() && !superStr.isNever())) {
    for (auto [name, ty] : subStr.singletons) {
      if (!superStr.singletons.count(name))
        return false;
    }
  } else if (subStr.isString() && superStr.isUnion())
    return false;

  return true;
}

void NormalizedClassType::pushPair(TypeId ty, TypeIds negations) {
  auto result = classes.insert(std::make_pair(ty, std::move(negations)));
  if (result.second)
    ordering.push_back(ty);
  LUAU_ASSERT(ordering.size() == classes.size());
}

void NormalizedClassType::resetToNever() {
  ordering.clear();
  classes.clear();
}

bool NormalizedClassType::isNever() const { return classes.empty(); }

void NormalizedFunctionType::resetToTop() {
  isTop = true;
  parts.clear();
}

void NormalizedFunctionType::resetToNever() {
  isTop = false;
  parts.clear();
}

bool NormalizedFunctionType::isNever() const { return !isTop && parts.empty(); }

NormalizedType::NormalizedType(NotNull<BuiltinTypes> builtinTypes)
    : tops(builtinTypes->neverType), booleans(builtinTypes->neverType),
      errors(builtinTypes->neverType), nils(builtinTypes->neverType),
      numbers(builtinTypes->neverType), strings{NormalizedStringType::never},
      threads(builtinTypes->neverType), buffers(builtinTypes->neverType) {}

bool NormalizedType::isUnknown() const {
  if (get<UnknownType>(tops))
    return true;

  // Otherwise, we can still be unknown!
  bool hasAllPrimitives = isPrim(booleans, PrimitiveType::Boolean) &&
                          isPrim(nils, PrimitiveType::NilType) &&
                          isNumber(numbers) && strings.isString() &&
                          isPrim(threads, PrimitiveType::Thread) &&
                          isThread(threads);

  // Check is class
  bool isTopClass = false;
  for (auto [t, disj] : classes.classes) {
    if (auto ct = get<ClassType>(t)) {
      if (ct->name == "class" && disj.empty()) {
        isTopClass = true;
        break;
      }
    }
  }
  // Check is table
  bool isTopTable = false;
  for (auto t : tables) {
    if (isPrim(t, PrimitiveType::Table)) {
      isTopTable = true;
      break;
    }
  }
  // any = unknown or error ==> we need to make sure we have all the unknown
  // components, but not errors
  return get<NeverType>(errors) && hasAllPrimitives && isTopClass &&
         isTopTable && functions.isTop;
}

bool NormalizedType::isExactlyNumber() const {
  return hasNumbers() && !hasTops() && !hasBooleans() && !hasClasses() &&
         !hasErrors() && !hasNils() && !hasStrings() && !hasThreads() &&
         !hasBuffers() && !hasTables() && !hasFunctions() && !hasTyvars();
}

bool NormalizedType::isSubtypeOfString() const {
  return hasStrings() && !hasTops() && !hasBooleans() && !hasClasses() &&
         !hasErrors() && !hasNils() && !hasNumbers() && !hasThreads() &&
         !hasBuffers() && !hasTables() && !hasFunctions() && !hasTyvars();
}

bool NormalizedType::isSubtypeOfBooleans() const {
  return hasBooleans() && !hasTops() && !hasClasses() && !hasErrors() &&
         !hasNils() && !hasNumbers() && !hasStrings() && !hasThreads() &&
         !hasBuffers() && !hasTables() && !hasFunctions() && !hasTyvars();
}

bool NormalizedType::shouldSuppressErrors() const {
  return hasErrors() || get<AnyType>(tops);
}

bool NormalizedType::hasTopTable() const {
  return hasTables() &&
         std::any_of(tables.begin(), tables.end(), [&](TypeId ty) {
           auto primTy = get<PrimitiveType>(ty);
           return primTy && primTy->type == PrimitiveType::Type::Table;
         });
}

bool NormalizedType::hasTops() const { return !get<NeverType>(tops); }

bool NormalizedType::hasBooleans() const { return !get<NeverType>(booleans); }

bool NormalizedType::hasClasses() const { return !classes.isNever(); }

bool NormalizedType::hasErrors() const { return !get<NeverType>(errors); }

bool NormalizedType::hasNils() const { return !get<NeverType>(nils); }

bool NormalizedType::hasNumbers() const { return !get<NeverType>(numbers); }

bool NormalizedType::hasStrings() const { return !strings.isNever(); }

bool NormalizedType::hasThreads() const { return !get<NeverType>(threads); }

bool NormalizedType::hasBuffers() const { return !get<NeverType>(buffers); }

bool NormalizedType::hasTables() const { return !tables.isNever(); }

bool NormalizedType::hasFunctions() const { return !functions.isNever(); }

bool NormalizedType::hasTyvars() const { return !tyvars.empty(); }

bool NormalizedType::isFalsy() const {

  bool hasAFalse = false;
  if (auto singleton = get<SingletonType>(booleans)) {
    if (auto bs = singleton->variant.get_if<BooleanSingleton>())
      hasAFalse = !bs->value;
  }

  return (hasAFalse || hasNils()) &&
         (!hasTops() && !hasClasses() && !hasErrors() && !hasNumbers() &&
          !hasStrings() && !hasThreads() && !hasBuffers() && !hasTables() &&
          !hasFunctions() && !hasTyvars());
}

bool NormalizedType::isTruthy() const { return !isFalsy(); }

static bool isShallowInhabited(const NormalizedType &norm) {
  // This test is just a shallow check, for example it returns `true` for `{ p :
  // never }`
  return !get<NeverType>(norm.tops) || !get<NeverType>(norm.booleans) ||
         !norm.classes.isNever() || !get<NeverType>(norm.errors) ||
         !get<NeverType>(norm.nils) || !get<NeverType>(norm.numbers) ||
         !norm.strings.isNever() || !get<NeverType>(norm.threads) ||
         !get<NeverType>(norm.buffers) || !norm.functions.isNever() ||
         !norm.tables.empty() || !norm.tyvars.empty();
}

NormalizationResult Normalizer::isInhabited(const NormalizedType *norm) {
  Set<TypeId> seen{nullptr};

  return isInhabited(norm, seen);
}

NormalizationResult Normalizer::isInhabited(const NormalizedType *norm,
                                            Set<TypeId> &seen) {
  RecursionCounter _rc(&sharedState->counters.recursionCount);
  if (!withinResourceLimits() || !norm)
    return NormalizationResult::HitLimits;

  if (!get<NeverType>(norm->tops) || !get<NeverType>(norm->booleans) ||
      !get<NeverType>(norm->errors) || !get<NeverType>(norm->nils) ||
      !get<NeverType>(norm->numbers) || !get<NeverType>(norm->threads) ||
      !get<NeverType>(norm->buffers) || !norm->classes.isNever() ||
      !norm->strings.isNever() || !norm->functions.isNever())
    return NormalizationResult::True;

  for (const auto &[_, intersect] : norm->tyvars) {
    NormalizationResult res = isInhabited(intersect.get(), seen);
    if (res != NormalizationResult::False)
      return res;
  }

  for (TypeId table : norm->tables) {
    NormalizationResult res = isInhabited(table, seen);
    if (res != NormalizationResult::False)
      return res;
  }

  return NormalizationResult::False;
}

NormalizationResult Normalizer::isInhabited(TypeId ty) {
  if (cacheInhabitance) {
    if (bool *result = cachedIsInhabited.find(ty))
      return *result ? NormalizationResult::True : NormalizationResult::False;
  }

  Set<TypeId> seen{nullptr};
  NormalizationResult result = isInhabited(ty, seen);

  if (cacheInhabitance && result == NormalizationResult::True)
    cachedIsInhabited[ty] = true;
  else if (cacheInhabitance && result == NormalizationResult::False)
    cachedIsInhabited[ty] = false;

  return result;
}

NormalizationResult Normalizer::isInhabited(TypeId ty, Set<TypeId> &seen) {
  RecursionCounter _rc(&sharedState->counters.recursionCount);
  if (!withinResourceLimits())
    return NormalizationResult::HitLimits;

  // TODO: use log.follow(ty), CLI-64291
  ty = follow(ty);

  if (get<NeverType>(ty))
    return NormalizationResult::False;

  if (!get<IntersectionType>(ty) && !get<UnionType>(ty) &&
      !get<TableType>(ty) && !get<MetatableType>(ty))
    return NormalizationResult::True;

  if (seen.count(ty))
    return NormalizationResult::True;

  seen.insert(ty);

  if (const TableType *ttv = get<TableType>(ty)) {
    for (const auto &[_, prop] : ttv->props) {
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        // A table enclosing a read property whose type is uninhabitable is also
        // itself uninhabitable, but not its write property. That just means the
        // write property doesn't exist, and so is readonly.
        if (auto ty = prop.readTy) {
          NormalizationResult res = isInhabited(*ty, seen);
          if (res != NormalizationResult::True)
            return res;
        }
      } else {
        NormalizationResult res = isInhabited(prop.type(), seen);
        if (res != NormalizationResult::True)
          return res;
      }
    }
    return NormalizationResult::True;
  }

  if (const MetatableType *mtv = get<MetatableType>(ty)) {
    NormalizationResult res = isInhabited(mtv->table, seen);
    if (res != NormalizationResult::True)
      return res;
    return isInhabited(mtv->metatable, seen);
  }

  std::shared_ptr<const NormalizedType> norm = normalize(ty);
  return isInhabited(norm.get(), seen);
}

NormalizationResult Normalizer::isIntersectionInhabited(TypeId left,
                                                        TypeId right) {
  Set<TypeId> seen{nullptr};
  return isIntersectionInhabited(left, right, seen);
}

NormalizationResult Normalizer::isIntersectionInhabited(TypeId left,
                                                        TypeId right,
                                                        Set<TypeId> &seenSet) {
  left = follow(left);
  right = follow(right);
  // We're asking if intersection is inahbited between left and right but we've
  // already seen them ....

  if (cacheInhabitance) {
    if (bool *result = cachedIsInhabitedIntersection.find({left, right}))
      return *result ? NormalizationResult::True : NormalizationResult::False;
  }

  NormalizedType norm{builtinTypes};
  NormalizationResult res =
      normalizeIntersections({left, right}, norm, seenSet);
  if (res != NormalizationResult::True) {
    if (cacheInhabitance && res == NormalizationResult::False)
      cachedIsInhabitedIntersection[{left, right}] = false;

    return res;
  }

  NormalizationResult result = isInhabited(&norm, seenSet);

  if (cacheInhabitance && result == NormalizationResult::True)
    cachedIsInhabitedIntersection[{left, right}] = true;
  else if (cacheInhabitance && result == NormalizationResult::False)
    cachedIsInhabitedIntersection[{left, right}] = false;

  return result;
}

static int tyvarIndex(TypeId ty) {
  if (const GenericType *gtv = get<GenericType>(ty))
    return gtv->index;
  else if (const FreeType *ftv = get<FreeType>(ty))
    return ftv->index;
  else if (const BlockedType *btv = get<BlockedType>(ty))
    return btv->index;
  else
    return 0;
}

static bool isTop(NotNull<BuiltinTypes> builtinTypes,
                  const NormalizedClassType &classes) {
  if (classes.classes.size() != 1)
    return false;

  auto first = classes.classes.begin();
  if (first->first != builtinTypes->classType)
    return false;

  if (!first->second.empty())
    return false;

  return true;
}

static void resetToTop(NotNull<BuiltinTypes> builtinTypes,
                       NormalizedClassType &classes) {
  classes.ordering.clear();
  classes.classes.clear();
  classes.pushPair(builtinTypes->classType, TypeIds{});
}

#ifdef LUAU_ASSERTENABLED

static bool isNormalizedTop(TypeId ty) {
  return get<NeverType>(ty) || get<AnyType>(ty) || get<UnknownType>(ty);
}

static bool isNormalizedBoolean(TypeId ty) {
  if (get<NeverType>(ty))
    return true;
  else if (const PrimitiveType *ptv = get<PrimitiveType>(ty))
    return ptv->type == PrimitiveType::Boolean;
  else if (const SingletonType *stv = get<SingletonType>(ty))
    return get<BooleanSingleton>(stv);
  else
    return false;
}

static bool isNormalizedError(TypeId ty) {
  if (get<NeverType>(ty) || get<ErrorType>(ty))
    return true;
  else
    return false;
}

static bool isNormalizedNil(TypeId ty) {
  if (get<NeverType>(ty))
    return true;
  else if (const PrimitiveType *ptv = get<PrimitiveType>(ty))
    return ptv->type == PrimitiveType::NilType;
  else
    return false;
}

static bool isNormalizedNumber(TypeId ty) {
  if (get<NeverType>(ty))
    return true;
  else if (const PrimitiveType *ptv = get<PrimitiveType>(ty))
    return ptv->type == PrimitiveType::Number;
  else
    return false;
}

static bool isNormalizedString(const NormalizedStringType &ty) {
  if (ty.isString())
    return true;

  for (auto &[str, ty] : ty.singletons) {
    if (const SingletonType *stv = get<SingletonType>(ty)) {
      if (const StringSingleton *sstv = get<StringSingleton>(stv)) {
        if (sstv->value != str)
          return false;
      } else
        return false;
    } else
      return false;
  }

  return true;
}

static bool isNormalizedThread(TypeId ty) {
  if (get<NeverType>(ty))
    return true;
  else if (const PrimitiveType *ptv = get<PrimitiveType>(ty))
    return ptv->type == PrimitiveType::Thread;
  else
    return false;
}

static bool isNormalizedBuffer(TypeId ty) {
  if (get<NeverType>(ty))
    return true;
  else if (const PrimitiveType *ptv = get<PrimitiveType>(ty))
    return ptv->type == PrimitiveType::Buffer;
  else
    return false;
}

static bool areNormalizedFunctions(const NormalizedFunctionType &tys) {
  for (TypeId ty : tys.parts) {
    if (!get<FunctionType>(ty) && !get<ErrorType>(ty))
      return false;
  }
  return true;
}

static bool areNormalizedTables(const TypeIds &tys) {
  for (TypeId ty : tys) {
    if (get<TableType>(ty) || get<MetatableType>(ty))
      continue;

    const PrimitiveType *pt = get<PrimitiveType>(ty);
    if (!pt)
      return false;

    if (pt->type == PrimitiveType::Table)
      continue;

    return false;
  }

  return true;
}

static bool areNormalizedClasses(const NormalizedClassType &tys) {
  for (const auto &[ty, negations] : tys.classes) {
    const ClassType *ctv = get<ClassType>(ty);
    if (!ctv) {
      return false;
    }

    for (TypeId negation : negations) {
      const ClassType *nctv = get<ClassType>(negation);
      if (!nctv) {
        return false;
      }

      if (!isSubclass(nctv, ctv)) {
        return false;
      }
    }

    for (const auto &[otherTy, otherNegations] : tys.classes) {
      if (otherTy == ty)
        continue;

      const ClassType *octv = get<ClassType>(otherTy);
      if (!octv) {
        return false;
      }

      if (isSubclass(ctv, octv)) {
        auto iss = [ctv](TypeId t) {
          const ClassType *c = get<ClassType>(t);
          if (!c)
            return false;

          return isSubclass(ctv, c);
        };

        if (!std::any_of(otherNegations.begin(), otherNegations.end(), iss))
          return false;
      }
    }
  }

  return true;
}

static bool isPlainTyvar(TypeId ty) {
  return (get<FreeType>(ty) || get<GenericType>(ty) || get<BlockedType>(ty) ||
          get<PendingExpansionType>(ty) || get<TypeFunctionInstanceType>(ty));
}

static bool isNormalizedTyvar(const NormalizedTyvars &tyvars) {
  for (auto &[tyvar, intersect] : tyvars) {
    if (!isPlainTyvar(tyvar))
      return false;
    if (!isShallowInhabited(*intersect))
      return false;
    for (auto &[other, _] : intersect->tyvars)
      if (tyvarIndex(other) <= tyvarIndex(tyvar))
        return false;
  }
  return true;
}

#endif // LUAU_ASSERTENABLED

static void assertInvariant(const NormalizedType &norm) {
#ifdef LUAU_ASSERTENABLED
  if (!FFlag::DebugLuauCheckNormalizeInvariant)
    return;

  LUAU_ASSERT(isNormalizedTop(norm.tops));
  LUAU_ASSERT(isNormalizedBoolean(norm.booleans));
  LUAU_ASSERT(areNormalizedClasses(norm.classes));
  LUAU_ASSERT(isNormalizedError(norm.errors));
  LUAU_ASSERT(isNormalizedNil(norm.nils));
  LUAU_ASSERT(isNormalizedNumber(norm.numbers));
  LUAU_ASSERT(isNormalizedString(norm.strings));
  LUAU_ASSERT(isNormalizedThread(norm.threads));
  LUAU_ASSERT(isNormalizedBuffer(norm.buffers));
  LUAU_ASSERT(areNormalizedFunctions(norm.functions));
  LUAU_ASSERT(areNormalizedTables(norm.tables));
  LUAU_ASSERT(isNormalizedTyvar(norm.tyvars));
  for (auto &[_, child] : norm.tyvars)
    assertInvariant(*child);
#endif
}

Normalizer::Normalizer(TypeArena *arena, NotNull<BuiltinTypes> builtinTypes,
                       NotNull<UnifierSharedState> sharedState,
                       bool cacheInhabitance)
    : arena(arena), builtinTypes(builtinTypes), sharedState(sharedState),
      cacheInhabitance(cacheInhabitance) {}

static bool isCacheable(TypeId ty, Set<TypeId> &seen);

static bool isCacheable(TypePackId tp, Set<TypeId> &seen) {
  tp = follow(tp);

  auto it = begin(tp);
  auto endIt = end(tp);
  for (; it != endIt; ++it) {
    if (!isCacheable(*it, seen))
      return false;
  }

  if (auto tail = it.tail()) {
    if (get<FreeTypePack>(*tail) || get<BlockedTypePack>(*tail) ||
        get<TypeFunctionInstanceTypePack>(*tail))
      return false;
  }

  return true;
}

static bool isCacheable(TypeId ty, Set<TypeId> &seen) {
  if (seen.contains(ty))
    return true;
  seen.insert(ty);

  ty = follow(ty);

  if (get<FreeType>(ty) || get<BlockedType>(ty) ||
      get<PendingExpansionType>(ty))
    return false;

  if (auto tfi = get<TypeFunctionInstanceType>(ty)) {
    for (TypeId t : tfi->typeArguments) {
      if (!isCacheable(t, seen))
        return false;
    }

    for (TypePackId tp : tfi->packArguments) {
      if (!isCacheable(tp, seen))
        return false;
    }
  }

  return true;
}

static bool isCacheable(TypeId ty) {
  Set<TypeId> seen{nullptr};
  return isCacheable(ty, seen);
}

std::shared_ptr<const NormalizedType> Normalizer::normalize(TypeId ty) {
  if (!arena)
    sharedState->iceHandler->ice("Normalizing types outside a module");

  auto found = cachedNormals.find(ty);
  if (found != cachedNormals.end())
    return found->second;

  NormalizedType norm{builtinTypes};
  Set<TypeId> seenSetTypes{nullptr};
  NormalizationResult res = unionNormalWithTy(norm, ty, seenSetTypes);
  if (res != NormalizationResult::True)
    return nullptr;

  if (norm.isUnknown()) {
    clearNormal(norm);
    norm.tops = builtinTypes->unknownType;
  }

  std::shared_ptr<NormalizedType> shared =
      std::make_shared<NormalizedType>(std::move(norm));

  if (shared->isCacheable)
    cachedNormals[ty] = shared;

  return shared;
}

NormalizationResult
Normalizer::normalizeIntersections(const std::vector<TypeId> &intersections,
                                   NormalizedType &outType,
                                   Set<TypeId> &seenSet) {
  if (!arena)
    sharedState->iceHandler->ice("Normalizing types outside a module");
  NormalizedType norm{builtinTypes};
  norm.tops = builtinTypes->anyType;
  // Now we need to intersect the two types
  Set<TypeId> seenSetTypes{nullptr};
  for (auto ty : intersections) {
    NormalizationResult res = intersectNormalWithTy(norm, ty, seenSet);
    if (res != NormalizationResult::True)
      return res;
  }

  NormalizationResult res = unionNormals(outType, norm);
  if (res != NormalizationResult::True)
    return res;

  return NormalizationResult::True;
}

void Normalizer::clearNormal(NormalizedType &norm) {
  norm.tops = builtinTypes->neverType;
  norm.booleans = builtinTypes->neverType;
  norm.classes.resetToNever();
  norm.errors = builtinTypes->neverType;
  norm.nils = builtinTypes->neverType;
  norm.numbers = builtinTypes->neverType;
  norm.strings.resetToNever();
  norm.threads = builtinTypes->neverType;
  norm.buffers = builtinTypes->neverType;
  norm.tables.clear();
  norm.functions.resetToNever();
  norm.tyvars.clear();
}

// ------- Cached TypeIds
const TypeIds *Normalizer::cacheTypeIds(TypeIds tys) {
  auto found = cachedTypeIds.find(&tys);
  if (found != cachedTypeIds.end())
    return found->first;

  std::unique_ptr<TypeIds> uniq = std::make_unique<TypeIds>(std::move(tys));
  const TypeIds *result = uniq.get();
  cachedTypeIds[result] = std::move(uniq);
  return result;
}

TypeId Normalizer::unionType(TypeId here, TypeId there) {
  here = follow(here);
  there = follow(there);

  if (here == there)
    return here;
  if (get<NeverType>(here) || get<AnyType>(there))
    return there;
  if (get<NeverType>(there) || get<AnyType>(here))
    return here;

  TypeIds tmps;

  if (const UnionType *utv = get<UnionType>(here)) {
    TypeIds heres;
    heres.insert(begin(utv), end(utv));
    tmps.insert(heres.begin(), heres.end());
    cachedUnions[cacheTypeIds(std::move(heres))] = here;
  } else
    tmps.insert(here);

  if (const UnionType *utv = get<UnionType>(there)) {
    TypeIds theres;
    theres.insert(begin(utv), end(utv));
    tmps.insert(theres.begin(), theres.end());
    cachedUnions[cacheTypeIds(std::move(theres))] = there;
  } else
    tmps.insert(there);

  auto cacheHit = cachedUnions.find(&tmps);
  if (cacheHit != cachedUnions.end())
    return cacheHit->second;

  std::vector<TypeId> parts;
  parts.insert(parts.end(), tmps.begin(), tmps.end());
  TypeId result = arena->addType(UnionType{std::move(parts)});
  cachedUnions[cacheTypeIds(std::move(tmps))] = result;

  return result;
}

TypeId Normalizer::intersectionType(TypeId here, TypeId there) {
  here = follow(here);
  there = follow(there);

  if (here == there)
    return here;
  if (get<NeverType>(here) || get<AnyType>(there))
    return here;
  if (get<NeverType>(there) || get<AnyType>(here))
    return there;

  TypeIds tmps;

  if (const IntersectionType *utv = get<IntersectionType>(here)) {
    TypeIds heres;
    heres.insert(begin(utv), end(utv));
    tmps.insert(heres.begin(), heres.end());
    cachedIntersections[cacheTypeIds(std::move(heres))] = here;
  } else
    tmps.insert(here);

  if (const IntersectionType *utv = get<IntersectionType>(there)) {
    TypeIds theres;
    theres.insert(begin(utv), end(utv));
    tmps.insert(theres.begin(), theres.end());
    cachedIntersections[cacheTypeIds(std::move(theres))] = there;
  } else
    tmps.insert(there);

  if (tmps.size() == 1)
    return *tmps.begin();

  auto cacheHit = cachedIntersections.find(&tmps);
  if (cacheHit != cachedIntersections.end())
    return cacheHit->second;

  std::vector<TypeId> parts;
  parts.insert(parts.end(), tmps.begin(), tmps.end());
  TypeId result = arena->addType(IntersectionType{std::move(parts)});
  cachedIntersections[cacheTypeIds(std::move(tmps))] = result;

  return result;
}

void Normalizer::clearCaches() {
  cachedNormals.clear();
  cachedIntersections.clear();
  cachedUnions.clear();
  cachedTypeIds.clear();
}

// ------- Normalizing unions
TypeId Normalizer::unionOfTops(TypeId here, TypeId there) {
  if (get<NeverType>(here) || get<AnyType>(there))
    return there;
  else
    return here;
}

TypeId Normalizer::unionOfBools(TypeId here, TypeId there) {
  if (get<NeverType>(here))
    return there;
  if (get<NeverType>(there))
    return here;
  if (const BooleanSingleton *hbool =
          get<BooleanSingleton>(get<SingletonType>(here)))
    if (const BooleanSingleton *tbool =
            get<BooleanSingleton>(get<SingletonType>(there)))
      if (hbool->value == tbool->value)
        return here;
  return builtinTypes->booleanType;
}

void Normalizer::unionClassesWithClass(TypeIds &heres, TypeId there) {
  if (heres.count(there))
    return;

  const ClassType *tctv = get<ClassType>(there);

  for (auto it = heres.begin(); it != heres.end();) {
    TypeId here = *it;
    const ClassType *hctv = get<ClassType>(here);
    if (isSubclass(tctv, hctv))
      return;
    else if (isSubclass(hctv, tctv))
      it = heres.erase(it);
    else
      it++;
  }

  heres.insert(there);
}

void Normalizer::unionClasses(TypeIds &heres, const TypeIds &theres) {
  for (TypeId there : theres)
    unionClassesWithClass(heres, there);
}

static bool isSubclass(TypeId test, TypeId parent) {
  const ClassType *testCtv = get<ClassType>(test);
  const ClassType *parentCtv = get<ClassType>(parent);

  LUAU_ASSERT(testCtv);
  LUAU_ASSERT(parentCtv);

  return isSubclass(testCtv, parentCtv);
}

void Normalizer::unionClassesWithClass(NormalizedClassType &heres,
                                       TypeId there) {
  for (auto it = heres.ordering.begin(); it != heres.ordering.end();) {
    TypeId hereTy = *it;
    TypeIds &hereNegations = heres.classes.at(hereTy);

    // If the incoming class is a subclass of another class in the map, we
    // must ensure that it is negated by one of the negations in the same
    // cluster. If it isn't, we do not need to insert it - the subtyping
    // relationship is already handled by this entry. If it is, we must
    // insert it, to capture the presence of this particular subtype.
    if (isSubclass(there, hereTy)) {
      for (auto nIt = hereNegations.begin(); nIt != hereNegations.end();) {
        TypeId hereNegation = *nIt;

        // If the incoming class is a subclass of one of the negations,
        // we must insert it into the class map.
        if (isSubclass(there, hereNegation)) {
          heres.pushPair(there, TypeIds{});
          return;
        }
        // If the incoming class is a superclass of one of the
        // negations, then the negation no longer applies and must be
        // removed. This is also true if they are equal. Since classes
        // are, at this time, entirely persistent (we do not clone
        // them), a pointer identity check is sufficient.
        else if (isSubclass(hereNegation, there)) {
          nIt = hereNegations.erase(nIt);
        }
        // If the incoming class is unrelated to the negation, we move
        // on to the next item.
        else {
          ++nIt;
        }
      }

      // If, at the end of the above loop, we haven't returned, that means
      // that the class is not a subclass of one of the negations, and is
      // covered by the existing subtype relationship. We can return now.
      return;
    }
    // If the incoming class is a superclass of another class in the map, we
    // need to replace the existing class with the incoming class,
    // preserving the relevant negations.
    else if (isSubclass(hereTy, there)) {
      TypeIds negations = std::move(hereNegations);
      it = heres.ordering.erase(it);
      heres.classes.erase(hereTy);

      heres.pushPair(there, std::move(negations));
      return;
    }

    // If the incoming class is unrelated to the class in the map, we move
    // on. If we do not otherwise exit from this method body, we will
    // eventually fall out of this loop and insert the incoming class, which
    // we have proven to be completely unrelated to any class in the map,
    // into the map itself.
    ++it;
  }

  heres.pushPair(there, TypeIds{});
}

void Normalizer::unionClasses(NormalizedClassType &heres,
                              const NormalizedClassType &theres) {
  // This method bears much similarity with unionClassesWithClass, but is
  // solving a more general problem. In unionClassesWithClass, we are dealing
  // with a singular positive type. Since it's one type, we can use early
  // returns as control flow. Since it's guaranteed to be positive, we do not
  // have negations to worry about combining. The two aspects combine to make
  // the tasks this method must perform different enough to warrant a separate
  // implementation.

  for (const TypeId thereTy : theres.ordering) {
    const TypeIds &thereNegations = theres.classes.at(thereTy);

    // If it happens that there are _no_ classes in the current map, or the
    // incoming class is completely unrelated to any class in the current
    // map, we must insert the incoming pair as-is.
    bool insert = true;

    for (auto it = heres.ordering.begin(); it != heres.ordering.end();) {
      TypeId hereTy = *it;
      TypeIds &hereNegations = heres.classes.at(hereTy);

      if (isSubclass(thereTy, hereTy)) {
        bool inserted = false;
        for (auto nIt = hereNegations.begin(); nIt != hereNegations.end();) {
          TypeId hereNegateTy = *nIt;

          // If the incoming class is a subclass of one of the negations,
          // we must insert it into the class map.
          if (isSubclass(thereTy, hereNegateTy)) {
            // We do not concern ourselves with iterator
            // invalidation here because we will break out of the
            // loop over `heres` when `inserted` is set, and we do
            // not read from the iterator after this point.
            inserted = true;
            heres.pushPair(thereTy, thereNegations);
            break;
          }
          // If the incoming class is a superclass of one of the
          // negations, then the negation no longer applies and must
          // be removed. This is also true if they are equal. Since
          // classes are, at this time, entirely persistent (we do not
          // clone them), a pointer identity check is sufficient.
          else if (isSubclass(hereNegateTy, thereTy)) {
            inserted = true;
            nIt = hereNegations.erase(nIt);
            break;
          }
          // If the incoming class is unrelated to the negation, we
          // move on to the next item.
          else {
            ++nIt;
          }
        }

        if (inserted) {
          insert = false;
          break;
        }
      } else if (isSubclass(hereTy, thereTy)) {
        TypeIds negations = std::move(hereNegations);
        unionClasses(negations, thereNegations);

        it = heres.ordering.erase(it);
        heres.classes.erase(hereTy);
        heres.pushPair(thereTy, std::move(negations));
        insert = false;
        break;
      } else if (hereTy == thereTy) {
        unionClasses(hereNegations, thereNegations);
        insert = false;
        break;
      }

      ++it;
    }

    if (insert) {
      heres.pushPair(thereTy, thereNegations);
    }
  }
}

void Normalizer::unionStrings(NormalizedStringType &here,
                              const NormalizedStringType &there) {
  if (there.isString())
    here.resetToString();
  else if (here.isUnion() && there.isUnion())
    here.singletons.insert(there.singletons.begin(), there.singletons.end());
  else if (here.isUnion() && there.isIntersection()) {
    here.isCofinite = true;
    for (const auto &pair : there.singletons) {
      auto it = here.singletons.find(pair.first);
      if (it != end(here.singletons))
        here.singletons.erase(it);
      else
        here.singletons.insert(pair);
    }
  } else if (here.isIntersection() && there.isUnion()) {
    for (const auto &[name, ty] : there.singletons)
      here.singletons.erase(name);
  } else if (here.isIntersection() && there.isIntersection()) {
    auto iter = begin(here.singletons);
    auto endIter = end(here.singletons);

    while (iter != endIter) {
      if (!there.singletons.count(iter->first)) {
        auto eraseIt = iter;
        ++iter;
        here.singletons.erase(eraseIt);
      } else
        ++iter;
    }
  } else
    LUAU_ASSERT(!"Unreachable");
}

std::optional<TypePackId> Normalizer::unionOfTypePacks(TypePackId here,
                                                       TypePackId there) {
  if (here == there)
    return here;

  std::vector<TypeId> head;
  std::optional<TypePackId> tail;

  bool hereSubThere = true;
  bool thereSubHere = true;

  TypePackIterator ith = begin(here);
  TypePackIterator itt = begin(there);

  while (ith != end(here) && itt != end(there)) {
    TypeId hty = *ith;
    TypeId tty = *itt;
    TypeId ty = unionType(hty, tty);
    if (ty != hty)
      thereSubHere = false;
    if (ty != tty)
      hereSubThere = false;
    head.push_back(ty);
    ith++;
    itt++;
  }

  auto dealWithDifferentArities =
      [&](TypePackIterator &ith, TypePackIterator itt, TypePackId here,
          TypePackId there, bool &hereSubThere, bool &thereSubHere) {
        if (ith != end(here)) {
          TypeId tty = builtinTypes->nilType;
          if (std::optional<TypePackId> ttail = itt.tail()) {
            if (const VariadicTypePack *tvtp = get<VariadicTypePack>(*ttail))
              tty = tvtp->ty;
            else
              // Luau doesn't have unions of type pack variables
              return false;
          } else
            // Type packs of different arities are incomparable
            return false;

          while (ith != end(here)) {
            TypeId hty = *ith;
            TypeId ty = unionType(hty, tty);
            if (ty != hty)
              thereSubHere = false;
            if (ty != tty)
              hereSubThere = false;
            head.push_back(ty);
            ith++;
          }
        }
        return true;
      };

  if (!dealWithDifferentArities(ith, itt, here, there, hereSubThere,
                                thereSubHere))
    return std::nullopt;

  if (!dealWithDifferentArities(itt, ith, there, here, thereSubHere,
                                hereSubThere))
    return std::nullopt;

  if (std::optional<TypePackId> htail = ith.tail()) {
    if (std::optional<TypePackId> ttail = itt.tail()) {
      if (*htail == *ttail)
        tail = htail;
      else if (const VariadicTypePack *hvtp = get<VariadicTypePack>(*htail)) {
        if (const VariadicTypePack *tvtp = get<VariadicTypePack>(*ttail)) {
          TypeId ty = unionType(hvtp->ty, tvtp->ty);
          if (ty != hvtp->ty)
            thereSubHere = false;
          if (ty != tvtp->ty)
            hereSubThere = false;
          bool hidden = hvtp->hidden & tvtp->hidden;
          tail = arena->addTypePack(VariadicTypePack{ty, hidden});
        } else
          // Luau doesn't have unions of type pack variables
          return std::nullopt;
      } else
        // Luau doesn't have unions of type pack variables
        return std::nullopt;
    } else if (get<VariadicTypePack>(*htail)) {
      hereSubThere = false;
      tail = htail;
    } else
      // Luau doesn't have unions of type pack variables
      return std::nullopt;
  } else if (std::optional<TypePackId> ttail = itt.tail()) {
    if (get<VariadicTypePack>(*ttail)) {
      thereSubHere = false;
      tail = htail;
    } else
      // Luau doesn't have unions of type pack variables
      return std::nullopt;
  }

  if (hereSubThere)
    return there;
  else if (thereSubHere)
    return here;
  if (!head.empty())
    return arena->addTypePack(TypePack{head, tail});
  else if (tail)
    return *tail;
  else
    // TODO: Add an emptyPack to singleton types
    return arena->addTypePack({});
}

std::optional<TypeId> Normalizer::unionOfFunctions(TypeId here, TypeId there) {
  if (get<ErrorType>(here))
    return here;

  if (get<ErrorType>(there))
    return there;

  const FunctionType *hftv = get<FunctionType>(here);
  LUAU_ASSERT(hftv);
  const FunctionType *tftv = get<FunctionType>(there);
  LUAU_ASSERT(tftv);

  if (hftv->generics != tftv->generics)
    return std::nullopt;
  if (hftv->genericPacks != tftv->genericPacks)
    return std::nullopt;

  std::optional<TypePackId> argTypes =
      intersectionOfTypePacks(hftv->argTypes, tftv->argTypes);
  if (!argTypes)
    return std::nullopt;

  std::optional<TypePackId> retTypes =
      unionOfTypePacks(hftv->retTypes, tftv->retTypes);
  if (!retTypes)
    return std::nullopt;

  if (*argTypes == hftv->argTypes && *retTypes == hftv->retTypes)
    return here;
  if (*argTypes == tftv->argTypes && *retTypes == tftv->retTypes)
    return there;

  FunctionType result{*argTypes, *retTypes};
  result.generics = hftv->generics;
  result.genericPacks = hftv->genericPacks;
  return arena->addType(std::move(result));
}

void Normalizer::unionFunctions(NormalizedFunctionType &heres,
                                const NormalizedFunctionType &theres) {
  if (heres.isTop)
    return;
  if (theres.isTop)
    heres.resetToTop();

  if (theres.isNever())
    return;

  TypeIds tmps;

  if (heres.isNever()) {
    tmps.insert(theres.parts.begin(), theres.parts.end());
    heres.parts = std::move(tmps);
    return;
  }

  for (TypeId here : heres.parts)
    for (TypeId there : theres.parts) {
      if (std::optional<TypeId> fun = unionOfFunctions(here, there))
        tmps.insert(*fun);
      else
        tmps.insert(builtinTypes->errorRecoveryType(there));
    }

  heres.parts = std::move(tmps);
}

void Normalizer::unionFunctionsWithFunction(NormalizedFunctionType &heres,
                                            TypeId there) {
  if (heres.isNever()) {
    TypeIds tmps;
    tmps.insert(there);
    heres.parts = std::move(tmps);
    return;
  }

  TypeIds tmps;
  for (TypeId here : heres.parts) {
    if (std::optional<TypeId> fun = unionOfFunctions(here, there))
      tmps.insert(*fun);
    else
      tmps.insert(builtinTypes->errorRecoveryType(there));
  }
  heres.parts = std::move(tmps);
}

void Normalizer::unionTablesWithTable(TypeIds &heres, TypeId there) {
  // TODO: remove unions of tables where possible

  // we can always skip `never`
  if (normalizeAwayUninhabitableTables() && get<NeverType>(there))
    return;

  heres.insert(there);
}

void Normalizer::unionTables(TypeIds &heres, const TypeIds &theres) {
  for (TypeId there : theres) {
    if (there == builtinTypes->tableType) {
      heres.clear();
      heres.insert(there);
      return;
    } else {
      unionTablesWithTable(heres, there);
    }
  }
}

// So why `ignoreSmallerTyvars`?
//
// First up, what it does... Every tyvar has an index, and this parameter says
// to ignore any tyvars in `there` if their index is less than or equal to the
// parameter. The parameter is always greater than any tyvars mentioned in here,
// so the result is a lower bound on any tyvars in `here.tyvars`.
//
// This is used to maintain in invariant, which is that in any tyvar `X&T`, any
// any tyvar `Y&U` in `T`, the index of `X` is less than the index of `Y`. This
// is an implementation of *ordered decision diagrams*
// (https://en.wikipedia.org/wiki/Binary_decision_diagram#Variable_ordering)
// which are a compression technique used to save memory usage when representing
// boolean formulae.
//
// The idea is that if you have an out-of-order decision diagram
// like `Z&(X|Y)`, to re-order it in this case to `(X&Z)|(Y&Z)`.
// The hope is that by imposing a global order, there's a higher chance of
// sharing opportunities, and hence reduced memory.
//
// And yes, this is essentially a SAT solver hidden inside a typechecker.
// That's what you get for having a type system with generics, intersection and
// union types.
NormalizationResult Normalizer::unionNormals(NormalizedType &here,
                                             const NormalizedType &there,
                                             int ignoreSmallerTyvars) {
  here.isCacheable &= there.isCacheable;

  TypeId tops = unionOfTops(here.tops, there.tops);
  if (get<UnknownType>(tops) &&
      (get<ErrorType>(here.errors) || get<ErrorType>(there.errors)))
    tops = builtinTypes->anyType;
  if (!get<NeverType>(tops)) {
    clearNormal(here);
    here.tops = tops;
    return NormalizationResult::True;
  }

  for (auto it = there.tyvars.begin(); it != there.tyvars.end(); it++) {
    TypeId tyvar = it->first;
    const NormalizedType &inter = *it->second;
    int index = tyvarIndex(tyvar);
    if (index <= ignoreSmallerTyvars)
      continue;
    auto [emplaced, fresh] = here.tyvars.emplace(
        tyvar, std::make_unique<NormalizedType>(NormalizedType{builtinTypes}));
    if (fresh) {
      NormalizationResult res = unionNormals(*emplaced->second, here, index);
      if (res != NormalizationResult::True)
        return res;
    }

    NormalizationResult res = unionNormals(*emplaced->second, inter, index);
    if (res != NormalizationResult::True)
      return res;
  }

  here.booleans = unionOfBools(here.booleans, there.booleans);
  unionClasses(here.classes, there.classes);

  here.errors = (get<NeverType>(there.errors) ? here.errors : there.errors);
  here.nils = (get<NeverType>(there.nils) ? here.nils : there.nils);
  here.numbers = (get<NeverType>(there.numbers) ? here.numbers : there.numbers);
  unionStrings(here.strings, there.strings);
  here.threads = (get<NeverType>(there.threads) ? here.threads : there.threads);
  here.buffers = (get<NeverType>(there.buffers) ? here.buffers : there.buffers);
  unionFunctions(here.functions, there.functions);
  unionTables(here.tables, there.tables);
  return NormalizationResult::True;
}

bool Normalizer::withinResourceLimits() {
  // If cache is too large, clear it
  if (FInt::LuauNormalizeCacheLimit > 0) {
    size_t cacheUsage = cachedNormals.size() + cachedIntersections.size() +
                        cachedUnions.size() + cachedTypeIds.size() +
                        cachedIsInhabited.size() +
                        cachedIsInhabitedIntersection.size();
    if (cacheUsage > size_t(FInt::LuauNormalizeCacheLimit)) {
      clearCaches();
      return false;
    }
  }

  // Check the recursion count
  if (sharedState->counters.recursionLimit > 0)
    if (sharedState->counters.recursionLimit <
        sharedState->counters.recursionCount)
      return false;

  return true;
}

NormalizationResult
Normalizer::intersectNormalWithNegationTy(TypeId toNegate,
                                          NormalizedType &intersect) {

  std::optional<NormalizedType> negated;

  std::shared_ptr<const NormalizedType> normal = normalize(toNegate);
  negated = negateNormal(*normal);

  if (!negated)
    return NormalizationResult::False;
  intersectNormals(intersect, *negated);
  return NormalizationResult::True;
}

// See above for an explaination of `ignoreSmallerTyvars`.
NormalizationResult Normalizer::unionNormalWithTy(NormalizedType &here,
                                                  TypeId there,
                                                  Set<TypeId> &seenSetTypes,
                                                  int ignoreSmallerTyvars) {
  RecursionCounter _rc(&sharedState->counters.recursionCount);
  if (!withinResourceLimits())
    return NormalizationResult::HitLimits;

  there = follow(there);

  if (get<AnyType>(there) || get<UnknownType>(there)) {
    TypeId tops = unionOfTops(here.tops, there);
    if (get<UnknownType>(tops) && get<ErrorType>(here.errors))
      tops = builtinTypes->anyType;
    clearNormal(here);
    here.tops = tops;
    return NormalizationResult::True;
  } else if (get<NeverType>(there) || get<AnyType>(here.tops))
    return NormalizationResult::True;
  else if (get<ErrorType>(there) && get<UnknownType>(here.tops)) {
    here.tops = builtinTypes->anyType;
    return NormalizationResult::True;
  } else if (const UnionType *utv = get<UnionType>(there)) {
    if (seenSetTypes.count(there))
      return NormalizationResult::True;
    seenSetTypes.insert(there);

    for (UnionTypeIterator it = begin(utv); it != end(utv); ++it) {
      NormalizationResult res = unionNormalWithTy(here, *it, seenSetTypes);
      if (res != NormalizationResult::True) {
        seenSetTypes.erase(there);
        return res;
      }
    }

    seenSetTypes.erase(there);
    return NormalizationResult::True;
  } else if (const IntersectionType *itv = get<IntersectionType>(there)) {
    if (seenSetTypes.count(there))
      return NormalizationResult::True;
    seenSetTypes.insert(there);

    NormalizedType norm{builtinTypes};
    norm.tops = builtinTypes->anyType;
    for (IntersectionTypeIterator it = begin(itv); it != end(itv); ++it) {
      NormalizationResult res = intersectNormalWithTy(norm, *it, seenSetTypes);
      if (res != NormalizationResult::True) {
        seenSetTypes.erase(there);
        return res;
      }
    }

    seenSetTypes.erase(there);

    return unionNormals(here, norm);
  } else if (get<UnknownType>(here.tops))
    return NormalizationResult::True;
  else if (get<GenericType>(there) || get<FreeType>(there) ||
           get<BlockedType>(there) || get<PendingExpansionType>(there) ||
           get<TypeFunctionInstanceType>(there)) {
    if (tyvarIndex(there) <= ignoreSmallerTyvars)
      return NormalizationResult::True;
    NormalizedType inter{builtinTypes};
    inter.tops = builtinTypes->unknownType;
    here.tyvars.insert_or_assign(
        there, std::make_unique<NormalizedType>(std::move(inter)));

    if (!isCacheable(there))
      here.isCacheable = false;
  } else if (get<FunctionType>(there))
    unionFunctionsWithFunction(here.functions, there);
  else if (get<TableType>(there) || get<MetatableType>(there))
    unionTablesWithTable(here.tables, there);
  else if (get<ClassType>(there))
    unionClassesWithClass(here.classes, there);
  else if (get<ErrorType>(there))
    here.errors = there;
  else if (const PrimitiveType *ptv = get<PrimitiveType>(there)) {
    if (ptv->type == PrimitiveType::Boolean)
      here.booleans = there;
    else if (ptv->type == PrimitiveType::NilType)
      here.nils = there;
    else if (ptv->type == PrimitiveType::Number)
      here.numbers = there;
    else if (ptv->type == PrimitiveType::String)
      here.strings.resetToString();
    else if (ptv->type == PrimitiveType::Thread)
      here.threads = there;
    else if (ptv->type == PrimitiveType::Buffer)
      here.buffers = there;
    else if (ptv->type == PrimitiveType::Function) {
      here.functions.resetToTop();
    } else if (ptv->type == PrimitiveType::Table) {
      here.tables.clear();
      here.tables.insert(there);
    } else
      LUAU_ASSERT(!"Unreachable");
  } else if (const SingletonType *stv = get<SingletonType>(there)) {
    if (get<BooleanSingleton>(stv))
      here.booleans = unionOfBools(here.booleans, there);
    else if (const StringSingleton *sstv = get<StringSingleton>(stv)) {
      if (here.strings.isCofinite) {
        auto it = here.strings.singletons.find(sstv->value);
        if (it != here.strings.singletons.end())
          here.strings.singletons.erase(it);
      } else
        here.strings.singletons.insert({sstv->value, there});
    } else
      LUAU_ASSERT(!"Unreachable");
  } else if (const NegationType *ntv = get<NegationType>(there)) {
    std::optional<NormalizedType> tn;

    std::shared_ptr<const NormalizedType> thereNormal = normalize(ntv->ty);
    tn = negateNormal(*thereNormal);

    if (!tn)
      return NormalizationResult::False;

    NormalizationResult res = unionNormals(here, *tn);
    if (res != NormalizationResult::True)
      return res;
  } else if (get<PendingExpansionType>(there) ||
             get<TypeFunctionInstanceType>(there)) {
    // nothing
  } else
    LUAU_ASSERT(!"Unreachable");

  for (auto &[tyvar, intersect] : here.tyvars) {
    NormalizationResult res =
        unionNormalWithTy(*intersect, there, seenSetTypes, tyvarIndex(tyvar));
    if (res != NormalizationResult::True)
      return res;
  }

  assertInvariant(here);
  return NormalizationResult::True;
}

// ------- Negations

std::optional<NormalizedType>
Normalizer::negateNormal(const NormalizedType &here) {
  NormalizedType result{builtinTypes};
  result.isCacheable = here.isCacheable;

  if (!get<NeverType>(here.tops)) {
    // The negation of unknown or any is never.  Easy.
    return result;
  }

  if (!get<NeverType>(here.errors)) {
    // Negating an error yields the same error.
    result.errors = here.errors;
    return result;
  }

  if (get<NeverType>(here.booleans))
    result.booleans = builtinTypes->booleanType;
  else if (get<PrimitiveType>(here.booleans))
    result.booleans = builtinTypes->neverType;
  else if (auto stv = get<SingletonType>(here.booleans)) {
    auto boolean = get<BooleanSingleton>(stv);
    LUAU_ASSERT(boolean != nullptr);
    if (boolean->value)
      result.booleans = builtinTypes->falseType;
    else
      result.booleans = builtinTypes->trueType;
  }

  if (here.classes.isNever()) {
    resetToTop(builtinTypes, result.classes);
  } else if (isTop(builtinTypes, result.classes)) {
    result.classes.resetToNever();
  } else {
    TypeIds rootNegations{};

    for (const auto &[hereParent, hereNegations] : here.classes.classes) {
      if (hereParent != builtinTypes->classType)
        rootNegations.insert(hereParent);

      for (TypeId hereNegation : hereNegations)
        unionClassesWithClass(result.classes, hereNegation);
    }

    if (!rootNegations.empty())
      result.classes.pushPair(builtinTypes->classType, rootNegations);
  }

  result.nils = get<NeverType>(here.nils) ? builtinTypes->nilType
                                          : builtinTypes->neverType;
  result.numbers = get<NeverType>(here.numbers) ? builtinTypes->numberType
                                                : builtinTypes->neverType;

  result.strings = here.strings;
  result.strings.isCofinite = !result.strings.isCofinite;

  result.threads = get<NeverType>(here.threads) ? builtinTypes->threadType
                                                : builtinTypes->neverType;
  result.buffers = get<NeverType>(here.buffers) ? builtinTypes->bufferType
                                                : builtinTypes->neverType;

  /*
   * Things get weird and so, so complicated if we allow negations of
   * arbitrary function types.  Ordinary code can never form these kinds of
   * types, so we decline to negate them.
   */
  if (here.functions.isNever())
    result.functions.resetToTop();
  else if (here.functions.isTop)
    result.functions.resetToNever();
  else
    return std::nullopt;

  /*
   * It is not possible to negate an arbitrary table type, because function
   * types are not runtime-testable. Thus, we prohibit negation of anything
   * other than `table` and `never`.
   */
  if (here.tables.empty())
    result.tables.insert(builtinTypes->tableType);
  else if (here.tables.size() == 1 &&
           here.tables.front() == builtinTypes->tableType)
    result.tables.clear();
  else
    return std::nullopt;

  // TODO: negating tables
  // TODO: negating tyvars?

  return result;
}

TypeIds Normalizer::negateAll(const TypeIds &theres) {
  TypeIds tys;
  for (TypeId there : theres)
    tys.insert(negate(there));
  return tys;
}

TypeId Normalizer::negate(TypeId there) {
  there = follow(there);
  if (get<AnyType>(there))
    return there;
  else if (get<UnknownType>(there))
    return builtinTypes->neverType;
  else if (get<NeverType>(there))
    return builtinTypes->unknownType;
  else if (auto ntv = get<NegationType>(there))
    return ntv->ty; // TODO: do we want to normalize this?
  else if (auto utv = get<UnionType>(there)) {
    std::vector<TypeId> parts;
    for (TypeId option : utv)
      parts.push_back(negate(option));
    return arena->addType(IntersectionType{std::move(parts)});
  } else if (auto itv = get<IntersectionType>(there)) {
    std::vector<TypeId> options;
    for (TypeId part : itv)
      options.push_back(negate(part));
    return arena->addType(UnionType{std::move(options)});
  } else
    return there;
}

void Normalizer::subtractPrimitive(NormalizedType &here, TypeId ty) {
  const PrimitiveType *ptv = get<PrimitiveType>(follow(ty));
  LUAU_ASSERT(ptv);
  switch (ptv->type) {
  case PrimitiveType::NilType:
    here.nils = builtinTypes->neverType;
    break;
  case PrimitiveType::Boolean:
    here.booleans = builtinTypes->neverType;
    break;
  case PrimitiveType::Number:
    here.numbers = builtinTypes->neverType;
    break;
  case PrimitiveType::String:
    here.strings.resetToNever();
    break;
  case PrimitiveType::Thread:
    here.threads = builtinTypes->neverType;
    break;
  case PrimitiveType::Buffer:
    here.buffers = builtinTypes->neverType;
    break;
  case PrimitiveType::Function:
    here.functions.resetToNever();
    break;
  case PrimitiveType::Table:
    here.tables.clear();
    break;
  }
}

void Normalizer::subtractSingleton(NormalizedType &here, TypeId ty) {
  const SingletonType *stv = get<SingletonType>(ty);
  LUAU_ASSERT(stv);

  if (const StringSingleton *ss = get<StringSingleton>(stv)) {
    if (here.strings.isCofinite)
      here.strings.singletons.insert({ss->value, ty});
    else {
      auto it = here.strings.singletons.find(ss->value);
      if (it != here.strings.singletons.end())
        here.strings.singletons.erase(it);
    }
  } else if (const BooleanSingleton *bs = get<BooleanSingleton>(stv)) {
    if (get<NeverType>(here.booleans)) {
      // Nothing
    } else if (get<PrimitiveType>(here.booleans))
      here.booleans =
          bs->value ? builtinTypes->falseType : builtinTypes->trueType;
    else if (auto hereSingleton = get<SingletonType>(here.booleans)) {
      const BooleanSingleton *hereBooleanSingleton =
          get<BooleanSingleton>(hereSingleton);
      LUAU_ASSERT(hereBooleanSingleton);

      // Crucial subtlety: ty (and thus bs) are the value that is being
      // negated out. We therefore reduce to never when the values match,
      // rather than when they differ.
      if (bs->value == hereBooleanSingleton->value)
        here.booleans = builtinTypes->neverType;
    } else
      LUAU_ASSERT(!"Unreachable");
  } else
    LUAU_ASSERT(!"Unreachable");
}

// ------- Normalizing intersections
TypeId Normalizer::intersectionOfTops(TypeId here, TypeId there) {
  if (get<NeverType>(here) || get<AnyType>(there))
    return here;
  else
    return there;
}

TypeId Normalizer::intersectionOfBools(TypeId here, TypeId there) {
  if (get<NeverType>(here))
    return here;
  if (get<NeverType>(there))
    return there;
  if (const BooleanSingleton *hbool =
          get<BooleanSingleton>(get<SingletonType>(here)))
    if (const BooleanSingleton *tbool =
            get<BooleanSingleton>(get<SingletonType>(there)))
      return (hbool->value == tbool->value ? here : builtinTypes->neverType);
    else
      return here;
  else
    return there;
}

void Normalizer::intersectClasses(NormalizedClassType &heres,
                                  const NormalizedClassType &theres) {
  if (theres.isNever()) {
    heres.resetToNever();
    return;
  } else if (isTop(builtinTypes, theres)) {
    return;
  }

  // For intersections of two distinct class sets, we must normalize to a map
  // where, for each entry, one of the following is true:
  // - The class is the superclass of all other classes in the map
  // - The class is a subclass of another class B in the map _and_ a subclass
  //   of one of B's negations.
  //
  // Once we have identified the common superclass, we proceed down the list
  // of class types. For each class and negation pair in the incoming set, we
  // check each entry in the current set.
  // - If the incoming class is exactly identical to a class in the current
  //   set, we union the negations together and move on.
  // - If the incoming class is a subclass of a class in the current set, we
  //   replace the current class with the incoming class. We keep negations
  //   that are a subclass of the incoming class, and discard ones that
  //   aren't.
  // - If the incoming class is a superclass of a class in the current set, we
  //   take the negations that are a subclass of the current class and union
  //   them with the negations for the current class.
  // - If the incoming class is unrelated to any class in the current set, we
  //   declare the result of the intersection operation to be never.
  for (const TypeId thereTy : theres.ordering) {
    const TypeIds &thereNegations = theres.classes.at(thereTy);

    for (auto it = heres.ordering.begin(); it != heres.ordering.end();) {
      TypeId hereTy = *it;
      TypeIds &hereNegations = heres.classes.at(hereTy);

      if (isSubclass(thereTy, hereTy)) {
        TypeIds negations = std::move(hereNegations);

        for (auto nIt = negations.begin(); nIt != negations.end();) {
          if (!isSubclass(*nIt, thereTy)) {
            nIt = negations.erase(nIt);
          } else {
            ++nIt;
          }
        }

        unionClasses(negations, thereNegations);

        it = heres.ordering.erase(it);
        heres.classes.erase(hereTy);
        heres.pushPair(thereTy, std::move(negations));
        break;
      } else if (isSubclass(hereTy, thereTy)) {
        TypeIds negations = thereNegations;

        for (auto nIt = negations.begin(); nIt != negations.end();) {
          if (!isSubclass(*nIt, hereTy)) {
            nIt = negations.erase(nIt);
          } else {
            ++nIt;
          }
        }

        unionClasses(hereNegations, negations);
        break;
      } else if (hereTy == thereTy) {
        unionClasses(hereNegations, thereNegations);
        break;
      } else {
        it = heres.ordering.erase(it);
        heres.classes.erase(hereTy);
      }
    }
  }
}

void Normalizer::intersectClassesWithClass(NormalizedClassType &heres,
                                           TypeId there) {
  for (auto it = heres.ordering.begin(); it != heres.ordering.end();) {
    TypeId hereTy = *it;
    const TypeIds &hereNegations = heres.classes.at(hereTy);

    // If the incoming class _is_ the current class, we skip it. Maybe
    // another entry will have a different story. We check for this first
    // because isSubclass will be true if the types are equal, and entering
    // either of those branches below will trigger wrong behaviors.
    if (hereTy == there) {
      ++it;
    }
    // If the incoming class is a subclass of this type, we replace the
    // current class with the incoming class. We preserve negations that are
    // a subclass of the incoming class, and discard ones that aren't.
    else if (isSubclass(there, hereTy)) {
      TypeIds negations = std::move(hereNegations);

      for (auto nIt = negations.begin(); nIt != negations.end();) {
        if (!isSubclass(*nIt, there)) {
          nIt = negations.erase(nIt);
        } else {
          ++nIt;
        }
      }

      it = heres.ordering.erase(it);
      heres.classes.erase(hereTy);
      heres.pushPair(there, std::move(negations));
      break;
    }
    // If the incoming class is a superclass of the current class, we don't
    // insert it into the map.
    else if (isSubclass(hereTy, there)) {
      return;
    }
    // If the incoming class is completely unrelated to the current class,
    // we drop the current class from the map.
    else {
      it = heres.ordering.erase(it);
      heres.classes.erase(hereTy);
    }
  }
}

void Normalizer::intersectStrings(NormalizedStringType &here,
                                  const NormalizedStringType &there) {
  /* There are 9 cases to worry about here
       Normalized Left    | Normalized Right
     C1 string            | string              ===> trivial
     C2 string - {u_1,..} | string              ===> trivial
     C3 {u_1, ..}         | string              ===> trivial
     C4 string            | string - {v_1, ..}  ===> string - {v_1, ..}
     C5 string - {u_1,..} | string - {v_1, ..}  ===> string - ({u_s} U {v_s})
     C6 {u_1, ..}         | string - {v_1, ..}  ===> {u_s} - {v_s}
     C7 string            | {v_1, ..}           ===> {v_s}
     C8 string - {u_1,..} | {v_1, ..}           ===> {v_s} - {u_s}
     C9 {u_1, ..}         | {v_1, ..}           ===> {u_s}  {v_s}
  */
  // Case 1,2,3
  if (there.isString())
    return;
  // Case 4, Case 7
  else if (here.isString()) {
    here.singletons.clear();
    for (const auto &[key, type] : there.singletons)
      here.singletons[key] = type;
    here.isCofinite = here.isCofinite && there.isCofinite;
  }
  // Case 5
  else if (here.isIntersection() && there.isIntersection()) {
    here.isCofinite = true;
    for (const auto &[key, type] : there.singletons)
      here.singletons[key] = type;
  }
  // Case 6
  else if (here.isUnion() && there.isIntersection()) {
    here.isCofinite = false;
    for (const auto &[key, _] : there.singletons)
      here.singletons.erase(key);
  }
  // Case 8
  else if (here.isIntersection() && there.isUnion()) {
    here.isCofinite = false;
    std::map<std::string, TypeId> result(there.singletons);
    for (const auto &[key, _] : here.singletons)
      result.erase(key);
    here.singletons = result;
  }
  // Case 9
  else if (here.isUnion() && there.isUnion()) {
    here.isCofinite = false;
    std::map<std::string, TypeId> result;
    result.insert(here.singletons.begin(), here.singletons.end());
    result.insert(there.singletons.begin(), there.singletons.end());
    for (auto it = result.begin(); it != result.end();)
      if (!here.singletons.count(it->first) ||
          !there.singletons.count(it->first))
        it = result.erase(it);
      else
        ++it;
    here.singletons = result;
  } else
    LUAU_ASSERT(0 && "Internal Error - unrecognized case");
}

std::optional<TypePackId>
Normalizer::intersectionOfTypePacks(TypePackId here, TypePackId there) {
  if (here == there)
    return here;

  std::vector<TypeId> head;
  std::optional<TypePackId> tail;

  bool hereSubThere = true;
  bool thereSubHere = true;

  TypePackIterator ith = begin(here);
  TypePackIterator itt = begin(there);

  while (ith != end(here) && itt != end(there)) {
    TypeId hty = *ith;
    TypeId tty = *itt;
    TypeId ty = intersectionType(hty, tty);
    if (ty != hty)
      hereSubThere = false;
    if (ty != tty)
      thereSubHere = false;
    head.push_back(ty);
    ith++;
    itt++;
  }

  auto dealWithDifferentArities =
      [&](TypePackIterator &ith, TypePackIterator itt, TypePackId here,
          TypePackId there, bool &hereSubThere, bool &thereSubHere) {
        if (ith != end(here)) {
          TypeId tty = builtinTypes->nilType;
          if (std::optional<TypePackId> ttail = itt.tail()) {
            if (const VariadicTypePack *tvtp = get<VariadicTypePack>(*ttail))
              tty = tvtp->ty;
            else
              // Luau doesn't have intersections of type pack variables
              return false;
          } else
            // Type packs of different arities are incomparable
            return false;

          while (ith != end(here)) {
            TypeId hty = *ith;
            TypeId ty = intersectionType(hty, tty);
            if (ty != hty)
              hereSubThere = false;
            if (ty != tty)
              thereSubHere = false;
            head.push_back(ty);
            ith++;
          }
        }
        return true;
      };

  if (!dealWithDifferentArities(ith, itt, here, there, hereSubThere,
                                thereSubHere))
    return std::nullopt;

  if (!dealWithDifferentArities(itt, ith, there, here, thereSubHere,
                                hereSubThere))
    return std::nullopt;

  if (std::optional<TypePackId> htail = ith.tail()) {
    if (std::optional<TypePackId> ttail = itt.tail()) {
      if (*htail == *ttail)
        tail = htail;
      else if (const VariadicTypePack *hvtp = get<VariadicTypePack>(*htail)) {
        if (const VariadicTypePack *tvtp = get<VariadicTypePack>(*ttail)) {
          TypeId ty = intersectionType(hvtp->ty, tvtp->ty);
          if (ty != hvtp->ty)
            thereSubHere = false;
          if (ty != tvtp->ty)
            hereSubThere = false;
          bool hidden = hvtp->hidden & tvtp->hidden;
          tail = arena->addTypePack(VariadicTypePack{ty, hidden});
        } else
          // Luau doesn't have unions of type pack variables
          return std::nullopt;
      } else
        // Luau doesn't have unions of type pack variables
        return std::nullopt;
    } else if (get<VariadicTypePack>(*htail))
      hereSubThere = false;
    else
      // Luau doesn't have unions of type pack variables
      return std::nullopt;
  } else if (std::optional<TypePackId> ttail = itt.tail()) {
    if (get<VariadicTypePack>(*ttail))
      thereSubHere = false;
    else
      // Luau doesn't have unions of type pack variables
      return std::nullopt;
  }

  if (hereSubThere)
    return here;
  else if (thereSubHere)
    return there;
  if (!head.empty())
    return arena->addTypePack(TypePack{head, tail});
  else if (tail)
    return *tail;
  else
    // TODO: Add an emptyPack to singleton types
    return arena->addTypePack({});
}

std::optional<TypeId> Normalizer::intersectionOfTables(TypeId here,
                                                       TypeId there,
                                                       Set<TypeId> &seenSet) {
  if (here == there)
    return here;

  RecursionCounter _rc(&sharedState->counters.recursionCount);
  if (sharedState->counters.recursionLimit > 0 &&
      sharedState->counters.recursionLimit <
          sharedState->counters.recursionCount)
    return std::nullopt;

  if (isPrim(here, PrimitiveType::Table))
    return there;
  else if (isPrim(there, PrimitiveType::Table))
    return here;

  if (get<NeverType>(here))
    return there;
  else if (get<NeverType>(there))
    return here;
  else if (get<AnyType>(here))
    return there;
  else if (get<AnyType>(there))
    return here;

  TypeId htable = here;
  TypeId hmtable = nullptr;
  if (const MetatableType *hmtv = get<MetatableType>(here)) {
    htable = follow(hmtv->table);
    hmtable = follow(hmtv->metatable);
  }
  TypeId ttable = there;
  TypeId tmtable = nullptr;
  if (const MetatableType *tmtv = get<MetatableType>(there)) {
    ttable = follow(tmtv->table);
    tmtable = follow(tmtv->metatable);
  }

  const TableType *httv = get<TableType>(htable);
  if (!httv)
    return std::nullopt;

  const TableType *tttv = get<TableType>(ttable);
  if (!tttv)
    return std::nullopt;

  if (httv->state == TableState::Free || tttv->state == TableState::Free)
    return std::nullopt;
  if (httv->state == TableState::Generic || tttv->state == TableState::Generic)
    return std::nullopt;

  TableState state = httv->state;
  if (tttv->state == TableState::Unsealed)
    state = tttv->state;

  TypeLevel level = max(httv->level, tttv->level);
  Scope *scope = max(httv->scope, tttv->scope);

  std::unique_ptr<TableType> result = nullptr;
  bool hereSubThere = true;
  bool thereSubHere = true;

  for (const auto &[name, hprop] : httv->props) {
    Property prop = hprop;
    auto tfound = tttv->props.find(name);
    if (tfound == tttv->props.end())
      thereSubHere = false;
    else {
      const auto &[_name, tprop] = *tfound;
      // TODO: variance issues here, which can't be fixed until we have
      // read/write property types
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        if (hprop.readTy.has_value()) {
          if (tprop.readTy.has_value()) {
            // if the intersection of the read types of a property is
            // uninhabited, the whole table is `never`.
            if (fixReduceStackPressure()) {
              // We've seen these table prop elements before and we're about to
              // ask if their intersection is inhabited
              if (fixCyclicTablesBlowingStack()) {
                if (seenSet.contains(*hprop.readTy) &&
                    seenSet.contains(*tprop.readTy)) {
                  seenSet.erase(*hprop.readTy);
                  seenSet.erase(*tprop.readTy);
                  return {builtinTypes->neverType};
                } else {
                  seenSet.insert(*hprop.readTy);
                  seenSet.insert(*tprop.readTy);
                }
              }

              NormalizationResult res = isIntersectionInhabited(
                  *hprop.readTy, *tprop.readTy, seenSet);

              // Cleanup
              if (fixCyclicTablesBlowingStack()) {
                seenSet.erase(*hprop.readTy);
                seenSet.erase(*tprop.readTy);
              }

              if (normalizeAwayUninhabitableTables() &&
                  NormalizationResult::True != res)
                return {builtinTypes->neverType};
            } else {
              if (normalizeAwayUninhabitableTables() &&
                  NormalizationResult::False ==
                      isIntersectionInhabited(*hprop.readTy, *tprop.readTy))
                return {builtinTypes->neverType};
            }

            TypeId ty = simplifyIntersection(builtinTypes, NotNull{arena},
                                             *hprop.readTy, *tprop.readTy)
                            .result;
            prop.readTy = ty;
            hereSubThere &= (ty == hprop.readTy);
            thereSubHere &= (ty == tprop.readTy);
          } else {
            prop.readTy = *hprop.readTy;
            thereSubHere = false;
          }
        } else if (tprop.readTy.has_value()) {
          prop.readTy = *tprop.readTy;
          hereSubThere = false;
        }

        if (hprop.writeTy.has_value()) {
          if (tprop.writeTy.has_value()) {
            prop.writeTy = simplifyIntersection(builtinTypes, NotNull{arena},
                                                *hprop.writeTy, *tprop.writeTy)
                               .result;
            hereSubThere &= (prop.writeTy == hprop.writeTy);
            thereSubHere &= (prop.writeTy == tprop.writeTy);
          } else {
            prop.writeTy = *hprop.writeTy;
            thereSubHere = false;
          }
        } else if (tprop.writeTy.has_value()) {
          prop.writeTy = *tprop.writeTy;
          hereSubThere = false;
        }
      } else {
        prop.setType(intersectionType(hprop.type(), tprop.type()));
        hereSubThere &= (prop.type() == hprop.type());
        thereSubHere &= (prop.type() == tprop.type());
      }
    }

    // TODO: string indexers

    if (prop.readTy || prop.writeTy) {
      if (!result.get())
        result = std::make_unique<TableType>(TableType{state, level, scope});
      result->props[name] = prop;
    }
  }

  for (const auto &[name, tprop] : tttv->props) {
    if (httv->props.count(name) == 0) {
      if (!result.get())
        result = std::make_unique<TableType>(TableType{state, level, scope});

      result->props[name] = tprop;
      hereSubThere = false;
    }
  }

  if (httv->indexer && tttv->indexer) {
    // TODO: What should intersection of indexes be?
    TypeId index =
        unionType(httv->indexer->indexType, tttv->indexer->indexType);
    TypeId indexResult = intersectionType(httv->indexer->indexResultType,
                                          tttv->indexer->indexResultType);
    if (!result.get())
      result = std::make_unique<TableType>(TableType{state, level, scope});
    result->indexer = {index, indexResult};
    hereSubThere &= (httv->indexer->indexType == index) &&
                    (httv->indexer->indexResultType == indexResult);
    thereSubHere &= (tttv->indexer->indexType == index) &&
                    (tttv->indexer->indexResultType == indexResult);
  } else if (httv->indexer) {
    if (!result.get())
      result = std::make_unique<TableType>(TableType{state, level, scope});
    result->indexer = httv->indexer;
    thereSubHere = false;
  } else if (tttv->indexer) {
    if (!result.get())
      result = std::make_unique<TableType>(TableType{state, level, scope});
    result->indexer = tttv->indexer;
    hereSubThere = false;
  }

  TypeId table;
  if (hereSubThere)
    table = htable;
  else if (thereSubHere)
    table = ttable;
  else {
    if (result.get())
      table = arena->addType(std::move(*result));
    else
      table = arena->addType(TableType{state, level, scope});
  }

  if (tmtable && hmtable) {
    // NOTE: this assumes metatables are ivariant
    if (std::optional<TypeId> mtable =
            intersectionOfTables(hmtable, tmtable, seenSet)) {
      if (table == htable && *mtable == hmtable)
        return here;
      else if (table == ttable && *mtable == tmtable)
        return there;
      else
        return arena->addType(MetatableType{table, *mtable});
    } else
      return std::nullopt;
  } else if (hmtable) {
    if (table == htable)
      return here;
    else
      return arena->addType(MetatableType{table, hmtable});
  } else if (tmtable) {
    if (table == ttable)
      return there;
    else
      return arena->addType(MetatableType{table, tmtable});
  } else
    return table;
}

void Normalizer::intersectTablesWithTable(TypeIds &heres, TypeId there,
                                          Set<TypeId> &seenSetTypes) {
  TypeIds tmp;
  for (TypeId here : heres) {
    if (std::optional<TypeId> inter =
            intersectionOfTables(here, there, seenSetTypes))
      tmp.insert(*inter);
  }
  heres.retain(tmp);
  heres.insert(tmp.begin(), tmp.end());
}

void Normalizer::intersectTables(TypeIds &heres, const TypeIds &theres) {
  TypeIds tmp;
  for (TypeId here : heres) {
    for (TypeId there : theres) {
      Set<TypeId> seenSetTypes{nullptr};
      if (std::optional<TypeId> inter =
              intersectionOfTables(here, there, seenSetTypes))
        tmp.insert(*inter);
    }
  }

  heres.retain(tmp);
  heres.insert(tmp.begin(), tmp.end());
}

std::optional<TypeId> Normalizer::intersectionOfFunctions(TypeId here,
                                                          TypeId there) {
  const FunctionType *hftv = get<FunctionType>(here);
  LUAU_ASSERT(hftv);
  const FunctionType *tftv = get<FunctionType>(there);
  LUAU_ASSERT(tftv);

  if (hftv->generics != tftv->generics)
    return std::nullopt;
  if (hftv->genericPacks != tftv->genericPacks)
    return std::nullopt;

  TypePackId argTypes;
  TypePackId retTypes;

  if (hftv->retTypes == tftv->retTypes) {
    std::optional<TypePackId> argTypesOpt =
        unionOfTypePacks(hftv->argTypes, tftv->argTypes);
    if (!argTypesOpt)
      return std::nullopt;
    argTypes = *argTypesOpt;
    retTypes = hftv->retTypes;
  } else if (hftv->argTypes == tftv->argTypes) {
    std::optional<TypePackId> retTypesOpt =
        intersectionOfTypePacks(hftv->argTypes, tftv->argTypes);
    if (!retTypesOpt)
      return std::nullopt;
    argTypes = hftv->argTypes;
    retTypes = *retTypesOpt;
  } else
    return std::nullopt;

  if (argTypes == hftv->argTypes && retTypes == hftv->retTypes)
    return here;
  if (argTypes == tftv->argTypes && retTypes == tftv->retTypes)
    return there;

  FunctionType result{argTypes, retTypes};
  result.generics = hftv->generics;
  result.genericPacks = hftv->genericPacks;
  return arena->addType(std::move(result));
}

std::optional<TypeId> Normalizer::unionSaturatedFunctions(TypeId here,
                                                          TypeId there) {
  // Deep breath...
  //
  // When we come to check overloaded functions for subtyping,
  // we have to compare (F1 & ... & FM) <: (G1 & ... G GN)
  // where each Fi or Gj is a function type. Now that intersection on the right
  // is no problem, since that's true if and only if (F1 & ... & FM) <: Gj for
  // every j. But the intersection on the left is annoying, since we might have
  // (F1 & ... & FM) <: G but no Fi <: G.  For example
  //
  //   ((number? -> number?) & (string? -> string?)) <: (nil -> nil)
  //
  // So in this case, what we do is define Apply<F, T> for the result of
  // applying a function of type F to an argument of type T, and then F <: (T ->
  // U) if and only if Apply<F, T> <: U. For example:
  //
  //   if f : ((number? -> number?) & (string? -> string?))
  //   then f(nil) must be nil, so
  //   Apply<((number? -> number?) & (string? -> string?)), nil> is nil
  //
  // So subtyping on overloaded functions "just" boils down to defining Apply<F,
  // T>.
  //
  // Now for non-overloaded functions, this is easy!
  // Apply<(R -> S), T> is S if T <: R, and an error type otherwise.
  //
  // But for overloaded functions it's not so simple. We'd like Apply<F1 & ... &
  // FM, T> to just be Apply<F1, T> & ... & Apply<FM, T> but oh dear
  //
  //   if f : ((number -> number) & (string -> string))
  //   and x : (number | string)
  //   then f(x) : (number | string)
  //
  // so we want
  //
  //   Apply<((number -> number) & (string -> string)), (number | string)> is
  //   (number | string)
  //
  // but
  //
  //   Apply<(number -> number), (number | string)> is an error
  //   Apply<(string -> string), (number | string)> is an error
  //
  // that is Apply<F, T> should consider all possible combinations of overloads
  // of F, not just individual overloads.
  //
  // For this reason, when we're normalizing function types (in order to check
  // subtyping or perform overload resolution) we should first *union-saturate*
  // them. An overloaded function is union-saturated whenever:
  //
  //    if (R -> S) is an overload of F
  //    and (T -> U) is an overload of F
  //    then ((R | T) -> (S | U)) is a subtype of an overload of F
  //
  // Any overloaded function can be normalized to a union-saturated one by
  // adding enough extra overloads. For example, union-saturating
  //
  //   ((number -> number) & (string -> string))
  //
  // is
  //
  //   ((number -> number) & (string -> string) & ((number | string) -> (number
  //   | string)))
  //
  // For union-saturated overloaded functions, the "obvious" algorithm works:
  //
  //   Apply<F1 & ... & FM, T>  is   Apply<F1, T> & ... & Apply<FM, T>
  //
  // so we can define Apply, so we can perform overloaded function resolution
  // and check subtyping on overloaded function types, yay!
  //
  // This is yet another potential source of exponential blow-up, sigh, since
  // the union-saturation of a function with N overloads may have 2^N overloads
  // (one for every subset). In practice, that hopefully won't happen that
  // often, in particular we only union-saturate overloads with different return
  // types, and there are hopefully not very many cases of that.
  //
  // All of this is mechanically verified in Agda, at
  // https://github.com/luau-lang/agda-typeck
  //
  // It is essentially the algorithm defined in
  // https://pnwamk.github.io/sst-tutorial/ except that we're precomputing the
  // union-saturation rather than converting to disjunctive normal form on the
  // fly.
  //
  // This is all built on semantic subtyping:
  //
  //   Covariance and Contravariance, Giuseppe Castagna,
  //   Logical Methods in Computer Science 16(1), 2022
  //   https://arxiv.org/abs/1809.01427
  //
  //   A gentle introduction to semantic subtyping, Giuseppe Castagna and Alain
  //   Frisch, Proc. Principles and practice of declarative programming 2005, pp
  //   198208 https://doi.org/10.1145/1069774.1069793

  const FunctionType *hftv = get<FunctionType>(here);
  if (!hftv)
    return std::nullopt;
  const FunctionType *tftv = get<FunctionType>(there);
  if (!tftv)
    return std::nullopt;

  if (hftv->generics != tftv->generics)
    return std::nullopt;
  if (hftv->genericPacks != tftv->genericPacks)
    return std::nullopt;

  std::optional<TypePackId> argTypes =
      unionOfTypePacks(hftv->argTypes, tftv->argTypes);
  if (!argTypes)
    return std::nullopt;
  std::optional<TypePackId> retTypes =
      unionOfTypePacks(hftv->retTypes, tftv->retTypes);
  if (!retTypes)
    return std::nullopt;

  FunctionType result{*argTypes, *retTypes};
  result.generics = hftv->generics;
  result.genericPacks = hftv->genericPacks;
  return arena->addType(std::move(result));
}

void Normalizer::intersectFunctionsWithFunction(NormalizedFunctionType &heres,
                                                TypeId there) {
  if (heres.isNever())
    return;

  heres.isTop = false;

  for (auto it = heres.parts.begin(); it != heres.parts.end();) {
    TypeId here = *it;
    if (get<ErrorType>(here))
      it++;
    else if (std::optional<TypeId> tmp = intersectionOfFunctions(here, there)) {
      heres.parts.erase(it);
      heres.parts.insert(*tmp);
      return;
    } else
      it++;
  }

  TypeIds tmps;
  for (TypeId here : heres.parts) {
    if (std::optional<TypeId> tmp = unionSaturatedFunctions(here, there))
      tmps.insert(*tmp);
  }
  heres.parts.insert(there);
  heres.parts.insert(tmps.begin(), tmps.end());
}

void Normalizer::intersectFunctions(NormalizedFunctionType &heres,
                                    const NormalizedFunctionType &theres) {
  if (heres.isNever())
    return;
  else if (theres.isNever()) {
    heres.resetToNever();
    return;
  } else {
    for (TypeId there : theres.parts)
      intersectFunctionsWithFunction(heres, there);
  }
}

NormalizationResult
Normalizer::intersectTyvarsWithTy(NormalizedTyvars &here, TypeId there,
                                  Set<TypeId> &seenSetTypes) {
  for (auto it = here.begin(); it != here.end();) {
    NormalizedType &inter = *it->second;
    NormalizationResult res = intersectNormalWithTy(inter, there, seenSetTypes);
    if (res != NormalizationResult::True)
      return res;
    if (isShallowInhabited(inter))
      ++it;
    else
      it = here.erase(it);
  }
  return NormalizationResult::True;
}

// See above for an explaination of `ignoreSmallerTyvars`.
NormalizationResult Normalizer::intersectNormals(NormalizedType &here,
                                                 const NormalizedType &there,
                                                 int ignoreSmallerTyvars) {
  if (!get<NeverType>(there.tops)) {
    here.tops = intersectionOfTops(here.tops, there.tops);
    return NormalizationResult::True;
  } else if (!get<NeverType>(here.tops)) {
    clearNormal(here);
    return unionNormals(here, there, ignoreSmallerTyvars);
  }

  here.booleans = intersectionOfBools(here.booleans, there.booleans);

  intersectClasses(here.classes, there.classes);
  here.errors = (get<NeverType>(there.errors) ? there.errors : here.errors);
  here.nils = (get<NeverType>(there.nils) ? there.nils : here.nils);
  here.numbers = (get<NeverType>(there.numbers) ? there.numbers : here.numbers);
  intersectStrings(here.strings, there.strings);
  here.threads = (get<NeverType>(there.threads) ? there.threads : here.threads);
  here.buffers = (get<NeverType>(there.buffers) ? there.buffers : here.buffers);
  intersectFunctions(here.functions, there.functions);
  intersectTables(here.tables, there.tables);

  for (auto &[tyvar, inter] : there.tyvars) {
    int index = tyvarIndex(tyvar);
    if (ignoreSmallerTyvars < index) {
      auto [found, fresh] = here.tyvars.emplace(
          tyvar,
          std::make_unique<NormalizedType>(NormalizedType{builtinTypes}));
      if (fresh) {
        NormalizationResult res = unionNormals(*found->second, here, index);
        if (res != NormalizationResult::True)
          return res;
      }
    }
  }
  for (auto it = here.tyvars.begin(); it != here.tyvars.end();) {
    TypeId tyvar = it->first;
    NormalizedType &inter = *it->second;
    int index = tyvarIndex(tyvar);
    LUAU_ASSERT(ignoreSmallerTyvars < index);
    auto found = there.tyvars.find(tyvar);
    if (found == there.tyvars.end()) {
      NormalizationResult res = intersectNormals(inter, there, index);
      if (res != NormalizationResult::True)
        return res;
    } else {
      NormalizationResult res = intersectNormals(inter, *found->second, index);
      if (res != NormalizationResult::True)
        return res;
    }
    if (isShallowInhabited(inter))
      it++;
    else
      it = here.tyvars.erase(it);
  }
  return NormalizationResult::True;
}

NormalizationResult
Normalizer::intersectNormalWithTy(NormalizedType &here, TypeId there,
                                  Set<TypeId> &seenSetTypes) {
  RecursionCounter _rc(&sharedState->counters.recursionCount);
  if (!withinResourceLimits())
    return NormalizationResult::HitLimits;

  there = follow(there);

  if (get<AnyType>(there) || get<UnknownType>(there)) {
    here.tops = intersectionOfTops(here.tops, there);
    return NormalizationResult::True;
  } else if (!get<NeverType>(here.tops)) {
    clearNormal(here);
    return unionNormalWithTy(here, there, seenSetTypes);
  } else if (const UnionType *utv = get<UnionType>(there)) {
    NormalizedType norm{builtinTypes};
    for (UnionTypeIterator it = begin(utv); it != end(utv); ++it) {
      NormalizationResult res = unionNormalWithTy(norm, *it, seenSetTypes);
      if (res != NormalizationResult::True)
        return res;
    }
    return intersectNormals(here, norm);
  } else if (const IntersectionType *itv = get<IntersectionType>(there)) {
    for (IntersectionTypeIterator it = begin(itv); it != end(itv); ++it) {
      NormalizationResult res = intersectNormalWithTy(here, *it, seenSetTypes);
      if (res != NormalizationResult::True)
        return res;
    }
    return NormalizationResult::True;
  } else if (get<GenericType>(there) || get<FreeType>(there) ||
             get<BlockedType>(there) || get<PendingExpansionType>(there) ||
             get<TypeFunctionInstanceType>(there)) {
    NormalizedType thereNorm{builtinTypes};
    NormalizedType topNorm{builtinTypes};
    topNorm.tops = builtinTypes->unknownType;
    thereNorm.tyvars.insert_or_assign(
        there, std::make_unique<NormalizedType>(std::move(topNorm)));
    here.isCacheable = false;
    return intersectNormals(here, thereNorm);
  }

  NormalizedTyvars tyvars = std::move(here.tyvars);

  if (const FunctionType *utv = get<FunctionType>(there)) {
    NormalizedFunctionType functions = std::move(here.functions);
    clearNormal(here);
    intersectFunctionsWithFunction(functions, there);
    here.functions = std::move(functions);
  } else if (get<TableType>(there) || get<MetatableType>(there)) {
    TypeIds tables = std::move(here.tables);
    clearNormal(here);
    intersectTablesWithTable(tables, there, seenSetTypes);
    here.tables = std::move(tables);
  } else if (get<ClassType>(there)) {
    NormalizedClassType nct = std::move(here.classes);
    clearNormal(here);
    intersectClassesWithClass(nct, there);
    here.classes = std::move(nct);
  } else if (get<ErrorType>(there)) {
    TypeId errors = here.errors;
    clearNormal(here);
    here.errors = errors;
  } else if (const PrimitiveType *ptv = get<PrimitiveType>(there)) {
    TypeId booleans = here.booleans;
    TypeId nils = here.nils;
    TypeId numbers = here.numbers;
    NormalizedStringType strings = std::move(here.strings);
    NormalizedFunctionType functions = std::move(here.functions);
    TypeId threads = here.threads;
    TypeId buffers = here.buffers;
    TypeIds tables = std::move(here.tables);

    clearNormal(here);

    if (ptv->type == PrimitiveType::Boolean)
      here.booleans = booleans;
    else if (ptv->type == PrimitiveType::NilType)
      here.nils = nils;
    else if (ptv->type == PrimitiveType::Number)
      here.numbers = numbers;
    else if (ptv->type == PrimitiveType::String)
      here.strings = std::move(strings);
    else if (ptv->type == PrimitiveType::Thread)
      here.threads = threads;
    else if (ptv->type == PrimitiveType::Buffer)
      here.buffers = buffers;
    else if (ptv->type == PrimitiveType::Function)
      here.functions = std::move(functions);
    else if (ptv->type == PrimitiveType::Table)
      here.tables = std::move(tables);
    else
      LUAU_ASSERT(!"Unreachable");
  } else if (const SingletonType *stv = get<SingletonType>(there)) {
    TypeId booleans = here.booleans;
    NormalizedStringType strings = std::move(here.strings);

    clearNormal(here);

    if (get<BooleanSingleton>(stv))
      here.booleans = intersectionOfBools(booleans, there);
    else if (const StringSingleton *sstv = get<StringSingleton>(stv)) {
      if (strings.includes(sstv->value))
        here.strings.singletons.insert({sstv->value, there});
    } else
      LUAU_ASSERT(!"Unreachable");
  } else if (const NegationType *ntv = get<NegationType>(there)) {
    TypeId t = follow(ntv->ty);
    if (const PrimitiveType *ptv = get<PrimitiveType>(t))
      subtractPrimitive(here, ntv->ty);
    else if (const SingletonType *stv = get<SingletonType>(t))
      subtractSingleton(here, follow(ntv->ty));
    else if (get<ClassType>(t)) {
      NormalizationResult res = intersectNormalWithNegationTy(t, here);
      if (shouldEarlyExit(res))
        return res;
    } else if (const UnionType *itv = get<UnionType>(t)) {
      for (TypeId part : itv->options) {
        NormalizationResult res = intersectNormalWithNegationTy(part, here);
        if (shouldEarlyExit(res))
          return res;
      }
    } else if (get<AnyType>(t)) {
      // HACK: Refinements sometimes intersect with ~any under the
      // assumption that it is the same as any.
      return NormalizationResult::True;
    } else if (get<NeverType>(t)) {
      // if we're intersecting with `~never`, this is equivalent to intersecting
      // with `unknown` this is a noop since an intersection with `unknown` is
      // trivial.
      return NormalizationResult::True;
    } else if ((FFlag::LuauNormalizeNotUnknownIntersection ||
                FFlag::DebugLuauDeferredConstraintResolution) &&
               get<UnknownType>(t)) {
      // if we're intersecting with `~unknown`, this is equivalent to
      // intersecting with `never` this means we should clear the type entirely.
      clearNormal(here);
      return NormalizationResult::True;
    } else if (auto nt = get<NegationType>(t))
      return intersectNormalWithTy(here, nt->ty, seenSetTypes);
    else {
      // TODO negated unions, intersections, table, and function.
      // Report a TypeError for other types.
      LUAU_ASSERT(!"Unimplemented");
    }
  } else if (get<NeverType>(there)) {
    here.classes.resetToNever();
  } else
    LUAU_ASSERT(!"Unreachable");

  NormalizationResult res = intersectTyvarsWithTy(tyvars, there, seenSetTypes);
  if (res != NormalizationResult::True)
    return res;
  here.tyvars = std::move(tyvars);

  return NormalizationResult::True;
}

void makeTableShared(TypeId ty) {
  ty = follow(ty);
  if (auto tableTy = getMutable<TableType>(ty)) {
    for (auto &[_, prop] : tableTy->props)
      prop.makeShared();
  } else if (auto metatableTy = get<MetatableType>(ty)) {
    makeTableShared(metatableTy->metatable);
    makeTableShared(metatableTy->table);
  }
}

// -------- Convert back from a normalized type to a type
TypeId Normalizer::typeFromNormal(const NormalizedType &norm) {
  assertInvariant(norm);
  if (!get<NeverType>(norm.tops))
    return norm.tops;

  std::vector<TypeId> result;

  if (!get<NeverType>(norm.booleans))
    result.push_back(norm.booleans);

  if (isTop(builtinTypes, norm.classes)) {
    result.push_back(builtinTypes->classType);
  } else if (!norm.classes.isNever()) {
    std::vector<TypeId> parts;
    parts.reserve(norm.classes.classes.size());

    for (const TypeId normTy : norm.classes.ordering) {
      const TypeIds &normNegations = norm.classes.classes.at(normTy);

      if (normNegations.empty()) {
        parts.push_back(normTy);
      } else {
        std::vector<TypeId> intersection;
        intersection.reserve(normNegations.size() + 1);

        intersection.push_back(normTy);
        for (TypeId negation : normNegations) {
          intersection.push_back(arena->addType(NegationType{negation}));
        }

        parts.push_back(
            arena->addType(IntersectionType{std::move(intersection)}));
      }
    }

    if (parts.size() == 1) {
      result.push_back(parts.at(0));
    } else if (parts.size() > 1) {
      result.push_back(arena->addType(UnionType{std::move(parts)}));
    }
  }

  if (!get<NeverType>(norm.errors))
    result.push_back(norm.errors);
  if (norm.functions.isTop)
    result.push_back(builtinTypes->functionType);
  else if (!norm.functions.isNever()) {
    if (norm.functions.parts.size() == 1)
      result.push_back(*norm.functions.parts.begin());
    else {
      std::vector<TypeId> parts;
      parts.insert(parts.end(), norm.functions.parts.begin(),
                   norm.functions.parts.end());
      result.push_back(arena->addType(IntersectionType{std::move(parts)}));
    }
  }
  if (!get<NeverType>(norm.nils))
    result.push_back(norm.nils);
  if (!get<NeverType>(norm.numbers))
    result.push_back(norm.numbers);
  if (norm.strings.isString())
    result.push_back(builtinTypes->stringType);
  else if (norm.strings.isUnion()) {
    for (auto &[_, ty] : norm.strings.singletons)
      result.push_back(ty);
  } else if (norm.strings.isIntersection()) {
    std::vector<TypeId> parts;
    parts.push_back(builtinTypes->stringType);
    for (const auto &[name, ty] : norm.strings.singletons)
      parts.push_back(arena->addType(NegationType{ty}));

    result.push_back(arena->addType(IntersectionType{std::move(parts)}));
  }
  if (!get<NeverType>(norm.threads))
    result.push_back(builtinTypes->threadType);
  if (!get<NeverType>(norm.buffers))
    result.push_back(builtinTypes->bufferType);

  if (FFlag::DebugLuauDeferredConstraintResolution) {
    result.reserve(result.size() + norm.tables.size());
    for (auto table : norm.tables) {
      makeTableShared(table);
      result.push_back(table);
    }
  } else
    result.insert(result.end(), norm.tables.begin(), norm.tables.end());

  for (auto &[tyvar, intersect] : norm.tyvars) {
    if (get<NeverType>(intersect->tops)) {
      TypeId ty = typeFromNormal(*intersect);
      result.push_back(arena->addType(IntersectionType{{tyvar, ty}}));
    } else
      result.push_back(tyvar);
  }

  if (result.size() == 0)
    return builtinTypes->neverType;
  else if (result.size() == 1)
    return result[0];
  else
    return arena->addType(UnionType{std::move(result)});
}

bool isSubtype(TypeId subTy, TypeId superTy, NotNull<Scope> scope,
               NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter &ice) {
  UnifierSharedState sharedState{&ice};
  TypeArena arena;
  Normalizer normalizer{&arena, builtinTypes, NotNull{&sharedState}};

  // Subtyping under DCR is not implemented using unification!
  if (FFlag::DebugLuauDeferredConstraintResolution) {
    Subtyping subtyping{builtinTypes, NotNull{&arena}, NotNull{&normalizer},
                        NotNull{&ice}, scope};

    return subtyping.isSubtype(subTy, superTy).isSubtype;
  } else {
    Unifier u{NotNull{&normalizer}, scope, Location{}, Covariant};

    u.tryUnify(subTy, superTy);
    return !u.failure;
  }
}

bool isSubtype(TypePackId subPack, TypePackId superPack, NotNull<Scope> scope,
               NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter &ice) {
  UnifierSharedState sharedState{&ice};
  TypeArena arena;
  Normalizer normalizer{&arena, builtinTypes, NotNull{&sharedState}};

  // Subtyping under DCR is not implemented using unification!
  if (FFlag::DebugLuauDeferredConstraintResolution) {
    Subtyping subtyping{builtinTypes, NotNull{&arena}, NotNull{&normalizer},
                        NotNull{&ice}, scope};

    return subtyping.isSubtype(subPack, superPack).isSubtype;
  } else {
    Unifier u{NotNull{&normalizer}, scope, Location{}, Covariant};

    u.tryUnify(subPack, superPack);
    return !u.failure;
  }
}

bool isConsistentSubtype(TypeId subTy, TypeId superTy, NotNull<Scope> scope,
                         NotNull<BuiltinTypes> builtinTypes,
                         InternalErrorReporter &ice) {
  LUAU_ASSERT(!FFlag::DebugLuauDeferredConstraintResolution);

  UnifierSharedState sharedState{&ice};
  TypeArena arena;
  Normalizer normalizer{&arena, builtinTypes, NotNull{&sharedState}};
  Unifier u{NotNull{&normalizer}, scope, Location{}, Covariant};

  u.tryUnify(subTy, superTy);
  const bool ok = u.errors.empty() && u.log.empty();
  return ok;
}

bool isConsistentSubtype(TypePackId subPack, TypePackId superPack,
                         NotNull<Scope> scope,
                         NotNull<BuiltinTypes> builtinTypes,
                         InternalErrorReporter &ice) {
  LUAU_ASSERT(!FFlag::DebugLuauDeferredConstraintResolution);

  UnifierSharedState sharedState{&ice};
  TypeArena arena;
  Normalizer normalizer{&arena, builtinTypes, NotNull{&sharedState}};
  Unifier u{NotNull{&normalizer}, scope, Location{}, Covariant};

  u.tryUnify(subPack, superPack);
  const bool ok = u.errors.empty() && u.log.empty();
  return ok;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Quantify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

LUAU_FASTFLAG(DebugLuauSharedSelf)

namespace Luau {

struct Quantifier final : TypeOnceVisitor {
  TypeLevel level;
  std::vector<TypeId> generics;
  std::vector<TypePackId> genericPacks;
  Scope *scope = nullptr;
  bool seenGenericType = false;
  bool seenMutableType = false;

  explicit Quantifier(TypeLevel level) : level(level) {}

  /// @return true if outer encloses inner
  bool subsumes(Scope *outer, Scope *inner) {
    while (inner) {
      if (inner == outer)
        return true;
      inner = inner->parent.get();
    }

    return false;
  }

  bool visit(TypeId ty, const FreeType &ftv) override {
    seenMutableType = true;

    if (!level.subsumes(ftv.level))
      return false;

    *asMutable(ty) = GenericType{level};

    generics.push_back(ty);

    return false;
  }

  bool visit(TypeId ty, const TableType &) override {
    LUAU_ASSERT(getMutable<TableType>(ty));
    TableType &ttv = *getMutable<TableType>(ty);

    if (ttv.state == TableState::Generic)
      seenGenericType = true;

    if (ttv.state == TableState::Free)
      seenMutableType = true;

    if (!level.subsumes(ttv.level)) {
      if (ttv.state == TableState::Unsealed)
        seenMutableType = true;
      return false;
    }

    if (ttv.state == TableState::Free) {
      ttv.state = TableState::Generic;
      seenGenericType = true;
    } else if (ttv.state == TableState::Unsealed)
      ttv.state = TableState::Sealed;

    ttv.level = level;

    return true;
  }

  bool visit(TypePackId tp, const FreeTypePack &ftp) override {
    seenMutableType = true;

    if (!level.subsumes(ftp.level))
      return false;

    *asMutable(tp) = GenericTypePack{level};
    genericPacks.push_back(tp);
    return true;
  }
};

void quantify(TypeId ty, TypeLevel level) {
  if (FFlag::DebugLuauSharedSelf) {
    ty = follow(ty);

    if (auto ttv = getTableType(ty); ttv && ttv->selfTy) {
      Quantifier selfQ{level};
      selfQ.traverse(*ttv->selfTy);

      Quantifier q{level};
      q.traverse(ty);

      for (const auto &[_, prop] : ttv->props) {
        auto ftv = getMutable<FunctionType>(follow(prop.type()));
        if (!ftv || !ftv->hasSelf)
          continue;

        if (Luau::first(ftv->argTypes) == ttv->selfTy) {
          ftv->generics.insert(ftv->generics.end(), selfQ.generics.begin(),
                               selfQ.generics.end());
          ftv->genericPacks.insert(ftv->genericPacks.end(),
                                   selfQ.genericPacks.begin(),
                                   selfQ.genericPacks.end());
        }
      }
    } else if (auto ftv = getMutable<FunctionType>(ty)) {
      Quantifier q{level};
      q.traverse(ty);

      ftv->generics.insert(ftv->generics.end(), q.generics.begin(),
                           q.generics.end());
      ftv->genericPacks.insert(ftv->genericPacks.end(), q.genericPacks.begin(),
                               q.genericPacks.end());

      if (ftv->generics.empty() && ftv->genericPacks.empty() &&
          !q.seenMutableType && !q.seenGenericType)
        ftv->hasNoFreeOrGenericTypes = true;
    }
  } else {
    Quantifier q{level};
    q.traverse(ty);

    FunctionType *ftv = getMutable<FunctionType>(ty);
    LUAU_ASSERT(ftv);
    ftv->generics.insert(ftv->generics.end(), q.generics.begin(),
                         q.generics.end());
    ftv->genericPacks.insert(ftv->genericPacks.end(), q.genericPacks.begin(),
                             q.genericPacks.end());
  }
}

struct PureQuantifier : Substitution {
  Scope *scope;
  OrderedMap<TypeId, TypeId> insertedGenerics;
  OrderedMap<TypePackId, TypePackId> insertedGenericPacks;
  bool seenMutableType = false;
  bool seenGenericType = false;

  PureQuantifier(TypeArena *arena, Scope *scope)
      : Substitution(TxnLog::empty(), arena), scope(scope) {}

  bool isDirty(TypeId ty) override {
    LUAU_ASSERT(ty == follow(ty));

    if (auto ftv = get<FreeType>(ty)) {
      bool result = subsumes(scope, ftv->scope);
      seenMutableType |= result;
      return result;
    } else if (auto ttv = get<TableType>(ty)) {
      if (ttv->state == TableState::Free)
        seenMutableType = true;
      else if (ttv->state == TableState::Generic)
        seenGenericType = true;

      return (ttv->state == TableState::Unsealed ||
              ttv->state == TableState::Free) &&
             subsumes(scope, ttv->scope);
    }

    return false;
  }

  bool isDirty(TypePackId tp) override {
    if (auto ftp = get<FreeTypePack>(tp)) {
      return subsumes(scope, ftp->scope);
    }

    return false;
  }

  TypeId clean(TypeId ty) override {
    if (auto ftv = get<FreeType>(ty)) {
      TypeId result = arena->addType(GenericType{scope});
      insertedGenerics.push(ty, result);
      return result;
    } else if (auto ttv = get<TableType>(ty)) {
      TypeId result = arena->addType(TableType{});
      TableType *resultTable = getMutable<TableType>(result);
      LUAU_ASSERT(resultTable);

      *resultTable = *ttv;
      resultTable->level = TypeLevel{};
      resultTable->scope = scope;

      if (ttv->state == TableState::Free) {
        resultTable->state = TableState::Generic;
        insertedGenerics.push(ty, result);
      } else if (ttv->state == TableState::Unsealed)
        resultTable->state = TableState::Sealed;

      return result;
    }

    return ty;
  }

  TypePackId clean(TypePackId tp) override {
    if (auto ftp = get<FreeTypePack>(tp)) {
      TypePackId result =
          arena->addTypePack(TypePackVar{GenericTypePack{scope}});
      insertedGenericPacks.push(tp, result);
      return result;
    }

    return tp;
  }

  bool ignoreChildren(TypeId ty) override {
    if (get<ClassType>(ty))
      return true;

    return ty->persistent;
  }
  bool ignoreChildren(TypePackId ty) override { return ty->persistent; }
};

std::optional<QuantifierResult> quantify(TypeArena *arena, TypeId ty,
                                         Scope *scope) {
  PureQuantifier quantifier{arena, scope};
  std::optional<TypeId> result = quantifier.substitute(ty);
  if (!result)
    return std::nullopt;

  FunctionType *ftv = getMutable<FunctionType>(*result);
  LUAU_ASSERT(ftv);
  ftv->scope = scope;

  for (auto k : quantifier.insertedGenerics.keys) {
    TypeId g = quantifier.insertedGenerics.pairings[k];
    if (get<GenericType>(g))
      ftv->generics.push_back(g);
  }

  for (auto k : quantifier.insertedGenericPacks.keys)
    ftv->genericPacks.push_back(quantifier.insertedGenericPacks.pairings[k]);

  ftv->hasNoFreeOrGenericTypes =
      ftv->generics.empty() && ftv->genericPacks.empty() &&
      !quantifier.seenGenericType && !quantifier.seenMutableType;

  return std::optional<QuantifierResult>(
      {*result, std::move(quantifier.insertedGenerics),
       std::move(quantifier.insertedGenericPacks)});
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Symbol.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

namespace Luau {

bool Symbol::operator==(const Symbol &rhs) const {
  if (local)
    return local == rhs.local;
  else if (global.value)
    return rhs.global.value &&
           global ==
               rhs.global.value; // Subtlety: AstName::operator==(const char*)
                                 // uses strcmp, not pointer identity.
  else if (FFlag::DebugLuauDeferredConstraintResolution)
    return !rhs.local &&
           !rhs.global.value; // Reflexivity: we already know `this` Symbol is
                              // empty, so check that rhs is.
  else
    return false;
}

std::string toString(const Symbol &name) {
  if (name.local)
    return name.local->name.value;

  LUAU_ASSERT(name.global.value);
  return name.global.value;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifier2.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// DONE : was aleready inlined <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <optional>

LUAU_FASTINT(LuauTypeInferRecursionLimit)

namespace Luau {

static bool areCompatible(TypeId left, TypeId right) {
  auto p = get2<TableType, TableType>(follow(left), follow(right));
  if (!p)
    return true;

  const TableType *leftTable = p.first;
  LUAU_ASSERT(leftTable);
  const TableType *rightTable = p.second;
  LUAU_ASSERT(rightTable);

  const auto missingPropIsCompatible = [](const Property &leftProp,
                                          const TableType *rightTable) {
    // Two tables may be compatible even if their shapes aren't exactly the
    // same if the extra property is optional, free (and therefore
    // potentially optional), or if the right table has an indexer.  Or if
    // the right table is free (and therefore potentially has an indexer or
    // a compatible property)

    LUAU_ASSERT(leftProp.isReadOnly() || leftProp.isShared());

    const TypeId leftType =
        follow(leftProp.isReadOnly() ? *leftProp.readTy : leftProp.type());

    if (isOptional(leftType) || get<FreeType>(leftType) ||
        rightTable->state == TableState::Free ||
        rightTable->indexer.has_value())
      return true;

    return false;
  };

  for (const auto &[name, leftProp] : leftTable->props) {
    auto it = rightTable->props.find(name);
    if (it == rightTable->props.end()) {
      if (!missingPropIsCompatible(leftProp, rightTable))
        return false;
    }
  }

  for (const auto &[name, rightProp] : rightTable->props) {
    auto it = leftTable->props.find(name);
    if (it == leftTable->props.end()) {
      if (!missingPropIsCompatible(rightProp, leftTable))
        return false;
    }
  }

  return true;
}

// returns `true` if `ty` is irressolvable and should be added to
// `incompleteSubtypes`.
static bool isIrresolvable(TypeId ty) {
  return get<BlockedType>(ty) || get<TypeFunctionInstanceType>(ty);
}

// returns `true` if `tp` is irressolvable and should be added to
// `incompleteSubtypes`.
static bool isIrresolvable(TypePackId tp) {
  return get<BlockedTypePack>(tp) || get<TypeFunctionInstanceTypePack>(tp);
}

Unifier2::Unifier2(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes,
                   NotNull<Scope> scope, NotNull<InternalErrorReporter> ice)
    : arena(arena), builtinTypes(builtinTypes), scope(scope), ice(ice),
      limits(TypeCheckLimits{}) // TODO: typecheck limits in unifier2
      ,
      recursionLimit(FInt::LuauTypeInferRecursionLimit),
      uninhabitedTypeFamilies(nullptr) {}

Unifier2::Unifier2(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes,
                   NotNull<Scope> scope, NotNull<InternalErrorReporter> ice,
                   DenseHashSet<const void *> *uninhabitedTypeFamilies)
    : arena(arena), builtinTypes(builtinTypes), scope(scope), ice(ice),
      limits(TypeCheckLimits{}) // TODO: typecheck limits in unifier2
      ,
      recursionLimit(FInt::LuauTypeInferRecursionLimit),
      uninhabitedTypeFamilies(uninhabitedTypeFamilies) {}

bool Unifier2::unify(TypeId subTy, TypeId superTy) {
  subTy = follow(subTy);
  superTy = follow(superTy);

  if (auto subGen = genericSubstitutions.find(subTy))
    return unify(*subGen, superTy);

  if (auto superGen = genericSubstitutions.find(superTy))
    return unify(subTy, *superGen);

  if (seenTypePairings.contains({subTy, superTy}))
    return true;
  seenTypePairings.insert({subTy, superTy});

  if (subTy == superTy)
    return true;

  // We have potentially done some unifications while dispatching either
  // `SubtypeConstraint` or `PackSubtypeConstraint`, so rather than implementing
  // backtracking or traversing the entire type graph multiple times, we could
  // push additional constraints as we discover blocked types along with their
  // proper bounds.
  //
  // But we exclude these two subtyping patterns, they are tautological:
  //   - never <: *blocked*
  //   - *blocked* <: unknown
  if ((isIrresolvable(subTy) || isIrresolvable(superTy)) &&
      !get<NeverType>(subTy) && !get<UnknownType>(superTy)) {
    if (uninhabitedTypeFamilies && (uninhabitedTypeFamilies->contains(subTy) ||
                                    uninhabitedTypeFamilies->contains(superTy)))
      return true;

    incompleteSubtypes.push_back(SubtypeConstraint{subTy, superTy});
    return true;
  }

  FreeType *subFree = getMutable<FreeType>(subTy);
  FreeType *superFree = getMutable<FreeType>(superTy);

  if (superFree) {
    superFree->lowerBound = mkUnion(superFree->lowerBound, subTy);
  }

  if (subFree) {
    return unifyFreeWithType(subTy, superTy);
  }

  if (subFree || superFree)
    return true;

  auto subFn = get<FunctionType>(subTy);
  auto superFn = get<FunctionType>(superTy);
  if (subFn && superFn)
    return unify(subTy, superFn);

  auto subUnion = get<UnionType>(subTy);
  auto superUnion = get<UnionType>(superTy);
  if (subUnion)
    return unify(subUnion, superTy);
  else if (superUnion)
    return unify(subTy, superUnion);

  auto subIntersection = get<IntersectionType>(subTy);
  auto superIntersection = get<IntersectionType>(superTy);
  if (subIntersection)
    return unify(subIntersection, superTy);
  else if (superIntersection)
    return unify(subTy, superIntersection);

  auto subNever = get<NeverType>(subTy);
  auto superNever = get<NeverType>(superTy);
  if (subNever && superNever)
    return true;
  else if (subNever && superFn) {
    // If `never` is the subtype, then we can propagate that inward.
    bool argResult = unify(superFn->argTypes, builtinTypes->neverTypePack);
    bool retResult = unify(builtinTypes->neverTypePack, superFn->retTypes);
    return argResult && retResult;
  } else if (subFn && superNever) {
    // If `never` is the supertype, then we can propagate that inward.
    bool argResult = unify(builtinTypes->neverTypePack, subFn->argTypes);
    bool retResult = unify(subFn->retTypes, builtinTypes->neverTypePack);
    return argResult && retResult;
  }

  auto subAny = get<AnyType>(subTy);
  auto superAny = get<AnyType>(superTy);

  auto subTable = getMutable<TableType>(subTy);
  auto superTable = get<TableType>(superTy);

  if (subAny && superAny)
    return true;
  else if (subAny && superFn)
    return unify(subAny, superFn);
  else if (subFn && superAny)
    return unify(subFn, superAny);
  else if (subAny && superTable)
    return unify(subAny, superTable);
  else if (subTable && superAny)
    return unify(subTable, superAny);

  if (subTable && superTable) {
    // `boundTo` works like a bound type, and therefore we'd replace it
    // with the `boundTo` and try unification again.
    //
    // However, these pointers should have been chased already by follow().
    LUAU_ASSERT(!subTable->boundTo);
    LUAU_ASSERT(!superTable->boundTo);

    return unify(subTable, superTable);
  }

  auto subMetatable = get<MetatableType>(subTy);
  auto superMetatable = get<MetatableType>(superTy);
  if (subMetatable && superMetatable)
    return unify(subMetatable, superMetatable);
  else if (subMetatable) // if we only have one metatable, unify with the inner
                         // table
    return unify(subMetatable->table, superTy);
  else if (superMetatable) // if we only have one metatable, unify with the
                           // inner table
    return unify(subTy, superMetatable->table);

  auto [subNegation, superNegation] =
      get2<NegationType, NegationType>(subTy, superTy);
  if (subNegation && superNegation)
    return unify(subNegation->ty, superNegation->ty);

  // The unification failed, but we're not doing type checking.
  return true;
}

// If superTy is a function and subTy already has a
// potentially-compatible function in its upper bound, we assume that
// the function is not overloaded and attempt to combine superTy into
// subTy's existing function bound.
bool Unifier2::unifyFreeWithType(TypeId subTy, TypeId superTy) {
  FreeType *subFree = getMutable<FreeType>(subTy);
  LUAU_ASSERT(subFree);

  auto doDefault = [&]() {
    subFree->upperBound = mkIntersection(subFree->upperBound, superTy);
    expandedFreeTypes[subTy].push_back(superTy);
    return true;
  };

  TypeId upperBound = follow(subFree->upperBound);

  if (get<FunctionType>(upperBound))
    return unify(subFree->upperBound, superTy);

  const FunctionType *superFunction = get<FunctionType>(superTy);
  if (!superFunction)
    return doDefault();

  const auto [superArgHead, superArgTail] = flatten(superFunction->argTypes);
  if (superArgTail)
    return doDefault();

  const IntersectionType *upperBoundIntersection =
      get<IntersectionType>(subFree->upperBound);
  if (!upperBoundIntersection)
    return doDefault();

  bool ok = true;
  bool foundOne = false;

  for (TypeId part : upperBoundIntersection->parts) {
    const FunctionType *ft = get<FunctionType>(follow(part));
    if (!ft)
      continue;

    const auto [subArgHead, subArgTail] = flatten(ft->argTypes);

    if (!subArgTail && subArgHead.size() == superArgHead.size()) {
      foundOne = true;
      ok &= unify(part, superTy);
    }
  }

  if (foundOne)
    return ok;
  else
    return doDefault();
}

bool Unifier2::unify(TypeId subTy, const FunctionType *superFn) {
  const FunctionType *subFn = get<FunctionType>(subTy);

  bool shouldInstantiate =
      (superFn->generics.empty() && !subFn->generics.empty()) ||
      (superFn->genericPacks.empty() && !subFn->genericPacks.empty());

  if (shouldInstantiate) {
    for (auto generic : subFn->generics)
      genericSubstitutions[generic] = freshType(arena, builtinTypes, scope);

    for (auto genericPack : subFn->genericPacks)
      genericPackSubstitutions[genericPack] = arena->freshTypePack(scope);
  }

  bool argResult = unify(superFn->argTypes, subFn->argTypes);
  bool retResult = unify(subFn->retTypes, superFn->retTypes);
  return argResult && retResult;
}

bool Unifier2::unify(const UnionType *subUnion, TypeId superTy) {
  bool result = true;

  // if the occurs check fails for any option, it fails overall
  for (auto subOption : subUnion->options) {
    if (areCompatible(subOption, superTy))
      result &= unify(subOption, superTy);
  }

  return result;
}

bool Unifier2::unify(TypeId subTy, const UnionType *superUnion) {
  bool result = true;

  // if the occurs check fails for any option, it fails overall
  for (auto superOption : superUnion->options) {
    if (areCompatible(subTy, superOption))
      result &= unify(subTy, superOption);
  }

  return result;
}

bool Unifier2::unify(const IntersectionType *subIntersection, TypeId superTy) {
  bool result = true;

  // if the occurs check fails for any part, it fails overall
  for (auto subPart : subIntersection->parts)
    result &= unify(subPart, superTy);

  return result;
}

bool Unifier2::unify(TypeId subTy, const IntersectionType *superIntersection) {
  bool result = true;

  // if the occurs check fails for any part, it fails overall
  for (auto superPart : superIntersection->parts)
    result &= unify(subTy, superPart);

  return result;
}

bool Unifier2::unify(TableType *subTable, const TableType *superTable) {
  bool result = true;

  // It suffices to only check one direction of properties since we'll only ever
  // have work to do during unification if the property is present in both table
  // types.
  for (const auto &[propName, subProp] : subTable->props) {
    auto superPropOpt = superTable->props.find(propName);

    if (superPropOpt != superTable->props.end()) {
      const Property &superProp = superPropOpt->second;

      if (subProp.isReadOnly() && superProp.isReadOnly())
        result &= unify(*subProp.readTy, *superPropOpt->second.readTy);
      else if (subProp.isReadOnly())
        result &= unify(*subProp.readTy, superProp.type());
      else if (superProp.isReadOnly())
        result &= unify(subProp.type(), *superProp.readTy);
      else {
        result &= unify(subProp.type(), superProp.type());
        result &= unify(superProp.type(), subProp.type());
      }
    }
  }

  auto subTypeParamsIter = subTable->instantiatedTypeParams.begin();
  auto superTypeParamsIter = superTable->instantiatedTypeParams.begin();

  while (subTypeParamsIter != subTable->instantiatedTypeParams.end() &&
         superTypeParamsIter != superTable->instantiatedTypeParams.end()) {
    result &= unify(*subTypeParamsIter, *superTypeParamsIter);

    subTypeParamsIter++;
    superTypeParamsIter++;
  }

  auto subTypePackParamsIter = subTable->instantiatedTypePackParams.begin();
  auto superTypePackParamsIter = superTable->instantiatedTypePackParams.begin();

  while (subTypePackParamsIter != subTable->instantiatedTypePackParams.end() &&
         superTypePackParamsIter !=
             superTable->instantiatedTypePackParams.end()) {
    result &= unify(*subTypePackParamsIter, *superTypePackParamsIter);

    subTypePackParamsIter++;
    superTypePackParamsIter++;
  }

  if (subTable->selfTy && superTable->selfTy)
    result &= unify(*subTable->selfTy, *superTable->selfTy);

  if (subTable->indexer && superTable->indexer) {
    result &=
        unify(subTable->indexer->indexType, superTable->indexer->indexType);
    result &= unify(subTable->indexer->indexResultType,
                    superTable->indexer->indexResultType);
  }

  if (!subTable->indexer && subTable->state == TableState::Unsealed &&
      superTable->indexer) {
    /*
     * Unsealed tables are always created from literal table expressions. We
     * can't be completely certain whether such a table has an indexer just
     * by the content of the expression itself, so we need to be a bit more
     * flexible here.
     *
     * If we are trying to reconcile an unsealed table with a table that has
     * an indexer, we therefore conclude that the unsealed table has the
     * same indexer.
     */

    TypeId indexType = superTable->indexer->indexType;
    if (TypeId *subst = genericSubstitutions.find(indexType))
      indexType = *subst;

    TypeId indexResultType = superTable->indexer->indexResultType;
    if (TypeId *subst = genericSubstitutions.find(indexResultType))
      indexResultType = *subst;

    subTable->indexer = TableIndexer{indexType, indexResultType};
  }

  return result;
}

bool Unifier2::unify(const MetatableType *subMetatable,
                     const MetatableType *superMetatable) {
  return unify(subMetatable->metatable, superMetatable->metatable) &&
         unify(subMetatable->table, superMetatable->table);
}

bool Unifier2::unify(const AnyType *subAny, const FunctionType *superFn) {
  // If `any` is the subtype, then we can propagate that inward.
  bool argResult = unify(superFn->argTypes, builtinTypes->anyTypePack);
  bool retResult = unify(builtinTypes->anyTypePack, superFn->retTypes);
  return argResult && retResult;
}

bool Unifier2::unify(const FunctionType *subFn, const AnyType *superAny) {
  // If `any` is the supertype, then we can propagate that inward.
  bool argResult = unify(builtinTypes->anyTypePack, subFn->argTypes);
  bool retResult = unify(subFn->retTypes, builtinTypes->anyTypePack);
  return argResult && retResult;
}

bool Unifier2::unify(const AnyType *subAny, const TableType *superTable) {
  for (const auto &[propName, prop] : superTable->props) {
    if (prop.readTy)
      unify(builtinTypes->anyType, *prop.readTy);

    if (prop.writeTy)
      unify(*prop.writeTy, builtinTypes->anyType);
  }

  if (superTable->indexer) {
    unify(builtinTypes->anyType, superTable->indexer->indexType);
    unify(builtinTypes->anyType, superTable->indexer->indexResultType);
  }

  return true;
}

bool Unifier2::unify(const TableType *subTable, const AnyType *superAny) {
  for (const auto &[propName, prop] : subTable->props) {
    if (prop.readTy)
      unify(*prop.readTy, builtinTypes->anyType);

    if (prop.writeTy)
      unify(builtinTypes->anyType, *prop.writeTy);
  }

  if (subTable->indexer) {
    unify(subTable->indexer->indexType, builtinTypes->anyType);
    unify(subTable->indexer->indexResultType, builtinTypes->anyType);
  }

  return true;
}

// FIXME?  This should probably return an ErrorVec or an optional<TypeError>
// rather than a boolean to signal an occurs check failure.
bool Unifier2::unify(TypePackId subTp, TypePackId superTp) {
  subTp = follow(subTp);
  superTp = follow(superTp);

  if (auto subGen = genericPackSubstitutions.find(subTp))
    return unify(*subGen, superTp);

  if (auto superGen = genericPackSubstitutions.find(superTp))
    return unify(subTp, *superGen);

  if (seenTypePackPairings.contains({subTp, superTp}))
    return true;
  seenTypePackPairings.insert({subTp, superTp});

  if (subTp == superTp)
    return true;

  if (isIrresolvable(subTp) || isIrresolvable(superTp)) {
    if (uninhabitedTypeFamilies && (uninhabitedTypeFamilies->contains(subTp) ||
                                    uninhabitedTypeFamilies->contains(superTp)))
      return true;

    incompleteSubtypes.push_back(PackSubtypeConstraint{subTp, superTp});
    return true;
  }

  const FreeTypePack *subFree = get<FreeTypePack>(subTp);
  const FreeTypePack *superFree = get<FreeTypePack>(superTp);

  if (subFree) {
    DenseHashSet<TypePackId> seen{nullptr};
    if (OccursCheckResult::Fail == occursCheck(seen, subTp, superTp)) {
      emplaceTypePack<BoundTypePack>(asMutable(subTp),
                                     builtinTypes->errorTypePack);
      return false;
    }

    emplaceTypePack<BoundTypePack>(asMutable(subTp), superTp);
    return true;
  }

  if (superFree) {
    DenseHashSet<TypePackId> seen{nullptr};
    if (OccursCheckResult::Fail == occursCheck(seen, superTp, subTp)) {
      emplaceTypePack<BoundTypePack>(asMutable(superTp),
                                     builtinTypes->errorTypePack);
      return false;
    }

    emplaceTypePack<BoundTypePack>(asMutable(superTp), subTp);
    return true;
  }

  size_t maxLength =
      std::max(flatten(subTp).first.size(), flatten(superTp).first.size());

  auto [subTypes, subTail] =
      extendTypePack(*arena, builtinTypes, subTp, maxLength);
  auto [superTypes, superTail] =
      extendTypePack(*arena, builtinTypes, superTp, maxLength);

  // right-pad the subpack with nils if `superPack` is larger since that's what
  // a function call does
  if (subTypes.size() < maxLength) {
    for (size_t i = 0; i <= maxLength - subTypes.size(); i++)
      subTypes.push_back(builtinTypes->nilType);
  }

  if (subTypes.size() < maxLength || superTypes.size() < maxLength)
    return true;

  for (size_t i = 0; i < maxLength; ++i)
    unify(subTypes[i], superTypes[i]);

  if (subTail && superTail) {
    TypePackId followedSubTail = follow(*subTail);
    TypePackId followedSuperTail = follow(*superTail);

    if (get<FreeTypePack>(followedSubTail) ||
        get<FreeTypePack>(followedSuperTail))
      return unify(followedSubTail, followedSuperTail);
  } else if (subTail) {
    TypePackId followedSubTail = follow(*subTail);
    if (get<FreeTypePack>(followedSubTail))
      emplaceTypePack<BoundTypePack>(asMutable(followedSubTail),
                                     builtinTypes->emptyTypePack);
  } else if (superTail) {
    TypePackId followedSuperTail = follow(*superTail);
    if (get<FreeTypePack>(followedSuperTail))
      emplaceTypePack<BoundTypePack>(asMutable(followedSuperTail),
                                     builtinTypes->emptyTypePack);
  }

  return true;
}

struct FreeTypeSearcher : TypeVisitor {
  NotNull<Scope> scope;

  explicit FreeTypeSearcher(NotNull<Scope> scope)
      : TypeVisitor(/*skipBoundTypes*/ true), scope(scope) {}

  enum Polarity {
    Positive,
    Negative,
    Both,
  };

  Polarity polarity = Positive;

  void flip() {
    switch (polarity) {
    case Positive:
      polarity = Negative;
      break;
    case Negative:
      polarity = Positive;
      break;
    case Both:
      break;
    }
  }

  DenseHashSet<const void *> seenPositive{nullptr};
  DenseHashSet<const void *> seenNegative{nullptr};

  bool seenWithPolarity(const void *ty) {
    switch (polarity) {
    case Positive: {
      if (seenPositive.contains(ty))
        return true;

      seenPositive.insert(ty);
      return false;
    }
    case Negative: {
      if (seenNegative.contains(ty))
        return true;

      seenNegative.insert(ty);
      return false;
    }
    case Both: {
      if (seenPositive.contains(ty) && seenNegative.contains(ty))
        return true;

      seenPositive.insert(ty);
      seenNegative.insert(ty);
      return false;
    }
    }

    return false;
  }

  // The keys in these maps are either TypeIds or TypePackIds. It's safe to
  // mix them because we only use these pointers as unique keys.  We never
  // indirect them.
  DenseHashMap<const void *, size_t> negativeTypes{0};
  DenseHashMap<const void *, size_t> positiveTypes{0};

  bool visit(TypeId ty) override {
    if (seenWithPolarity(ty))
      return false;

    LUAU_ASSERT(ty);
    return true;
  }

  bool visit(TypeId ty, const FreeType &ft) override {
    if (seenWithPolarity(ty))
      return false;

    if (!subsumes(scope, ft.scope))
      return true;

    switch (polarity) {
    case Positive:
      positiveTypes[ty]++;
      break;
    case Negative:
      negativeTypes[ty]++;
      break;
    case Both:
      positiveTypes[ty]++;
      negativeTypes[ty]++;
      break;
    }

    return true;
  }

  bool visit(TypeId ty, const TableType &tt) override {
    if (seenWithPolarity(ty))
      return false;

    if ((tt.state == TableState::Free || tt.state == TableState::Unsealed) &&
        subsumes(scope, tt.scope)) {
      switch (polarity) {
      case Positive:
        positiveTypes[ty]++;
        break;
      case Negative:
        negativeTypes[ty]++;
        break;
      case Both:
        positiveTypes[ty]++;
        negativeTypes[ty]++;
        break;
      }
    }

    for (const auto &[_name, prop] : tt.props) {
      if (prop.isReadOnly())
        traverse(*prop.readTy);
      else {
        LUAU_ASSERT(prop.isShared());

        Polarity p = polarity;
        polarity = Both;
        traverse(prop.type());
        polarity = p;
      }
    }

    if (tt.indexer) {
      traverse(tt.indexer->indexType);
      traverse(tt.indexer->indexResultType);
    }

    return false;
  }

  bool visit(TypeId ty, const FunctionType &ft) override {
    if (seenWithPolarity(ty))
      return false;

    flip();
    traverse(ft.argTypes);
    flip();

    traverse(ft.retTypes);

    return false;
  }

  bool visit(TypeId, const ClassType &) override { return false; }

  bool visit(TypePackId tp, const FreeTypePack &ftp) override {
    if (seenWithPolarity(tp))
      return false;

    if (!subsumes(scope, ftp.scope))
      return true;

    switch (polarity) {
    case Positive:
      positiveTypes[tp]++;
      break;
    case Negative:
      negativeTypes[tp]++;
      break;
    case Both:
      positiveTypes[tp]++;
      negativeTypes[tp]++;
      break;
    }

    return true;
  }
};

TypeId Unifier2::mkUnion(TypeId left, TypeId right) {
  left = follow(left);
  right = follow(right);

  return simplifyUnion(builtinTypes, arena, left, right).result;
}

TypeId Unifier2::mkIntersection(TypeId left, TypeId right) {
  left = follow(left);
  right = follow(right);

  return simplifyIntersection(builtinTypes, arena, left, right).result;
}

OccursCheckResult Unifier2::occursCheck(DenseHashSet<TypeId> &seen,
                                        TypeId needle, TypeId haystack) {
  RecursionLimiter _ra(&recursionCount, recursionLimit);

  OccursCheckResult occurrence = OccursCheckResult::Pass;

  auto check = [&](TypeId ty) {
    if (occursCheck(seen, needle, ty) == OccursCheckResult::Fail)
      occurrence = OccursCheckResult::Fail;
  };

  needle = follow(needle);
  haystack = follow(haystack);

  if (seen.find(haystack))
    return OccursCheckResult::Pass;

  seen.insert(haystack);

  if (get<ErrorType>(needle))
    return OccursCheckResult::Pass;

  if (!get<FreeType>(needle))
    ice->ice("Expected needle to be free");

  if (needle == haystack)
    return OccursCheckResult::Fail;

  if (auto haystackFree = get<FreeType>(haystack)) {
    check(haystackFree->lowerBound);
    check(haystackFree->upperBound);
  } else if (auto ut = get<UnionType>(haystack)) {
    for (TypeId ty : ut->options)
      check(ty);
  } else if (auto it = get<IntersectionType>(haystack)) {
    for (TypeId ty : it->parts)
      check(ty);
  }

  return occurrence;
}

OccursCheckResult Unifier2::occursCheck(DenseHashSet<TypePackId> &seen,
                                        TypePackId needle,
                                        TypePackId haystack) {
  needle = follow(needle);
  haystack = follow(haystack);

  if (seen.find(haystack))
    return OccursCheckResult::Pass;

  seen.insert(haystack);

  if (getMutable<ErrorTypePack>(needle))
    return OccursCheckResult::Pass;

  if (!getMutable<FreeTypePack>(needle))
    ice->ice("Expected needle pack to be free");

  RecursionLimiter _ra(&recursionCount, recursionLimit);

  while (!getMutable<Unifiable::Error>(haystack)) {
    if (needle == haystack)
      return OccursCheckResult::Fail;

    if (auto a = get<TypePack>(haystack); a && a->tail) {
      haystack = follow(*a->tail);
      continue;
    }

    break;
  }

  return OccursCheckResult::Pass;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Unifiable.h>

namespace Luau {
namespace Unifiable {

static int nextIndex = 0;

int freshIndex() { return ++nextIndex; }

Error::Error() : index(++nextIndex) {}

int Error::nextIndex = 0;

} // namespace Unifiable
} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/ToDot.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@ PACK.lua : not found, likely and std header
#include <unordered_map>

// @@@@@ PACK.LUA : was already included! <unordered_set>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

namespace Luau {

namespace {

struct StateDot {
  StateDot(ToDotOptions opts) : opts(opts) {}

  ToDotOptions opts;

  std::unordered_set<TypeId> seenTy;
  std::unordered_set<TypePackId> seenTp;
  std::unordered_map<TypeId, int> tyToIndex;
  std::unordered_map<TypePackId, int> tpToIndex;
  int nextIndex = 1;
  std::string result;

  bool canDuplicatePrimitive(TypeId ty);

  void visitChildren(TypeId ty, int index);
  void visitChildren(TypePackId ty, int index);

  void visitChild(TypeId ty, int parentIndex, const char *linkName = nullptr);
  void visitChild(TypePackId tp, int parentIndex,
                  const char *linkName = nullptr);

  void startNode(int index);
  void finishNode();

  void startNodeLabel();
  void finishNodeLabel(TypeId ty);
  void finishNodeLabel(TypePackId tp);
};

bool StateDot::canDuplicatePrimitive(TypeId ty) {
  if (get<BoundType>(ty))
    return false;

  return get<PrimitiveType>(ty) || get<AnyType>(ty) || get<UnknownType>(ty) ||
         get<NeverType>(ty);
}

void StateDot::visitChild(TypeId ty, int parentIndex, const char *linkName) {
  if (!tyToIndex.count(ty) ||
      (opts.duplicatePrimitives && canDuplicatePrimitive(ty)))
    tyToIndex[ty] = nextIndex++;

  int index = tyToIndex[ty];

  if (parentIndex != 0) {
    if (linkName)
      formatAppend(result, "n%d -> n%d [label=\"%s\"];\n", parentIndex, index,
                   linkName);
    else
      formatAppend(result, "n%d -> n%d;\n", parentIndex, index);
  }

  if (opts.duplicatePrimitives && canDuplicatePrimitive(ty)) {
    if (get<PrimitiveType>(ty))
      formatAppend(result, "n%d [label=\"%s\"];\n", index,
                   toString(ty).c_str());
    else if (get<AnyType>(ty))
      formatAppend(result, "n%d [label=\"any\"];\n", index);
    else if (get<UnknownType>(ty))
      formatAppend(result, "n%d [label=\"unknown\"];\n", index);
    else if (get<NeverType>(ty))
      formatAppend(result, "n%d [label=\"never\"];\n", index);
  } else {
    visitChildren(ty, index);
  }
}

void StateDot::visitChild(TypePackId tp, int parentIndex,
                          const char *linkName) {
  if (!tpToIndex.count(tp))
    tpToIndex[tp] = nextIndex++;

  if (parentIndex != 0) {
    if (linkName)
      formatAppend(result, "n%d -> n%d [label=\"%s\"];\n", parentIndex,
                   tpToIndex[tp], linkName);
    else
      formatAppend(result, "n%d -> n%d;\n", parentIndex, tpToIndex[tp]);
  }

  visitChildren(tp, tpToIndex[tp]);
}

void StateDot::startNode(int index) { formatAppend(result, "n%d [", index); }

void StateDot::finishNode() { formatAppend(result, "];\n"); }

void StateDot::startNodeLabel() { formatAppend(result, "label=\""); }

void StateDot::finishNodeLabel(TypeId ty) {
  if (opts.showPointers)
    formatAppend(result, "\n0x%p", ty);
  // additional common attributes can be added here as well
  result += "\"";
}

void StateDot::finishNodeLabel(TypePackId tp) {
  if (opts.showPointers)
    formatAppend(result, "\n0x%p", tp);
  // additional common attributes can be added here as well
  result += "\"";
}

void StateDot::visitChildren(TypeId ty, int index) {
  if (seenTy.count(ty))
    return;
  seenTy.insert(ty);

  startNode(index);
  startNodeLabel();

  auto go = [&](auto &&t) {
    using T = std::decay_t<decltype(t)>;

    if constexpr (std::is_same_v<T, BoundType>) {
      formatAppend(result, "BoundType %d", index);
      finishNodeLabel(ty);
      finishNode();

      visitChild(t.boundTo, index);
    } else if constexpr (std::is_same_v<T, BlockedType>) {
      formatAppend(result, "BlockedType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, FunctionType>) {
      formatAppend(result, "FunctionType %d", index);
      finishNodeLabel(ty);
      finishNode();

      visitChild(t.argTypes, index, "arg");
      visitChild(t.retTypes, index, "ret");
    } else if constexpr (std::is_same_v<T, TableType>) {
      if (t.name)
        formatAppend(result, "TableType %s", t.name->c_str());
      else if (t.syntheticName)
        formatAppend(result, "TableType %s", t.syntheticName->c_str());
      else
        formatAppend(result, "TableType %d", index);
      finishNodeLabel(ty);
      finishNode();

      if (t.boundTo)
        return visitChild(*t.boundTo, index, "boundTo");

      for (const auto &[name, prop] : t.props)
        visitChild(prop.type(), index, name.c_str());
      if (t.indexer) {
        visitChild(t.indexer->indexType, index, "[index]");
        visitChild(t.indexer->indexResultType, index, "[value]");
      }
      for (TypeId itp : t.instantiatedTypeParams)
        visitChild(itp, index, "typeParam");

      for (TypePackId itp : t.instantiatedTypePackParams)
        visitChild(itp, index, "typePackParam");
    } else if constexpr (std::is_same_v<T, MetatableType>) {
      formatAppend(result, "MetatableType %d", index);
      finishNodeLabel(ty);
      finishNode();

      visitChild(t.table, index, "table");
      visitChild(t.metatable, index, "metatable");
    } else if constexpr (std::is_same_v<T, UnionType>) {
      formatAppend(result, "UnionType %d", index);
      finishNodeLabel(ty);
      finishNode();

      for (TypeId opt : t.options)
        visitChild(opt, index);
    } else if constexpr (std::is_same_v<T, IntersectionType>) {
      formatAppend(result, "IntersectionType %d", index);
      finishNodeLabel(ty);
      finishNode();

      for (TypeId part : t.parts)
        visitChild(part, index);
    } else if constexpr (std::is_same_v<T, LazyType>) {
      formatAppend(result, "LazyType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, PendingExpansionType>) {
      formatAppend(result, "PendingExpansionType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, GenericType>) {
      if (t.explicitName)
        formatAppend(result, "GenericType %s", t.name.c_str());
      else
        formatAppend(result, "GenericType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, FreeType>) {
      formatAppend(result, "FreeType %d", index);
      finishNodeLabel(ty);
      finishNode();

      if (FFlag::DebugLuauDeferredConstraintResolution) {
        if (!get<NeverType>(t.lowerBound))
          visitChild(t.lowerBound, index, "[lowerBound]");

        if (!get<UnknownType>(t.upperBound))
          visitChild(t.upperBound, index, "[upperBound]");
      }
    } else if constexpr (std::is_same_v<T, AnyType>) {
      formatAppend(result, "AnyType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, UnknownType>) {
      formatAppend(result, "UnknownType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, NeverType>) {
      formatAppend(result, "NeverType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, PrimitiveType>) {
      formatAppend(result, "PrimitiveType %s", toString(ty).c_str());
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, ErrorType>) {
      formatAppend(result, "ErrorType %d", index);
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, ClassType>) {
      formatAppend(result, "ClassType %s", t.name.c_str());
      finishNodeLabel(ty);
      finishNode();

      for (const auto &[name, prop] : t.props)
        visitChild(prop.type(), index, name.c_str());

      if (t.parent)
        visitChild(*t.parent, index, "[parent]");

      if (t.metatable)
        visitChild(*t.metatable, index, "[metatable]");

      if (t.indexer) {
        visitChild(t.indexer->indexType, index, "[index]");
        visitChild(t.indexer->indexResultType, index, "[value]");
      }
    } else if constexpr (std::is_same_v<T, SingletonType>) {
      std::string res;

      if (const StringSingleton *ss = get<StringSingleton>(&t)) {
        // Don't put in quotes anywhere. If it's outside of the call to escape,
        // then it's invalid syntax. If it's inside, then escaping is super
        // noisy.
        res = "string: " + escape(ss->value);
      } else if (const BooleanSingleton *bs = get<BooleanSingleton>(&t)) {
        res = "boolean: ";
        res += bs->value ? "true" : "false";
      } else
        LUAU_ASSERT(!"unknown singleton type");

      formatAppend(result, "SingletonType %s", res.c_str());
      finishNodeLabel(ty);
      finishNode();
    } else if constexpr (std::is_same_v<T, NegationType>) {
      formatAppend(result, "NegationType %d", index);
      finishNodeLabel(ty);
      finishNode();

      visitChild(t.ty, index, "[negated]");
    } else if constexpr (std::is_same_v<T, TypeFunctionInstanceType>) {
      formatAppend(result, "TypeFunctionInstanceType %s %d",
                   t.family->name.c_str(), index);
      finishNodeLabel(ty);
      finishNode();

      for (TypeId tyParam : t.typeArguments)
        visitChild(tyParam, index);

      for (TypePackId tpParam : t.packArguments)
        visitChild(tpParam, index);
    } else
      static_assert(always_false_v<T>, "unknown type kind");
  };

  visit(go, ty->ty);
}

void StateDot::visitChildren(TypePackId tp, int index) {
  if (seenTp.count(tp))
    return;
  seenTp.insert(tp);

  startNode(index);
  startNodeLabel();

  if (const BoundTypePack *btp = get<BoundTypePack>(tp)) {
    formatAppend(result, "BoundTypePack %d", index);
    finishNodeLabel(tp);
    finishNode();

    visitChild(btp->boundTo, index);
  } else if (const TypePack *tpp = get<TypePack>(tp)) {
    formatAppend(result, "TypePack %d", index);
    finishNodeLabel(tp);
    finishNode();

    for (TypeId tv : tpp->head)
      visitChild(tv, index);
    if (tpp->tail)
      visitChild(*tpp->tail, index, "tail");
  } else if (const VariadicTypePack *vtp = get<VariadicTypePack>(tp)) {
    formatAppend(result, "VariadicTypePack %s%d", vtp->hidden ? "hidden " : "",
                 index);
    finishNodeLabel(tp);
    finishNode();

    visitChild(vtp->ty, index);
  } else if (const FreeTypePack *ftp = get<FreeTypePack>(tp)) {
    formatAppend(result, "FreeTypePack %d", index);
    finishNodeLabel(tp);
    finishNode();
  } else if (const GenericTypePack *gtp = get<GenericTypePack>(tp)) {
    if (gtp->explicitName)
      formatAppend(result, "GenericTypePack %s", gtp->name.c_str());
    else
      formatAppend(result, "GenericTypePack %d", index);
    finishNodeLabel(tp);
    finishNode();
  } else if (get<Unifiable::Error>(tp)) {
    formatAppend(result, "ErrorTypePack %d", index);
    finishNodeLabel(tp);
    finishNode();
  } else {
    LUAU_ASSERT(!"unknown type pack kind");
    finishNodeLabel(tp);
    finishNode();
  }
}

} // namespace

std::string toDot(TypeId ty, const ToDotOptions &opts) {
  StateDot state{opts};

  state.result = "digraph graphname {\n";
  state.visitChild(ty, 0);
  state.result += "}";

  return state.result;
}

std::string toDot(TypePackId tp, const ToDotOptions &opts) {
  StateDot state{opts};

  state.result = "digraph graphname {\n";
  state.visitChild(tp, 0);
  state.result += "}";

  return state.result;
}

std::string toDot(TypeId ty) { return toDot(ty, {}); }

std::string toDot(TypePackId tp) { return toDot(tp, {}); }

void dumpDot(TypeId ty) { printf("%s\n", toDot(ty).c_str()); }

void dumpDot(TypePackId tp) { printf("%s\n", toDot(tp).c_str()); }

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Differ.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <unordered_set>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau {
std::string DiffPathNode::toString() const {
  switch (kind) {
  case DiffPathNode::Kind::TableProperty: {
    if (!tableProperty.has_value())
      throw InternalCompilerError{
          "DiffPathNode has kind TableProperty but tableProperty is nullopt"};
    return *tableProperty;
    break;
  }
  case DiffPathNode::Kind::FunctionArgument: {
    if (!index.has_value())
      return "Arg[Variadic]";
    // Add 1 because Lua is 1-indexed
    return "Arg[" + std::to_string(*index + 1) + "]";
  }
  case DiffPathNode::Kind::FunctionReturn: {
    if (!index.has_value())
      return "Ret[Variadic]";
    // Add 1 because Lua is 1-indexed
    return "Ret[" + std::to_string(*index + 1) + "]";
  }
  case DiffPathNode::Kind::Negation: {
    return "Negation";
  }
  default: {
    throw InternalCompilerError{"DiffPathNode::toString is not exhaustive"};
  }
  }
}

DiffPathNode DiffPathNode::constructWithTableProperty(Name tableProperty) {
  return DiffPathNode{DiffPathNode::Kind::TableProperty, tableProperty,
                      std::nullopt};
}

DiffPathNode DiffPathNode::constructWithKindAndIndex(Kind kind, size_t index) {
  return DiffPathNode{kind, std::nullopt, index};
}

DiffPathNode DiffPathNode::constructWithKind(Kind kind) {
  return DiffPathNode{kind, std::nullopt, std::nullopt};
}

DiffPathNodeLeaf DiffPathNodeLeaf::detailsNormal(TypeId ty) {
  return DiffPathNodeLeaf{ty, std::nullopt, std::nullopt, false, std::nullopt};
}

DiffPathNodeLeaf DiffPathNodeLeaf::detailsTableProperty(TypeId ty,
                                                        Name tableProperty) {
  return DiffPathNodeLeaf{ty, tableProperty, std::nullopt, false, std::nullopt};
}

DiffPathNodeLeaf DiffPathNodeLeaf::detailsUnionIndex(TypeId ty, size_t index) {
  return DiffPathNodeLeaf{ty, std::nullopt, std::nullopt, false, index};
}

DiffPathNodeLeaf DiffPathNodeLeaf::detailsLength(int minLength,
                                                 bool isVariadic) {
  return DiffPathNodeLeaf{std::nullopt, std::nullopt, minLength, isVariadic,
                          std::nullopt};
}

DiffPathNodeLeaf DiffPathNodeLeaf::nullopts() {
  return DiffPathNodeLeaf{std::nullopt, std::nullopt, std::nullopt, false,
                          std::nullopt};
}

std::string DiffPath::toString(bool prependDot) const {
  std::string pathStr;
  bool isFirstInForLoop = !prependDot;
  for (auto node = path.rbegin(); node != path.rend(); node++) {
    if (isFirstInForLoop) {
      isFirstInForLoop = false;
    } else {
      pathStr += ".";
    }
    pathStr += node->toString();
  }
  return pathStr;
}
std::string DiffError::toStringALeaf(std::string rootName,
                                     const DiffPathNodeLeaf &leaf,
                                     const DiffPathNodeLeaf &otherLeaf,
                                     bool multiLine) const {
  std::string conditionalNewline = multiLine ? "\n" : " ";
  std::string conditionalIndent = multiLine ? "    " : "";
  std::string pathStr{rootName + diffPath.toString(true)};
  switch (kind) {
  case DiffError::Kind::Normal: {
    checkNonMissingPropertyLeavesHaveNulloptTableProperty();
    return pathStr + conditionalNewline + "has type" + conditionalNewline +
           conditionalIndent + Luau::toString(*leaf.ty);
  }
  case DiffError::Kind::MissingTableProperty: {
    if (leaf.ty.has_value()) {
      if (!leaf.tableProperty.has_value())
        throw InternalCompilerError{"leaf.tableProperty is nullopt"};
      return pathStr + "." + *leaf.tableProperty + conditionalNewline +
             "has type" + conditionalNewline + conditionalIndent +
             Luau::toString(*leaf.ty);
    } else if (otherLeaf.ty.has_value()) {
      if (!otherLeaf.tableProperty.has_value())
        throw InternalCompilerError{"otherLeaf.tableProperty is nullopt"};
      return pathStr + conditionalNewline + "is missing the property" +
             conditionalNewline + conditionalIndent + *otherLeaf.tableProperty;
    }
    throw InternalCompilerError{"Both leaf.ty and otherLeaf.ty is nullopt"};
  }
  case DiffError::Kind::MissingUnionMember: {
    // TODO: do normal case
    if (leaf.ty.has_value()) {
      if (!leaf.unionIndex.has_value())
        throw InternalCompilerError{"leaf.unionIndex is nullopt"};
      return pathStr + conditionalNewline + "is a union containing type" +
             conditionalNewline + conditionalIndent + Luau::toString(*leaf.ty);
    } else if (otherLeaf.ty.has_value()) {
      return pathStr + conditionalNewline + "is a union missing type" +
             conditionalNewline + conditionalIndent +
             Luau::toString(*otherLeaf.ty);
    }
    throw InternalCompilerError{"Both leaf.ty and otherLeaf.ty is nullopt"};
  }
  case DiffError::Kind::MissingIntersectionMember: {
    // TODO: better message for intersections
    // An intersection of just functions is always an "overloaded function"
    // An intersection of just tables is always a "joined table"
    if (leaf.ty.has_value()) {
      if (!leaf.unionIndex.has_value())
        throw InternalCompilerError{"leaf.unionIndex is nullopt"};
      return pathStr + conditionalNewline +
             "is an intersection containing type" + conditionalNewline +
             conditionalIndent + Luau::toString(*leaf.ty);
    } else if (otherLeaf.ty.has_value()) {
      return pathStr + conditionalNewline + "is an intersection missing type" +
             conditionalNewline + conditionalIndent +
             Luau::toString(*otherLeaf.ty);
    }
    throw InternalCompilerError{"Both leaf.ty and otherLeaf.ty is nullopt"};
  }
  case DiffError::Kind::LengthMismatchInFnArgs: {
    if (!leaf.minLength.has_value())
      throw InternalCompilerError{"leaf.minLength is nullopt"};
    return pathStr + conditionalNewline + "takes " +
           std::to_string(*leaf.minLength) +
           (leaf.isVariadic ? " or more" : "") + " arguments";
  }
  case DiffError::Kind::LengthMismatchInFnRets: {
    if (!leaf.minLength.has_value())
      throw InternalCompilerError{"leaf.minLength is nullopt"};
    return pathStr + conditionalNewline + "returns " +
           std::to_string(*leaf.minLength) +
           (leaf.isVariadic ? " or more" : "") + " values";
  }
  default: {
    throw InternalCompilerError{"DiffPath::toStringALeaf is not exhaustive"};
  }
  }
}

void DiffError::checkNonMissingPropertyLeavesHaveNulloptTableProperty() const {
  if (left.tableProperty.has_value() || right.tableProperty.has_value())
    throw InternalCompilerError{"Non-MissingProperty DiffError should have "
                                "nullopt tableProperty in both leaves"};
}

std::string getDevFixFriendlyName(const std::optional<std::string> &maybeSymbol,
                                  TypeId ty) {
  if (maybeSymbol.has_value())
    return *maybeSymbol;

  if (auto table = get<TableType>(ty)) {
    if (table->name.has_value())
      return *table->name;
    else if (table->syntheticName.has_value())
      return *table->syntheticName;
  }
  if (auto metatable = get<MetatableType>(ty)) {
    if (metatable->syntheticName.has_value()) {
      return *metatable->syntheticName;
    }
  }
  return "<unlabeled-symbol>";
}

std::string DifferEnvironment::getDevFixFriendlyNameLeft() const {
  return getDevFixFriendlyName(externalSymbolLeft, rootLeft);
}

std::string DifferEnvironment::getDevFixFriendlyNameRight() const {
  return getDevFixFriendlyName(externalSymbolRight, rootRight);
}

std::string DiffError::toString(bool multiLine) const {
  std::string conditionalNewline = multiLine ? "\n" : " ";
  std::string conditionalIndent = multiLine ? "    " : "";
  switch (kind) {
  case DiffError::Kind::IncompatibleGeneric: {
    std::string diffPathStr{diffPath.toString(true)};
    return "DiffError: these two types are not equal because the left generic "
           "at" +
           conditionalNewline + conditionalIndent + leftRootName + diffPathStr +
           conditionalNewline +
           "cannot be the same type parameter as the right generic at" +
           conditionalNewline + conditionalIndent + rightRootName + diffPathStr;
  }
  default: {
    return "DiffError: these two types are not equal because the left type at" +
           conditionalNewline + conditionalIndent +
           toStringALeaf(leftRootName, left, right, multiLine) + "," +
           conditionalNewline + "while the right type at" + conditionalNewline +
           conditionalIndent +
           toStringALeaf(rightRootName, right, left, multiLine);
  }
  }
}

void DiffError::checkValidInitialization(const DiffPathNodeLeaf &left,
                                         const DiffPathNodeLeaf &right) {
  if (!left.ty.has_value() || !right.ty.has_value()) {
    // TODO: think about whether this should be always thrown!
    // For example, Kind::Primitive doesn't make too much sense to have a TypeId
    // throw InternalCompilerError{"Left and Right fields are leaf nodes and
    // must have a TypeId"};
  }
}

void DifferResult::wrapDiffPath(DiffPathNode node) {
  if (!diffError.has_value()) {
    throw InternalCompilerError{
        "Cannot wrap diffPath because there is no diffError"};
  }

  diffError->diffPath.path.push_back(node);
}

static DifferResult diffUsingEnv(DifferEnvironment &env, TypeId left,
                                 TypeId right);
static DifferResult diffTable(DifferEnvironment &env, TypeId left,
                              TypeId right);
static DifferResult diffMetatable(DifferEnvironment &env, TypeId left,
                                  TypeId right);
static DifferResult diffPrimitive(DifferEnvironment &env, TypeId left,
                                  TypeId right);
static DifferResult diffSingleton(DifferEnvironment &env, TypeId left,
                                  TypeId right);
static DifferResult diffFunction(DifferEnvironment &env, TypeId left,
                                 TypeId right);
static DifferResult diffGeneric(DifferEnvironment &env, TypeId left,
                                TypeId right);
static DifferResult diffNegation(DifferEnvironment &env, TypeId left,
                                 TypeId right);
static DifferResult diffClass(DifferEnvironment &env, TypeId left,
                              TypeId right);
struct FindSeteqCounterexampleResult {
  // nullopt if no counterexample found
  std::optional<size_t> mismatchIdx;
  // true if counterexample is in the left, false if cex is in the right
  bool inLeft;
};
static FindSeteqCounterexampleResult
findSeteqCounterexample(DifferEnvironment &env, const std::vector<TypeId> &left,
                        const std::vector<TypeId> &right);
static DifferResult diffUnion(DifferEnvironment &env, TypeId left,
                              TypeId right);
static DifferResult diffIntersection(DifferEnvironment &env, TypeId left,
                                     TypeId right);
/**
 * The last argument gives context info on which complex type contained the
 * TypePack.
 */
static DifferResult diffTpi(DifferEnvironment &env,
                            DiffError::Kind possibleNonNormalErrorKind,
                            TypePackId left, TypePackId right);
static DifferResult diffCanonicalTpShape(
    DifferEnvironment &env, DiffError::Kind possibleNonNormalErrorKind,
    const std::pair<std::vector<TypeId>, std::optional<TypePackId>> &left,
    const std::pair<std::vector<TypeId>, std::optional<TypePackId>> &right);
static DifferResult
diffHandleFlattenedTail(DifferEnvironment &env,
                        DiffError::Kind possibleNonNormalErrorKind,
                        TypePackId left, TypePackId right);
static DifferResult diffGenericTp(DifferEnvironment &env, TypePackId left,
                                  TypePackId right);

static DifferResult diffTable(DifferEnvironment &env, TypeId left,
                              TypeId right) {
  const TableType *leftTable = get<TableType>(left);
  const TableType *rightTable = get<TableType>(right);
  LUAU_ASSERT(leftTable);
  LUAU_ASSERT(rightTable);

  for (auto const &[field, value] : leftTable->props) {
    if (rightTable->props.find(field) == rightTable->props.end()) {
      // left has a field the right doesn't
      return DifferResult{DiffError{
          DiffError::Kind::MissingTableProperty,
          DiffPathNodeLeaf::detailsTableProperty(value.type(), field),
          DiffPathNodeLeaf::nullopts(),
          env.getDevFixFriendlyNameLeft(),
          env.getDevFixFriendlyNameRight(),
      }};
    }
  }
  for (auto const &[field, value] : rightTable->props) {
    if (leftTable->props.find(field) == leftTable->props.end()) {
      // right has a field the left doesn't
      return DifferResult{DiffError{
          DiffError::Kind::MissingTableProperty, DiffPathNodeLeaf::nullopts(),
          DiffPathNodeLeaf::detailsTableProperty(value.type(), field),
          env.getDevFixFriendlyNameLeft(), env.getDevFixFriendlyNameRight()}};
    }
  }
  // left and right have the same set of keys
  for (auto const &[field, leftValue] : leftTable->props) {
    auto const &rightValue = rightTable->props.at(field);
    DifferResult differResult =
        diffUsingEnv(env, leftValue.type(), rightValue.type());
    if (differResult.diffError.has_value()) {
      differResult.wrapDiffPath(
          DiffPathNode::constructWithTableProperty(field));
      return differResult;
    }
  }
  return DifferResult{};
}

static DifferResult diffMetatable(DifferEnvironment &env, TypeId left,
                                  TypeId right) {
  const MetatableType *leftMetatable = get<MetatableType>(left);
  const MetatableType *rightMetatable = get<MetatableType>(right);
  LUAU_ASSERT(leftMetatable);
  LUAU_ASSERT(rightMetatable);

  DifferResult diffRes =
      diffUsingEnv(env, leftMetatable->table, rightMetatable->table);
  if (diffRes.diffError.has_value()) {
    return diffRes;
  }

  diffRes =
      diffUsingEnv(env, leftMetatable->metatable, rightMetatable->metatable);
  if (diffRes.diffError.has_value()) {
    diffRes.wrapDiffPath(
        DiffPathNode::constructWithTableProperty("__metatable"));
    return diffRes;
  }
  return DifferResult{};
}

static DifferResult diffPrimitive(DifferEnvironment &env, TypeId left,
                                  TypeId right) {
  const PrimitiveType *leftPrimitive = get<PrimitiveType>(left);
  const PrimitiveType *rightPrimitive = get<PrimitiveType>(right);
  LUAU_ASSERT(leftPrimitive);
  LUAU_ASSERT(rightPrimitive);

  if (leftPrimitive->type != rightPrimitive->type) {
    return DifferResult{DiffError{
        DiffError::Kind::Normal,
        DiffPathNodeLeaf::detailsNormal(left),
        DiffPathNodeLeaf::detailsNormal(right),
        env.getDevFixFriendlyNameLeft(),
        env.getDevFixFriendlyNameRight(),
    }};
  }
  return DifferResult{};
}

static DifferResult diffSingleton(DifferEnvironment &env, TypeId left,
                                  TypeId right) {
  const SingletonType *leftSingleton = get<SingletonType>(left);
  const SingletonType *rightSingleton = get<SingletonType>(right);
  LUAU_ASSERT(leftSingleton);
  LUAU_ASSERT(rightSingleton);

  if (*leftSingleton != *rightSingleton) {
    return DifferResult{DiffError{
        DiffError::Kind::Normal,
        DiffPathNodeLeaf::detailsNormal(left),
        DiffPathNodeLeaf::detailsNormal(right),
        env.getDevFixFriendlyNameLeft(),
        env.getDevFixFriendlyNameRight(),
    }};
  }
  return DifferResult{};
}

static DifferResult diffFunction(DifferEnvironment &env, TypeId left,
                                 TypeId right) {
  const FunctionType *leftFunction = get<FunctionType>(left);
  const FunctionType *rightFunction = get<FunctionType>(right);
  LUAU_ASSERT(leftFunction);
  LUAU_ASSERT(rightFunction);

  DifferResult differResult =
      diffTpi(env, DiffError::Kind::LengthMismatchInFnArgs,
              leftFunction->argTypes, rightFunction->argTypes);
  if (differResult.diffError.has_value())
    return differResult;
  return diffTpi(env, DiffError::Kind::LengthMismatchInFnRets,
                 leftFunction->retTypes, rightFunction->retTypes);
}

static DifferResult diffGeneric(DifferEnvironment &env, TypeId left,
                                TypeId right) {
  LUAU_ASSERT(get<GenericType>(left));
  LUAU_ASSERT(get<GenericType>(right));
  // Try to pair up the generics
  bool isLeftFree = !env.genericMatchedPairs.contains(left);
  bool isRightFree = !env.genericMatchedPairs.contains(right);
  if (isLeftFree && isRightFree) {
    env.genericMatchedPairs[left] = right;
    env.genericMatchedPairs[right] = left;
    return DifferResult{};
  } else if (isLeftFree || isRightFree) {
    return DifferResult{DiffError{
        DiffError::Kind::IncompatibleGeneric,
        DiffPathNodeLeaf::nullopts(),
        DiffPathNodeLeaf::nullopts(),
        env.getDevFixFriendlyNameLeft(),
        env.getDevFixFriendlyNameRight(),
    }};
  }

  // Both generics are already paired up
  if (*env.genericMatchedPairs.find(left) == right)
    return DifferResult{};

  return DifferResult{DiffError{
      DiffError::Kind::IncompatibleGeneric,
      DiffPathNodeLeaf::nullopts(),
      DiffPathNodeLeaf::nullopts(),
      env.getDevFixFriendlyNameLeft(),
      env.getDevFixFriendlyNameRight(),
  }};
}

static DifferResult diffNegation(DifferEnvironment &env, TypeId left,
                                 TypeId right) {
  const NegationType *leftNegation = get<NegationType>(left);
  const NegationType *rightNegation = get<NegationType>(right);
  LUAU_ASSERT(leftNegation);
  LUAU_ASSERT(rightNegation);

  DifferResult differResult =
      diffUsingEnv(env, leftNegation->ty, rightNegation->ty);
  if (!differResult.diffError.has_value())
    return DifferResult{};

  differResult.wrapDiffPath(
      DiffPathNode::constructWithKind(DiffPathNode::Kind::Negation));
  return differResult;
}

static DifferResult diffClass(DifferEnvironment &env, TypeId left,
                              TypeId right) {
  const ClassType *leftClass = get<ClassType>(left);
  const ClassType *rightClass = get<ClassType>(right);
  LUAU_ASSERT(leftClass);
  LUAU_ASSERT(rightClass);

  if (leftClass == rightClass) {
    return DifferResult{};
  }

  return DifferResult{DiffError{
      DiffError::Kind::Normal,
      DiffPathNodeLeaf::detailsNormal(left),
      DiffPathNodeLeaf::detailsNormal(right),
      env.getDevFixFriendlyNameLeft(),
      env.getDevFixFriendlyNameRight(),
  }};
}

static FindSeteqCounterexampleResult
findSeteqCounterexample(DifferEnvironment &env, const std::vector<TypeId> &left,
                        const std::vector<TypeId> &right) {
  std::unordered_set<size_t> unmatchedRightIdxes;
  for (size_t i = 0; i < right.size(); i++)
    unmatchedRightIdxes.insert(i);
  for (size_t leftIdx = 0; leftIdx < left.size(); leftIdx++) {
    bool leftIdxIsMatched = false;
    auto unmatchedRightIdxIt = unmatchedRightIdxes.begin();
    while (unmatchedRightIdxIt != unmatchedRightIdxes.end()) {
      DifferResult differResult =
          diffUsingEnv(env, left[leftIdx], right[*unmatchedRightIdxIt]);
      if (differResult.diffError.has_value()) {
        unmatchedRightIdxIt++;
        continue;
      }
      // unmatchedRightIdxIt is matched with current leftIdx
      env.recordProvenEqual(left[leftIdx], right[*unmatchedRightIdxIt]);
      leftIdxIsMatched = true;
      unmatchedRightIdxIt = unmatchedRightIdxes.erase(unmatchedRightIdxIt);
    }
    if (!leftIdxIsMatched) {
      return FindSeteqCounterexampleResult{leftIdx, true};
    }
  }
  if (unmatchedRightIdxes.empty())
    return FindSeteqCounterexampleResult{std::nullopt, false};
  return FindSeteqCounterexampleResult{*unmatchedRightIdxes.begin(), false};
}

static DifferResult diffUnion(DifferEnvironment &env, TypeId left,
                              TypeId right) {
  const UnionType *leftUnion = get<UnionType>(left);
  const UnionType *rightUnion = get<UnionType>(right);
  LUAU_ASSERT(leftUnion);
  LUAU_ASSERT(rightUnion);

  FindSeteqCounterexampleResult findSeteqCexResult =
      findSeteqCounterexample(env, leftUnion->options, rightUnion->options);
  if (findSeteqCexResult.mismatchIdx.has_value()) {
    if (findSeteqCexResult.inLeft)
      return DifferResult{DiffError{
          DiffError::Kind::MissingUnionMember,
          DiffPathNodeLeaf::detailsUnionIndex(
              leftUnion->options[*findSeteqCexResult.mismatchIdx],
              *findSeteqCexResult.mismatchIdx),
          DiffPathNodeLeaf::nullopts(),
          env.getDevFixFriendlyNameLeft(),
          env.getDevFixFriendlyNameRight(),
      }};
    else
      return DifferResult{DiffError{
          DiffError::Kind::MissingUnionMember,
          DiffPathNodeLeaf::nullopts(),
          DiffPathNodeLeaf::detailsUnionIndex(
              rightUnion->options[*findSeteqCexResult.mismatchIdx],
              *findSeteqCexResult.mismatchIdx),
          env.getDevFixFriendlyNameLeft(),
          env.getDevFixFriendlyNameRight(),
      }};
  }

  // TODO: somehow detect mismatch index, likely using heuristics

  return DifferResult{};
}

static DifferResult diffIntersection(DifferEnvironment &env, TypeId left,
                                     TypeId right) {
  const IntersectionType *leftIntersection = get<IntersectionType>(left);
  const IntersectionType *rightIntersection = get<IntersectionType>(right);
  LUAU_ASSERT(leftIntersection);
  LUAU_ASSERT(rightIntersection);

  FindSeteqCounterexampleResult findSeteqCexResult = findSeteqCounterexample(
      env, leftIntersection->parts, rightIntersection->parts);
  if (findSeteqCexResult.mismatchIdx.has_value()) {
    if (findSeteqCexResult.inLeft)
      return DifferResult{DiffError{
          DiffError::Kind::MissingIntersectionMember,
          DiffPathNodeLeaf::detailsUnionIndex(
              leftIntersection->parts[*findSeteqCexResult.mismatchIdx],
              *findSeteqCexResult.mismatchIdx),
          DiffPathNodeLeaf::nullopts(),
          env.getDevFixFriendlyNameLeft(),
          env.getDevFixFriendlyNameRight(),
      }};
    else
      return DifferResult{DiffError{
          DiffError::Kind::MissingIntersectionMember,
          DiffPathNodeLeaf::nullopts(),
          DiffPathNodeLeaf::detailsUnionIndex(
              rightIntersection->parts[*findSeteqCexResult.mismatchIdx],
              *findSeteqCexResult.mismatchIdx),
          env.getDevFixFriendlyNameLeft(),
          env.getDevFixFriendlyNameRight(),
      }};
  }

  // TODO: somehow detect mismatch index, likely using heuristics

  return DifferResult{};
}

static DifferResult diffUsingEnv(DifferEnvironment &env, TypeId left,
                                 TypeId right) {
  left = follow(left);
  right = follow(right);

  if (left->ty.index() != right->ty.index()) {
    return DifferResult{DiffError{
        DiffError::Kind::Normal,
        DiffPathNodeLeaf::detailsNormal(left),
        DiffPathNodeLeaf::detailsNormal(right),
        env.getDevFixFriendlyNameLeft(),
        env.getDevFixFriendlyNameRight(),
    }};
  }

  // Both left and right are the same variant

  // Check cycles & caches
  if (env.isAssumedEqual(left, right) || env.isProvenEqual(left, right))
    return DifferResult{};

  if (isSimple(left)) {
    if (auto lp = get<PrimitiveType>(left))
      return diffPrimitive(env, left, right);
    else if (auto ls = get<SingletonType>(left)) {
      return diffSingleton(env, left, right);
    } else if (auto la = get<AnyType>(left)) {
      // Both left and right must be Any if either is Any for them to be equal!
      return DifferResult{};
    } else if (auto lu = get<UnknownType>(left)) {
      return DifferResult{};
    } else if (auto ln = get<NeverType>(left)) {
      return DifferResult{};
    } else if (auto ln = get<NegationType>(left)) {
      return diffNegation(env, left, right);
    } else if (auto lc = get<ClassType>(left)) {
      return diffClass(env, left, right);
    }

    throw InternalCompilerError{
        "Unimplemented Simple TypeId variant for diffing"};
  }

  // Both left and right are the same non-Simple
  // Non-simple types must record visits in the DifferEnvironment
  env.pushVisiting(left, right);

  if (auto lt = get<TableType>(left)) {
    DifferResult diffRes = diffTable(env, left, right);
    if (!diffRes.diffError.has_value()) {
      env.recordProvenEqual(left, right);
    }
    env.popVisiting();
    return diffRes;
  }
  if (auto lm = get<MetatableType>(left)) {
    env.popVisiting();
    return diffMetatable(env, left, right);
  }
  if (auto lf = get<FunctionType>(left)) {
    DifferResult diffRes = diffFunction(env, left, right);
    if (!diffRes.diffError.has_value()) {
      env.recordProvenEqual(left, right);
    }
    env.popVisiting();
    return diffRes;
  }
  if (auto lg = get<GenericType>(left)) {
    DifferResult diffRes = diffGeneric(env, left, right);
    if (!diffRes.diffError.has_value()) {
      env.recordProvenEqual(left, right);
    }
    env.popVisiting();
    return diffRes;
  }
  if (auto lu = get<UnionType>(left)) {
    DifferResult diffRes = diffUnion(env, left, right);
    if (!diffRes.diffError.has_value()) {
      env.recordProvenEqual(left, right);
    }
    env.popVisiting();
    return diffRes;
  }
  if (auto li = get<IntersectionType>(left)) {
    DifferResult diffRes = diffIntersection(env, left, right);
    if (!diffRes.diffError.has_value()) {
      env.recordProvenEqual(left, right);
    }
    env.popVisiting();
    return diffRes;
  }
  if (auto le = get<Luau::Unifiable::Error>(left)) {
    // TODO: return debug-friendly result state
    env.popVisiting();
    return DifferResult{};
  }

  throw InternalCompilerError{
      "Unimplemented non-simple TypeId variant for diffing"};
}

static DifferResult diffTpi(DifferEnvironment &env,
                            DiffError::Kind possibleNonNormalErrorKind,
                            TypePackId left, TypePackId right) {
  left = follow(left);
  right = follow(right);

  // Canonicalize
  std::pair<std::vector<TypeId>, std::optional<TypePackId>> leftFlatTpi =
      flatten(left);
  std::pair<std::vector<TypeId>, std::optional<TypePackId>> rightFlatTpi =
      flatten(right);

  // Check for shape equality
  DifferResult diffResult = diffCanonicalTpShape(
      env, possibleNonNormalErrorKind, leftFlatTpi, rightFlatTpi);
  if (diffResult.diffError.has_value()) {
    return diffResult;
  }

  // Left and Right have the same shape
  for (size_t i = 0; i < leftFlatTpi.first.size(); i++) {
    DifferResult differResult =
        diffUsingEnv(env, leftFlatTpi.first[i], rightFlatTpi.first[i]);
    if (!differResult.diffError.has_value())
      continue;

    switch (possibleNonNormalErrorKind) {
    case DiffError::Kind::LengthMismatchInFnArgs: {
      differResult.wrapDiffPath(DiffPathNode::constructWithKindAndIndex(
          DiffPathNode::Kind::FunctionArgument, i));
      return differResult;
    }
    case DiffError::Kind::LengthMismatchInFnRets: {
      differResult.wrapDiffPath(DiffPathNode::constructWithKindAndIndex(
          DiffPathNode::Kind::FunctionReturn, i));
      return differResult;
    }
    default: {
      throw InternalCompilerError{"Unhandled Tpi diffing case with same shape"};
    }
    }
  }
  if (!leftFlatTpi.second.has_value())
    return DifferResult{};

  return diffHandleFlattenedTail(env, possibleNonNormalErrorKind,
                                 *leftFlatTpi.second, *rightFlatTpi.second);
}

static DifferResult diffCanonicalTpShape(
    DifferEnvironment &env, DiffError::Kind possibleNonNormalErrorKind,
    const std::pair<std::vector<TypeId>, std::optional<TypePackId>> &left,
    const std::pair<std::vector<TypeId>, std::optional<TypePackId>> &right) {
  if (left.first.size() == right.first.size() &&
      left.second.has_value() == right.second.has_value())
    return DifferResult{};

  return DifferResult{DiffError{
      possibleNonNormalErrorKind,
      DiffPathNodeLeaf::detailsLength(int(left.first.size()),
                                      left.second.has_value()),
      DiffPathNodeLeaf::detailsLength(int(right.first.size()),
                                      right.second.has_value()),
      env.getDevFixFriendlyNameLeft(),
      env.getDevFixFriendlyNameRight(),
  }};
}

static DifferResult
diffHandleFlattenedTail(DifferEnvironment &env,
                        DiffError::Kind possibleNonNormalErrorKind,
                        TypePackId left, TypePackId right) {
  left = follow(left);
  right = follow(right);

  if (left->ty.index() != right->ty.index()) {
    return DifferResult{DiffError{
        DiffError::Kind::Normal,
        DiffPathNodeLeaf::detailsNormal(env.visitingBegin()->first),
        DiffPathNodeLeaf::detailsNormal(env.visitingBegin()->second),
        env.getDevFixFriendlyNameLeft(),
        env.getDevFixFriendlyNameRight(),
    }};
  }

  // Both left and right are the same variant

  if (auto lv = get<VariadicTypePack>(left)) {
    auto rv = get<VariadicTypePack>(right);
    DifferResult differResult = diffUsingEnv(env, lv->ty, rv->ty);
    if (!differResult.diffError.has_value())
      return DifferResult{};

    switch (possibleNonNormalErrorKind) {
    case DiffError::Kind::LengthMismatchInFnArgs: {
      differResult.wrapDiffPath(DiffPathNode::constructWithKind(
          DiffPathNode::Kind::FunctionArgument));
      return differResult;
    }
    case DiffError::Kind::LengthMismatchInFnRets: {
      differResult.wrapDiffPath(
          DiffPathNode::constructWithKind(DiffPathNode::Kind::FunctionReturn));
      return differResult;
    }
    default: {
      throw InternalCompilerError{
          "Unhandled flattened tail case for VariadicTypePack"};
    }
    }
  }
  if (auto lg = get<GenericTypePack>(left)) {
    DifferResult diffRes = diffGenericTp(env, left, right);
    if (!diffRes.diffError.has_value())
      return DifferResult{};
    switch (possibleNonNormalErrorKind) {
    case DiffError::Kind::LengthMismatchInFnArgs: {
      diffRes.wrapDiffPath(DiffPathNode::constructWithKind(
          DiffPathNode::Kind::FunctionArgument));
      return diffRes;
    }
    case DiffError::Kind::LengthMismatchInFnRets: {
      diffRes.wrapDiffPath(
          DiffPathNode::constructWithKind(DiffPathNode::Kind::FunctionReturn));
      return diffRes;
    }
    default: {
      throw InternalCompilerError{
          "Unhandled flattened tail case for GenericTypePack"};
    }
    }
  }

  throw InternalCompilerError{
      "Unhandled tail type pack variant for flattened tails"};
}

static DifferResult diffGenericTp(DifferEnvironment &env, TypePackId left,
                                  TypePackId right) {
  LUAU_ASSERT(get<GenericTypePack>(left));
  LUAU_ASSERT(get<GenericTypePack>(right));
  // Try to pair up the generics
  bool isLeftFree = !env.genericTpMatchedPairs.contains(left);
  bool isRightFree = !env.genericTpMatchedPairs.contains(right);
  if (isLeftFree && isRightFree) {
    env.genericTpMatchedPairs[left] = right;
    env.genericTpMatchedPairs[right] = left;
    return DifferResult{};
  } else if (isLeftFree || isRightFree) {
    return DifferResult{DiffError{
        DiffError::Kind::IncompatibleGeneric,
        DiffPathNodeLeaf::nullopts(),
        DiffPathNodeLeaf::nullopts(),
        env.getDevFixFriendlyNameLeft(),
        env.getDevFixFriendlyNameRight(),
    }};
  }

  // Both generics are already paired up
  if (*env.genericTpMatchedPairs.find(left) == right)
    return DifferResult{};

  return DifferResult{DiffError{
      DiffError::Kind::IncompatibleGeneric,
      DiffPathNodeLeaf::nullopts(),
      DiffPathNodeLeaf::nullopts(),
      env.getDevFixFriendlyNameLeft(),
      env.getDevFixFriendlyNameRight(),
  }};
}

bool DifferEnvironment::isProvenEqual(TypeId left, TypeId right) const {
  return provenEqual.find({left, right}) != provenEqual.end();
}

bool DifferEnvironment::isAssumedEqual(TypeId left, TypeId right) const {
  return visiting.find({left, right}) != visiting.end();
}

void DifferEnvironment::recordProvenEqual(TypeId left, TypeId right) {
  provenEqual.insert({left, right});
  provenEqual.insert({right, left});
}

void DifferEnvironment::pushVisiting(TypeId left, TypeId right) {
  LUAU_ASSERT(visiting.find({left, right}) == visiting.end());
  LUAU_ASSERT(visiting.find({right, left}) == visiting.end());
  visitingStack.push_back({left, right});
  visiting.insert({left, right});
  visiting.insert({right, left});
}

void DifferEnvironment::popVisiting() {
  auto tyPair = visitingStack.back();
  visiting.erase({tyPair.first, tyPair.second});
  visiting.erase({tyPair.second, tyPair.first});
  visitingStack.pop_back();
}

std::vector<std::pair<TypeId, TypeId>>::const_reverse_iterator
DifferEnvironment::visitingBegin() const {
  return visitingStack.crbegin();
}

std::vector<std::pair<TypeId, TypeId>>::const_reverse_iterator
DifferEnvironment::visitingEnd() const {
  return visitingStack.crend();
}

DifferResult diff(TypeId ty1, TypeId ty2) {
  DifferEnvironment differEnv{ty1, ty2, std::nullopt, std::nullopt};
  return diffUsingEnv(differEnv, ty1, ty2);
}

DifferResult diffWithSymbols(TypeId ty1, TypeId ty2,
                             std::optional<std::string> symbol1,
                             std::optional<std::string> symbol2) {
  DifferEnvironment differEnv{ty1, ty2, symbol1, symbol2};
  return diffUsingEnv(differEnv, ty1, ty2);
}

bool isSimple(TypeId ty) {
  ty = follow(ty);
  // TODO: think about GenericType, etc.
  return get<PrimitiveType>(ty) || get<SingletonType>(ty) || get<AnyType>(ty) ||
         get<NegationType>(ty) || get<ClassType>(ty) || get<UnknownType>(ty) ||
         get<NeverType>(ty);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/DataFlowGraph.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Def.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : was already included! <optional>

LUAU_FASTFLAG(DebugLuauFreezeArena)
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

namespace Luau {

bool doesCallError(const AstExprCall *call); // TypeInfer.cpp

const RefinementKey *RefinementKeyArena::leaf(DefId def) {
  return allocator.allocate(RefinementKey{nullptr, def, std::nullopt});
}

const RefinementKey *RefinementKeyArena::node(const RefinementKey *parent,
                                              DefId def,
                                              const std::string &propName) {
  return allocator.allocate(RefinementKey{parent, def, propName});
}

DefId DataFlowGraph::getDef(const AstExpr *expr) const {
  auto def = astDefs.find(expr);
  LUAU_ASSERT(def);
  return NotNull{*def};
}

std::optional<DefId>
DataFlowGraph::getRValueDefForCompoundAssign(const AstExpr *expr) const {
  auto def = compoundAssignDefs.find(expr);
  return def ? std::optional<DefId>(*def) : std::nullopt;
}

DefId DataFlowGraph::getDef(const AstLocal *local) const {
  auto def = localDefs.find(local);
  LUAU_ASSERT(def);
  return NotNull{*def};
}

DefId DataFlowGraph::getDef(const AstStatDeclareGlobal *global) const {
  auto def = declaredDefs.find(global);
  LUAU_ASSERT(def);
  return NotNull{*def};
}

DefId DataFlowGraph::getDef(const AstStatDeclareFunction *func) const {
  auto def = declaredDefs.find(func);
  LUAU_ASSERT(def);
  return NotNull{*def};
}

const RefinementKey *
DataFlowGraph::getRefinementKey(const AstExpr *expr) const {
  if (auto key = astRefinementKeys.find(expr))
    return *key;

  return nullptr;
}

std::optional<DefId> DfgScope::lookup(Symbol symbol) const {
  for (const DfgScope *current = this; current; current = current->parent) {
    if (auto def = current->bindings.find(symbol))
      return NotNull{*def};
  }

  return std::nullopt;
}

std::optional<DefId> DfgScope::lookup(DefId def, const std::string &key) const {
  for (const DfgScope *current = this; current; current = current->parent) {
    if (auto props = current->props.find(def)) {
      if (auto it = props->find(key); it != props->end())
        return NotNull{it->second};
    }
  }

  return std::nullopt;
}

void DfgScope::inherit(const DfgScope *childScope) {
  for (const auto &[k, a] : childScope->bindings) {
    if (lookup(k))
      bindings[k] = a;
  }

  for (const auto &[k1, a1] : childScope->props) {
    for (const auto &[k2, a2] : a1)
      props[k1][k2] = a2;
  }
}

bool DfgScope::canUpdateDefinition(Symbol symbol) const {
  for (const DfgScope *current = this; current; current = current->parent) {
    if (current->bindings.find(symbol))
      return true;
    else if (current->scopeType == DfgScope::Loop)
      return false;
  }

  return true;
}

bool DfgScope::canUpdateDefinition(DefId def, const std::string &key) const {
  for (const DfgScope *current = this; current; current = current->parent) {
    if (auto props = current->props.find(def))
      return true;
    else if (current->scopeType == DfgScope::Loop)
      return false;
  }

  return true;
}

DataFlowGraph
DataFlowGraphBuilder::build(AstStatBlock *block,
                            NotNull<InternalErrorReporter> handle) {
  LUAU_ASSERT(FFlag::DebugLuauDeferredConstraintResolution);

  DataFlowGraphBuilder builder;
  builder.handle = handle;
  builder.moduleScope =
      builder.childScope(nullptr); // nullptr is the root DFG scope.
  builder.visitBlockWithoutChildScope(builder.moduleScope, block);
  builder.resolveCaptures();

  if (FFlag::DebugLuauFreezeArena) {
    builder.defArena->allocator.freeze();
    builder.keyArena->allocator.freeze();
  }

  return std::move(builder.graph);
}

void DataFlowGraphBuilder::resolveCaptures() {
  for (const auto &[_, capture] : captures) {
    std::vector<DefId> operands;
    for (size_t i = capture.versionOffset; i < capture.allVersions.size(); ++i)
      collectOperands(capture.allVersions[i], &operands);

    for (DefId captureDef : capture.captureDefs) {
      Phi *phi = const_cast<Phi *>(get<Phi>(captureDef));
      LUAU_ASSERT(phi);
      LUAU_ASSERT(phi->operands.empty());
      phi->operands = operands;
    }
  }
}

DfgScope *DataFlowGraphBuilder::childScope(DfgScope *scope,
                                           DfgScope::ScopeType scopeType) {
  return scopes.emplace_back(new DfgScope{scope, scopeType}).get();
}

void DataFlowGraphBuilder::join(DfgScope *p, DfgScope *a, DfgScope *b) {
  joinBindings(p, *a, *b);
  joinProps(p, *a, *b);
}

void DataFlowGraphBuilder::joinBindings(DfgScope *p, const DfgScope &a,
                                        const DfgScope &b) {
  for (const auto &[sym, def1] : a.bindings) {
    if (auto def2 = b.bindings.find(sym))
      p->bindings[sym] = defArena->phi(NotNull{def1}, NotNull{*def2});
    else if (auto def2 = p->lookup(sym))
      p->bindings[sym] = defArena->phi(NotNull{def1}, NotNull{*def2});
  }

  for (const auto &[sym, def1] : b.bindings) {
    if (auto def2 = p->lookup(sym))
      p->bindings[sym] = defArena->phi(NotNull{def1}, NotNull{*def2});
  }
}

void DataFlowGraphBuilder::joinProps(DfgScope *result, const DfgScope &a,
                                     const DfgScope &b) {
  auto phinodify = [this](DfgScope *scope, const auto &a, const auto &b,
                          DefId parent) mutable {
    auto &p = scope->props[parent];
    for (const auto &[k, defA] : a) {
      if (auto it = b.find(k); it != b.end())
        p[k] = defArena->phi(NotNull{it->second}, NotNull{defA});
      else if (auto it = p.find(k); it != p.end())
        p[k] = defArena->phi(NotNull{it->second}, NotNull{defA});
      else if (auto def2 = scope->lookup(parent, k))
        p[k] = defArena->phi(*def2, NotNull{defA});
      else
        p[k] = defA;
    }

    for (const auto &[k, defB] : b) {
      if (auto it = a.find(k); it != a.end())
        continue;
      else if (auto it = p.find(k); it != p.end())
        p[k] = defArena->phi(NotNull{it->second}, NotNull{defB});
      else if (auto def2 = scope->lookup(parent, k))
        p[k] = defArena->phi(*def2, NotNull{defB});
      else
        p[k] = defB;
    }
  };

  for (const auto &[def, a1] : a.props) {
    result->props.try_insert(def, {});
    if (auto a2 = b.props.find(def))
      phinodify(result, a1, *a2, NotNull{def});
    else if (auto a2 = result->props.find(def))
      phinodify(result, a1, *a2, NotNull{def});
  }

  for (const auto &[def, a1] : b.props) {
    result->props.try_insert(def, {});
    if (a.props.find(def))
      continue;
    else if (auto a2 = result->props.find(def))
      phinodify(result, a1, *a2, NotNull{def});
  }
}

DefId DataFlowGraphBuilder::lookup(DfgScope *scope, Symbol symbol) {
  // true if any of the considered scopes are a loop.
  bool outsideLoopScope = false;
  for (DfgScope *current = scope; current; current = current->parent) {
    outsideLoopScope = outsideLoopScope || current->scopeType == DfgScope::Loop;

    if (auto found = current->bindings.find(symbol))
      return NotNull{*found};
    else if (current->scopeType == DfgScope::Function) {
      FunctionCapture &capture = captures[symbol];
      DefId captureDef = defArena->phi({});
      capture.captureDefs.push_back(captureDef);

      // If we are outside of a loop scope, then we don't want to actually bind
      // uses of `symbol` to this new phi node since it will not get populated.
      if (!outsideLoopScope)
        scope->bindings[symbol] = captureDef;

      return NotNull{captureDef};
    }
  }

  DefId result = defArena->freshCell();
  scope->bindings[symbol] = result;
  captures[symbol].allVersions.push_back(result);
  return result;
}

DefId DataFlowGraphBuilder::lookup(DfgScope *scope, DefId def,
                                   const std::string &key) {
  for (DfgScope *current = scope; current; current = current->parent) {
    if (auto props = current->props.find(def)) {
      if (auto it = props->find(key); it != props->end())
        return NotNull{it->second};
    } else if (auto phi = get<Phi>(def);
               phi && phi->operands.empty()) // Unresolved phi nodes
    {
      DefId result = defArena->freshCell();
      scope->props[def][key] = result;
      return result;
    }
  }

  if (auto phi = get<Phi>(def)) {
    std::vector<DefId> defs;
    for (DefId operand : phi->operands)
      defs.push_back(lookup(scope, operand, key));

    DefId result = defArena->phi(defs);
    scope->props[def][key] = result;
    return result;
  } else if (get<Cell>(def)) {
    DefId result = defArena->freshCell();
    scope->props[def][key] = result;
    return result;
  } else
    handle->ice("Inexhaustive lookup cases in DataFlowGraphBuilder::lookup");
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatBlock *b) {
  DfgScope *child = childScope(scope);
  ControlFlow cf = visitBlockWithoutChildScope(child, b);
  scope->inherit(child);
  return cf;
}

ControlFlow DataFlowGraphBuilder::visitBlockWithoutChildScope(DfgScope *scope,
                                                              AstStatBlock *b) {
  std::optional<ControlFlow> firstControlFlow;
  for (AstStat *stat : b->body) {
    ControlFlow cf = visit(scope, stat);
    if (cf != ControlFlow::None && !firstControlFlow)
      firstControlFlow = cf;
  }

  return firstControlFlow.value_or(ControlFlow::None);
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStat *s) {
  if (auto b = s->as<AstStatBlock>())
    return visit(scope, b);
  else if (auto i = s->as<AstStatIf>())
    return visit(scope, i);
  else if (auto w = s->as<AstStatWhile>())
    return visit(scope, w);
  else if (auto r = s->as<AstStatRepeat>())
    return visit(scope, r);
  else if (auto b = s->as<AstStatBreak>())
    return visit(scope, b);
  else if (auto c = s->as<AstStatContinue>())
    return visit(scope, c);
  else if (auto r = s->as<AstStatReturn>())
    return visit(scope, r);
  else if (auto e = s->as<AstStatExpr>())
    return visit(scope, e);
  else if (auto l = s->as<AstStatLocal>())
    return visit(scope, l);
  else if (auto f = s->as<AstStatFor>())
    return visit(scope, f);
  else if (auto f = s->as<AstStatForIn>())
    return visit(scope, f);
  else if (auto a = s->as<AstStatAssign>())
    return visit(scope, a);
  else if (auto c = s->as<AstStatCompoundAssign>())
    return visit(scope, c);
  else if (auto f = s->as<AstStatFunction>())
    return visit(scope, f);
  else if (auto l = s->as<AstStatLocalFunction>())
    return visit(scope, l);
  else if (auto t = s->as<AstStatTypeAlias>())
    return visit(scope, t);
  else if (auto d = s->as<AstStatDeclareGlobal>())
    return visit(scope, d);
  else if (auto d = s->as<AstStatDeclareFunction>())
    return visit(scope, d);
  else if (auto d = s->as<AstStatDeclareClass>())
    return visit(scope, d);
  else if (auto error = s->as<AstStatError>())
    return visit(scope, error);
  else
    handle->ice("Unknown AstStat in DataFlowGraphBuilder::visit");
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatIf *i) {
  visitExpr(scope, i->condition);

  DfgScope *thenScope = childScope(scope);
  DfgScope *elseScope = childScope(scope);

  ControlFlow thencf = visit(thenScope, i->thenbody);
  ControlFlow elsecf = ControlFlow::None;
  if (i->elsebody)
    elsecf = visit(elseScope, i->elsebody);

  if (thencf != ControlFlow::None && elsecf == ControlFlow::None)
    join(scope, scope, elseScope);
  else if (thencf == ControlFlow::None && elsecf != ControlFlow::None)
    join(scope, thenScope, scope);
  else if ((thencf | elsecf) == ControlFlow::None)
    join(scope, thenScope, elseScope);

  if (thencf == elsecf)
    return thencf;
  else if (matches(thencf, ControlFlow::Returns | ControlFlow::Throws) &&
           matches(elsecf, ControlFlow::Returns | ControlFlow::Throws))
    return ControlFlow::Returns;
  else
    return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatWhile *w) {
  // TODO(controlflow): entry point has a back edge from exit point
  DfgScope *whileScope = childScope(scope, DfgScope::Loop);
  visitExpr(whileScope, w->condition);
  visit(whileScope, w->body);

  scope->inherit(whileScope);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatRepeat *r) {
  // TODO(controlflow): entry point has a back edge from exit point
  DfgScope *repeatScope = childScope(scope, DfgScope::Loop);
  visitBlockWithoutChildScope(repeatScope, r->body);
  visitExpr(repeatScope, r->condition);

  scope->inherit(repeatScope);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatBreak *b) {
  return ControlFlow::Breaks;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatContinue *c) {
  return ControlFlow::Continues;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatReturn *r) {
  for (AstExpr *e : r->list)
    visitExpr(scope, e);

  return ControlFlow::Returns;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatExpr *e) {
  visitExpr(scope, e->expr);
  if (auto call = e->expr->as<AstExprCall>(); call && doesCallError(call))
    return ControlFlow::Throws;
  else
    return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatLocal *l) {
  // We're gonna need a `visitExprList` and `visitVariadicExpr` (function calls
  // and `...`)
  std::vector<DefId> defs;
  defs.reserve(l->values.size);
  for (AstExpr *e : l->values)
    defs.push_back(visitExpr(scope, e).def);

  for (size_t i = 0; i < l->vars.size; ++i) {
    AstLocal *local = l->vars.data[i];
    if (local->annotation)
      visitType(scope, local->annotation);

    // We need to create a new def to intentionally avoid alias tracking, but
    // we'd like to make sure that the non-aliased defs are also marked as a
    // subscript for refinements.
    bool subscripted =
        i < defs.size() && containsSubscriptedDefinition(defs[i]);
    DefId def = defArena->freshCell(subscripted);
    if (i < l->values.size) {
      AstExpr *e = l->values.data[i];
      if (const AstExprTable *tbl = e->as<AstExprTable>()) {
        def = defs[i];
      }
    }
    graph.localDefs[local] = def;
    scope->bindings[local] = def;
    captures[local].allVersions.push_back(def);
  }

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatFor *f) {
  DfgScope *forScope = childScope(scope, DfgScope::Loop);

  visitExpr(scope, f->from);
  visitExpr(scope, f->to);
  if (f->step)
    visitExpr(scope, f->step);

  if (f->var->annotation)
    visitType(forScope, f->var->annotation);

  DefId def = defArena->freshCell();
  graph.localDefs[f->var] = def;
  scope->bindings[f->var] = def;
  captures[f->var].allVersions.push_back(def);

  // TODO(controlflow): entry point has a back edge from exit point
  visit(forScope, f->body);

  scope->inherit(forScope);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatForIn *f) {
  DfgScope *forScope = childScope(scope, DfgScope::Loop);

  for (AstLocal *local : f->vars) {
    if (local->annotation)
      visitType(forScope, local->annotation);

    DefId def = defArena->freshCell();
    graph.localDefs[local] = def;
    forScope->bindings[local] = def;
    captures[local].allVersions.push_back(def);
  }

  // TODO(controlflow): entry point has a back edge from exit point
  // We're gonna need a `visitExprList` and `visitVariadicExpr` (function calls
  // and `...`)
  for (AstExpr *e : f->values)
    visitExpr(forScope, e);

  visit(forScope, f->body);

  scope->inherit(forScope);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatAssign *a) {
  std::vector<DefId> defs;
  defs.reserve(a->values.size);
  for (AstExpr *e : a->values)
    defs.push_back(visitExpr(scope, e).def);

  for (size_t i = 0; i < a->vars.size; ++i) {
    AstExpr *v = a->vars.data[i];
    visitLValue(scope, v, i < defs.size() ? defs[i] : defArena->freshCell());
  }

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope,
                                        AstStatCompoundAssign *c) {
  // TODO: This needs revisiting because this is incorrect. The `c->var` part is
  // both being read and written to, but the `c->var` only has one pointer
  // address, so we need to come up with a way to store both. For now, it's not
  // important because we don't have type states, but it is going to be
  // important, e.g.
  //
  // local a = 5 -- a-1
  // a += 5      -- a-2 = a-1 + 5
  // We can't just visit `c->var` as a rvalue and then separately traverse
  // `c->var` as an lvalue, since that's O(n^2).
  DefId def = visitExpr(scope, c->value).def;
  visitLValue(scope, c->var, def, /* isCompoundAssignment */ true);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatFunction *f) {
  // In the old solver, we assumed that the name of the function is always a
  // function in the body but this isn't true, e.g. the following example will
  // print `5`, not a function address.
  //
  // local function f() print(f) end
  // local g = f
  // f = 5
  // g() --> 5
  //
  // which is evidence that references to variables must be a phi node of all
  // possible definitions, but for bug compatibility, we'll assume the same
  // thing here.
  visitLValue(scope, f->name, defArena->freshCell());
  visitExpr(scope, f->func);

  if (auto local = f->name->as<AstExprLocal>()) {
    // local f
    // function f()
    //   if cond() then
    //     f() -- should reference only the function version and other future
    //     version, and nothing prior
    //   end
    // end
    FunctionCapture &capture = captures[local->local];
    capture.versionOffset = capture.allVersions.size() - 1;
  }

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope,
                                        AstStatLocalFunction *l) {
  DefId def = defArena->freshCell();
  graph.localDefs[l->name] = def;
  scope->bindings[l->name] = def;
  captures[l->name].allVersions.push_back(def);
  visitExpr(scope, l->func);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatTypeAlias *t) {
  DfgScope *unreachable = childScope(scope);
  visitGenerics(unreachable, t->generics);
  visitGenericPacks(unreachable, t->genericPacks);
  visitType(unreachable, t->type);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope,
                                        AstStatDeclareGlobal *d) {
  DefId def = defArena->freshCell();
  graph.declaredDefs[d] = def;
  scope->bindings[d->name] = def;
  captures[d->name].allVersions.push_back(def);

  visitType(scope, d->type);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope,
                                        AstStatDeclareFunction *d) {
  DefId def = defArena->freshCell();
  graph.declaredDefs[d] = def;
  scope->bindings[d->name] = def;
  captures[d->name].allVersions.push_back(def);

  DfgScope *unreachable = childScope(scope);
  visitGenerics(unreachable, d->generics);
  visitGenericPacks(unreachable, d->genericPacks);
  visitTypeList(unreachable, d->params);
  visitTypeList(unreachable, d->retTypes);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope,
                                        AstStatDeclareClass *d) {
  // This declaration does not "introduce" any bindings in value namespace,
  // so there's no symbolic value to begin with. We'll traverse the properties
  // because their type annotations may depend on something in the value
  // namespace.
  DfgScope *unreachable = childScope(scope);
  for (AstDeclaredClassProp prop : d->props)
    visitType(unreachable, prop.ty);

  return ControlFlow::None;
}

ControlFlow DataFlowGraphBuilder::visit(DfgScope *scope, AstStatError *error) {
  DfgScope *unreachable = childScope(scope);
  for (AstStat *s : error->statements)
    visit(unreachable, s);
  for (AstExpr *e : error->expressions)
    visitExpr(unreachable, e);

  return ControlFlow::None;
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope, AstExpr *e) {
  // Some subexpressions could be visited two times. If we've already seen it,
  // just extract it.
  if (auto def = graph.astDefs.find(e)) {
    auto key = graph.astRefinementKeys.find(e);
    return {NotNull{*def}, key ? *key : nullptr};
  }

  auto go = [&]() -> DataFlowResult {
    if (auto g = e->as<AstExprGroup>())
      return visitExpr(scope, g);
    else if (auto c = e->as<AstExprConstantNil>())
      return {defArena->freshCell(), nullptr}; // ok
    else if (auto c = e->as<AstExprConstantBool>())
      return {defArena->freshCell(), nullptr}; // ok
    else if (auto c = e->as<AstExprConstantNumber>())
      return {defArena->freshCell(), nullptr}; // ok
    else if (auto c = e->as<AstExprConstantString>())
      return {defArena->freshCell(), nullptr}; // ok
    else if (auto l = e->as<AstExprLocal>())
      return visitExpr(scope, l);
    else if (auto g = e->as<AstExprGlobal>())
      return visitExpr(scope, g);
    else if (auto v = e->as<AstExprVarargs>())
      return {defArena->freshCell(), nullptr}; // ok
    else if (auto c = e->as<AstExprCall>())
      return visitExpr(scope, c);
    else if (auto i = e->as<AstExprIndexName>())
      return visitExpr(scope, i);
    else if (auto i = e->as<AstExprIndexExpr>())
      return visitExpr(scope, i);
    else if (auto f = e->as<AstExprFunction>())
      return visitExpr(scope, f);
    else if (auto t = e->as<AstExprTable>())
      return visitExpr(scope, t);
    else if (auto u = e->as<AstExprUnary>())
      return visitExpr(scope, u);
    else if (auto b = e->as<AstExprBinary>())
      return visitExpr(scope, b);
    else if (auto t = e->as<AstExprTypeAssertion>())
      return visitExpr(scope, t);
    else if (auto i = e->as<AstExprIfElse>())
      return visitExpr(scope, i);
    else if (auto i = e->as<AstExprInterpString>())
      return visitExpr(scope, i);
    else if (auto error = e->as<AstExprError>())
      return visitExpr(scope, error);
    else
      handle->ice("Unknown AstExpr in DataFlowGraphBuilder::visitExpr");
  };

  auto [def, key] = go();
  graph.astDefs[e] = def;
  if (key)
    graph.astRefinementKeys[e] = key;
  return {def, key};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprGroup *group) {
  return visitExpr(scope, group->expr);
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprLocal *l) {
  DefId def = lookup(scope, l->local);
  const RefinementKey *key = keyArena->leaf(def);
  return {def, key};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprGlobal *g) {
  DefId def = lookup(scope, g->name);
  return {def, keyArena->leaf(def)};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprCall *c) {
  visitExpr(scope, c->func);

  for (AstExpr *arg : c->args)
    visitExpr(scope, arg);

  // calls should be treated as subscripted.
  return {defArena->freshCell(/* subscripted */ true), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprIndexName *i) {
  auto [parentDef, parentKey] = visitExpr(scope, i->expr);

  std::string index = i->index.value;

  DefId def = lookup(scope, parentDef, index);
  return {def, keyArena->node(parentKey, def, index)};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprIndexExpr *i) {
  auto [parentDef, parentKey] = visitExpr(scope, i->expr);
  visitExpr(scope, i->index);

  if (auto string = i->index->as<AstExprConstantString>()) {
    std::string index{string->value.data, string->value.size};

    DefId def = lookup(scope, parentDef, index);
    return {def, keyArena->node(parentKey, def, index)};
  }

  return {defArena->freshCell(/* subscripted= */ true), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprFunction *f) {
  DfgScope *signatureScope = childScope(scope, DfgScope::Function);

  if (AstLocal *self = f->self) {
    // There's no syntax for `self` to have an annotation if using `function
    // t:m()`
    LUAU_ASSERT(!self->annotation);

    DefId def = defArena->freshCell();
    graph.localDefs[self] = def;
    signatureScope->bindings[self] = def;
    captures[self].allVersions.push_back(def);
  }

  for (AstLocal *param : f->args) {
    if (param->annotation)
      visitType(signatureScope, param->annotation);

    DefId def = defArena->freshCell();
    graph.localDefs[param] = def;
    signatureScope->bindings[param] = def;
    captures[param].allVersions.push_back(def);
  }

  if (f->varargAnnotation)
    visitTypePack(scope, f->varargAnnotation);

  if (f->returnAnnotation)
    visitTypeList(signatureScope, *f->returnAnnotation);

  // TODO: function body can be re-entrant, as in mutations that occurs at the
  // end of the function can also be visible to the beginning of the function,
  // so statically speaking, the body of the function has an exit point that
  // points back to itself, e.g.
  //
  // local function f() print(f) f = 5 end
  // local g = f
  // g() --> function: address
  // g() --> 5
  visit(signatureScope, f->body);

  return {defArena->freshCell(), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprTable *t) {
  DefId tableCell = defArena->freshCell();
  scope->props[tableCell] = {};
  for (AstExprTable::Item item : t->items) {
    DataFlowResult result = visitExpr(scope, item.value);
    if (item.key) {
      visitExpr(scope, item.key);
      if (auto string = item.key->as<AstExprConstantString>())
        scope->props[tableCell][string->value.data] = result.def;
    }
  }

  return {tableCell, nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprUnary *u) {
  visitExpr(scope, u->expr);

  return {defArena->freshCell(), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprBinary *b) {
  visitExpr(scope, b->left);
  visitExpr(scope, b->right);

  return {defArena->freshCell(), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprTypeAssertion *t) {
  auto [def, key] = visitExpr(scope, t->expr);
  visitType(scope, t->annotation);

  return {def, key};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprIfElse *i) {
  visitExpr(scope, i->condition);
  visitExpr(scope, i->trueExpr);
  visitExpr(scope, i->falseExpr);

  return {defArena->freshCell(), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprInterpString *i) {
  for (AstExpr *e : i->expressions)
    visitExpr(scope, e);

  return {defArena->freshCell(), nullptr};
}

DataFlowResult DataFlowGraphBuilder::visitExpr(DfgScope *scope,
                                               AstExprError *error) {
  DfgScope *unreachable = childScope(scope);
  for (AstExpr *e : error->expressions)
    visitExpr(unreachable, e);

  return {defArena->freshCell(), nullptr};
}

void DataFlowGraphBuilder::visitLValue(DfgScope *scope, AstExpr *e,
                                       DefId incomingDef,
                                       bool isCompoundAssignment) {
  auto go = [&]() {
    if (auto l = e->as<AstExprLocal>())
      return visitLValue(scope, l, incomingDef, isCompoundAssignment);
    else if (auto g = e->as<AstExprGlobal>())
      return visitLValue(scope, g, incomingDef, isCompoundAssignment);
    else if (auto i = e->as<AstExprIndexName>())
      return visitLValue(scope, i, incomingDef);
    else if (auto i = e->as<AstExprIndexExpr>())
      return visitLValue(scope, i, incomingDef);
    else if (auto error = e->as<AstExprError>())
      return visitLValue(scope, error, incomingDef);
    else
      handle->ice("Unknown AstExpr in DataFlowGraphBuilder::visitLValue");
  };

  graph.astDefs[e] = go();
}

DefId DataFlowGraphBuilder::visitLValue(DfgScope *scope, AstExprLocal *l,
                                        DefId incomingDef,
                                        bool isCompoundAssignment) {
  // We need to keep the previous def around for a compound assignment.
  if (isCompoundAssignment) {
    DefId def = lookup(scope, l->local);
    graph.compoundAssignDefs[l] = def;
  }

  // In order to avoid alias tracking, we need to clip the reference to the
  // parent def.
  if (scope->canUpdateDefinition(l->local)) {
    DefId updated =
        defArena->freshCell(containsSubscriptedDefinition(incomingDef));
    scope->bindings[l->local] = updated;
    captures[l->local].allVersions.push_back(updated);
    return updated;
  } else
    return visitExpr(scope, static_cast<AstExpr *>(l)).def;
}

DefId DataFlowGraphBuilder::visitLValue(DfgScope *scope, AstExprGlobal *g,
                                        DefId incomingDef,
                                        bool isCompoundAssignment) {
  // We need to keep the previous def around for a compound assignment.
  if (isCompoundAssignment) {
    DefId def = lookup(scope, g->name);
    graph.compoundAssignDefs[g] = def;
  }

  // In order to avoid alias tracking, we need to clip the reference to the
  // parent def.
  if (scope->canUpdateDefinition(g->name)) {
    DefId updated =
        defArena->freshCell(containsSubscriptedDefinition(incomingDef));
    scope->bindings[g->name] = updated;
    captures[g->name].allVersions.push_back(updated);
    return updated;
  } else
    return visitExpr(scope, static_cast<AstExpr *>(g)).def;
}

DefId DataFlowGraphBuilder::visitLValue(DfgScope *scope, AstExprIndexName *i,
                                        DefId incomingDef) {
  DefId parentDef = visitExpr(scope, i->expr).def;

  if (scope->canUpdateDefinition(parentDef, i->index.value)) {
    DefId updated =
        defArena->freshCell(containsSubscriptedDefinition(incomingDef));
    scope->props[parentDef][i->index.value] = updated;
    return updated;
  } else
    return visitExpr(scope, static_cast<AstExpr *>(i)).def;
}

DefId DataFlowGraphBuilder::visitLValue(DfgScope *scope, AstExprIndexExpr *i,
                                        DefId incomingDef) {
  DefId parentDef = visitExpr(scope, i->expr).def;
  visitExpr(scope, i->index);

  if (auto string = i->index->as<AstExprConstantString>()) {
    if (scope->canUpdateDefinition(parentDef, string->value.data)) {
      DefId updated =
          defArena->freshCell(containsSubscriptedDefinition(incomingDef));
      scope->props[parentDef][string->value.data] = updated;
      return updated;
    } else
      return visitExpr(scope, static_cast<AstExpr *>(i)).def;
  } else
    return defArena->freshCell(/*subscripted=*/true);
}

DefId DataFlowGraphBuilder::visitLValue(DfgScope *scope, AstExprError *error,
                                        DefId incomingDef) {
  return visitExpr(scope, error).def;
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstType *t) {
  if (auto r = t->as<AstTypeReference>())
    return visitType(scope, r);
  else if (auto table = t->as<AstTypeTable>())
    return visitType(scope, table);
  else if (auto f = t->as<AstTypeFunction>())
    return visitType(scope, f);
  else if (auto tyof = t->as<AstTypeTypeof>())
    return visitType(scope, tyof);
  else if (auto u = t->as<AstTypeUnion>())
    return visitType(scope, u);
  else if (auto i = t->as<AstTypeIntersection>())
    return visitType(scope, i);
  else if (auto e = t->as<AstTypeError>())
    return visitType(scope, e);
  else if (auto s = t->as<AstTypeSingletonBool>())
    return; // ok
  else if (auto s = t->as<AstTypeSingletonString>())
    return; // ok
  else
    handle->ice("Unknown AstType in DataFlowGraphBuilder::visitType");
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeReference *r) {
  for (AstTypeOrPack param : r->parameters) {
    if (param.type)
      visitType(scope, param.type);
    else
      visitTypePack(scope, param.typePack);
  }
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeTable *t) {
  for (AstTableProp p : t->props)
    visitType(scope, p.type);

  if (t->indexer) {
    visitType(scope, t->indexer->indexType);
    visitType(scope, t->indexer->resultType);
  }
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeFunction *f) {
  visitGenerics(scope, f->generics);
  visitGenericPacks(scope, f->genericPacks);
  visitTypeList(scope, f->argTypes);
  visitTypeList(scope, f->returnTypes);
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeTypeof *t) {
  visitExpr(scope, t->expr);
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeUnion *u) {
  for (AstType *t : u->types)
    visitType(scope, t);
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeIntersection *i) {
  for (AstType *t : i->types)
    visitType(scope, t);
}

void DataFlowGraphBuilder::visitType(DfgScope *scope, AstTypeError *error) {
  for (AstType *t : error->types)
    visitType(scope, t);
}

void DataFlowGraphBuilder::visitTypePack(DfgScope *scope, AstTypePack *p) {
  if (auto e = p->as<AstTypePackExplicit>())
    return visitTypePack(scope, e);
  else if (auto v = p->as<AstTypePackVariadic>())
    return visitTypePack(scope, v);
  else if (auto g = p->as<AstTypePackGeneric>())
    return; // ok
  else
    handle->ice("Unknown AstTypePack in DataFlowGraphBuilder::visitTypePack");
}

void DataFlowGraphBuilder::visitTypePack(DfgScope *scope,
                                         AstTypePackExplicit *e) {
  visitTypeList(scope, e->typeList);
}

void DataFlowGraphBuilder::visitTypePack(DfgScope *scope,
                                         AstTypePackVariadic *v) {
  visitType(scope, v->variadicType);
}

void DataFlowGraphBuilder::visitTypeList(DfgScope *scope, AstTypeList l) {
  for (AstType *t : l.types)
    visitType(scope, t);

  if (l.tailType)
    visitTypePack(scope, l.tailType);
}

void DataFlowGraphBuilder::visitGenerics(DfgScope *scope,
                                         AstArray<AstGenericType> g) {
  for (AstGenericType generic : g) {
    if (generic.defaultValue)
      visitType(scope, generic.defaultValue);
  }
}

void DataFlowGraphBuilder::visitGenericPacks(DfgScope *scope,
                                             AstArray<AstGenericTypePack> g) {
  for (AstGenericTypePack generic : g) {
    if (generic.defaultValue)
      visitTypePack(scope, generic.defaultValue);
  }
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

LUAU_FASTFLAGVARIABLE(DebugLuauFreezeArena, false);

namespace Luau {

void TypeArena::clear() {
  types.clear();
  typePacks.clear();
}

TypeId TypeArena::addTV(Type &&tv) {
  TypeId allocated = types.allocate(std::move(tv));

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypeId TypeArena::freshType(TypeLevel level) {
  TypeId allocated = types.allocate(FreeType{level});

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypeId TypeArena::freshType(Scope *scope) {
  TypeId allocated = types.allocate(FreeType{scope});

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypeId TypeArena::freshType(Scope *scope, TypeLevel level) {
  TypeId allocated = types.allocate(FreeType{scope, level});

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypePackId TypeArena::freshTypePack(Scope *scope) {
  TypePackId allocated = typePacks.allocate(FreeTypePack{scope});

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypePackId TypeArena::addTypePack(std::initializer_list<TypeId> types) {
  TypePackId allocated = typePacks.allocate(TypePack{std::move(types)});

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypePackId TypeArena::addTypePack(std::vector<TypeId> types,
                                  std::optional<TypePackId> tail) {
  TypePackId allocated = typePacks.allocate(TypePack{std::move(types), tail});

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypePackId TypeArena::addTypePack(TypePack tp) {
  TypePackId allocated = typePacks.allocate(std::move(tp));

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypePackId TypeArena::addTypePack(TypePackVar tp) {
  TypePackId allocated = typePacks.allocate(std::move(tp));

  asMutable(allocated)->owningArena = this;

  return allocated;
}

TypeId TypeArena::addTypeFunction(const TypeFunction &family,
                                  std::initializer_list<TypeId> types) {
  return addType(TypeFunctionInstanceType{family, std::move(types)});
}

TypeId TypeArena::addTypeFunction(const TypeFunction &family,
                                  std::vector<TypeId> typeArguments,
                                  std::vector<TypePackId> packArguments) {
  return addType(TypeFunctionInstanceType{family, std::move(typeArguments),
                                          std::move(packArguments)});
}

TypePackId TypeArena::addTypePackFunction(const TypePackFunction &family,
                                          std::initializer_list<TypeId> types) {
  return addTypePack(
      TypeFunctionInstanceTypePack{NotNull{&family}, std::move(types)});
}

TypePackId
TypeArena::addTypePackFunction(const TypePackFunction &family,
                               std::vector<TypeId> typeArguments,
                               std::vector<TypePackId> packArguments) {
  return addTypePack(TypeFunctionInstanceTypePack{
      NotNull{&family}, std::move(typeArguments), std::move(packArguments)});
}

void freeze(TypeArena &arena) {
  if (!FFlag::DebugLuauFreezeArena)
    return;

  arena.types.freeze();
  arena.typePacks.freeze();
}

void unfreeze(TypeArena &arena) {
  if (!FFlag::DebugLuauFreezeArena)
    return;

  arena.types.unfreeze();
  arena.typePacks.unfreeze();
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/TypedAllocator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

#ifdef _WIN32
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
// @@@ PACK.lua : not found, likely and std header
#include <windows.h>

const size_t kPageSize = 4096;
#else
// @@@ PACK.lua : not found, likely and std header
#include <sys/mman.h>

// @@@ PACK.lua : not found, likely and std header
#include <unistd.h>

#if defined(__FreeBSD__) && !(_POSIX_C_SOURCE >= 200112L)
const size_t kPageSize = getpagesize();
#else
const size_t kPageSize = sysconf(_SC_PAGESIZE);
#endif
#endif
// @@@ PACK.lua : not found, likely and std header
#include <stdlib.h>

LUAU_FASTFLAG(DebugLuauFreezeArena)

namespace Luau {

static size_t pageAlign(size_t size) {
  return (size + kPageSize - 1) & ~(kPageSize - 1);
}

void *pagedAllocate(size_t size) {
  // By default we use operator new/delete instead of malloc/free so that they
  // can be overridden externally
  if (!FFlag::DebugLuauFreezeArena) {
    return ::operator new(size, std::nothrow);
  }

  // On Windows, VirtualAlloc results in 64K granularity allocations; we
  // allocate in chunks of ~32K so aligned_malloc is a little more efficient On
  // Linux, we must use mmap because using regular heap results in mprotect()
  // fragmenting the page table and us bumping into 64K mmap limit.
#ifdef _WIN32
  return _aligned_malloc(size, kPageSize);
#elif defined(__FreeBSD__)
  return aligned_alloc(kPageSize, size);
#else
  return mmap(nullptr, pageAlign(size), PROT_READ | PROT_WRITE,
              MAP_PRIVATE | MAP_ANON, -1, 0);
#endif
}

void pagedDeallocate(void *ptr, size_t size) {
  // By default we use operator new/delete instead of malloc/free so that they
  // can be overridden externally
  if (!FFlag::DebugLuauFreezeArena)
    return ::operator delete(ptr);

#ifdef _WIN32
  _aligned_free(ptr);
#elif defined(__FreeBSD__)
  free(ptr);
#else
  int rc = munmap(ptr, size);
  LUAU_ASSERT(rc == 0);
#endif
}

void pagedFreeze(void *ptr, size_t size) {
  LUAU_ASSERT(FFlag::DebugLuauFreezeArena);
  LUAU_ASSERT(uintptr_t(ptr) % kPageSize == 0);

#ifdef _WIN32
  DWORD oldProtect;
  BOOL rc = VirtualProtect(ptr, pageAlign(size), PAGE_READONLY, &oldProtect);
  LUAU_ASSERT(rc);
#else
  int rc = mprotect(ptr, pageAlign(size), PROT_READ);
  LUAU_ASSERT(rc == 0);
#endif
}

void pagedUnfreeze(void *ptr, size_t size) {
  LUAU_ASSERT(FFlag::DebugLuauFreezeArena);
  LUAU_ASSERT(uintptr_t(ptr) % kPageSize == 0);

#ifdef _WIN32
  DWORD oldProtect;
  BOOL rc = VirtualProtect(ptr, pageAlign(size), PAGE_READWRITE, &oldProtect);
  LUAU_ASSERT(rc);
#else
  int rc = mprotect(ptr, pageAlign(size), PROT_READ | PROT_WRITE);
  LUAU_ASSERT(rc == 0);
#endif
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Autocomplete.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/AstQuery.h>

// DONE : was aleready inlined <Luau/BuiltinDefinitions.h>

// DONE : was aleready inlined <Luau/Frontend.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <unordered_set>

// @@@ PACK.lua : not found, likely and std header
#include <utility>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

static const std::unordered_set<std::string> kStatementStartingKeywords = {
    "while", "if",     "local", "repeat",   "function", "do",
    "for",   "return", "break", "continue", "type",     "export"};

namespace Luau {

static bool alreadyHasParens(const std::vector<AstNode *> &nodes) {
  auto iter = nodes.rbegin();
  while (iter != nodes.rend() &&
         ((*iter)->is<AstExprLocal>() || (*iter)->is<AstExprGlobal>() ||
          (*iter)->is<AstExprIndexName>() || (*iter)->is<AstExprIndexExpr>())) {
    iter++;
  }

  if (iter == nodes.rend() || iter == nodes.rbegin()) {
    return false;
  }

  if (AstExprCall *call = (*iter)->as<AstExprCall>()) {
    return call->func == *(iter - 1);
  }

  return false;
}

static ParenthesesRecommendation
getParenRecommendationForFunc(const FunctionType *func,
                              const std::vector<AstNode *> &nodes) {
  if (alreadyHasParens(nodes)) {
    return ParenthesesRecommendation::None;
  }

  auto idxExpr = nodes.back()->as<AstExprIndexName>();
  bool hasImplicitSelf = idxExpr && idxExpr->op == ':';
  auto [argTypes, argVariadicPack] = Luau::flatten(func->argTypes);

  if (argVariadicPack.has_value() && isVariadic(*argVariadicPack))
    return ParenthesesRecommendation::CursorInside;

  bool noArgFunction =
      argTypes.empty() || (hasImplicitSelf && argTypes.size() == 1);
  return noArgFunction ? ParenthesesRecommendation::CursorAfter
                       : ParenthesesRecommendation::CursorInside;
}

static ParenthesesRecommendation
getParenRecommendationForIntersect(const IntersectionType *intersect,
                                   const std::vector<AstNode *> &nodes) {
  ParenthesesRecommendation rec = ParenthesesRecommendation::None;
  for (Luau::TypeId partId : intersect->parts) {
    if (auto partFunc = Luau::get<FunctionType>(partId)) {
      rec = std::max(rec, getParenRecommendationForFunc(partFunc, nodes));
    } else {
      return ParenthesesRecommendation::None;
    }
  }
  return rec;
}

static ParenthesesRecommendation
getParenRecommendation(TypeId id, const std::vector<AstNode *> &nodes,
                       TypeCorrectKind typeCorrect) {
  // If element is already type-correct, even a function should be inserted
  // without parenthesis
  if (typeCorrect == TypeCorrectKind::Correct)
    return ParenthesesRecommendation::None;

  id = Luau::follow(id);
  if (auto func = get<FunctionType>(id)) {
    return getParenRecommendationForFunc(func, nodes);
  } else if (auto intersect = get<IntersectionType>(id)) {
    return getParenRecommendationForIntersect(intersect, nodes);
  }
  return ParenthesesRecommendation::None;
}

static std::optional<TypeId>
findExpectedTypeAt(const Module &module, AstNode *node, Position position) {
  auto expr = node->asExpr();
  if (!expr)
    return std::nullopt;

  // Extra care for first function call argument location
  // When we don't have anything inside () yet, we also don't have an AST node
  // to base our lookup
  if (AstExprCall *exprCall = expr->as<AstExprCall>()) {
    if (exprCall->args.size == 0 && exprCall->argLocation.contains(position)) {
      auto it = module.astTypes.find(exprCall->func);

      if (!it)
        return std::nullopt;

      const FunctionType *ftv = get<FunctionType>(follow(*it));

      if (!ftv)
        return std::nullopt;

      auto [head, tail] = flatten(ftv->argTypes);
      unsigned index = exprCall->self ? 1 : 0;

      if (index < head.size())
        return head[index];

      return std::nullopt;
    }
  }

  auto it = module.astExpectedTypes.find(expr);
  if (!it)
    return std::nullopt;

  return *it;
}

static bool checkTypeMatch(TypeId subTy, TypeId superTy, NotNull<Scope> scope,
                           TypeArena *typeArena,
                           NotNull<BuiltinTypes> builtinTypes) {
  InternalErrorReporter iceReporter;
  UnifierSharedState unifierState(&iceReporter);
  Normalizer normalizer{typeArena, builtinTypes, NotNull{&unifierState}};

  if (FFlag::DebugLuauDeferredConstraintResolution) {
    Subtyping subtyping{builtinTypes, NotNull{typeArena}, NotNull{&normalizer},
                        NotNull{&iceReporter}, scope};

    return subtyping.isSubtype(subTy, superTy).isSubtype;
  } else {
    Unifier unifier(NotNull<Normalizer>{&normalizer}, scope, Location(),
                    Variance::Covariant);

    // Cost of normalization can be too high for autocomplete response time
    // requirements
    unifier.normalize = false;
    unifier.checkInhabited = false;

    return unifier.canUnify(subTy, superTy).empty();
  }
}

static TypeCorrectKind checkTypeCorrectKind(const Module &module,
                                            TypeArena *typeArena,
                                            NotNull<BuiltinTypes> builtinTypes,
                                            AstNode *node, Position position,
                                            TypeId ty) {
  ty = follow(ty);

  LUAU_ASSERT(module.hasModuleScope());

  NotNull<Scope> moduleScope{module.getModuleScope().get()};

  auto typeAtPosition = findExpectedTypeAt(module, node, position);

  if (!typeAtPosition)
    return TypeCorrectKind::None;

  TypeId expectedType = follow(*typeAtPosition);

  auto checkFunctionType = [typeArena, builtinTypes, moduleScope,
                            &expectedType](const FunctionType *ftv) {
    if (std::optional<TypeId> firstRetTy = first(ftv->retTypes))
      return checkTypeMatch(*firstRetTy, expectedType, moduleScope, typeArena,
                            builtinTypes);

    return false;
  };

  // We also want to suggest functions that return compatible result
  if (const FunctionType *ftv = get<FunctionType>(ty);
      ftv && checkFunctionType(ftv)) {
    return TypeCorrectKind::CorrectFunctionResult;
  } else if (const IntersectionType *itv = get<IntersectionType>(ty)) {
    for (TypeId id : itv->parts) {
      if (const FunctionType *ftv = get<FunctionType>(id);
          ftv && checkFunctionType(ftv)) {
        return TypeCorrectKind::CorrectFunctionResult;
      }
    }
  }

  return checkTypeMatch(ty, expectedType, moduleScope, typeArena, builtinTypes)
             ? TypeCorrectKind::Correct
             : TypeCorrectKind::None;
}

enum class PropIndexType {
  Point,
  Colon,
  Key,
};

static void autocompleteProps(
    const Module &module, TypeArena *typeArena,
    NotNull<BuiltinTypes> builtinTypes, TypeId rootTy, TypeId ty,
    PropIndexType indexType, const std::vector<AstNode *> &nodes,
    AutocompleteEntryMap &result, std::unordered_set<TypeId> &seen,
    std::optional<const ClassType *> containingClass = std::nullopt) {
  rootTy = follow(rootTy);
  ty = follow(ty);

  if (seen.count(ty))
    return;
  seen.insert(ty);

  auto isWrongIndexer = [typeArena, builtinTypes, &module, rootTy,
                         indexType](Luau::TypeId type) {
    if (indexType == PropIndexType::Key)
      return false;

    bool calledWithSelf = indexType == PropIndexType::Colon;

    auto isCompatibleCall = [typeArena, builtinTypes, &module, rootTy,
                             calledWithSelf](const FunctionType *ftv) {
      // Strong match with definition is a success
      if (calledWithSelf == ftv->hasSelf)
        return true;

      // Calls on classes require strict match between how function is declared
      // and how it's called
      if (get<ClassType>(rootTy))
        return false;

      // When called with ':', but declared without 'self', it is invalid if a
      // function has incompatible first argument or no arguments at all When
      // called with '.', but declared with 'self', it is considered invalid if
      // first argument is compatible
      if (std::optional<TypeId> firstArgTy = first(ftv->argTypes)) {
        if (checkTypeMatch(rootTy, *firstArgTy,
                           NotNull{module.getModuleScope().get()}, typeArena,
                           builtinTypes))
          return calledWithSelf;
      }

      return !calledWithSelf;
    };

    if (const FunctionType *ftv = get<FunctionType>(type))
      return !isCompatibleCall(ftv);

    // For intersections, any part that is successful makes the whole call
    // successful
    if (const IntersectionType *itv = get<IntersectionType>(type)) {
      for (auto subType : itv->parts) {
        if (const FunctionType *ftv =
                get<FunctionType>(Luau::follow(subType))) {
          if (isCompatibleCall(ftv))
            return false;
        }
      }
    }

    return calledWithSelf;
  };

  auto fillProps = [&](const ClassType::Props &props) {
    for (const auto &[name, prop] : props) {
      // We are walking up the class hierarchy, so if we encounter a property
      // that we have already populated, it takes precedence over the property
      // we found just now.
      if (result.count(name) == 0 && name != kParseNameError) {
        Luau::TypeId type;

        if (FFlag::DebugLuauDeferredConstraintResolution) {
          if (auto ty = prop.readTy)
            type = follow(*ty);
          else
            continue;
        } else
          type = follow(prop.type());

        TypeCorrectKind typeCorrect =
            indexType == PropIndexType::Key
                ? TypeCorrectKind::Correct
                : checkTypeCorrectKind(module, typeArena, builtinTypes,
                                       nodes.back(), {{}, {}}, type);

        ParenthesesRecommendation parens =
            indexType == PropIndexType::Key
                ? ParenthesesRecommendation::None
                : getParenRecommendation(type, nodes, typeCorrect);

        result[name] = AutocompleteEntry{AutocompleteEntryKind::Property,
                                         type,
                                         prop.deprecated,
                                         isWrongIndexer(type),
                                         typeCorrect,
                                         containingClass,
                                         &prop,
                                         prop.documentationSymbol,
                                         {},
                                         parens,
                                         {},
                                         indexType == PropIndexType::Colon};
      }
    }
  };

  auto fillMetatableProps = [&](const TableType *mtable) {
    auto indexIt = mtable->props.find("__index");
    if (indexIt != mtable->props.end()) {
      TypeId followed = follow(indexIt->second.type());
      if (get<TableType>(followed) || get<MetatableType>(followed)) {
        autocompleteProps(module, typeArena, builtinTypes, rootTy, followed,
                          indexType, nodes, result, seen);
      } else if (auto indexFunction = get<FunctionType>(followed)) {
        std::optional<TypeId> indexFunctionResult =
            first(indexFunction->retTypes);
        if (indexFunctionResult)
          autocompleteProps(module, typeArena, builtinTypes, rootTy,
                            *indexFunctionResult, indexType, nodes, result,
                            seen);
      }
    }
  };

  if (auto cls = get<ClassType>(ty)) {
    containingClass = containingClass.value_or(cls);
    fillProps(cls->props);
    if (cls->parent)
      autocompleteProps(module, typeArena, builtinTypes, rootTy, *cls->parent,
                        indexType, nodes, result, seen, containingClass);
  } else if (auto tbl = get<TableType>(ty))
    fillProps(tbl->props);
  else if (auto mt = get<MetatableType>(ty)) {
    autocompleteProps(module, typeArena, builtinTypes, rootTy, mt->table,
                      indexType, nodes, result, seen);

    if (auto mtable = get<TableType>(follow(mt->metatable)))
      fillMetatableProps(mtable);
  } else if (auto i = get<IntersectionType>(ty)) {
    // Complete all properties in every variant
    for (TypeId ty : i->parts) {
      AutocompleteEntryMap inner;
      std::unordered_set<TypeId> innerSeen = seen;

      autocompleteProps(module, typeArena, builtinTypes, rootTy, ty, indexType,
                        nodes, inner, innerSeen);

      for (auto &pair : inner)
        result.insert(pair);
    }
  } else if (auto u = get<UnionType>(ty)) {
    // Complete all properties common to all variants
    auto iter = begin(u);
    auto endIter = end(u);

    while (iter != endIter) {
      if (isNil(*iter))
        ++iter;
      else
        break;
    }

    if (iter == endIter)
      return;

    autocompleteProps(module, typeArena, builtinTypes, rootTy, *iter, indexType,
                      nodes, result, seen);

    ++iter;

    while (iter != endIter) {
      AutocompleteEntryMap inner;
      std::unordered_set<TypeId> innerSeen;

      if (isNil(*iter)) {
        ++iter;
        continue;
      }

      autocompleteProps(module, typeArena, builtinTypes, rootTy, *iter,
                        indexType, nodes, inner, innerSeen);

      std::unordered_set<std::string> toRemove;

      for (const auto &[k, v] : result) {
        (void)v;
        if (!inner.count(k))
          toRemove.insert(k);
      }

      for (const std::string &k : toRemove)
        result.erase(k);

      ++iter;
    }
  } else if (auto pt = get<PrimitiveType>(ty)) {
    if (pt->metatable) {
      if (auto mtable = get<TableType>(*pt->metatable))
        fillMetatableProps(mtable);
    }
  } else if (get<StringSingleton>(get<SingletonType>(ty))) {
    autocompleteProps(module, typeArena, builtinTypes, rootTy,
                      builtinTypes->stringType, indexType, nodes, result, seen);
  }
}

static void autocompleteKeywords(const SourceModule &sourceModule,
                                 const std::vector<AstNode *> &ancestry,
                                 Position position,
                                 AutocompleteEntryMap &result) {
  LUAU_ASSERT(!ancestry.empty());

  AstNode *node = ancestry.back();

  if (!node->is<AstExprFunction>() && node->asExpr()) {
    // This is not strictly correct. We should recommend `and` and `or` only
    // after another expression, not at the start of a new one. We should only
    // recommend `not` at the start of an expression. Detecting either case
    // reliably is quite complex, however; this is good enough for now.

    // These are not context-sensitive keywords, so we can unconditionally
    // assign.
    result["and"] = {AutocompleteEntryKind::Keyword};
    result["or"] = {AutocompleteEntryKind::Keyword};
    result["not"] = {AutocompleteEntryKind::Keyword};
  }
}

static void autocompleteProps(const Module &module, TypeArena *typeArena,
                              NotNull<BuiltinTypes> builtinTypes, TypeId ty,
                              PropIndexType indexType,
                              const std::vector<AstNode *> &nodes,
                              AutocompleteEntryMap &result) {
  std::unordered_set<TypeId> seen;
  autocompleteProps(module, typeArena, builtinTypes, ty, ty, indexType, nodes,
                    result, seen);
}

AutocompleteEntryMap autocompleteProps(const Module &module,
                                       TypeArena *typeArena,
                                       NotNull<BuiltinTypes> builtinTypes,
                                       TypeId ty, PropIndexType indexType,
                                       const std::vector<AstNode *> &nodes) {
  AutocompleteEntryMap result;
  autocompleteProps(module, typeArena, builtinTypes, ty, indexType, nodes,
                    result);
  return result;
}

AutocompleteEntryMap autocompleteModuleTypes(const Module &module,
                                             Position position,
                                             std::string_view moduleName) {
  AutocompleteEntryMap result;

  for (ScopePtr scope = findScopeAtPosition(module, position); scope;
       scope = scope->parent) {
    if (auto it = scope->importedTypeBindings.find(std::string(moduleName));
        it != scope->importedTypeBindings.end()) {
      for (const auto &[name, ty] : it->second)
        result[name] = AutocompleteEntry{AutocompleteEntryKind::Type, ty.type};

      break;
    }
  }

  return result;
}

static void autocompleteStringSingleton(TypeId ty, bool addQuotes,
                                        AstNode *node, Position position,
                                        AutocompleteEntryMap &result) {
  if (position == node->location.begin || position == node->location.end) {
    if (auto str = node->as<AstExprConstantString>();
        str && str->quoteStyle == AstExprConstantString::Quoted)
      return;
    else if (node->is<AstExprInterpString>())
      return;
  }

  auto formatKey = [addQuotes](const std::string &key) {
    if (addQuotes)
      return "\"" + escape(key) + "\"";

    return escape(key);
  };

  ty = follow(ty);

  if (auto ss = get<StringSingleton>(get<SingletonType>(ty))) {
    result[formatKey(ss->value)] =
        AutocompleteEntry{AutocompleteEntryKind::String, ty, false, false,
                          TypeCorrectKind::Correct};
  } else if (auto uty = get<UnionType>(ty)) {
    for (auto el : uty) {
      if (auto ss = get<StringSingleton>(get<SingletonType>(el)))
        result[formatKey(ss->value)] =
            AutocompleteEntry{AutocompleteEntryKind::String, ty, false, false,
                              TypeCorrectKind::Correct};
    }
  }
};

static bool canSuggestInferredType(ScopePtr scope, TypeId ty) {
  ty = follow(ty);

  // No point in suggesting 'any', invalid to suggest others
  if (get<AnyType>(ty) || get<ErrorType>(ty) || get<GenericType>(ty) ||
      get<FreeType>(ty))
    return false;

  // No syntax for unnamed tables with a metatable
  if (get<MetatableType>(ty))
    return false;

  if (const TableType *ttv = get<TableType>(ty)) {
    if (ttv->name)
      return true;

    if (ttv->syntheticName)
      return false;
  }

  // We might still have a type with cycles or one that is too long, we'll check
  // that later
  return true;
}

// Walk complex type trees to find the element that is being edited
static std::optional<TypeId> findTypeElementAt(AstType *astType, TypeId ty,
                                               Position position);

static std::optional<TypeId> findTypeElementAt(const AstTypeList &astTypeList,
                                               TypePackId tp,
                                               Position position) {
  for (size_t i = 0; i < astTypeList.types.size; i++) {
    AstType *type = astTypeList.types.data[i];

    if (type->location.containsClosed(position)) {
      auto [head, _] = flatten(tp);

      if (i < head.size())
        return findTypeElementAt(type, head[i], position);
    }
  }

  if (AstTypePack *argTp = astTypeList.tailType) {
    if (auto variadic = argTp->as<AstTypePackVariadic>()) {
      if (variadic->location.containsClosed(position)) {
        auto [_, tail] = flatten(tp);

        if (tail) {
          if (const VariadicTypePack *vtp =
                  get<VariadicTypePack>(follow(*tail)))
            return findTypeElementAt(variadic->variadicType, vtp->ty, position);
        }
      }
    }
  }

  return {};
}

static std::optional<TypeId> findTypeElementAt(AstType *astType, TypeId ty,
                                               Position position) {
  ty = follow(ty);

  if (astType->is<AstTypeReference>())
    return ty;

  if (astType->is<AstTypeError>())
    return ty;

  if (AstTypeFunction *type = astType->as<AstTypeFunction>()) {
    const FunctionType *ftv = get<FunctionType>(ty);

    if (!ftv)
      return {};

    if (auto element =
            findTypeElementAt(type->argTypes, ftv->argTypes, position))
      return element;

    if (auto element =
            findTypeElementAt(type->returnTypes, ftv->retTypes, position))
      return element;
  }

  // It's possible to walk through other types like intrsection and unions if we
  // find value in doing that
  return {};
}

std::optional<TypeId> getLocalTypeInScopeAt(const Module &module,
                                            Position position,
                                            AstLocal *local) {
  if (ScopePtr scope = findScopeAtPosition(module, position)) {
    for (const auto &[name, binding] : scope->bindings) {
      if (name == local)
        return binding.typeId;
    }
  }

  return {};
}

template <typename T>
static std::optional<std::string>
tryToStringDetailed(const ScopePtr &scope, T ty, bool functionTypeArguments) {
  ToStringOptions opts;
  opts.useLineBreaks = false;
  opts.hideTableKind = true;
  opts.functionTypeArguments = functionTypeArguments;
  opts.scope = scope;
  ToStringResult name = toStringDetailed(ty, opts);

  if (name.error || name.invalid || name.cycle || name.truncated)
    return std::nullopt;

  return name.name;
}

static std::optional<Name>
tryGetTypeNameInScope(ScopePtr scope, TypeId ty,
                      bool functionTypeArguments = false) {
  if (!canSuggestInferredType(scope, ty))
    return std::nullopt;

  return tryToStringDetailed(scope, ty, functionTypeArguments);
}

static bool tryAddTypeCorrectSuggestion(AutocompleteEntryMap &result,
                                        ScopePtr scope, AstType *topType,
                                        TypeId inferredType,
                                        Position position) {
  std::optional<TypeId> ty;

  if (topType)
    ty = findTypeElementAt(topType, inferredType, position);
  else
    ty = inferredType;

  if (!ty)
    return false;

  if (auto name = tryGetTypeNameInScope(scope, *ty)) {
    if (auto it = result.find(*name); it != result.end())
      it->second.typeCorrect = TypeCorrectKind::Correct;
    else
      result[*name] = AutocompleteEntry{AutocompleteEntryKind::Type, *ty, false,
                                        false, TypeCorrectKind::Correct};

    return true;
  }

  return false;
}

static std::optional<TypeId> tryGetTypePackTypeAt(TypePackId tp, size_t index) {
  auto [tpHead, tpTail] = flatten(tp);

  if (index < tpHead.size())
    return tpHead[index];

  // Infinite tail
  if (tpTail) {
    if (const VariadicTypePack *vtp = get<VariadicTypePack>(follow(*tpTail)))
      return vtp->ty;
  }

  return {};
}

template <typename T>
std::optional<const T *> returnFirstNonnullOptionOfType(const UnionType *utv) {
  std::optional<const T *> ret;
  for (TypeId subTy : utv) {
    if (isNil(subTy))
      continue;

    if (const T *ftv = get<T>(follow(subTy))) {
      if (ret.has_value()) {
        return std::nullopt;
      }
      ret = ftv;
    } else {
      return std::nullopt;
    }
  }
  return ret;
}

static std::optional<bool>
functionIsExpectedAt(const Module &module, AstNode *node, Position position) {
  auto typeAtPosition = findExpectedTypeAt(module, node, position);

  if (!typeAtPosition)
    return std::nullopt;

  TypeId expectedType = follow(*typeAtPosition);

  if (get<FunctionType>(expectedType))
    return true;

  if (const IntersectionType *itv = get<IntersectionType>(expectedType)) {
    return std::all_of(begin(itv->parts), end(itv->parts), [](auto &&ty) {
      return get<FunctionType>(Luau::follow(ty)) != nullptr;
    });
  }

  if (const UnionType *utv = get<UnionType>(expectedType))
    return returnFirstNonnullOptionOfType<FunctionType>(utv).has_value();

  return false;
}

AutocompleteEntryMap
autocompleteTypeNames(const Module &module, Position position,
                      const std::vector<AstNode *> &ancestry) {
  AutocompleteEntryMap result;

  ScopePtr startScope = findScopeAtPosition(module, position);

  for (ScopePtr scope = startScope; scope; scope = scope->parent) {
    for (const auto &[name, ty] : scope->exportedTypeBindings) {
      if (!result.count(name))
        result[name] = AutocompleteEntry{AutocompleteEntryKind::Type,
                                         ty.type,
                                         false,
                                         false,
                                         TypeCorrectKind::None,
                                         std::nullopt,
                                         std::nullopt,
                                         ty.type->documentationSymbol};
    }

    for (const auto &[name, ty] : scope->privateTypeBindings) {
      if (!result.count(name))
        result[name] = AutocompleteEntry{AutocompleteEntryKind::Type,
                                         ty.type,
                                         false,
                                         false,
                                         TypeCorrectKind::None,
                                         std::nullopt,
                                         std::nullopt,
                                         ty.type->documentationSymbol};
    }

    for (const auto &[name, _] : scope->importedTypeBindings) {
      if (auto binding = scope->linearSearchForBinding(name, true)) {
        if (!result.count(name))
          result[name] =
              AutocompleteEntry{AutocompleteEntryKind::Module, binding->typeId};
      }
    }
  }

  AstNode *parent = nullptr;
  AstType *topType = nullptr; // TODO: rename?

  for (auto it = ancestry.rbegin(), e = ancestry.rend(); it != e; ++it) {
    if (AstType *asType = (*it)->asType()) {
      topType = asType;
    } else {
      parent = *it;
      break;
    }
  }

  if (!parent)
    return result;

  if (AstStatLocal *node =
          parent
              ->as<AstStatLocal>()) // Try to provide inferred type of the local
  {
    // Look at which of the variable types we are defining
    for (size_t i = 0; i < node->vars.size; i++) {
      AstLocal *var = node->vars.data[i];

      if (var->annotation &&
          var->annotation->location.containsClosed(position)) {
        if (node->values.size == 0)
          break;

        unsigned tailPos = 0;

        // For multiple return values we will try to unpack last function call
        // return type pack
        if (i >= node->values.size) {
          tailPos = int(i) - int(node->values.size) + 1;
          i = int(node->values.size) - 1;
        }

        AstExpr *expr = node->values.data[i]->asExpr();

        if (!expr)
          break;

        TypeId inferredType = nullptr;

        if (AstExprCall *exprCall = expr->as<AstExprCall>()) {
          if (auto it = module.astTypes.find(exprCall->func)) {
            if (const FunctionType *ftv = get<FunctionType>(follow(*it))) {
              if (auto ty = tryGetTypePackTypeAt(ftv->retTypes, tailPos))
                inferredType = *ty;
            }
          }
        } else {
          if (tailPos != 0)
            break;

          if (auto it = module.astTypes.find(expr))
            inferredType = *it;
        }

        if (inferredType)
          tryAddTypeCorrectSuggestion(result, startScope, topType, inferredType,
                                      position);

        break;
      }
    }
  } else if (AstExprFunction *node = parent->as<AstExprFunction>()) {
    // For lookup inside expected function type if that's available
    auto tryGetExpectedFunctionType =
        [](const Module &module, AstExpr *expr) -> const FunctionType * {
      auto it = module.astExpectedTypes.find(expr);

      if (!it)
        return nullptr;

      TypeId ty = follow(*it);

      if (const FunctionType *ftv = get<FunctionType>(ty))
        return ftv;

      // Handle optional function type
      if (const UnionType *utv = get<UnionType>(ty)) {
        return returnFirstNonnullOptionOfType<FunctionType>(utv).value_or(
            nullptr);
      }

      return nullptr;
    };

    // Find which argument type we are defining
    for (size_t i = 0; i < node->args.size; i++) {
      AstLocal *arg = node->args.data[i];

      if (arg->annotation &&
          arg->annotation->location.containsClosed(position)) {
        if (const FunctionType *ftv =
                tryGetExpectedFunctionType(module, node)) {
          if (auto ty = tryGetTypePackTypeAt(ftv->argTypes, i))
            tryAddTypeCorrectSuggestion(result, startScope, topType, *ty,
                                        position);
        }
        // Otherwise, try to use the type inferred by typechecker
        else if (auto inferredType =
                     getLocalTypeInScopeAt(module, position, arg)) {
          tryAddTypeCorrectSuggestion(result, startScope, topType,
                                      *inferredType, position);
        }

        break;
      }
    }

    if (AstTypePack *argTp = node->varargAnnotation) {
      if (auto variadic = argTp->as<AstTypePackVariadic>()) {
        if (variadic->location.containsClosed(position)) {
          if (const FunctionType *ftv =
                  tryGetExpectedFunctionType(module, node)) {
            if (auto ty = tryGetTypePackTypeAt(ftv->argTypes, ~0u))
              tryAddTypeCorrectSuggestion(result, startScope, topType, *ty,
                                          position);
          }
        }
      }
    }

    if (!node->returnAnnotation)
      return result;

    for (size_t i = 0; i < node->returnAnnotation->types.size; i++) {
      AstType *ret = node->returnAnnotation->types.data[i];

      if (ret->location.containsClosed(position)) {
        if (const FunctionType *ftv =
                tryGetExpectedFunctionType(module, node)) {
          if (auto ty = tryGetTypePackTypeAt(ftv->retTypes, i))
            tryAddTypeCorrectSuggestion(result, startScope, topType, *ty,
                                        position);
        }

        // TODO: with additional type information, we could suggest inferred
        // return type here
        break;
      }
    }

    if (AstTypePack *retTp = node->returnAnnotation->tailType) {
      if (auto variadic = retTp->as<AstTypePackVariadic>()) {
        if (variadic->location.containsClosed(position)) {
          if (const FunctionType *ftv =
                  tryGetExpectedFunctionType(module, node)) {
            if (auto ty = tryGetTypePackTypeAt(ftv->retTypes, ~0u))
              tryAddTypeCorrectSuggestion(result, startScope, topType, *ty,
                                          position);
          }
        }
      }
    }
  }

  return result;
}

static bool isInLocalNames(const std::vector<AstNode *> &ancestry,
                           Position position) {
  for (auto iter = ancestry.rbegin(); iter != ancestry.rend(); iter++) {
    if (auto statLocal = (*iter)->as<AstStatLocal>()) {
      for (auto var : statLocal->vars) {
        if (var->location.containsClosed(position)) {
          return true;
        }
      }
    } else if (auto funcExpr = (*iter)->as<AstExprFunction>()) {
      if (funcExpr->argLocation && funcExpr->argLocation->contains(position)) {
        return true;
      }
    } else if (auto localFunc = (*iter)->as<AstStatLocalFunction>()) {
      return localFunc->name->location.containsClosed(position);
    } else if (auto block = (*iter)->as<AstStatBlock>()) {
      if (block->body.size > 0) {
        return false;
      }
    } else if ((*iter)->asStat()) {
      return false;
    }
  }
  return false;
}

static bool isIdentifier(AstNode *node) {
  return node->is<AstExprGlobal>() || node->is<AstExprLocal>();
}

static bool isBeingDefined(const std::vector<AstNode *> &ancestry,
                           const Symbol &symbol) {
  // Current set of rules only check for local binding match
  if (!symbol.local)
    return false;

  for (auto iter = ancestry.rbegin(); iter != ancestry.rend(); iter++) {
    if (auto statLocal = (*iter)->as<AstStatLocal>()) {
      for (auto var : statLocal->vars) {
        if (symbol.local == var)
          return true;
      }
    }
  }

  return false;
}

template <typename T> T *extractStat(const std::vector<AstNode *> &ancestry) {
  AstNode *node = ancestry.size() >= 1 ? ancestry.rbegin()[0] : nullptr;
  if (!node)
    return nullptr;

  if (T *t = node->as<T>())
    return t;

  AstNode *parent = ancestry.size() >= 2 ? ancestry.rbegin()[1] : nullptr;
  if (!parent)
    return nullptr;

  AstNode *grandParent = ancestry.size() >= 3 ? ancestry.rbegin()[2] : nullptr;
  AstNode *greatGrandParent =
      ancestry.size() >= 4 ? ancestry.rbegin()[3] : nullptr;

  if (!grandParent)
    return nullptr;

  if (T *t = parent->as<T>(); t && grandParent->is<AstStatBlock>())
    return t;

  if (!greatGrandParent)
    return nullptr;

  if (T *t = greatGrandParent->as<T>(); t && grandParent->is<AstStatBlock>() &&
                                        parent->is<AstStatError>() &&
                                        isIdentifier(node))
    return t;

  return nullptr;
}

static bool isBindingLegalAtCurrentPosition(const Symbol &symbol,
                                            const Binding &binding,
                                            Position pos) {
  if (symbol.local)
    return binding.location.end < pos;

  // Builtin globals have an empty location; for defined globals, we want pos to
  // be outside of the definition range to suggest it
  return binding.location == Location() ||
         !binding.location.containsClosed(pos);
}

static AutocompleteEntryMap
autocompleteStatement(const SourceModule &sourceModule, const Module &module,
                      const std::vector<AstNode *> &ancestry,
                      Position position) {
  // This is inefficient. :(
  ScopePtr scope = findScopeAtPosition(module, position);

  AutocompleteEntryMap result;

  if (isInLocalNames(ancestry, position)) {
    autocompleteKeywords(sourceModule, ancestry, position, result);
    return result;
  }

  while (scope) {
    for (const auto &[name, binding] : scope->bindings) {
      if (!isBindingLegalAtCurrentPosition(name, binding, position))
        continue;

      std::string n = toString(name);
      if (!result.count(n))
        result[n] = {AutocompleteEntryKind::Binding,
                     binding.typeId,
                     binding.deprecated,
                     false,
                     TypeCorrectKind::None,
                     std::nullopt,
                     std::nullopt,
                     binding.documentationSymbol,
                     {},
                     getParenRecommendation(binding.typeId, ancestry,
                                            TypeCorrectKind::None)};
    }

    scope = scope->parent;
  }

  for (const auto &kw : kStatementStartingKeywords)
    result.emplace(kw, AutocompleteEntry{AutocompleteEntryKind::Keyword});

  for (auto it = ancestry.rbegin(); it != ancestry.rend(); ++it) {
    if (AstStatForIn *statForIn = (*it)->as<AstStatForIn>();
        statForIn && !statForIn->body->hasEnd)
      result.emplace("end", AutocompleteEntry{AutocompleteEntryKind::Keyword});
    else if (AstStatFor *statFor = (*it)->as<AstStatFor>();
             statFor && !statFor->body->hasEnd)
      result.emplace("end", AutocompleteEntry{AutocompleteEntryKind::Keyword});
    else if (AstStatIf *statIf = (*it)->as<AstStatIf>()) {
      bool hasEnd = statIf->thenbody->hasEnd;
      if (statIf->elsebody) {
        if (AstStatBlock *elseBlock = statIf->elsebody->as<AstStatBlock>())
          hasEnd = elseBlock->hasEnd;
      }

      if (!hasEnd)
        result.emplace("end",
                       AutocompleteEntry{AutocompleteEntryKind::Keyword});
    } else if (AstStatWhile *statWhile = (*it)->as<AstStatWhile>();
               statWhile && !statWhile->body->hasEnd)
      result.emplace("end", AutocompleteEntry{AutocompleteEntryKind::Keyword});
    else if (AstExprFunction *exprFunction = (*it)->as<AstExprFunction>();
             exprFunction && !exprFunction->body->hasEnd)
      result.emplace("end", AutocompleteEntry{AutocompleteEntryKind::Keyword});
    if (AstStatBlock *exprBlock = (*it)->as<AstStatBlock>();
        exprBlock && !exprBlock->hasEnd)
      result.emplace("end", AutocompleteEntry{AutocompleteEntryKind::Keyword});
  }

  if (ancestry.size() >= 2) {
    AstNode *parent = ancestry.rbegin()[1];
    if (AstStatIf *statIf = parent->as<AstStatIf>()) {
      if (!statIf->elsebody ||
          (statIf->elseLocation &&
           statIf->elseLocation->containsClosed(position))) {
        result.emplace("else",
                       AutocompleteEntry{AutocompleteEntryKind::Keyword});
        result.emplace("elseif",
                       AutocompleteEntry{AutocompleteEntryKind::Keyword});
      }
    }

    if (AstStatRepeat *statRepeat = parent->as<AstStatRepeat>();
        statRepeat && !statRepeat->body->hasEnd)
      result.emplace("until",
                     AutocompleteEntry{AutocompleteEntryKind::Keyword});
  }

  if (ancestry.size() >= 4) {
    auto iter = ancestry.rbegin();
    if (AstStatIf *statIf = iter[3]->as<AstStatIf>();
        statIf != nullptr && !statIf->elsebody && iter[2]->is<AstStatBlock>() &&
        iter[1]->is<AstStatError>() && isIdentifier(iter[0])) {
      result.emplace("else", AutocompleteEntry{AutocompleteEntryKind::Keyword});
      result.emplace("elseif",
                     AutocompleteEntry{AutocompleteEntryKind::Keyword});
    }
  }

  if (AstStatRepeat *statRepeat = extractStat<AstStatRepeat>(ancestry);
      statRepeat && !statRepeat->body->hasEnd)
    result.emplace("until", AutocompleteEntry{AutocompleteEntryKind::Keyword});

  return result;
}

// Returns true iff `node` was handled by this function (completions, if any,
// are returned in `outResult`)
static bool autocompleteIfElseExpression(const AstNode *node,
                                         const std::vector<AstNode *> &ancestry,
                                         const Position &position,
                                         AutocompleteEntryMap &outResult) {
  AstNode *parent = ancestry.size() >= 2 ? ancestry.rbegin()[1] : nullptr;
  if (!parent)
    return false;

  if (node->is<AstExprIfElse>()) {
    // Don't try to complete when the current node is an if-else expression
    // (i.e. only try to complete when the node is a child of an if-else
    // expression.
    return true;
  }

  AstExprIfElse *ifElseExpr = parent->as<AstExprIfElse>();
  if (!ifElseExpr || ifElseExpr->condition->location.containsClosed(position)) {
    return false;
  } else if (!ifElseExpr->hasThen) {
    outResult["then"] = {AutocompleteEntryKind::Keyword};
    return true;
  } else if (ifElseExpr->trueExpr->location.containsClosed(position)) {
    return false;
  } else if (!ifElseExpr->hasElse) {
    outResult["else"] = {AutocompleteEntryKind::Keyword};
    outResult["elseif"] = {AutocompleteEntryKind::Keyword};
    return true;
  } else {
    return false;
  }
}

static AutocompleteContext
autocompleteExpression(const SourceModule &sourceModule, const Module &module,
                       NotNull<BuiltinTypes> builtinTypes, TypeArena *typeArena,
                       const std::vector<AstNode *> &ancestry,
                       Position position, AutocompleteEntryMap &result) {
  LUAU_ASSERT(!ancestry.empty());

  AstNode *node = ancestry.rbegin()[0];

  if (node->is<AstExprIndexName>()) {
    if (auto it = module.astTypes.find(node->asExpr()))
      autocompleteProps(module, typeArena, builtinTypes, *it,
                        PropIndexType::Point, ancestry, result);
  } else if (autocompleteIfElseExpression(node, ancestry, position, result))
    return AutocompleteContext::Keyword;
  else if (node->is<AstExprFunction>())
    return AutocompleteContext::Unknown;
  else {
    // This is inefficient. :(
    ScopePtr scope = findScopeAtPosition(module, position);

    while (scope) {
      for (const auto &[name, binding] : scope->bindings) {
        if (!isBindingLegalAtCurrentPosition(name, binding, position))
          continue;

        if (isBeingDefined(ancestry, name))
          continue;

        std::string n = toString(name);
        if (!result.count(n)) {
          TypeCorrectKind typeCorrect = checkTypeCorrectKind(
              module, typeArena, builtinTypes, node, position, binding.typeId);

          result[n] = {
              AutocompleteEntryKind::Binding,
              binding.typeId,
              binding.deprecated,
              false,
              typeCorrect,
              std::nullopt,
              std::nullopt,
              binding.documentationSymbol,
              {},
              getParenRecommendation(binding.typeId, ancestry, typeCorrect)};
        }
      }

      scope = scope->parent;
    }

    TypeCorrectKind correctForNil = checkTypeCorrectKind(
        module, typeArena, builtinTypes, node, position, builtinTypes->nilType);
    TypeCorrectKind correctForTrue =
        checkTypeCorrectKind(module, typeArena, builtinTypes, node, position,
                             builtinTypes->trueType);
    TypeCorrectKind correctForFalse =
        checkTypeCorrectKind(module, typeArena, builtinTypes, node, position,
                             builtinTypes->falseType);
    TypeCorrectKind correctForFunction =
        functionIsExpectedAt(module, node, position).value_or(false)
            ? TypeCorrectKind::Correct
            : TypeCorrectKind::None;

    result["if"] = {AutocompleteEntryKind::Keyword, std::nullopt, false, false};
    result["true"] = {AutocompleteEntryKind::Keyword, builtinTypes->booleanType,
                      false, false, correctForTrue};
    result["false"] = {AutocompleteEntryKind::Keyword,
                       builtinTypes->booleanType, false, false,
                       correctForFalse};
    result["nil"] = {AutocompleteEntryKind::Keyword, builtinTypes->nilType,
                     false, false, correctForNil};
    result["not"] = {AutocompleteEntryKind::Keyword};
    result["function"] = {AutocompleteEntryKind::Keyword, std::nullopt, false,
                          false, correctForFunction};

    if (auto ty = findExpectedTypeAt(module, node, position))
      autocompleteStringSingleton(*ty, true, node, position, result);
  }

  return AutocompleteContext::Expression;
}

static AutocompleteResult
autocompleteExpression(const SourceModule &sourceModule, const Module &module,
                       NotNull<BuiltinTypes> builtinTypes, TypeArena *typeArena,
                       const std::vector<AstNode *> &ancestry,
                       Position position) {
  AutocompleteEntryMap result;
  AutocompleteContext context =
      autocompleteExpression(sourceModule, module, builtinTypes, typeArena,
                             ancestry, position, result);
  return {result, ancestry, context};
}

static std::optional<const ClassType *>
getMethodContainingClass(const ModulePtr &module, AstExpr *funcExpr) {
  AstExpr *parentExpr = nullptr;
  if (auto indexName = funcExpr->as<AstExprIndexName>()) {
    parentExpr = indexName->expr;
  } else if (auto indexExpr = funcExpr->as<AstExprIndexExpr>()) {
    parentExpr = indexExpr->expr;
  } else {
    return std::nullopt;
  }

  auto parentIt = module->astTypes.find(parentExpr);
  if (!parentIt) {
    return std::nullopt;
  }

  Luau::TypeId parentType = Luau::follow(*parentIt);

  if (auto parentClass = Luau::get<ClassType>(parentType)) {
    return parentClass;
  }

  if (auto parentUnion = Luau::get<UnionType>(parentType)) {
    return returnFirstNonnullOptionOfType<ClassType>(parentUnion);
  }

  return std::nullopt;
}

static bool stringPartOfInterpString(const AstNode *node, Position position) {
  const AstExprInterpString *interpString = node->as<AstExprInterpString>();
  if (!interpString) {
    return false;
  }

  for (const AstExpr *expression : interpString->expressions) {
    if (expression->location.containsClosed(position)) {
      return false;
    }
  }

  return true;
}

static bool isSimpleInterpolatedString(const AstNode *node) {
  const AstExprInterpString *interpString = node->as<AstExprInterpString>();
  return interpString != nullptr && interpString->expressions.size == 0;
}

static std::optional<std::string> getStringContents(const AstNode *node) {
  if (const AstExprConstantString *string = node->as<AstExprConstantString>()) {
    return std::string(string->value.data, string->value.size);
  } else if (const AstExprInterpString *interpString =
                 node->as<AstExprInterpString>();
             interpString && interpString->expressions.size == 0) {
    LUAU_ASSERT(interpString->strings.size == 1);
    return std::string(interpString->strings.data->data,
                       interpString->strings.data->size);
  } else {
    return std::nullopt;
  }
}

static std::optional<AutocompleteEntryMap>
autocompleteStringParams(const SourceModule &sourceModule,
                         const ModulePtr &module,
                         const std::vector<AstNode *> &nodes, Position position,
                         StringCompletionCallback callback) {
  if (nodes.size() < 2) {
    return std::nullopt;
  }

  if (!nodes.back()->is<AstExprConstantString>() &&
      !isSimpleInterpolatedString(nodes.back()) &&
      !nodes.back()->is<AstExprError>()) {
    return std::nullopt;
  }

  if (!nodes.back()->is<AstExprError>()) {
    if (nodes.back()->location.end == position ||
        nodes.back()->location.begin == position) {
      return std::nullopt;
    }
  }

  AstExprCall *candidate = nodes.at(nodes.size() - 2)->as<AstExprCall>();
  if (!candidate) {
    return std::nullopt;
  }

  // HACK: All current instances of 'magic string' params are the first
  // parameter of their functions, so we encode that here rather than putting a
  // useless member on the FunctionType struct.
  if (candidate->args.size > 1 &&
      !candidate->args.data[0]->location.contains(position)) {
    return std::nullopt;
  }

  auto it = module->astTypes.find(candidate->func);
  if (!it) {
    return std::nullopt;
  }

  std::optional<std::string> candidateString = getStringContents(nodes.back());

  auto performCallback =
      [&](const FunctionType *funcType) -> std::optional<AutocompleteEntryMap> {
    for (const std::string &tag : funcType->tags) {
      if (std::optional<AutocompleteEntryMap> ret =
              callback(tag, getMethodContainingClass(module, candidate->func),
                       candidateString)) {
        return ret;
      }
    }
    return std::nullopt;
  };

  auto followedId = Luau::follow(*it);
  if (auto functionType = Luau::get<FunctionType>(followedId)) {
    return performCallback(functionType);
  }

  if (auto intersect = Luau::get<IntersectionType>(followedId)) {
    for (TypeId part : intersect->parts) {
      if (auto candidateFunctionType = Luau::get<FunctionType>(part)) {
        if (std::optional<AutocompleteEntryMap> ret =
                performCallback(candidateFunctionType)) {
          return ret;
        }
      }
    }
  }

  return std::nullopt;
}

static AutocompleteResult
autocompleteWhileLoopKeywords(std::vector<AstNode *> ancestry) {
  AutocompleteEntryMap ret;
  ret["do"] = {AutocompleteEntryKind::Keyword};
  ret["and"] = {AutocompleteEntryKind::Keyword};
  ret["or"] = {AutocompleteEntryKind::Keyword};
  return {std::move(ret), std::move(ancestry), AutocompleteContext::Keyword};
}

static std::string makeAnonymous(const ScopePtr &scope,
                                 const FunctionType &funcTy) {
  std::string result = "function(";

  auto [args, tail] = Luau::flatten(funcTy.argTypes);

  bool first = true;
  // Skip the implicit 'self' argument if call is indexed with ':'
  for (size_t argIdx = 0; argIdx < args.size(); ++argIdx) {
    if (!first)
      result += ", ";
    else
      first = false;

    std::string name;
    if (argIdx < funcTy.argNames.size() && funcTy.argNames[argIdx])
      name = funcTy.argNames[argIdx]->name;
    else
      name = "a" + std::to_string(argIdx);

    if (std::optional<Name> type =
            tryGetTypeNameInScope(scope, args[argIdx], true))
      result += name + ": " + *type;
    else
      result += name;
  }

  if (tail && (Luau::isVariadic(*tail) ||
               Luau::get<Luau::FreeTypePack>(Luau::follow(*tail)))) {
    if (!first)
      result += ", ";

    std::optional<std::string> varArgType;
    if (const VariadicTypePack *pack = get<VariadicTypePack>(follow(*tail))) {
      if (std::optional<std::string> res =
              tryToStringDetailed(scope, pack->ty, true))
        varArgType = std::move(res);
    }

    if (varArgType)
      result += "...: " + *varArgType;
    else
      result += "...";
  }

  result += ")";

  auto [rets, retTail] = Luau::flatten(funcTy.retTypes);
  if (const size_t totalRetSize = rets.size() + (retTail ? 1 : 0);
      totalRetSize > 0) {
    if (std::optional<std::string> returnTypes =
            tryToStringDetailed(scope, funcTy.retTypes, true)) {
      result += ": ";
      bool wrap = totalRetSize != 1;
      if (wrap)
        result += "(";
      result += *returnTypes;
      if (wrap)
        result += ")";
    }
  }
  result += "  end";
  return result;
}

static std::optional<AutocompleteEntry>
makeAnonymousAutofilled(const ModulePtr &module, Position position,
                        const AstNode *node,
                        const std::vector<AstNode *> &ancestry) {
  const AstExprCall *call = node->as<AstExprCall>();
  if (!call && ancestry.size() > 1)
    call = ancestry[ancestry.size() - 2]->as<AstExprCall>();

  if (!call)
    return std::nullopt;

  if (!call->location.containsClosed(position) ||
      call->func->location.containsClosed(position))
    return std::nullopt;

  TypeId *typeIter = module->astTypes.find(call->func);
  if (!typeIter)
    return std::nullopt;

  const FunctionType *outerFunction = get<FunctionType>(follow(*typeIter));
  if (!outerFunction)
    return std::nullopt;

  size_t argument = 0;
  for (size_t i = 0; i < call->args.size; ++i) {
    if (call->args.data[i]->location.containsClosed(position)) {
      argument = i;
      break;
    }
  }

  if (call->self)
    argument++;

  std::optional<TypeId> argType;
  auto [args, tail] = flatten(outerFunction->argTypes);
  if (argument < args.size())
    argType = args[argument];

  if (!argType)
    return std::nullopt;

  TypeId followed = follow(*argType);
  const FunctionType *type = get<FunctionType>(followed);
  if (!type) {
    if (const UnionType *unionType = get<UnionType>(followed)) {
      if (std::optional<const FunctionType *> nonnullFunction =
              returnFirstNonnullOptionOfType<FunctionType>(unionType))
        type = *nonnullFunction;
    }
  }

  if (!type)
    return std::nullopt;

  const ScopePtr scope = findScopeAtPosition(*module, position);
  if (!scope)
    return std::nullopt;

  AutocompleteEntry entry;
  entry.kind = AutocompleteEntryKind::GeneratedFunction;
  entry.typeCorrect = TypeCorrectKind::Correct;
  entry.type = argType;
  entry.insertText = makeAnonymous(scope, *type);
  return std::make_optional(std::move(entry));
}

static AutocompleteResult autocomplete(const SourceModule &sourceModule,
                                       const ModulePtr &module,
                                       NotNull<BuiltinTypes> builtinTypes,
                                       TypeArena *typeArena, Scope *globalScope,
                                       Position position,
                                       StringCompletionCallback callback) {
  if (isWithinComment(sourceModule, position))
    return {};

  std::vector<AstNode *> ancestry =
      findAncestryAtPositionForAutocomplete(sourceModule, position);
  LUAU_ASSERT(!ancestry.empty());
  AstNode *node = ancestry.back();

  AstExprConstantNil dummy{Location{}};
  AstNode *parent = ancestry.size() >= 2 ? ancestry.rbegin()[1] : &dummy;

  // If we are inside a body of a function that doesn't have a completed
  // argument list, ignore the body node
  if (auto exprFunction = parent->as<AstExprFunction>();
      exprFunction && !exprFunction->argLocation &&
      node == exprFunction->body) {
    ancestry.pop_back();

    node = ancestry.back();
    parent = ancestry.size() >= 2 ? ancestry.rbegin()[1] : &dummy;
  }

  if (auto indexName = node->as<AstExprIndexName>()) {
    auto it = module->astTypes.find(indexName->expr);
    if (!it)
      return {};

    TypeId ty = follow(*it);
    PropIndexType indexType =
        indexName->op == ':' ? PropIndexType::Colon : PropIndexType::Point;

    return {autocompleteProps(*module, typeArena, builtinTypes, ty, indexType,
                              ancestry),
            ancestry, AutocompleteContext::Property};
  } else if (auto typeReference = node->as<AstTypeReference>()) {
    if (typeReference->prefix)
      return {autocompleteModuleTypes(*module, position,
                                      typeReference->prefix->value),
              ancestry, AutocompleteContext::Type};
    else
      return {autocompleteTypeNames(*module, position, ancestry), ancestry,
              AutocompleteContext::Type};
  } else if (node->is<AstTypeError>()) {
    return {autocompleteTypeNames(*module, position, ancestry), ancestry,
            AutocompleteContext::Type};
  } else if (AstStatLocal *statLocal = node->as<AstStatLocal>()) {
    if (statLocal->vars.size == 1 &&
        (!statLocal->equalsSignLocation ||
         position < statLocal->equalsSignLocation->begin))
      return {{{"function", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
              ancestry,
              AutocompleteContext::Unknown};
    else if (statLocal->equalsSignLocation &&
             position >= statLocal->equalsSignLocation->end)
      return autocompleteExpression(sourceModule, *module, builtinTypes,
                                    typeArena, ancestry, position);
    else
      return {};
  }

  else if (AstStatFor *statFor = extractStat<AstStatFor>(ancestry)) {
    if (!statFor->hasDo || position < statFor->doLocation.begin) {
      if (statFor->from->location.containsClosed(position) ||
          statFor->to->location.containsClosed(position) ||
          (statFor->step && statFor->step->location.containsClosed(position)))
        return autocompleteExpression(sourceModule, *module, builtinTypes,
                                      typeArena, ancestry, position);

      if (!statFor->from->is<AstExprError>() &&
          !statFor->to->is<AstExprError>() &&
          (!statFor->step || !statFor->step->is<AstExprError>()))
        return {{{"do", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
                ancestry,
                AutocompleteContext::Keyword};
      return {};
    }

    return {autocompleteStatement(sourceModule, *module, ancestry, position),
            ancestry, AutocompleteContext::Statement};
  }

  else if (AstStatForIn *statForIn = parent->as<AstStatForIn>();
           statForIn && (node->is<AstStatBlock>() || isIdentifier(node))) {
    if (!statForIn->hasIn || position <= statForIn->inLocation.begin) {
      AstLocal *lastName = statForIn->vars.data[statForIn->vars.size - 1];
      if (lastName->name == kParseNameError ||
          lastName->location.containsClosed(position)) {
        // Here we are either working with a missing binding (as would be the
        // case in a bare "for" keyword) or the cursor is still touching a
        // binding name.  The user is still typing a new name, so we should not
        // offer any suggestions.
        return {};
      }

      return {{{"in", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
              ancestry,
              AutocompleteContext::Keyword};
    }

    if (!statForIn->hasDo || position <= statForIn->doLocation.begin) {
      LUAU_ASSERT(statForIn->values.size > 0);
      AstExpr *lastExpr = statForIn->values.data[statForIn->values.size - 1];

      if (lastExpr->location.containsClosed(position))
        return autocompleteExpression(sourceModule, *module, builtinTypes,
                                      typeArena, ancestry, position);

      if (position > lastExpr->location.end)
        return {{{"do", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
                ancestry,
                AutocompleteContext::Keyword};

      return {}; // Not sure what this means
    }
  } else if (AstStatForIn *statForIn = extractStat<AstStatForIn>(ancestry)) {
    // The AST looks a bit differently if the cursor is at a position where only
    // the "do" keyword is allowed. ex "for f in f do"
    if (!statForIn->hasDo)
      return {{{"do", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
              ancestry,
              AutocompleteContext::Keyword};

    return {autocompleteStatement(sourceModule, *module, ancestry, position),
            ancestry, AutocompleteContext::Statement};
  }

  else if (AstStatWhile *statWhile = parent->as<AstStatWhile>();
           node->is<AstStatBlock>() && statWhile) {
    if (!statWhile->hasDo && !statWhile->condition->is<AstStatError>() &&
        position > statWhile->condition->location.end) {
      return autocompleteWhileLoopKeywords(ancestry);
    }

    if (!statWhile->hasDo || position < statWhile->doLocation.begin)
      return autocompleteExpression(sourceModule, *module, builtinTypes,
                                    typeArena, ancestry, position);

    if (statWhile->hasDo && position > statWhile->doLocation.end)
      return {autocompleteStatement(sourceModule, *module, ancestry, position),
              ancestry, AutocompleteContext::Statement};
  }

  else if (AstStatWhile *statWhile = extractStat<AstStatWhile>(ancestry);
           (statWhile &&
            (!statWhile->hasDo ||
             statWhile->doLocation.containsClosed(position)) &&
            statWhile->condition &&
            !statWhile->condition->location.containsClosed(position))) {
    return autocompleteWhileLoopKeywords(ancestry);
  } else if (AstStatIf *statIf = node->as<AstStatIf>();
             statIf && !statIf->elseLocation.has_value()) {
    return {{{"else", AutocompleteEntry{AutocompleteEntryKind::Keyword}},
             {"elseif", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
            ancestry,
            AutocompleteContext::Keyword};
  } else if (AstStatIf *statIf = parent->as<AstStatIf>();
             statIf && node->is<AstStatBlock>()) {
    if (statIf->condition->is<AstExprError>())
      return autocompleteExpression(sourceModule, *module, builtinTypes,
                                    typeArena, ancestry, position);
    else if (!statIf->thenLocation ||
             statIf->thenLocation->containsClosed(position))
      return {{{"then", AutocompleteEntry{AutocompleteEntryKind::Keyword}}},
              ancestry,
              AutocompleteContext::Keyword};
  } else if (AstStatIf *statIf = extractStat<AstStatIf>(ancestry);
             statIf &&
             (!statIf->thenLocation ||
              statIf->thenLocation->containsClosed(position)) &&
             (statIf->condition &&
              !statIf->condition->location.containsClosed(position))) {
    AutocompleteEntryMap ret;
    ret["then"] = {AutocompleteEntryKind::Keyword};
    ret["and"] = {AutocompleteEntryKind::Keyword};
    ret["or"] = {AutocompleteEntryKind::Keyword};
    return {std::move(ret), ancestry, AutocompleteContext::Keyword};
  } else if (AstStatRepeat *statRepeat = node->as<AstStatRepeat>();
             statRepeat && statRepeat->condition->is<AstExprError>())
    return autocompleteExpression(sourceModule, *module, builtinTypes,
                                  typeArena, ancestry, position);
  else if (AstStatRepeat *statRepeat = extractStat<AstStatRepeat>(ancestry);
           statRepeat)
    return {autocompleteStatement(sourceModule, *module, ancestry, position),
            ancestry, AutocompleteContext::Statement};
  else if (AstExprTable *exprTable = parent->as<AstExprTable>();
           exprTable &&
           (node->is<AstExprGlobal>() || node->is<AstExprConstantString>() ||
            node->is<AstExprInterpString>())) {
    for (const auto &[kind, key, value] : exprTable->items) {
      // If item doesn't have a key, maybe the value is actually the key
      if (key ? key == node : node->is<AstExprGlobal>() && value == node) {
        if (auto it = module->astExpectedTypes.find(exprTable)) {
          auto result = autocompleteProps(*module, typeArena, builtinTypes, *it,
                                          PropIndexType::Key, ancestry);

          if (auto nodeIt = module->astExpectedTypes.find(node->asExpr()))
            autocompleteStringSingleton(*nodeIt,
                                        !node->is<AstExprConstantString>(),
                                        node, position, result);

          if (!key) {
            // If there is "no key," it may be that the user
            // intends for the current token to be the key, but
            // has yet to type the `=` sign.
            //
            // If the key type is a union of singleton strings,
            // suggest those too.
            if (auto ttv = get<TableType>(follow(*it)); ttv && ttv->indexer) {
              autocompleteStringSingleton(ttv->indexer->indexType, false, node,
                                          position, result);
            }
          }

          // Remove keys that are already completed
          for (const auto &item : exprTable->items) {
            if (!item.key)
              continue;

            if (auto stringKey = item.key->as<AstExprConstantString>())
              result.erase(
                  std::string(stringKey->value.data, stringKey->value.size));
          }

          // If we know for sure that a key is being written, do not offer
          // general expression suggestions
          if (!key)
            autocompleteExpression(sourceModule, *module, builtinTypes,
                                   typeArena, ancestry, position, result);

          return {result, ancestry, AutocompleteContext::Property};
        }

        break;
      }
    }
  } else if (AstExprTable *exprTable = node->as<AstExprTable>()) {
    AutocompleteEntryMap result;

    if (auto it = module->astExpectedTypes.find(exprTable)) {
      result = autocompleteProps(*module, typeArena, builtinTypes, *it,
                                 PropIndexType::Key, ancestry);

      // If the key type is a union of singleton strings,
      // suggest those too.
      if (auto ttv = get<TableType>(follow(*it)); ttv && ttv->indexer) {
        autocompleteStringSingleton(ttv->indexer->indexType, false, node,
                                    position, result);
      }

      // Remove keys that are already completed
      for (const auto &item : exprTable->items) {
        if (!item.key)
          continue;

        if (auto stringKey = item.key->as<AstExprConstantString>())
          result.erase(
              std::string(stringKey->value.data, stringKey->value.size));
      }
    }

    // Also offer general expression suggestions
    autocompleteExpression(sourceModule, *module, builtinTypes, typeArena,
                           ancestry, position, result);

    return {result, ancestry, AutocompleteContext::Property};
  } else if (isIdentifier(node) &&
             (parent->is<AstStatExpr>() || parent->is<AstStatError>()))
    return {autocompleteStatement(sourceModule, *module, ancestry, position),
            ancestry, AutocompleteContext::Statement};

  if (std::optional<AutocompleteEntryMap> ret = autocompleteStringParams(
          sourceModule, module, ancestry, position, callback)) {
    return {*ret, ancestry, AutocompleteContext::String};
  } else if (node->is<AstExprConstantString>() ||
             isSimpleInterpolatedString(node)) {
    AutocompleteEntryMap result;

    if (auto it = module->astExpectedTypes.find(node->asExpr()))
      autocompleteStringSingleton(*it, false, node, position, result);

    if (ancestry.size() >= 2) {
      if (auto idxExpr =
              ancestry.at(ancestry.size() - 2)->as<AstExprIndexExpr>()) {
        if (auto it = module->astTypes.find(idxExpr->expr))
          autocompleteProps(*module, typeArena, builtinTypes, follow(*it),
                            PropIndexType::Point, ancestry, result);
      } else if (auto binExpr =
                     ancestry.at(ancestry.size() - 2)->as<AstExprBinary>()) {
        if (binExpr->op == AstExprBinary::CompareEq ||
            binExpr->op == AstExprBinary::CompareNe) {
          if (auto it = module->astTypes.find(
                  node == binExpr->left ? binExpr->right : binExpr->left))
            autocompleteStringSingleton(*it, false, node, position, result);
        }
      }
    }

    return {result, ancestry, AutocompleteContext::String};
  } else if (stringPartOfInterpString(node, position)) {
    // We're not a simple interpolated string, we're something like `a{"b"}@1`,
    // and we can't know what to format to
    AutocompleteEntryMap map;
    return {map, ancestry, AutocompleteContext::String};
  }

  if (node->is<AstExprConstantNumber>())
    return {};

  if (node->asExpr()) {
    AutocompleteResult ret = autocompleteExpression(
        sourceModule, *module, builtinTypes, typeArena, ancestry, position);
    if (std::optional<AutocompleteEntry> generated =
            makeAnonymousAutofilled(module, position, node, ancestry))
      ret.entryMap[kGeneratedAnonymousFunctionEntryName] =
          std::move(*generated);
    return ret;
  } else if (node->asStat())
    return {autocompleteStatement(sourceModule, *module, ancestry, position),
            ancestry, AutocompleteContext::Statement};

  return {};
}

AutocompleteResult autocomplete(Frontend &frontend,
                                const ModuleName &moduleName, Position position,
                                StringCompletionCallback callback) {
  const SourceModule *sourceModule = frontend.getSourceModule(moduleName);
  if (!sourceModule)
    return {};

  ModulePtr module;
  if (FFlag::DebugLuauDeferredConstraintResolution)
    module = frontend.moduleResolver.getModule(moduleName);
  else
    module = frontend.moduleResolverForAutocomplete.getModule(moduleName);

  if (!module)
    return {};

  NotNull<BuiltinTypes> builtinTypes = frontend.builtinTypes;
  Scope *globalScope;
  if (FFlag::DebugLuauDeferredConstraintResolution)
    globalScope = frontend.globals.globalScope.get();
  else
    globalScope = frontend.globalsForAutocomplete.globalScope.get();

  TypeArena typeArena;
  return autocomplete(*sourceModule, module, builtinTypes, &typeArena,
                      globalScope, position, callback);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Clone.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

// For each `Luau::clone` call, we will clone only up to N amount of types _and_
// packs, as controlled by this limit.
LUAU_FASTINTVARIABLE(LuauTypeCloneIterationLimit, 100'000)

namespace Luau {

namespace {

using Kind = Variant<TypeId, TypePackId>;

template <typename T> const T *get(const Kind &kind) {
  return get_if<T>(&kind);
}

class TypeCloner {
  NotNull<TypeArena> arena;
  NotNull<BuiltinTypes> builtinTypes;

  // A queue of kinds where we cloned it, but whose interior types hasn't
  // been updated to point to new clones. Once all of its interior types
  // has been updated, it gets removed from the queue.
  std::vector<Kind> queue;

  NotNull<SeenTypes> types;
  NotNull<SeenTypePacks> packs;

  int steps = 0;

public:
  TypeCloner(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes,
             NotNull<SeenTypes> types, NotNull<SeenTypePacks> packs)
      : arena(arena), builtinTypes(builtinTypes), types(types), packs(packs) {}

  TypeId clone(TypeId ty) {
    shallowClone(ty);
    run();

    if (hasExceededIterationLimit()) {
      TypeId error = builtinTypes->errorRecoveryType();
      (*types)[ty] = error;
      return error;
    }

    return find(ty).value_or(builtinTypes->errorRecoveryType());
  }

  TypePackId clone(TypePackId tp) {
    shallowClone(tp);
    run();

    if (hasExceededIterationLimit()) {
      TypePackId error = builtinTypes->errorRecoveryTypePack();
      (*packs)[tp] = error;
      return error;
    }

    return find(tp).value_or(builtinTypes->errorRecoveryTypePack());
  }

private:
  bool hasExceededIterationLimit() const {
    if (FInt::LuauTypeCloneIterationLimit == 0)
      return false;

    return steps + queue.size() >= size_t(FInt::LuauTypeCloneIterationLimit);
  }

  void run() {
    while (!queue.empty()) {
      ++steps;

      if (hasExceededIterationLimit())
        break;

      Kind kind = queue.back();
      queue.pop_back();

      if (find(kind))
        continue;

      cloneChildren(kind);
    }
  }

  std::optional<TypeId> find(TypeId ty) const {
    ty = follow(ty, FollowOption::DisableLazyTypeThunks);
    if (auto it = types->find(ty); it != types->end())
      return it->second;
    else if (ty->persistent)
      return ty;
    return std::nullopt;
  }

  std::optional<TypePackId> find(TypePackId tp) const {
    tp = follow(tp);
    if (auto it = packs->find(tp); it != packs->end())
      return it->second;
    else if (tp->persistent)
      return tp;
    return std::nullopt;
  }

  std::optional<Kind> find(Kind kind) const {
    if (auto ty = get<TypeId>(kind))
      return find(*ty);
    else if (auto tp = get<TypePackId>(kind))
      return find(*tp);
    else {
      LUAU_ASSERT(!"Unknown kind?");
      return std::nullopt;
    }
  }

private:
  TypeId shallowClone(TypeId ty) {
    // We want to [`Luau::follow`] but without forcing the expansion of
    // [`LazyType`]s.
    ty = follow(ty, FollowOption::DisableLazyTypeThunks);

    if (auto clone = find(ty))
      return *clone;
    else if (ty->persistent)
      return ty;

    TypeId target = arena->addType(ty->ty);
    asMutable(target)->documentationSymbol = ty->documentationSymbol;

    if (auto generic = getMutable<GenericType>(target))
      generic->scope = nullptr;
    else if (auto free = getMutable<FreeType>(target))
      free->scope = nullptr;
    else if (auto fn = getMutable<FunctionType>(target))
      fn->scope = nullptr;
    else if (auto table = getMutable<TableType>(target))
      table->scope = nullptr;

    (*types)[ty] = target;
    queue.push_back(target);
    return target;
  }

  TypePackId shallowClone(TypePackId tp) {
    tp = follow(tp);

    if (auto clone = find(tp))
      return *clone;
    else if (tp->persistent)
      return tp;

    TypePackId target = arena->addTypePack(tp->ty);

    if (auto generic = getMutable<GenericTypePack>(target))
      generic->scope = nullptr;
    else if (auto free = getMutable<FreeTypePack>(target))
      free->scope = nullptr;

    (*packs)[tp] = target;
    queue.push_back(target);
    return target;
  }

  Property shallowClone(const Property &p) {
    if (FFlag::DebugLuauDeferredConstraintResolution) {
      std::optional<TypeId> cloneReadTy;
      if (auto ty = p.readTy)
        cloneReadTy = shallowClone(*ty);

      std::optional<TypeId> cloneWriteTy;
      if (auto ty = p.writeTy)
        cloneWriteTy = shallowClone(*ty);

      Property cloned = Property::create(cloneReadTy, cloneWriteTy);
      cloned.deprecated = p.deprecated;
      cloned.deprecatedSuggestion = p.deprecatedSuggestion;
      cloned.location = p.location;
      cloned.tags = p.tags;
      cloned.documentationSymbol = p.documentationSymbol;
      cloned.typeLocation = p.typeLocation;
      return cloned;
    } else {
      return Property{
          shallowClone(p.type()),
          p.deprecated,
          p.deprecatedSuggestion,
          p.location,
          p.tags,
          p.documentationSymbol,
          p.typeLocation,
      };
    }
  }

  void cloneChildren(TypeId ty) {
    return visit([&](auto &&t) { return cloneChildren(&t); },
                 asMutable(ty)->ty);
  }

  void cloneChildren(TypePackId tp) {
    return visit([&](auto &&t) { return cloneChildren(&t); },
                 asMutable(tp)->ty);
  }

  void cloneChildren(Kind kind) {
    if (auto ty = get<TypeId>(kind))
      return cloneChildren(*ty);
    else if (auto tp = get<TypePackId>(kind))
      return cloneChildren(*tp);
    else
      LUAU_ASSERT(!"Item holds neither TypeId nor TypePackId when enqueuing "
                   "its children?");
  }

  // ErrorType and ErrorTypePack is an alias to this type.
  void cloneChildren(Unifiable::Error *t) {
    // noop.
  }

  void cloneChildren(BoundType *t) { t->boundTo = shallowClone(t->boundTo); }

  void cloneChildren(FreeType *t) {
    if (t->lowerBound)
      t->lowerBound = shallowClone(t->lowerBound);
    if (t->upperBound)
      t->upperBound = shallowClone(t->upperBound);
  }

  void cloneChildren(GenericType *t) {
    // TOOD: clone upper bounds.
  }

  void cloneChildren(PrimitiveType *t) {
    // noop.
  }

  void cloneChildren(BlockedType *t) {
    // TODO: In the new solver, we should ice.
  }

  void cloneChildren(PendingExpansionType *t) {
    // TODO: In the new solver, we should ice.
  }

  void cloneChildren(SingletonType *t) {
    // noop.
  }

  void cloneChildren(FunctionType *t) {
    for (TypeId &g : t->generics)
      g = shallowClone(g);

    for (TypePackId &gp : t->genericPacks)
      gp = shallowClone(gp);

    t->argTypes = shallowClone(t->argTypes);
    t->retTypes = shallowClone(t->retTypes);
  }

  void cloneChildren(TableType *t) {
    if (t->indexer) {
      t->indexer->indexType = shallowClone(t->indexer->indexType);
      t->indexer->indexResultType = shallowClone(t->indexer->indexResultType);
    }

    for (auto &[_, p] : t->props)
      p = shallowClone(p);

    for (TypeId &ty : t->instantiatedTypeParams)
      ty = shallowClone(ty);

    for (TypePackId &tp : t->instantiatedTypePackParams)
      tp = shallowClone(tp);
  }

  void cloneChildren(MetatableType *t) {
    t->table = shallowClone(t->table);
    t->metatable = shallowClone(t->metatable);
  }

  void cloneChildren(ClassType *t) {
    for (auto &[_, p] : t->props)
      p = shallowClone(p);

    if (t->parent)
      t->parent = shallowClone(*t->parent);

    if (t->metatable)
      t->metatable = shallowClone(*t->metatable);

    if (t->indexer) {
      t->indexer->indexType = shallowClone(t->indexer->indexType);
      t->indexer->indexResultType = shallowClone(t->indexer->indexResultType);
    }
  }

  void cloneChildren(AnyType *t) {
    // noop.
  }

  void cloneChildren(UnionType *t) {
    for (TypeId &ty : t->options)
      ty = shallowClone(ty);
  }

  void cloneChildren(IntersectionType *t) {
    for (TypeId &ty : t->parts)
      ty = shallowClone(ty);
  }

  void cloneChildren(LazyType *t) {
    if (auto unwrapped = t->unwrapped.load())
      t->unwrapped.store(shallowClone(unwrapped));
  }

  void cloneChildren(UnknownType *t) {
    // noop.
  }

  void cloneChildren(NeverType *t) {
    // noop.
  }

  void cloneChildren(NegationType *t) { t->ty = shallowClone(t->ty); }

  void cloneChildren(TypeFunctionInstanceType *t) {
    for (TypeId &ty : t->typeArguments)
      ty = shallowClone(ty);

    for (TypePackId &tp : t->packArguments)
      tp = shallowClone(tp);
  }

  void cloneChildren(FreeTypePack *t) {
    // TODO: clone lower and upper bounds.
    // TODO: In the new solver, we should ice.
  }

  void cloneChildren(GenericTypePack *t) {
    // TOOD: clone upper bounds.
  }

  void cloneChildren(BlockedTypePack *t) {
    // TODO: In the new solver, we should ice.
  }

  void cloneChildren(BoundTypePack *t) {
    t->boundTo = shallowClone(t->boundTo);
  }

  void cloneChildren(VariadicTypePack *t) { t->ty = shallowClone(t->ty); }

  void cloneChildren(TypePack *t) {
    for (TypeId &ty : t->head)
      ty = shallowClone(ty);

    if (t->tail)
      t->tail = shallowClone(*t->tail);
  }

  void cloneChildren(TypeFunctionInstanceTypePack *t) {
    for (TypeId &ty : t->typeArguments)
      ty = shallowClone(ty);

    for (TypePackId &tp : t->packArguments)
      tp = shallowClone(tp);
  }
};

} // namespace

TypePackId clone(TypePackId tp, TypeArena &dest, CloneState &cloneState) {
  if (tp->persistent)
    return tp;

  TypeCloner cloner{NotNull{&dest}, cloneState.builtinTypes,
                    NotNull{&cloneState.seenTypes},
                    NotNull{&cloneState.seenTypePacks}};
  return cloner.clone(tp);
}

TypeId clone(TypeId typeId, TypeArena &dest, CloneState &cloneState) {
  if (typeId->persistent)
    return typeId;

  TypeCloner cloner{NotNull{&dest}, cloneState.builtinTypes,
                    NotNull{&cloneState.seenTypes},
                    NotNull{&cloneState.seenTypePacks}};
  return cloner.clone(typeId);
}

TypeFun clone(const TypeFun &typeFun, TypeArena &dest, CloneState &cloneState) {
  TypeCloner cloner{NotNull{&dest}, cloneState.builtinTypes,
                    NotNull{&cloneState.seenTypes},
                    NotNull{&cloneState.seenTypePacks}};

  TypeFun copy = typeFun;

  for (auto &param : copy.typeParams) {
    param.ty = cloner.clone(param.ty);

    if (param.defaultValue)
      param.defaultValue = cloner.clone(*param.defaultValue);
  }

  for (auto &param : copy.typePackParams) {
    param.tp = cloner.clone(param.tp);

    if (param.defaultValue)
      param.defaultValue = cloner.clone(*param.defaultValue);
  }

  copy.type = cloner.clone(copy.type);

  return copy;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Constraint.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

#include "luau_ast_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Set.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeOrPack.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <stdexcept>

// @@@@@ PACK.LUA : was already included! <string>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

/*
 * Enables increasing levels of verbosity for Luau type names when stringifying.
 * After level 2, test cases will break unpredictably because a pointer to their
 * scope will be included in the stringification of generic and free types.
 *
 * Supported values:
 *
 * 0: Disabled, no changes.
 *
 * 1: Prefix free/generic types with free- and gen-, respectively. Also reveal
 * hidden variadic tails. Display block count for local types.
 *
 * 2: Suffix free/generic types with their scope depth.
 *
 * 3: Suffix free/generic types with their scope pointer, if present.
 */
LUAU_FASTINTVARIABLE(DebugLuauVerboseTypeNames, 0)
LUAU_FASTFLAGVARIABLE(DebugLuauToStringNoLexicalSort, false)

namespace Luau {

namespace {

struct FindCyclicTypes final : TypeVisitor {
  FindCyclicTypes() = default;
  FindCyclicTypes(const FindCyclicTypes &) = delete;
  FindCyclicTypes &operator=(const FindCyclicTypes &) = delete;

  bool exhaustive = false;
  Luau::Set<TypeId> visited{{}};
  Luau::Set<TypePackId> visitedPacks{{}};
  std::set<TypeId> cycles;
  std::set<TypePackId> cycleTPs;

  void cycle(TypeId ty) override { cycles.insert(ty); }

  void cycle(TypePackId tp) override { cycleTPs.insert(tp); }

  bool visit(TypeId ty) override { return visited.insert(ty); }

  bool visit(TypePackId tp) override { return visitedPacks.insert(tp); }

  bool visit(TypeId ty, const FreeType &ft) override {
    if (!visited.insert(ty))
      return false;

    if (FFlag::DebugLuauDeferredConstraintResolution) {
      // TODO: Replace these if statements with assert()s when we
      // delete FFlag::DebugLuauDeferredConstraintResolution.
      //
      // When the old solver is used, these pointers are always
      // unused. When the new solver is used, they are never null.

      if (ft.lowerBound)
        traverse(ft.lowerBound);
      if (ft.upperBound)
        traverse(ft.upperBound);
    }

    return false;
  }

  bool visit(TypeId ty, const TableType &ttv) override {
    if (!visited.insert(ty))
      return false;

    if (ttv.name || ttv.syntheticName) {
      for (TypeId itp : ttv.instantiatedTypeParams)
        traverse(itp);

      for (TypePackId itp : ttv.instantiatedTypePackParams)
        traverse(itp);

      return exhaustive;
    }

    return true;
  }

  bool visit(TypeId ty, const ClassType &) override { return false; }

  bool visit(TypeId, const PendingExpansionType &) override { return false; }
};

template <typename TID>
void findCyclicTypes(std::set<TypeId> &cycles, std::set<TypePackId> &cycleTPs,
                     TID ty, bool exhaustive) {
  FindCyclicTypes fct;
  fct.exhaustive = exhaustive;
  fct.traverse(ty);

  cycles = std::move(fct.cycles);
  cycleTPs = std::move(fct.cycleTPs);
}

} // namespace

static std::pair<bool, std::optional<Luau::Name>>
canUseTypeNameInScope(ScopePtr scope, const std::string &name) {
  for (ScopePtr curr = scope; curr; curr = curr->parent) {
    for (const auto &[importName, nameTable] : curr->importedTypeBindings) {
      if (nameTable.count(name))
        return {true, importName};
    }

    if (curr->exportedTypeBindings.count(name))
      return {true, std::nullopt};
  }

  return {false, std::nullopt};
}

struct StringifierState {
  ToStringOptions &opts;
  ToStringResult &result;

  DenseHashMap<TypeId, std::string> cycleNames{{}};
  DenseHashMap<TypePackId, std::string> cycleTpNames{{}};
  Set<void *> seen{{}};
  // `$$$` was chosen as the tombstone for `usedNames` since it is not a valid
  // name syntactically and is relatively short for string comparison reasons.
  DenseHashSet<std::string> usedNames{"$$$"};
  size_t indentation = 0;

  bool exhaustive;

  StringifierState(ToStringOptions &opts, ToStringResult &result)
      : opts(opts), result(result), exhaustive(opts.exhaustive) {
    for (const auto &[_, v] : opts.nameMap.types)
      usedNames.insert(v);
    for (const auto &[_, v] : opts.nameMap.typePacks)
      usedNames.insert(v);
  }

  bool hasSeen(const void *tv) {
    void *ttv = const_cast<void *>(tv);
    if (seen.contains(ttv))
      return true;

    seen.insert(ttv);
    return false;
  }

  void unsee(const void *tv) {
    void *ttv = const_cast<void *>(tv);

    if (seen.contains(ttv))
      seen.erase(ttv);
  }

  std::string getName(TypeId ty) {
    const size_t s = opts.nameMap.types.size();
    std::string &n = opts.nameMap.types[ty];
    if (!n.empty())
      return n;

    for (int count = 0; count < 256; ++count) {
      std::string candidate = generateName(usedNames.size() + count);
      if (!usedNames.contains(candidate)) {
        usedNames.insert(candidate);
        n = candidate;
        return candidate;
      }
    }

    return generateName(s);
  }

  int previousNameIndex = 0;

  std::string getName(TypePackId ty) {
    const size_t s = opts.nameMap.typePacks.size();
    std::string &n = opts.nameMap.typePacks[ty];
    if (!n.empty())
      return n;

    for (int count = 0; count < 256; ++count) {
      std::string candidate = generateName(previousNameIndex + count);
      if (!usedNames.contains(candidate)) {
        previousNameIndex += count;
        usedNames.insert(candidate);
        n = candidate;
        return candidate;
      }
    }

    return generateName(s);
  }

  void emit(const std::string &s) {
    if (opts.maxTypeLength > 0 && result.name.length() > opts.maxTypeLength)
      return;

    result.name += s;
  }

  void emitLevel(Scope *scope) {
    size_t count = 0;
    for (Scope *s = scope; s; s = s->parent.get())
      ++count;

    emit(count);

    if (FInt::DebugLuauVerboseTypeNames >= 3) {
      emit("-");
      char buffer[16];
      uint32_t s = uint32_t(intptr_t(scope) & 0xFFFFFF);
      snprintf(buffer, sizeof(buffer), "0x%x", s);
      emit(buffer);
    }
  }

  void emit(TypeLevel level) {
    emit(std::to_string(level.level));
    emit("-");
    emit(std::to_string(level.subLevel));
  }

  void emit(const char *s) {
    if (opts.maxTypeLength > 0 && result.name.length() > opts.maxTypeLength)
      return;

    result.name += s;
  }

  void emit(int i) { emit(std::to_string(i).c_str()); }

  void emit(size_t i) { emit(std::to_string(i).c_str()); }

  void indent() { indentation += 4; }

  void dedent() { indentation -= 4; }

  void newline() {
    if (!opts.useLineBreaks)
      return emit(" ");

    emit("\n");
    emitIndentation();
  }

private:
  void emitIndentation() {
    if (!opts.useLineBreaks)
      return;

    emit(std::string(indentation, ' '));
  }
};

struct TypeStringifier {
  StringifierState &state;

  explicit TypeStringifier(StringifierState &state) : state(state) {}

  void stringify(TypeId tv) {
    if (state.opts.maxTypeLength > 0 &&
        state.result.name.length() > state.opts.maxTypeLength)
      return;

    if (tv->ty.valueless_by_exception()) {
      state.result.error = true;
      state.emit("* VALUELESS BY EXCEPTION *");
      return;
    }

    if (auto p = state.cycleNames.find(tv)) {
      state.emit(*p);
      return;
    }

    Luau::visit([this, tv](auto &&t) { return (*this)(tv, t); }, tv->ty);
  }

  void emitKey(const std::string &name) {
    if (isIdentifier(name))
      state.emit(name);
    else {
      state.emit("[\"");
      state.emit(escape(name));
      state.emit("\"]");
    }
    state.emit(": ");
  }

  void _newStringify(const std::string &name, const Property &prop) {
    bool comma = false;
    if (prop.isShared()) {
      emitKey(name);
      stringify(prop.type());
      return;
    }

    if (prop.readTy) {
      state.emit("read ");
      emitKey(name);
      stringify(*prop.readTy);
      comma = true;
    }
    if (prop.writeTy) {
      if (comma) {
        state.emit(",");
        state.newline();
      }

      state.emit("write ");
      emitKey(name);
      stringify(*prop.writeTy);
    }
  }

  void stringify(const std::string &name, const Property &prop) {
    if (FFlag::DebugLuauDeferredConstraintResolution)
      return _newStringify(name, prop);

    emitKey(name);
    stringify(prop.type());
  }

  void stringify(TypePackId tp);
  void stringify(TypePackId tpid,
                 const std::vector<std::optional<FunctionArgument>> &names);

  void stringify(const std::vector<TypeId> &types,
                 const std::vector<TypePackId> &typePacks) {
    if (types.size() == 0 && typePacks.size() == 0)
      return;

    if (types.size() || typePacks.size())
      state.emit("<");

    bool first = true;

    for (TypeId ty : types) {
      if (!first)
        state.emit(", ");
      first = false;

      stringify(ty);
    }

    bool singleTp = typePacks.size() == 1;

    for (TypePackId tp : typePacks) {
      if (isEmpty(tp) && singleTp)
        continue;

      if (!first)
        state.emit(", ");
      else
        first = false;

      bool wrap = !singleTp && get<TypePack>(follow(tp));

      if (wrap)
        state.emit("(");

      stringify(tp);

      if (wrap)
        state.emit(")");
    }

    if (types.size() || typePacks.size())
      state.emit(">");
  }

  void operator()(TypeId ty, const FreeType &ftv) {
    state.result.invalid = true;

    // TODO: ftv.lowerBound and ftv.upperBound should always be non-nil when
    // the new solver is used. This can be replaced with an assert.
    if (FFlag::DebugLuauDeferredConstraintResolution && ftv.lowerBound &&
        ftv.upperBound) {
      const TypeId lowerBound = follow(ftv.lowerBound);
      const TypeId upperBound = follow(ftv.upperBound);
      if (get<NeverType>(lowerBound) && get<UnknownType>(upperBound)) {
        state.emit("'");
        state.emit(state.getName(ty));
      } else {
        state.emit("(");
        if (!get<NeverType>(lowerBound)) {
          stringify(lowerBound);
          state.emit(" <: ");
        }
        state.emit("'");
        state.emit(state.getName(ty));

        if (!get<UnknownType>(upperBound)) {
          state.emit(" <: ");
          stringify(upperBound);
        }
        state.emit(")");
      }
      return;
    }

    if (FInt::DebugLuauVerboseTypeNames >= 1)
      state.emit("free-");

    state.emit(state.getName(ty));

    if (FInt::DebugLuauVerboseTypeNames >= 2) {
      state.emit("-");
      if (FFlag::DebugLuauDeferredConstraintResolution)
        state.emitLevel(ftv.scope);
      else
        state.emit(ftv.level);
    }
  }

  void operator()(TypeId, const BoundType &btv) { stringify(btv.boundTo); }

  void operator()(TypeId ty, const GenericType &gtv) {
    if (FInt::DebugLuauVerboseTypeNames >= 1)
      state.emit("gen-");

    if (gtv.explicitName) {
      state.usedNames.insert(gtv.name);
      state.opts.nameMap.types[ty] = gtv.name;
      state.emit(gtv.name);
    } else
      state.emit(state.getName(ty));

    if (FInt::DebugLuauVerboseTypeNames >= 2) {
      state.emit("-");
      if (FFlag::DebugLuauDeferredConstraintResolution)
        state.emitLevel(gtv.scope);
      else
        state.emit(gtv.level);
    }
  }

  void operator()(TypeId, const BlockedType &btv) {
    state.emit("*blocked-");
    state.emit(btv.index);
    state.emit("*");
  }

  void operator()(TypeId ty, const PendingExpansionType &petv) {
    state.emit("*pending-expansion-");
    state.emit(petv.index);
    state.emit("*");
  }

  void operator()(TypeId, const PrimitiveType &ptv) {
    switch (ptv.type) {
    case PrimitiveType::NilType:
      state.emit("nil");
      return;
    case PrimitiveType::Boolean:
      state.emit("boolean");
      return;
    case PrimitiveType::Number:
      state.emit("number");
      return;
    case PrimitiveType::String:
      state.emit("string");
      return;
    case PrimitiveType::Thread:
      state.emit("thread");
      return;
    case PrimitiveType::Buffer:
      state.emit("buffer");
      return;
    case PrimitiveType::Function:
      state.emit("function");
      return;
    case PrimitiveType::Table:
      state.emit("table");
      return;
    default:
      LUAU_ASSERT(!"Unknown primitive type");
      throw InternalCompilerError("Unknown primitive type " +
                                  std::to_string(ptv.type));
    }
  }

  void operator()(TypeId, const SingletonType &stv) {
    if (const BooleanSingleton *bs = Luau::get<BooleanSingleton>(&stv))
      state.emit(bs->value ? "true" : "false");
    else if (const StringSingleton *ss = Luau::get<StringSingleton>(&stv)) {
      state.emit("\"");
      state.emit(escape(ss->value));
      state.emit("\"");
    } else {
      LUAU_ASSERT(!"Unknown singleton type");
      throw InternalCompilerError("Unknown singleton type");
    }
  }

  void operator()(TypeId, const FunctionType &ftv) {
    if (state.hasSeen(&ftv)) {
      state.result.cycle = true;
      state.emit("*CYCLE*");
      return;
    }

    // We should not be respecting opts.hideNamedFunctionTypeParameters here.
    if (ftv.generics.size() > 0 || ftv.genericPacks.size() > 0) {
      state.emit("<");
      bool comma = false;
      for (auto it = ftv.generics.begin(); it != ftv.generics.end(); ++it) {
        if (comma)
          state.emit(", ");
        comma = true;
        stringify(*it);
      }
      for (auto it = ftv.genericPacks.begin(); it != ftv.genericPacks.end();
           ++it) {
        if (comma)
          state.emit(", ");
        comma = true;
        stringify(*it);
      }
      state.emit(">");
    }

    if (FFlag::DebugLuauDeferredConstraintResolution) {
      if (ftv.isCheckedFunction)
        state.emit("@checked ");
    }

    state.emit("(");

    if (state.opts.functionTypeArguments)
      stringify(ftv.argTypes, ftv.argNames);
    else
      stringify(ftv.argTypes);

    state.emit(") -> ");

    bool plural = true;

    auto retBegin = begin(ftv.retTypes);
    auto retEnd = end(ftv.retTypes);
    if (retBegin != retEnd) {
      ++retBegin;
      if (retBegin == retEnd && !retBegin.tail())
        plural = false;
    }

    if (plural)
      state.emit("(");

    stringify(ftv.retTypes);

    if (plural)
      state.emit(")");

    state.unsee(&ftv);
  }

  void operator()(TypeId, const TableType &ttv) {
    if (ttv.boundTo)
      return stringify(*ttv.boundTo);

    if (!state.exhaustive) {
      if (ttv.name) {
        // If scope if provided, add module name and check visibility
        if (state.opts.scope) {
          auto [success, moduleName] =
              canUseTypeNameInScope(state.opts.scope, *ttv.name);

          if (!success)
            state.result.invalid = true;

          if (moduleName) {
            state.emit(*moduleName);
            state.emit(".");
          }
        }

        state.emit(*ttv.name);
        stringify(ttv.instantiatedTypeParams, ttv.instantiatedTypePackParams);
        return;
      }
      if (ttv.syntheticName) {
        state.result.invalid = true;
        state.emit(*ttv.syntheticName);
        stringify(ttv.instantiatedTypeParams, ttv.instantiatedTypePackParams);
        return;
      }
    }

    if (state.hasSeen(&ttv)) {
      state.result.cycle = true;
      state.emit("*CYCLE*");
      return;
    }

    std::string openbrace = "@@@";
    std::string closedbrace = "@@@?!";
    switch (state.opts.hideTableKind
                ? (FFlag::DebugLuauDeferredConstraintResolution
                       ? TableState::Sealed
                       : TableState::Unsealed)
                : ttv.state) {
    case TableState::Sealed:
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        openbrace = "{";
        closedbrace = "}";
      } else {
        state.result.invalid = true;
        openbrace = "{|";
        closedbrace = "|}";
      }
      break;
    case TableState::Unsealed:
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        state.result.invalid = true;
        openbrace = "{|";
        closedbrace = "|}";
      } else {
        openbrace = "{";
        closedbrace = "}";
      }
      break;
    case TableState::Free:
      state.result.invalid = true;
      openbrace = "{-";
      closedbrace = "-}";
      break;
    case TableState::Generic:
      state.result.invalid = true;
      openbrace = "{+";
      closedbrace = "+}";
      break;
    }

    // If this appears to be an array, we want to stringify it using the {T}
    // syntax.
    if (ttv.indexer && ttv.props.empty() && isNumber(ttv.indexer->indexType)) {
      state.emit("{");
      stringify(ttv.indexer->indexResultType);
      state.emit("}");

      state.unsee(&ttv);
      return;
    }

    state.emit(openbrace);
    state.indent();

    bool comma = false;
    if (ttv.indexer) {
      state.newline();
      state.emit("[");
      stringify(ttv.indexer->indexType);
      state.emit("]: ");
      stringify(ttv.indexer->indexResultType);
      comma = true;
    }

    size_t index = 0;
    size_t oldLength = state.result.name.length();
    for (const auto &[name, prop] : ttv.props) {
      if (comma) {
        state.emit(",");
        state.newline();
      } else
        state.newline();

      size_t length = state.result.name.length() - oldLength;

      if (state.opts.maxTableLength > 0 &&
          (length - 2 * index) >= state.opts.maxTableLength) {
        state.emit("... ");
        state.emit(std::to_string(ttv.props.size() - index));
        state.emit(" more ...");
        break;
      }

      stringify(name, prop);

      comma = true;
      ++index;
    }

    state.dedent();
    if (comma)
      state.newline();
    else
      state.emit("  ");
    state.emit(closedbrace);

    state.unsee(&ttv);
  }

  void operator()(TypeId, const MetatableType &mtv) {
    state.result.invalid = true;
    if (!state.exhaustive && mtv.syntheticName) {
      state.emit(*mtv.syntheticName);
      return;
    }

    state.emit("{ @metatable ");
    stringify(mtv.metatable);
    state.emit(",");
    state.newline();
    stringify(mtv.table);
    state.emit(" }");
  }

  void operator()(TypeId, const ClassType &ctv) { state.emit(ctv.name); }

  void operator()(TypeId, const AnyType &) { state.emit("any"); }

  void operator()(TypeId, const UnionType &uv) {
    if (state.hasSeen(&uv)) {
      state.result.cycle = true;
      state.emit("*CYCLE*");
      return;
    }

    bool optional = false;
    bool hasNonNilDisjunct = false;

    std::vector<std::string> results = {};
    for (auto el : &uv) {
      el = follow(el);

      if (isNil(el)) {
        optional = true;
        continue;
      } else {
        hasNonNilDisjunct = true;
      }

      std::string saved = std::move(state.result.name);

      bool needParens = !state.cycleNames.contains(el) &&
                        (get<IntersectionType>(el) || get<FunctionType>(el));

      if (needParens)
        state.emit("(");

      stringify(el);

      if (needParens)
        state.emit(")");

      results.push_back(std::move(state.result.name));
      state.result.name = std::move(saved);
    }

    state.unsee(&uv);

    if (!FFlag::DebugLuauToStringNoLexicalSort)
      std::sort(results.begin(), results.end());

    if (optional && results.size() > 1)
      state.emit("(");

    bool first = true;
    bool shouldPlaceOnNewlines =
        results.size() > state.opts.compositeTypesSingleLineLimit;
    for (std::string &ss : results) {
      if (!first) {
        if (shouldPlaceOnNewlines)
          state.newline();
        else
          state.emit(" ");
        state.emit("| ");
      }
      state.emit(ss);
      first = false;
    }

    if (optional) {
      const char *s = "?";
      if (results.size() > 1)
        s = ")?";

      if (!hasNonNilDisjunct)
        s = "nil";

      state.emit(s);
    }
  }

  void operator()(TypeId ty, const IntersectionType &uv) {
    if (state.hasSeen(&uv)) {
      state.result.cycle = true;
      state.emit("*CYCLE*");
      return;
    }

    std::vector<std::string> results = {};
    for (auto el : uv.parts) {
      el = follow(el);

      std::string saved = std::move(state.result.name);

      bool needParens = !state.cycleNames.contains(el) &&
                        (get<UnionType>(el) || get<FunctionType>(el));

      if (needParens)
        state.emit("(");

      stringify(el);

      if (needParens)
        state.emit(")");

      results.push_back(std::move(state.result.name));
      state.result.name = std::move(saved);
    }

    state.unsee(&uv);

    if (!FFlag::DebugLuauToStringNoLexicalSort)
      std::sort(results.begin(), results.end());

    bool first = true;
    bool shouldPlaceOnNewlines =
        results.size() > state.opts.compositeTypesSingleLineLimit ||
        isOverloadedFunction(ty);
    for (std::string &ss : results) {
      if (!first) {
        if (shouldPlaceOnNewlines)
          state.newline();
        else
          state.emit(" ");
        state.emit("& ");
      }
      state.emit(ss);
      first = false;
    }
  }

  void operator()(TypeId, const ErrorType &tv) {
    state.result.error = true;
    state.emit("*error-type*");
  }

  void operator()(TypeId, const LazyType &ltv) {
    if (TypeId unwrapped = ltv.unwrapped.load()) {
      stringify(unwrapped);
    } else {
      state.result.invalid = true;
      state.emit("lazy?");
    }
  }

  void operator()(TypeId, const UnknownType &ttv) { state.emit("unknown"); }

  void operator()(TypeId, const NeverType &ttv) { state.emit("never"); }

  void operator()(TypeId, const NegationType &ntv) {
    state.emit("~");

    // The precedence of `~` should be less than `|` and `&`.
    TypeId followed = follow(ntv.ty);
    bool parens = get<UnionType>(followed) || get<IntersectionType>(followed);

    if (parens)
      state.emit("(");

    stringify(ntv.ty);

    if (parens)
      state.emit(")");
  }

  void operator()(TypeId, const TypeFunctionInstanceType &tfitv) {
    state.emit(tfitv.family->name);
    state.emit("<");

    bool comma = false;
    for (TypeId ty : tfitv.typeArguments) {
      if (comma)
        state.emit(", ");

      comma = true;
      stringify(ty);
    }

    for (TypePackId tp : tfitv.packArguments) {
      if (comma)
        state.emit(", ");

      comma = true;
      stringify(tp);
    }

    state.emit(">");
  }
};

struct TypePackStringifier {
  StringifierState &state;

  const std::vector<std::optional<FunctionArgument>> elemNames;
  static inline const std::vector<std::optional<FunctionArgument>>
      dummyElemNames = {};
  unsigned elemIndex = 0;

  explicit TypePackStringifier(
      StringifierState &state,
      const std::vector<std::optional<FunctionArgument>> &elemNames)
      : state(state), elemNames(elemNames) {}

  explicit TypePackStringifier(StringifierState &state)
      : state(state), elemNames(dummyElemNames) {}

  void stringify(TypeId tv) {
    TypeStringifier tvs{state};
    tvs.stringify(tv);
  }

  void stringify(TypePackId tp) {
    if (state.opts.maxTypeLength > 0 &&
        state.result.name.length() > state.opts.maxTypeLength)
      return;

    if (tp->ty.valueless_by_exception()) {
      state.result.error = true;
      state.emit("* VALUELESS TP BY EXCEPTION *");
      return;
    }

    if (auto p = state.cycleTpNames.find(tp)) {
      state.emit(*p);
      return;
    }

    Luau::visit([this, tp](auto &&t) { return (*this)(tp, t); }, tp->ty);
  }

  void operator()(TypePackId, const TypePack &tp) {
    if (state.hasSeen(&tp)) {
      state.result.cycle = true;
      state.emit("*CYCLETP*");
      return;
    }

    bool first = true;

    for (const auto &typeId : tp.head) {
      if (first)
        first = false;
      else
        state.emit(", ");

      // Do not respect opts.namedFunctionOverrideArgNames here
      if (elemIndex < elemNames.size() && elemNames[elemIndex]) {
        state.emit(elemNames[elemIndex]->name);
        state.emit(": ");
      }

      elemIndex++;

      stringify(typeId);
    }

    if (tp.tail && !isEmpty(*tp.tail)) {
      TypePackId tail = follow(*tp.tail);
      if (auto vtp = get<VariadicTypePack>(tail);
          !vtp || (FInt::DebugLuauVerboseTypeNames < 1 && !vtp->hidden)) {
        if (first)
          first = false;
        else
          state.emit(", ");

        stringify(tail);
      }
    }

    state.unsee(&tp);
  }

  void operator()(TypePackId, const Unifiable::Error &error) {
    state.result.error = true;
    state.emit("*error-type*");
  }

  void operator()(TypePackId, const VariadicTypePack &pack) {
    state.emit("...");
    if (FInt::DebugLuauVerboseTypeNames >= 1 && pack.hidden) {
      state.emit("*hidden*");
    }
    stringify(pack.ty);
  }

  void operator()(TypePackId tp, const GenericTypePack &pack) {
    if (FInt::DebugLuauVerboseTypeNames >= 1)
      state.emit("gen-");

    if (pack.explicitName) {
      state.usedNames.insert(pack.name);
      state.opts.nameMap.typePacks[tp] = pack.name;
      state.emit(pack.name);
    } else {
      state.emit(state.getName(tp));
    }

    if (FInt::DebugLuauVerboseTypeNames >= 2) {
      state.emit("-");
      if (FFlag::DebugLuauDeferredConstraintResolution)
        state.emitLevel(pack.scope);
      else
        state.emit(pack.level);
    }

    state.emit("...");
  }

  void operator()(TypePackId tp, const FreeTypePack &pack) {
    state.result.invalid = true;
    if (FInt::DebugLuauVerboseTypeNames >= 1)
      state.emit("free-");
    state.emit(state.getName(tp));

    if (FInt::DebugLuauVerboseTypeNames >= 2) {
      state.emit("-");
      if (FFlag::DebugLuauDeferredConstraintResolution)
        state.emitLevel(pack.scope);
      else
        state.emit(pack.level);
    }

    state.emit("...");
  }

  void operator()(TypePackId, const BoundTypePack &btv) {
    stringify(btv.boundTo);
  }

  void operator()(TypePackId, const BlockedTypePack &btp) {
    state.emit("*blocked-tp-");
    state.emit(btp.index);
    state.emit("*");
  }

  void operator()(TypePackId, const TypeFunctionInstanceTypePack &tfitp) {
    state.emit(tfitp.family->name);
    state.emit("<");

    bool comma = false;
    for (TypeId p : tfitp.typeArguments) {
      if (comma)
        state.emit(", ");

      comma = true;
      stringify(p);
    }

    for (TypePackId p : tfitp.packArguments) {
      if (comma)
        state.emit(", ");

      comma = true;
      stringify(p);
    }

    state.emit(">");
  }
};

void TypeStringifier::stringify(TypePackId tp) {
  TypePackStringifier tps(state);
  tps.stringify(tp);
}

void TypeStringifier::stringify(
    TypePackId tpid,
    const std::vector<std::optional<FunctionArgument>> &names) {
  TypePackStringifier tps(state, names);
  tps.stringify(tpid);
}

static void assignCycleNames(
    const std::set<TypeId> &cycles, const std::set<TypePackId> &cycleTPs,
    DenseHashMap<TypeId, std::string> &cycleNames,
    DenseHashMap<TypePackId, std::string> &cycleTpNames, bool exhaustive) {
  int nextIndex = 1;

  for (TypeId cycleTy : cycles) {
    std::string name;

    // TODO: use the stringified type list if there are no cycles
    if (auto ttv = get<TableType>(follow(cycleTy));
        !exhaustive && ttv && (ttv->syntheticName || ttv->name)) {
      // If we have a cycle type in type parameters, assign a cycle name for
      // this named table
      if (std::find_if(ttv->instantiatedTypeParams.begin(),
                       ttv->instantiatedTypeParams.end(), [&](auto &&el) {
                         return cycles.count(follow(el));
                       }) != ttv->instantiatedTypeParams.end())
        cycleNames[cycleTy] = ttv->name ? *ttv->name : *ttv->syntheticName;

      continue;
    }

    name = "t" + std::to_string(nextIndex);
    ++nextIndex;

    cycleNames[cycleTy] = std::move(name);
  }

  for (TypePackId tp : cycleTPs) {
    std::string name = "tp" + std::to_string(nextIndex);
    ++nextIndex;
    cycleTpNames[tp] = std::move(name);
  }
}

ToStringResult toStringDetailed(TypeId ty, ToStringOptions &opts) {
  /*
   * 1. Walk the Type and track seen TypeIds.  When you reencounter a TypeId,
   * add it to a set of seen cycles.
   * 2. Generate some names for each cycle.  For a starting point, we can just
   * call them t0, t1 and so on.
   * 3. For each seen cycle, stringify it like we do now, but replace each known
   * cycle with its name.
   * 4. Print out the root of the type using the same algorithm as step 3.
   */
  ty = follow(ty);
  ToStringResult result;

  StringifierState state{opts, result};

  std::set<TypeId> cycles;
  std::set<TypePackId> cycleTPs;

  findCyclicTypes(cycles, cycleTPs, ty, opts.exhaustive);

  assignCycleNames(cycles, cycleTPs, state.cycleNames, state.cycleTpNames,
                   opts.exhaustive);

  TypeStringifier tvs{state};

  if (!opts.exhaustive) {
    if (auto ttv = get<TableType>(ty);
        ttv && (ttv->name || ttv->syntheticName)) {
      if (ttv->syntheticName)
        result.invalid = true;

      // If scope if provided, add module name and check visibility
      if (ttv->name && opts.scope) {
        auto [success, moduleName] =
            canUseTypeNameInScope(opts.scope, *ttv->name);

        if (!success)
          result.invalid = true;

        if (moduleName)
          result.name = format("%s.", moduleName->c_str());
      }

      result.name += ttv->name ? *ttv->name : *ttv->syntheticName;

      tvs.stringify(ttv->instantiatedTypeParams,
                    ttv->instantiatedTypePackParams);

      return result;
    } else if (auto mtv = get<MetatableType>(ty); mtv && mtv->syntheticName) {
      result.invalid = true;
      result.name = *mtv->syntheticName;
      return result;
    }
  }

  /* If the root itself is a cycle, we special case a little.
   * We go out of our way to print the following:
   *
   * t1 where t1 = the_whole_root_type
   */
  if (auto p = state.cycleNames.find(ty))
    state.emit(*p);
  else
    tvs.stringify(ty);

  if (!state.cycleNames.empty() || !state.cycleTpNames.empty()) {
    result.cycle = true;
    state.emit(" where ");
  }

  state.exhaustive = true;

  std::vector<std::pair<TypeId, std::string>> sortedCycleNames{
      state.cycleNames.begin(), state.cycleNames.end()};
  std::sort(sortedCycleNames.begin(), sortedCycleNames.end(),
            [](const auto &a, const auto &b) { return a.second < b.second; });

  bool semi = false;
  for (const auto &[cycleTy, name] : sortedCycleNames) {
    if (semi)
      state.emit(" ; ");

    state.emit(name);
    state.emit(" = ");
    Luau::visit([&tvs, cycleTy = cycleTy](auto &&t) { return tvs(cycleTy, t); },
                cycleTy->ty);

    semi = true;
  }

  std::vector<std::pair<TypePackId, std::string>> sortedCycleTpNames(
      state.cycleTpNames.begin(), state.cycleTpNames.end());
  std::sort(sortedCycleTpNames.begin(), sortedCycleTpNames.end(),
            [](const auto &a, const auto &b) { return a.second < b.second; });

  TypePackStringifier tps{state};

  for (const auto &[cycleTp, name] : sortedCycleTpNames) {
    if (semi)
      state.emit(" ; ");

    state.emit(name);
    state.emit(" = ");
    Luau::visit([&tps, cycleTy = cycleTp](auto &&t) { return tps(cycleTy, t); },
                cycleTp->ty);

    semi = true;
  }

  if (opts.maxTypeLength > 0 && result.name.length() > opts.maxTypeLength) {
    result.truncated = true;

    result.name += "... *TRUNCATED*";
  }

  return result;
}

ToStringResult toStringDetailed(TypePackId tp, ToStringOptions &opts) {
  /*
   * 1. Walk the Type and track seen TypeIds.  When you reencounter a TypeId,
   * add it to a set of seen cycles.
   * 2. Generate some names for each cycle.  For a starting point, we can just
   * call them t0, t1 and so on.
   * 3. For each seen cycle, stringify it like we do now, but replace each known
   * cycle with its name.
   * 4. Print out the root of the type using the same algorithm as step 3.
   */
  ToStringResult result;
  StringifierState state{opts, result};

  std::set<TypeId> cycles;
  std::set<TypePackId> cycleTPs;

  findCyclicTypes(cycles, cycleTPs, tp, opts.exhaustive);

  assignCycleNames(cycles, cycleTPs, state.cycleNames, state.cycleTpNames,
                   opts.exhaustive);

  TypeStringifier tvs{state};

  /* If the root itself is a cycle, we special case a little.
   * We go out of our way to print the following:
   *
   * t1 where t1 = the_whole_root_type
   */
  if (auto p = state.cycleTpNames.find(tp))
    state.emit(*p);
  else
    tvs.stringify(tp);

  if (!cycles.empty() || !cycleTPs.empty()) {
    result.cycle = true;
    state.emit(" where ");
  }

  state.exhaustive = true;

  std::vector<std::pair<TypeId, std::string>> sortedCycleNames{
      state.cycleNames.begin(), state.cycleNames.end()};
  std::sort(sortedCycleNames.begin(), sortedCycleNames.end(),
            [](const auto &a, const auto &b) { return a.second < b.second; });

  bool semi = false;
  for (const auto &[cycleTy, name] : sortedCycleNames) {
    if (semi)
      state.emit(" ; ");

    state.emit(name);
    state.emit(" = ");
    Luau::visit([&tvs, cycleTy = cycleTy](auto t) { return tvs(cycleTy, t); },
                cycleTy->ty);

    semi = true;
  }

  std::vector<std::pair<TypePackId, std::string>> sortedCycleTpNames{
      state.cycleTpNames.begin(), state.cycleTpNames.end()};
  std::sort(sortedCycleTpNames.begin(), sortedCycleTpNames.end(),
            [](const auto &a, const auto &b) { return a.second < b.second; });

  TypePackStringifier tps{tvs.state};

  for (const auto &[cycleTp, name] : sortedCycleTpNames) {
    if (semi)
      state.emit(" ; ");

    state.emit(name);
    state.emit(" = ");
    Luau::visit([&tps, cycleTp = cycleTp](auto t) { return tps(cycleTp, t); },
                cycleTp->ty);

    semi = true;
  }

  if (opts.maxTypeLength > 0 && result.name.length() > opts.maxTypeLength) {
    result.name += "... *TRUNCATED*";
  }

  return result;
}

std::string toString(TypeId ty, ToStringOptions &opts) {
  return toStringDetailed(ty, opts).name;
}

std::string toString(TypePackId tp, ToStringOptions &opts) {
  return toStringDetailed(tp, opts).name;
}

std::string toString(const Type &tv, ToStringOptions &opts) {
  return toString(const_cast<TypeId>(&tv), opts);
}

std::string toString(const TypePackVar &tp, ToStringOptions &opts) {
  return toString(const_cast<TypePackId>(&tp), opts);
}

std::string toStringNamedFunction(const std::string &funcName,
                                  const FunctionType &ftv,
                                  ToStringOptions &opts) {
  ToStringResult result;
  StringifierState state{opts, result};
  TypeStringifier tvs{state};

  state.emit(funcName);

  if (!opts.hideNamedFunctionTypeParameters)
    tvs.stringify(ftv.generics, ftv.genericPacks);

  state.emit("(");

  auto argPackIter = begin(ftv.argTypes);

  bool first = true;
  size_t idx = 0;
  while (argPackIter != end(ftv.argTypes)) {
    // ftv takes a self parameter as the first argument, skip it if specified in
    // option
    if (idx == 0 && ftv.hasSelf && opts.hideFunctionSelfArgument) {
      ++argPackIter;
      ++idx;
      continue;
    }

    if (!first)
      state.emit(", ");
    first = false;

    // We don't respect opts.functionTypeArguments
    if (idx < opts.namedFunctionOverrideArgNames.size()) {
      state.emit(opts.namedFunctionOverrideArgNames[idx] + ": ");
    } else if (idx < ftv.argNames.size() && ftv.argNames[idx]) {
      state.emit(ftv.argNames[idx]->name + ": ");
    } else {
      state.emit("_: ");
    }
    tvs.stringify(*argPackIter);

    ++argPackIter;
    ++idx;
  }

  if (argPackIter.tail()) {
    if (auto vtp = get<VariadicTypePack>(*argPackIter.tail());
        !vtp || !vtp->hidden) {
      if (!first)
        state.emit(", ");

      state.emit("...: ");

      if (vtp)
        tvs.stringify(vtp->ty);
      else
        tvs.stringify(*argPackIter.tail());
    }
  }

  state.emit("): ");

  size_t retSize = size(ftv.retTypes);
  bool hasTail = !finite(ftv.retTypes);
  bool wrap = get<TypePack>(follow(ftv.retTypes)) &&
              (hasTail ? retSize != 0 : retSize != 1);

  if (wrap)
    state.emit("(");

  tvs.stringify(ftv.retTypes);

  if (wrap)
    state.emit(")");

  return result.name;
}

static ToStringOptions &dumpOptions() {
  static ToStringOptions opts = ([]() {
    ToStringOptions o;
    o.exhaustive = true;
    o.functionTypeArguments = true;
    o.maxTableLength = 0;
    o.maxTypeLength = 0;
    return o;
  })();

  return opts;
}

std::string dump(TypeId ty) {
  std::string s = toString(ty, dumpOptions());
  printf("%s\n", s.c_str());
  return s;
}

std::string dump(const std::optional<TypeId> &ty) {
  if (ty)
    return dump(*ty);

  printf("nullopt\n");
  return "nullopt";
}

std::string dump(TypePackId ty) {
  std::string s = toString(ty, dumpOptions());
  printf("%s\n", s.c_str());
  return s;
}

std::string dump(const std::optional<TypePackId> &ty) {
  if (ty)
    return dump(*ty);

  printf("nullopt\n");
  return "nullopt";
}

std::string dump(const ScopePtr &scope, const char *name) {
  auto binding = scope->linearSearchForBinding(name);
  if (!binding) {
    printf("No binding %s\n", name);
    return {};
  }

  TypeId ty = binding->typeId;
  std::string s = toString(ty, dumpOptions());
  printf("%s\n", s.c_str());
  return s;
}

std::string generateName(size_t i) {
  std::string n;
  n = char('a' + i % 26);
  if (i >= 26)
    n += std::to_string(i / 26);
  return n;
}

std::string toStringVector(const std::vector<TypeId> &types,
                           ToStringOptions &opts) {
  std::string s;
  for (TypeId ty : types) {
    if (!s.empty())
      s += ", ";
    s += toString(ty, opts);
  }
  return s;
}

std::string toString(const Constraint &constraint, ToStringOptions &opts) {
  auto go = [&opts](auto &&c) -> std::string {
    using T = std::decay_t<decltype(c)>;

    auto tos = [&opts](auto &&a) { return toString(a, opts); };

    if constexpr (std::is_same_v<T, SubtypeConstraint>) {
      std::string subStr = tos(c.subType);
      std::string superStr = tos(c.superType);
      return subStr + " <: " + superStr;
    } else if constexpr (std::is_same_v<T, PackSubtypeConstraint>) {
      std::string subStr = tos(c.subPack);
      std::string superStr = tos(c.superPack);
      return subStr + " <...: " + superStr;
    } else if constexpr (std::is_same_v<T, GeneralizationConstraint>) {
      std::string subStr = tos(c.generalizedType);
      std::string superStr = tos(c.sourceType);
      return subStr + " ~ gen " + superStr;
    } else if constexpr (std::is_same_v<T, IterableConstraint>) {
      std::string iteratorStr = tos(c.iterator);
      std::string variableStr = toStringVector(c.variables, opts);

      return variableStr + " ~ iterate " + iteratorStr;
    } else if constexpr (std::is_same_v<T, NameConstraint>) {
      std::string namedStr = tos(c.namedType);
      return "@name(" + namedStr + ") = " + c.name;
    } else if constexpr (std::is_same_v<T, TypeAliasExpansionConstraint>) {
      std::string targetStr = tos(c.target);
      return "expand " + targetStr;
    } else if constexpr (std::is_same_v<T, FunctionCallConstraint>) {
      return "call " + tos(c.fn) + "( " + tos(c.argsPack) + " )" +
             " with { result = " + tos(c.result) + " }";
    } else if constexpr (std::is_same_v<T, FunctionCheckConstraint>) {
      return "function_check " + tos(c.fn) + " " + tos(c.argsPack);
    } else if constexpr (std::is_same_v<T, PrimitiveTypeConstraint>) {
      if (c.expectedType)
        return "prim " + tos(c.freeType) +
               "[expected: " + tos(*c.expectedType) + "] as " +
               tos(c.primitiveType);
      else
        return "prim " + tos(c.freeType) + " as " + tos(c.primitiveType);
    } else if constexpr (std::is_same_v<T, HasPropConstraint>) {
      return tos(c.resultType) + " ~ hasProp " + tos(c.subjectType) + ", \"" +
             c.prop + "\" ctx=" + std::to_string(int(c.context));
    } else if constexpr (std::is_same_v<T, HasIndexerConstraint>) {
      return tos(c.resultType) + " ~ hasIndexer " + tos(c.subjectType) + " " +
             tos(c.indexType);
    } else if constexpr (std::is_same_v<T, AssignPropConstraint>)
      return "assignProp " + tos(c.lhsType) + " " + c.propName + " " +
             tos(c.rhsType);
    else if constexpr (std::is_same_v<T, AssignIndexConstraint>)
      return "assignIndex " + tos(c.lhsType) + " " + tos(c.indexType) + " " +
             tos(c.rhsType);
    else if constexpr (std::is_same_v<T, UnpackConstraint>)
      return toStringVector(c.resultPack, opts) + " ~ ...unpack " +
             tos(c.sourcePack);
    else if constexpr (std::is_same_v<T, ReduceConstraint>)
      return "reduce " + tos(c.ty);
    else if constexpr (std::is_same_v<T, ReducePackConstraint>) {
      return "reduce " + tos(c.tp);
    } else if constexpr (std::is_same_v<T, EqualityConstraint>)
      return "equality: " + tos(c.resultType) + " ~ " + tos(c.assignmentType);
    else
      static_assert(always_false_v<T>, "Non-exhaustive constraint switch");
  };

  return visit(go, constraint.c);
}

std::string toString(const Constraint &constraint) {
  return toString(constraint, ToStringOptions{});
}

std::string dump(const Constraint &c) {
  ToStringOptions opts;
  opts.exhaustive = true;
  opts.functionTypeArguments = true;
  std::string s = toString(c, opts);
  printf("%s\n", s.c_str());
  return s;
}

std::optional<std::string> getFunctionNameAsString(const AstExpr &expr) {
  const AstExpr *curr = &expr;
  std::string s;

  for (;;) {
    if (auto local = curr->as<AstExprLocal>())
      return local->local->name.value + s;

    if (auto global = curr->as<AstExprGlobal>())
      return global->name.value + s;

    if (auto indexname = curr->as<AstExprIndexName>()) {
      curr = indexname->expr;

      s = "." + std::string(indexname->index.value) + s;
    } else if (auto group = curr->as<AstExprGroup>()) {
      curr = group->expr;
    } else {
      return std::nullopt;
    }
  }

  return s;
}

std::string toString(const Position &position) {
  return "{ line = " + std::to_string(position.line) +
         ", col = " + std::to_string(position.column) + " }";
}

std::string toString(const Location &location, int offset, bool useBegin) {
  return "(" + std::to_string(location.begin.line + offset) + ", " +
         std::to_string(location.begin.column + offset) + ") - (" +
         std::to_string(location.end.line + offset) + ", " +
         std::to_string(location.end.column + offset) + ")";
}

std::string toString(const TypeOrPack &tyOrTp, ToStringOptions &opts) {
  if (const TypeId *ty = get<TypeId>(tyOrTp))
    return toString(*ty, opts);
  else if (const TypePackId *tp = get<TypePackId>(tyOrTp))
    return toString(*tp, opts);
  else
    LUAU_UNREACHABLE();
}

std::string dump(const TypeOrPack &tyOrTp) {
  ToStringOptions opts;
  opts.exhaustive = true;
  opts.functionTypeArguments = true;
  std::string s = toString(tyOrTp, opts);
  printf("%s\n", s.c_str());
  return s;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Transpiler.h>

#include "luau_ast_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@ PACK.lua : not found, likely and std header
#include <limits>

// @@@@@ PACK.LUA : was already included! <math.h>

namespace {
bool isIdentifierStartChar(char c) {
  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_';
}

bool isDigit(char c) { return c >= '0' && c <= '9'; }

bool isIdentifierChar(char c) { return isIdentifierStartChar(c) || isDigit(c); }

const std::vector<std::string> keywords = {
    "and", "break",    "do",     "else", "elseif", "end",   "false",
    "for", "function", "if",     "in",   "local",  "nil",   "not",
    "or",  "repeat",   "return", "then", "true",   "until", "while"};

} // namespace

namespace Luau {

struct Writer {
  virtual ~Writer() {}

  virtual void advance(const Position &) = 0;
  virtual void newline() = 0;
  virtual void space() = 0;
  virtual void maybeSpace(const Position &newPos, int reserve) = 0;
  virtual void write(std::string_view) = 0;
  virtual void identifier(std::string_view name) = 0;
  virtual void keyword(std::string_view) = 0;
  virtual void symbol(std::string_view) = 0;
  virtual void literal(std::string_view) = 0;
  virtual void string(std::string_view) = 0;
};

struct StringWriter : Writer {
  std::string ss;
  Position pos{0, 0};
  char lastChar = '\0'; // used to determine whether we need to inject an extra
                        // space to preserve grammatical correctness.

  const std::string &str() const { return ss; }

  void advance(const Position &newPos) override {
    while (pos.line < newPos.line)
      newline();

    if (pos.column < newPos.column)
      write(std::string(newPos.column - pos.column, ' '));
  }

  void maybeSpace(const Position &newPos, int reserve) override {
    if (pos.column + reserve < newPos.column)
      space();
  }

  void newline() override {
    ss += '\n';
    pos.column = 0;
    ++pos.line;
    lastChar = '\n';
  }

  void space() override {
    ss += ' ';
    ++pos.column;
    lastChar = ' ';
  }

  void write(std::string_view s) override {
    if (s.empty())
      return;

    ss.append(s.data(), s.size());
    pos.column += unsigned(s.size());
    lastChar = s[s.size() - 1];
  }

  void write(char c) {
    ss += c;
    pos.column += 1;
    lastChar = c;
  }

  void identifier(std::string_view s) override {
    if (s.empty())
      return;

    if (isIdentifierChar(lastChar))
      space();

    write(s);
  }

  void keyword(std::string_view s) override {
    if (s.empty())
      return;

    if (isIdentifierChar(lastChar))
      space();

    write(s);
  }

  void symbol(std::string_view s) override {
    if (isDigit(lastChar) && s[0] == '.')
      space();

    write(s);
  }

  void literal(std::string_view s) override {
    if (s.empty())
      return;

    else if (isIdentifierChar(lastChar) && isDigit(s[0]))
      space();

    write(s);
  }

  void string(std::string_view s) override {
    char quote = '\'';
    if (std::string::npos != s.find(quote))
      quote = '\"';

    write(quote);
    write(escape(s));
    write(quote);
  }
};

class CommaSeparatorInserter {
public:
  CommaSeparatorInserter(Writer &w) : first(true), writer(w) {}
  void operator()() {
    if (first)
      first = !first;
    else
      writer.symbol(",");
  }

private:
  bool first;
  Writer &writer;
};

struct Printer {
  explicit Printer(Writer &writer) : writer(writer) {}

  bool writeTypes = false;
  Writer &writer;

  void visualize(const AstLocal &local) {
    advance(local.location.begin);

    writer.identifier(local.name.value);
    if (writeTypes && local.annotation) {
      writer.symbol(":");
      visualizeTypeAnnotation(*local.annotation);
    }
  }

  void visualizeTypePackAnnotation(const AstTypePack &annotation,
                                   bool forVarArg) {
    advance(annotation.location.begin);
    if (const AstTypePackVariadic *variadicTp =
            annotation.as<AstTypePackVariadic>()) {
      if (!forVarArg)
        writer.symbol("...");

      visualizeTypeAnnotation(*variadicTp->variadicType);
    } else if (const AstTypePackGeneric *genericTp =
                   annotation.as<AstTypePackGeneric>()) {
      writer.symbol(genericTp->genericName.value);
      writer.symbol("...");
    } else if (const AstTypePackExplicit *explicitTp =
                   annotation.as<AstTypePackExplicit>()) {
      LUAU_ASSERT(!forVarArg);
      visualizeTypeList(explicitTp->typeList, true);
    } else {
      LUAU_ASSERT(!"Unknown TypePackAnnotation kind");
    }
  }

  void visualizeTypeList(const AstTypeList &list,
                         bool unconditionallyParenthesize) {
    size_t typeCount = list.types.size + (list.tailType != nullptr ? 1 : 0);
    if (typeCount == 0) {
      writer.symbol("(");
      writer.symbol(")");
    } else if (typeCount == 1) {
      if (unconditionallyParenthesize)
        writer.symbol("(");

      // Only variadic tail
      if (list.types.size == 0) {
        visualizeTypePackAnnotation(*list.tailType, false);
      } else {
        visualizeTypeAnnotation(*list.types.data[0]);
      }

      if (unconditionallyParenthesize)
        writer.symbol(")");
    } else {
      writer.symbol("(");

      bool first = true;
      for (const auto &el : list.types) {
        if (first)
          first = false;
        else
          writer.symbol(",");

        visualizeTypeAnnotation(*el);
      }

      if (list.tailType) {
        writer.symbol(",");
        visualizeTypePackAnnotation(*list.tailType, false);
      }

      writer.symbol(")");
    }
  }

  bool isIntegerish(double d) {
    if (d <= std::numeric_limits<int>::max() &&
        d >= std::numeric_limits<int>::min())
      return double(int(d)) == d && !(d == 0.0 && signbit(d));
    else
      return false;
  }

  void visualize(AstExpr &expr) {
    advance(expr.location.begin);

    if (const auto &a = expr.as<AstExprGroup>()) {
      writer.symbol("(");
      visualize(*a->expr);
      writer.symbol(")");
    } else if (expr.is<AstExprConstantNil>()) {
      writer.keyword("nil");
    } else if (const auto &a = expr.as<AstExprConstantBool>()) {
      if (a->value)
        writer.keyword("true");
      else
        writer.keyword("false");
    } else if (const auto &a = expr.as<AstExprConstantNumber>()) {
      if (isinf(a->value)) {
        if (a->value > 0)
          writer.literal("1e500");
        else
          writer.literal("-1e500");
      } else if (isnan(a->value))
        writer.literal("0/0");
      else {
        if (isIntegerish(a->value))
          writer.literal(std::to_string(int(a->value)));
        else {
          char buffer[100];
          size_t len = snprintf(buffer, sizeof(buffer), "%.17g", a->value);
          writer.literal(std::string_view{buffer, len});
        }
      }
    } else if (const auto &a = expr.as<AstExprConstantString>()) {
      writer.string(std::string_view(a->value.data, a->value.size));
    } else if (const auto &a = expr.as<AstExprLocal>()) {
      writer.identifier(a->local->name.value);
    } else if (const auto &a = expr.as<AstExprGlobal>()) {
      writer.identifier(a->name.value);
    } else if (expr.is<AstExprVarargs>()) {
      writer.symbol("...");
    } else if (const auto &a = expr.as<AstExprCall>()) {
      visualize(*a->func);
      writer.symbol("(");

      bool first = true;
      for (const auto &arg : a->args) {
        if (first)
          first = false;
        else
          writer.symbol(",");

        visualize(*arg);
      }

      writer.symbol(")");
    } else if (const auto &a = expr.as<AstExprIndexName>()) {
      visualize(*a->expr);
      writer.symbol(std::string(1, a->op));
      writer.write(a->index.value);
    } else if (const auto &a = expr.as<AstExprIndexExpr>()) {
      visualize(*a->expr);
      writer.symbol("[");
      visualize(*a->index);
      writer.symbol("]");
    } else if (const auto &a = expr.as<AstExprFunction>()) {
      writer.keyword("function");
      visualizeFunctionBody(*a);
    } else if (const auto &a = expr.as<AstExprTable>()) {
      writer.symbol("{");

      bool first = true;

      for (const auto &item : a->items) {
        if (first)
          first = false;
        else
          writer.symbol(",");

        switch (item.kind) {
        case AstExprTable::Item::List:
          break;

        case AstExprTable::Item::Record: {
          const auto &value = item.key->as<AstExprConstantString>()->value;
          advance(item.key->location.begin);
          writer.identifier(std::string_view(value.data, value.size));
          writer.maybeSpace(item.value->location.begin, 1);
          writer.symbol("=");
        } break;

        case AstExprTable::Item::General: {
          writer.symbol("[");
          visualize(*item.key);
          writer.symbol("]");
          writer.maybeSpace(item.value->location.begin, 1);
          writer.symbol("=");
        } break;

        default:
          LUAU_ASSERT(!"Unknown table item kind");
        }

        advance(item.value->location.begin);
        visualize(*item.value);
      }

      Position endPos = expr.location.end;
      if (endPos.column > 0)
        --endPos.column;

      advance(endPos);

      writer.symbol("}");
      advance(expr.location.end);
    } else if (const auto &a = expr.as<AstExprUnary>()) {
      switch (a->op) {
      case AstExprUnary::Not:
        writer.keyword("not");
        break;
      case AstExprUnary::Minus:
        writer.symbol("-");
        break;
      case AstExprUnary::Len:
        writer.symbol("#");
        break;
      }
      visualize(*a->expr);
    } else if (const auto &a = expr.as<AstExprBinary>()) {
      visualize(*a->left);

      switch (a->op) {
      case AstExprBinary::Add:
      case AstExprBinary::Sub:
      case AstExprBinary::Mul:
      case AstExprBinary::Div:
      case AstExprBinary::FloorDiv:
      case AstExprBinary::Mod:
      case AstExprBinary::Pow:
      case AstExprBinary::CompareLt:
      case AstExprBinary::CompareGt:
        writer.maybeSpace(a->right->location.begin, 2);
        writer.symbol(toString(a->op));
        break;
      case AstExprBinary::Concat:
      case AstExprBinary::CompareNe:
      case AstExprBinary::CompareEq:
      case AstExprBinary::CompareLe:
      case AstExprBinary::CompareGe:
      case AstExprBinary::Or:
        writer.maybeSpace(a->right->location.begin, 3);
        writer.keyword(toString(a->op));
        break;
      case AstExprBinary::And:
        writer.maybeSpace(a->right->location.begin, 4);
        writer.keyword(toString(a->op));
        break;
      default:
        LUAU_ASSERT(!"Unknown Op");
      }

      visualize(*a->right);
    } else if (const auto &a = expr.as<AstExprTypeAssertion>()) {
      visualize(*a->expr);

      if (writeTypes) {
        writer.maybeSpace(a->annotation->location.begin, 2);
        writer.symbol("::");
        visualizeTypeAnnotation(*a->annotation);
      }
    } else if (const auto &a = expr.as<AstExprIfElse>()) {
      writer.keyword("if");
      visualize(*a->condition);
      writer.keyword("then");
      visualize(*a->trueExpr);
      writer.keyword("else");
      visualize(*a->falseExpr);
    } else if (const auto &a = expr.as<AstExprInterpString>()) {
      writer.symbol("`");

      size_t index = 0;

      for (const auto &string : a->strings) {
        writer.write(escape(std::string_view(string.data, string.size),
                            /* escapeForInterpString = */ true));

        if (index < a->expressions.size) {
          writer.symbol("{");
          visualize(*a->expressions.data[index]);
          writer.symbol("}");
        }

        index++;
      }

      writer.symbol("`");
    } else if (const auto &a = expr.as<AstExprError>()) {
      writer.symbol("(error-expr");

      for (size_t i = 0; i < a->expressions.size; i++) {
        writer.symbol(i == 0 ? ": " : ", ");
        visualize(*a->expressions.data[i]);
      }

      writer.symbol(")");
    } else {
      LUAU_ASSERT(!"Unknown AstExpr");
    }
  }

  void writeEnd(const Location &loc) {
    Position endPos = loc.end;
    if (endPos.column >= 3)
      endPos.column -= 3;
    advance(endPos);
    writer.keyword("end");
  }

  void advance(const Position &newPos) { writer.advance(newPos); }

  void visualize(AstStat &program) {
    advance(program.location.begin);

    if (const auto &block = program.as<AstStatBlock>()) {
      writer.keyword("do");
      for (const auto &s : block->body)
        visualize(*s);
      writer.advance(block->location.end);
      writeEnd(program.location);
    } else if (const auto &a = program.as<AstStatIf>()) {
      writer.keyword("if");
      visualizeElseIf(*a);
    } else if (const auto &a = program.as<AstStatWhile>()) {
      writer.keyword("while");
      visualize(*a->condition);
      writer.keyword("do");
      visualizeBlock(*a->body);
      writeEnd(program.location);
    } else if (const auto &a = program.as<AstStatRepeat>()) {
      writer.keyword("repeat");
      visualizeBlock(*a->body);
      if (a->condition->location.begin.column > 5)
        writer.advance(Position{a->condition->location.begin.line,
                                a->condition->location.begin.column - 6});
      writer.keyword("until");
      visualize(*a->condition);
    } else if (program.is<AstStatBreak>())
      writer.keyword("break");
    else if (program.is<AstStatContinue>())
      writer.keyword("continue");
    else if (const auto &a = program.as<AstStatReturn>()) {
      writer.keyword("return");

      bool first = true;
      for (const auto &expr : a->list) {
        if (first)
          first = false;
        else
          writer.symbol(",");
        visualize(*expr);
      }
    } else if (const auto &a = program.as<AstStatExpr>()) {
      visualize(*a->expr);
    } else if (const auto &a = program.as<AstStatLocal>()) {
      writer.keyword("local");

      bool first = true;
      for (const auto &local : a->vars) {
        if (first)
          first = false;
        else
          writer.write(",");

        visualize(*local);
      }

      first = true;
      for (const auto &value : a->values) {
        if (first) {
          first = false;
          writer.maybeSpace(value->location.begin, 2);
          writer.symbol("=");
        } else
          writer.symbol(",");

        visualize(*value);
      }
    } else if (const auto &a = program.as<AstStatFor>()) {
      writer.keyword("for");

      visualize(*a->var);
      writer.symbol("=");
      visualize(*a->from);
      writer.symbol(",");
      visualize(*a->to);
      if (a->step) {
        writer.symbol(",");
        visualize(*a->step);
      }
      writer.keyword("do");
      visualizeBlock(*a->body);

      writeEnd(program.location);
    } else if (const auto &a = program.as<AstStatForIn>()) {
      writer.keyword("for");

      bool first = true;
      for (const auto &var : a->vars) {
        if (first)
          first = false;
        else
          writer.symbol(",");

        visualize(*var);
      }

      writer.keyword("in");

      first = true;
      for (const auto &val : a->values) {
        if (first)
          first = false;
        else
          writer.symbol(",");

        visualize(*val);
      }

      writer.keyword("do");

      visualizeBlock(*a->body);

      writeEnd(program.location);
    } else if (const auto &a = program.as<AstStatAssign>()) {
      bool first = true;
      for (const auto &var : a->vars) {
        if (first)
          first = false;
        else
          writer.symbol(",");
        visualize(*var);
      }

      first = true;
      for (const auto &value : a->values) {
        if (first) {
          writer.maybeSpace(value->location.begin, 1);
          writer.symbol("=");
          first = false;
        } else
          writer.symbol(",");

        visualize(*value);
      }
    } else if (const auto &a = program.as<AstStatCompoundAssign>()) {
      visualize(*a->var);

      switch (a->op) {
      case AstExprBinary::Add:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("+=");
        break;
      case AstExprBinary::Sub:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("-=");
        break;
      case AstExprBinary::Mul:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("*=");
        break;
      case AstExprBinary::Div:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("/=");
        break;
      case AstExprBinary::FloorDiv:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("//=");
        break;
      case AstExprBinary::Mod:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("%=");
        break;
      case AstExprBinary::Pow:
        writer.maybeSpace(a->value->location.begin, 2);
        writer.symbol("^=");
        break;
      case AstExprBinary::Concat:
        writer.maybeSpace(a->value->location.begin, 3);
        writer.symbol("..=");
        break;
      default:
        LUAU_ASSERT(!"Unexpected compound assignment op");
      }

      visualize(*a->value);
    } else if (const auto &a = program.as<AstStatFunction>()) {
      writer.keyword("function");
      visualize(*a->name);
      visualizeFunctionBody(*a->func);
    } else if (const auto &a = program.as<AstStatLocalFunction>()) {
      writer.keyword("local function");
      advance(a->name->location.begin);
      writer.identifier(a->name->name.value);
      visualizeFunctionBody(*a->func);
    } else if (const auto &a = program.as<AstStatTypeAlias>()) {
      if (writeTypes) {
        if (a->exported)
          writer.keyword("export");

        writer.keyword("type");
        writer.identifier(a->name.value);
        if (a->generics.size > 0 || a->genericPacks.size > 0) {
          writer.symbol("<");
          CommaSeparatorInserter comma(writer);

          for (auto o : a->generics) {
            comma();

            writer.advance(o.location.begin);
            writer.identifier(o.name.value);

            if (o.defaultValue) {
              writer.maybeSpace(o.defaultValue->location.begin, 2);
              writer.symbol("=");
              visualizeTypeAnnotation(*o.defaultValue);
            }
          }

          for (auto o : a->genericPacks) {
            comma();

            writer.advance(o.location.begin);
            writer.identifier(o.name.value);
            writer.symbol("...");

            if (o.defaultValue) {
              writer.maybeSpace(o.defaultValue->location.begin, 2);
              writer.symbol("=");
              visualizeTypePackAnnotation(*o.defaultValue, false);
            }
          }

          writer.symbol(">");
        }
        writer.maybeSpace(a->type->location.begin, 2);
        writer.symbol("=");
        visualizeTypeAnnotation(*a->type);
      }
    } else if (const auto &a = program.as<AstStatError>()) {
      writer.symbol("(error-stat");

      for (size_t i = 0; i < a->expressions.size; i++) {
        writer.symbol(i == 0 ? ": " : ", ");
        visualize(*a->expressions.data[i]);
      }

      for (size_t i = 0; i < a->statements.size; i++) {
        writer.symbol(i == 0 && a->expressions.size == 0 ? ": " : ", ");
        visualize(*a->statements.data[i]);
      }

      writer.symbol(")");
    } else {
      LUAU_ASSERT(!"Unknown AstStat");
    }

    if (program.hasSemicolon)
      writer.symbol(";");
  }

  void visualizeFunctionBody(AstExprFunction &func) {
    if (func.generics.size > 0 || func.genericPacks.size > 0) {
      CommaSeparatorInserter comma(writer);
      writer.symbol("<");
      for (const auto &o : func.generics) {
        comma();

        writer.advance(o.location.begin);
        writer.identifier(o.name.value);
      }
      for (const auto &o : func.genericPacks) {
        comma();

        writer.advance(o.location.begin);
        writer.identifier(o.name.value);
        writer.symbol("...");
      }
      writer.symbol(">");
    }

    writer.symbol("(");
    CommaSeparatorInserter comma(writer);

    for (size_t i = 0; i < func.args.size; ++i) {
      AstLocal *local = func.args.data[i];

      comma();

      advance(local->location.begin);
      writer.identifier(local->name.value);
      if (writeTypes && local->annotation) {
        writer.symbol(":");
        visualizeTypeAnnotation(*local->annotation);
      }
    }

    if (func.vararg) {
      comma();
      advance(func.varargLocation.begin);
      writer.symbol("...");

      if (func.varargAnnotation) {
        writer.symbol(":");
        visualizeTypePackAnnotation(*func.varargAnnotation, true);
      }
    }

    writer.symbol(")");

    if (writeTypes && func.returnAnnotation) {
      writer.symbol(":");
      writer.space();

      visualizeTypeList(*func.returnAnnotation, false);
    }

    visualizeBlock(*func.body);
    writeEnd(func.location);
  }

  void visualizeBlock(AstStatBlock &block) {
    for (const auto &s : block.body)
      visualize(*s);
    writer.advance(block.location.end);
  }

  void visualizeBlock(AstStat &stat) {
    if (AstStatBlock *block = stat.as<AstStatBlock>())
      visualizeBlock(*block);
    else
      LUAU_ASSERT(!"visualizeBlock was expecting an AstStatBlock");
  }

  void visualizeElseIf(AstStatIf &elseif) {
    visualize(*elseif.condition);
    writer.keyword("then");
    visualizeBlock(*elseif.thenbody);

    if (elseif.elsebody == nullptr) {
      writeEnd(elseif.location);
    } else if (auto elseifelseif = elseif.elsebody->as<AstStatIf>()) {
      writer.keyword("elseif");
      visualizeElseIf(*elseifelseif);
    } else {
      writer.keyword("else");

      visualizeBlock(*elseif.elsebody);
      writeEnd(elseif.location);
    }
  }

  void visualizeTypeAnnotation(const AstType &typeAnnotation) {
    advance(typeAnnotation.location.begin);
    if (const auto &a = typeAnnotation.as<AstTypeReference>()) {
      if (a->prefix) {
        writer.write(a->prefix->value);
        writer.symbol(".");
      }

      writer.write(a->name.value);
      if (a->parameters.size > 0 || a->hasParameterList) {
        CommaSeparatorInserter comma(writer);
        writer.symbol("<");
        for (auto o : a->parameters) {
          comma();

          if (o.type)
            visualizeTypeAnnotation(*o.type);
          else
            visualizeTypePackAnnotation(*o.typePack, false);
        }

        writer.symbol(">");
      }
    } else if (const auto &a = typeAnnotation.as<AstTypeFunction>()) {
      if (a->generics.size > 0 || a->genericPacks.size > 0) {
        CommaSeparatorInserter comma(writer);
        writer.symbol("<");
        for (const auto &o : a->generics) {
          comma();

          writer.advance(o.location.begin);
          writer.identifier(o.name.value);
        }
        for (const auto &o : a->genericPacks) {
          comma();

          writer.advance(o.location.begin);
          writer.identifier(o.name.value);
          writer.symbol("...");
        }
        writer.symbol(">");
      }

      { visualizeTypeList(a->argTypes, true); }

      writer.symbol("->");
      visualizeTypeList(a->returnTypes, true);
    } else if (const auto &a = typeAnnotation.as<AstTypeTable>()) {
      AstTypeReference *indexType =
          a->indexer ? a->indexer->indexType->as<AstTypeReference>() : nullptr;

      if (a->props.size == 0 && indexType && indexType->name == "number") {
        writer.symbol("{");
        visualizeTypeAnnotation(*a->indexer->resultType);
        writer.symbol("}");
      } else {
        CommaSeparatorInserter comma(writer);

        writer.symbol("{");

        for (std::size_t i = 0; i < a->props.size; ++i) {
          comma();
          advance(a->props.data[i].location.begin);
          writer.identifier(a->props.data[i].name.value);
          if (a->props.data[i].type) {
            writer.symbol(":");
            visualizeTypeAnnotation(*a->props.data[i].type);
          }
        }
        if (a->indexer) {
          comma();
          writer.symbol("[");
          visualizeTypeAnnotation(*a->indexer->indexType);
          writer.symbol("]");
          writer.symbol(":");
          visualizeTypeAnnotation(*a->indexer->resultType);
        }
        writer.symbol("}");
      }
    } else if (auto a = typeAnnotation.as<AstTypeTypeof>()) {
      writer.keyword("typeof");
      writer.symbol("(");
      visualize(*a->expr);
      writer.symbol(")");
    } else if (const auto &a = typeAnnotation.as<AstTypeUnion>()) {
      if (a->types.size == 2) {
        AstType *l = a->types.data[0];
        AstType *r = a->types.data[1];

        auto lta = l->as<AstTypeReference>();
        if (lta && lta->name == "nil")
          std::swap(l, r);

        // it's still possible that we had a (T | U) or (T | nil) and not (nil |
        // T)
        auto rta = r->as<AstTypeReference>();
        if (rta && rta->name == "nil") {
          bool wrap = l->as<AstTypeIntersection>() || l->as<AstTypeFunction>();

          if (wrap)
            writer.symbol("(");

          visualizeTypeAnnotation(*l);

          if (wrap)
            writer.symbol(")");

          writer.symbol("?");
          return;
        }
      }

      for (size_t i = 0; i < a->types.size; ++i) {
        if (i > 0) {
          writer.maybeSpace(a->types.data[i]->location.begin, 2);
          writer.symbol("|");
        }

        bool wrap = a->types.data[i]->as<AstTypeIntersection>() ||
                    a->types.data[i]->as<AstTypeFunction>();

        if (wrap)
          writer.symbol("(");

        visualizeTypeAnnotation(*a->types.data[i]);

        if (wrap)
          writer.symbol(")");
      }
    } else if (const auto &a = typeAnnotation.as<AstTypeIntersection>()) {
      for (size_t i = 0; i < a->types.size; ++i) {
        if (i > 0) {
          writer.maybeSpace(a->types.data[i]->location.begin, 2);
          writer.symbol("&");
        }

        bool wrap = a->types.data[i]->as<AstTypeUnion>() ||
                    a->types.data[i]->as<AstTypeFunction>();

        if (wrap)
          writer.symbol("(");

        visualizeTypeAnnotation(*a->types.data[i]);

        if (wrap)
          writer.symbol(")");
      }
    } else if (const auto &a = typeAnnotation.as<AstTypeSingletonBool>()) {
      writer.keyword(a->value ? "true" : "false");
    } else if (const auto &a = typeAnnotation.as<AstTypeSingletonString>()) {
      writer.string(std::string_view(a->value.data, a->value.size));
    } else if (typeAnnotation.is<AstTypeError>()) {
      writer.symbol("%error-type%");
    } else {
      LUAU_ASSERT(!"Unknown AstType");
    }
  }
};

std::string toString(AstNode *node) {
  StringWriter writer;
  writer.pos = node->location.begin;

  Printer printer(writer);
  printer.writeTypes = true;

  if (auto statNode = node->asStat())
    printer.visualize(*statNode);
  else if (auto exprNode = node->asExpr())
    printer.visualize(*exprNode);
  else if (auto typeNode = node->asType())
    printer.visualizeTypeAnnotation(*typeNode);

  return writer.str();
}

void dump(AstNode *node) { printf("%s\n", toString(node).c_str()); }

std::string transpile(AstStatBlock &block) {
  StringWriter writer;
  Printer(writer).visualizeBlock(block);
  return writer.str();
}

std::string transpileWithTypes(AstStatBlock &block) {
  StringWriter writer;
  Printer printer(writer);
  printer.writeTypes = true;
  printer.visualizeBlock(block);
  return writer.str();
}

TranspileResult transpile(std::string_view source, ParseOptions options,
                          bool withTypes) {
  auto allocator = Allocator{};
  auto names = AstNameTable{allocator};
  ParseResult parseResult =
      Parser::parse(source.data(), source.size(), names, allocator, options);

  if (!parseResult.errors.empty()) {
    // TranspileResult keeps track of only a single error
    const ParseError &error = parseResult.errors.front();

    return TranspileResult{"", error.getLocation(), error.what()};
  }

  LUAU_ASSERT(parseResult.root);
  if (!parseResult.root)
    return TranspileResult{
        "", {}, "Internal error: Parser yielded empty parse tree"};

  if (withTypes)
    return TranspileResult{transpileWithTypes(*parseResult.root)};

  return TranspileResult{transpile(*parseResult.root)};
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/TypeAttach.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : was already included! <string>

static char *allocateString(Luau::Allocator &allocator,
                            std::string_view contents) {
  char *result = (char *)allocator.allocate(contents.size() + 1);
  memcpy(result, contents.data(), contents.size());
  result[contents.size()] = '\0';

  return result;
}

template <typename... Data>
static char *allocateString(Luau::Allocator &allocator, const char *format,
                            Data... data) {
  int len = snprintf(nullptr, 0, format, data...);
  char *result = (char *)allocator.allocate(len + 1);
  snprintf(result, len + 1, format, data...);
  return result;
}

using SyntheticNames = std::unordered_map<const void *, char *>;

namespace Luau {

static const char *getName(Allocator *allocator, SyntheticNames *syntheticNames,
                           const GenericType &gen) {
  size_t s = syntheticNames->size();
  char *&n = (*syntheticNames)[&gen];
  if (!n) {
    std::string str = gen.explicitName ? gen.name : generateName(s);
    n = static_cast<char *>(allocator->allocate(str.size() + 1));
    strcpy(n, str.c_str());
  }

  return n;
}

static const char *getName(Allocator *allocator, SyntheticNames *syntheticNames,
                           const GenericTypePack &gen) {
  size_t s = syntheticNames->size();
  char *&n = (*syntheticNames)[&gen];
  if (!n) {
    std::string str = gen.explicitName ? gen.name : generateName(s);
    n = static_cast<char *>(allocator->allocate(str.size() + 1));
    strcpy(n, str.c_str());
  }

  return n;
}

class TypeRehydrationVisitor {
  std::map<void *, int> seen;
  int count = 0;

  bool hasSeen(const void *tv) {
    void *ttv = const_cast<void *>(tv);
    auto it = seen.find(ttv);
    if (it != seen.end() && it->second < count)
      return true;

    seen[ttv] = count;
    return false;
  }

public:
  TypeRehydrationVisitor(
      Allocator *alloc, SyntheticNames *syntheticNames,
      const TypeRehydrationOptions &options = TypeRehydrationOptions())
      : allocator(alloc), syntheticNames(syntheticNames), options(options) {}

  AstTypePack *rehydrate(TypePackId tp);

  AstType *operator()(const PrimitiveType &ptv) {
    switch (ptv.type) {
    case PrimitiveType::NilType:
      return allocator->alloc<AstTypeReference>(
          Location(), std::nullopt, AstName("nil"), std::nullopt, Location());
    case PrimitiveType::Boolean:
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("boolean"),
                                                std::nullopt, Location());
    case PrimitiveType::Number:
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("number"), std::nullopt,
                                                Location());
    case PrimitiveType::String:
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("string"), std::nullopt,
                                                Location());
    case PrimitiveType::Thread:
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("thread"), std::nullopt,
                                                Location());
    case PrimitiveType::Buffer:
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("buffer"), std::nullopt,
                                                Location());
    case PrimitiveType::Function:
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("function"),
                                                std::nullopt, Location());
    case PrimitiveType::Table:
      return allocator->alloc<AstTypeReference>(
          Location(), std::nullopt, AstName("table"), std::nullopt, Location());
    default:
      LUAU_ASSERT(false); // this should be unreachable.
      return nullptr;
    }
  }

  AstType *operator()(const BlockedType &btv) {
    return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                              AstName("*blocked*"),
                                              std::nullopt, Location());
  }

  AstType *operator()(const PendingExpansionType &petv) {
    return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                              AstName("*pending-expansion*"),
                                              std::nullopt, Location());
  }

  AstType *operator()(const SingletonType &stv) {
    if (const BooleanSingleton *bs = get<BooleanSingleton>(&stv))
      return allocator->alloc<AstTypeSingletonBool>(Location(), bs->value);
    else if (const StringSingleton *ss = get<StringSingleton>(&stv)) {
      AstArray<char> value;
      value.data = const_cast<char *>(ss->value.c_str());
      value.size = strlen(value.data);
      return allocator->alloc<AstTypeSingletonString>(Location(), value);
    } else
      return nullptr;
  }

  AstType *operator()(const AnyType &) {
    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt, AstName("any"), std::nullopt, Location());
  }
  AstType *operator()(const TableType &ttv) {
    RecursionCounter counter(&count);

    if (ttv.name &&
        options.bannedNames.find(*ttv.name) == options.bannedNames.end()) {
      AstArray<AstTypeOrPack> parameters;
      parameters.size = ttv.instantiatedTypeParams.size();
      parameters.data = static_cast<AstTypeOrPack *>(
          allocator->allocate(sizeof(AstTypeOrPack) * parameters.size));

      for (size_t i = 0; i < ttv.instantiatedTypeParams.size(); ++i) {
        parameters.data[i] = {
            Luau::visit(*this, ttv.instantiatedTypeParams[i]->ty), {}};
      }

      for (size_t i = 0; i < ttv.instantiatedTypePackParams.size(); ++i) {
        parameters.data[i] = {{}, rehydrate(ttv.instantiatedTypePackParams[i])};
      }

      return allocator->alloc<AstTypeReference>(
          Location(), std::nullopt, AstName(ttv.name->c_str()), std::nullopt,
          Location(), parameters.size != 0, parameters);
    }

    if (hasSeen(&ttv)) {
      if (ttv.name)
        return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                  AstName(ttv.name->c_str()),
                                                  std::nullopt, Location());
      else
        return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                  AstName("<Cycle>"),
                                                  std::nullopt, Location());
    }

    AstArray<AstTableProp> props;
    props.size = ttv.props.size();
    props.data = static_cast<AstTableProp *>(
        allocator->allocate(sizeof(AstTableProp) * props.size));
    int idx = 0;
    for (const auto &[propName, prop] : ttv.props) {
      RecursionCounter counter(&count);

      char *name = allocateString(*allocator, propName);

      props.data[idx].name = AstName(name);
      props.data[idx].type = Luau::visit(*this, prop.type()->ty);
      props.data[idx].location = Location();
      idx++;
    }

    AstTableIndexer *indexer = nullptr;
    if (ttv.indexer) {
      RecursionCounter counter(&count);

      indexer = allocator->alloc<AstTableIndexer>();
      indexer->indexType = Luau::visit(*this, ttv.indexer->indexType->ty);
      indexer->resultType =
          Luau::visit(*this, ttv.indexer->indexResultType->ty);
    }
    return allocator->alloc<AstTypeTable>(Location(), props, indexer);
  }

  AstType *operator()(const MetatableType &mtv) {
    return Luau::visit(*this, mtv.table->ty);
  }

  AstType *operator()(const ClassType &ctv) {
    RecursionCounter counter(&count);

    char *name = allocateString(*allocator, ctv.name);

    if (!options.expandClassProps || hasSeen(&ctv) || count > 1)
      return allocator->alloc<AstTypeReference>(
          Location(), std::nullopt, AstName{name}, std::nullopt, Location());

    AstArray<AstTableProp> props;
    props.size = ctv.props.size();
    props.data = static_cast<AstTableProp *>(
        allocator->allocate(sizeof(AstTableProp) * props.size));

    int idx = 0;
    for (const auto &[propName, prop] : ctv.props) {
      char *name = allocateString(*allocator, propName);

      props.data[idx].name = AstName{name};
      props.data[idx].type = Luau::visit(*this, prop.type()->ty);
      props.data[idx].location = Location();
      idx++;
    }

    AstTableIndexer *indexer = nullptr;
    if (ctv.indexer) {
      RecursionCounter counter(&count);

      indexer = allocator->alloc<AstTableIndexer>();
      indexer->indexType = Luau::visit(*this, ctv.indexer->indexType->ty);
      indexer->resultType =
          Luau::visit(*this, ctv.indexer->indexResultType->ty);
    }

    return allocator->alloc<AstTypeTable>(Location(), props, indexer);
  }

  AstType *operator()(const FunctionType &ftv) {
    RecursionCounter counter(&count);

    if (hasSeen(&ftv))
      return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                                AstName("<Cycle>"),
                                                std::nullopt, Location());

    AstArray<AstGenericType> generics;
    generics.size = ftv.generics.size();
    generics.data = static_cast<AstGenericType *>(
        allocator->allocate(sizeof(AstGenericType) * generics.size));
    size_t numGenerics = 0;
    for (auto it = ftv.generics.begin(); it != ftv.generics.end(); ++it) {
      if (auto gtv = get<GenericType>(*it))
        generics.data[numGenerics++] = {AstName(gtv->name.c_str()), Location(),
                                        nullptr};
    }

    AstArray<AstGenericTypePack> genericPacks;
    genericPacks.size = ftv.genericPacks.size();
    genericPacks.data = static_cast<AstGenericTypePack *>(
        allocator->allocate(sizeof(AstGenericTypePack) * genericPacks.size));
    size_t numGenericPacks = 0;
    for (auto it = ftv.genericPacks.begin(); it != ftv.genericPacks.end();
         ++it) {
      if (auto gtv = get<GenericTypePack>(*it))
        genericPacks.data[numGenericPacks++] = {AstName(gtv->name.c_str()),
                                                Location(), nullptr};
    }

    AstArray<AstType *> argTypes;
    const auto &[argVector, argTail] = flatten(ftv.argTypes);
    argTypes.size = argVector.size();
    argTypes.data = static_cast<AstType **>(
        allocator->allocate(sizeof(AstType *) * argTypes.size));
    for (size_t i = 0; i < argTypes.size; ++i) {
      RecursionCounter counter(&count);

      argTypes.data[i] = Luau::visit(*this, (argVector[i])->ty);
    }

    AstTypePack *argTailAnnotation = nullptr;
    if (argTail)
      argTailAnnotation = rehydrate(*argTail);

    AstArray<std::optional<AstArgumentName>> argNames;
    argNames.size = ftv.argNames.size();
    argNames.data =
        static_cast<std::optional<AstArgumentName> *>(allocator->allocate(
            sizeof(std::optional<AstArgumentName>) * argNames.size));
    size_t i = 0;
    for (const auto &el : ftv.argNames) {
      std::optional<AstArgumentName> *arg = &argNames.data[i++];

      if (el)
        new (arg) std::optional<AstArgumentName>(
            AstArgumentName(AstName(el->name.c_str()), el->location));
      else
        new (arg) std::optional<AstArgumentName>();
    }

    AstArray<AstType *> returnTypes;
    const auto &[retVector, retTail] = flatten(ftv.retTypes);
    returnTypes.size = retVector.size();
    returnTypes.data = static_cast<AstType **>(
        allocator->allocate(sizeof(AstType *) * returnTypes.size));
    for (size_t i = 0; i < returnTypes.size; ++i) {
      RecursionCounter counter(&count);

      returnTypes.data[i] = Luau::visit(*this, (retVector[i])->ty);
    }

    AstTypePack *retTailAnnotation = nullptr;
    if (retTail)
      retTailAnnotation = rehydrate(*retTail);

    return allocator->alloc<AstTypeFunction>(
        Location(), generics, genericPacks,
        AstTypeList{argTypes, argTailAnnotation}, argNames,
        AstTypeList{returnTypes, retTailAnnotation});
  }
  AstType *operator()(const Unifiable::Error &) {
    return allocator->alloc<AstTypeReference>(Location(), std::nullopt,
                                              AstName("Unifiable<Error>"),
                                              std::nullopt, Location());
  }
  AstType *operator()(const GenericType &gtv) {
    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt,
        AstName(getName(allocator, syntheticNames, gtv)), std::nullopt,
        Location());
  }
  AstType *operator()(const Unifiable::Bound<TypeId> &bound) {
    return Luau::visit(*this, bound.boundTo->ty);
  }
  AstType *operator()(const FreeType &ft) {
    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt, AstName("free"), std::nullopt, Location());
  }
  AstType *operator()(const UnionType &uv) {
    AstArray<AstType *> unionTypes;
    unionTypes.size = uv.options.size();
    unionTypes.data = static_cast<AstType **>(
        allocator->allocate(sizeof(AstType *) * unionTypes.size));
    for (size_t i = 0; i < unionTypes.size; ++i) {
      unionTypes.data[i] = Luau::visit(*this, uv.options[i]->ty);
    }
    return allocator->alloc<AstTypeUnion>(Location(), unionTypes);
  }
  AstType *operator()(const IntersectionType &uv) {
    AstArray<AstType *> intersectionTypes;
    intersectionTypes.size = uv.parts.size();
    intersectionTypes.data = static_cast<AstType **>(
        allocator->allocate(sizeof(AstType *) * intersectionTypes.size));
    for (size_t i = 0; i < intersectionTypes.size; ++i) {
      intersectionTypes.data[i] = Luau::visit(*this, uv.parts[i]->ty);
    }
    return allocator->alloc<AstTypeIntersection>(Location(), intersectionTypes);
  }
  AstType *operator()(const LazyType &ltv) {
    if (TypeId unwrapped = ltv.unwrapped.load())
      return Luau::visit(*this, unwrapped->ty);

    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt, AstName("<Lazy?>"), std::nullopt, Location());
  }
  AstType *operator()(const UnknownType &ttv) {
    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt, AstName{"unknown"}, std::nullopt, Location());
  }
  AstType *operator()(const NeverType &ttv) {
    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt, AstName{"never"}, std::nullopt, Location());
  }
  AstType *operator()(const NegationType &ntv) {
    // FIXME: do the same thing we do with ErrorType
    throw InternalCompilerError("Cannot convert NegationType into AstNode");
  }
  AstType *operator()(const TypeFunctionInstanceType &tfit) {
    return allocator->alloc<AstTypeReference>(
        Location(), std::nullopt, AstName{tfit.family->name.c_str()},
        std::nullopt, Location());
  }

private:
  Allocator *allocator;
  SyntheticNames *syntheticNames;
  const TypeRehydrationOptions &options;
};

class TypePackRehydrationVisitor {
public:
  TypePackRehydrationVisitor(Allocator *allocator,
                             SyntheticNames *syntheticNames,
                             TypeRehydrationVisitor *typeVisitor)
      : allocator(allocator), syntheticNames(syntheticNames),
        typeVisitor(typeVisitor) {
    LUAU_ASSERT(allocator);
    LUAU_ASSERT(syntheticNames);
    LUAU_ASSERT(typeVisitor);
  }

  AstTypePack *operator()(const BoundTypePack &btp) const {
    return Luau::visit(*this, btp.boundTo->ty);
  }

  AstTypePack *operator()(const BlockedTypePack &btp) const {
    return allocator->alloc<AstTypePackGeneric>(Location(),
                                                AstName("*blocked*"));
  }

  AstTypePack *operator()(const TypePack &tp) const {
    AstArray<AstType *> head;
    head.size = tp.head.size();
    head.data = static_cast<AstType **>(
        allocator->allocate(sizeof(AstType *) * tp.head.size()));

    for (size_t i = 0; i < tp.head.size(); i++)
      head.data[i] = Luau::visit(*typeVisitor, tp.head[i]->ty);

    AstTypePack *tail = nullptr;

    if (tp.tail)
      tail = Luau::visit(*this, (*tp.tail)->ty);

    return allocator->alloc<AstTypePackExplicit>(Location(),
                                                 AstTypeList{head, tail});
  }

  AstTypePack *operator()(const VariadicTypePack &vtp) const {
    if (vtp.hidden)
      return nullptr;

    return allocator->alloc<AstTypePackVariadic>(
        Location(), Luau::visit(*typeVisitor, vtp.ty->ty));
  }

  AstTypePack *operator()(const GenericTypePack &gtp) const {
    return allocator->alloc<AstTypePackGeneric>(
        Location(), AstName(getName(allocator, syntheticNames, gtp)));
  }

  AstTypePack *operator()(const FreeTypePack &gtp) const {
    return allocator->alloc<AstTypePackGeneric>(Location(), AstName("free"));
  }

  AstTypePack *operator()(const Unifiable::Error &) const {
    return allocator->alloc<AstTypePackGeneric>(Location(),
                                                AstName("Unifiable<Error>"));
  }

  AstTypePack *operator()(const TypeFunctionInstanceTypePack &tfitp) const {
    return allocator->alloc<AstTypePackGeneric>(
        Location(), AstName(tfitp.family->name.c_str()));
  }

private:
  Allocator *allocator;
  SyntheticNames *syntheticNames;
  TypeRehydrationVisitor *typeVisitor;
};

AstTypePack *TypeRehydrationVisitor::rehydrate(TypePackId tp) {
  TypePackRehydrationVisitor tprv(allocator, syntheticNames, this);
  return Luau::visit(tprv, tp->ty);
}

class TypeAttacher : public AstVisitor {
public:
  TypeAttacher(Module &checker, Luau::Allocator *alloc)
      : module(checker), allocator(alloc) {}
  ScopePtr getScope(const Location &loc) {
    Location scopeLocation;
    ScopePtr scope = nullptr;
    for (const auto &s : module.scopes) {
      if (s.first.encloses(loc)) {
        if (!scope || scopeLocation.encloses(s.first)) {
          scopeLocation = s.first;
          scope = s.second;
        }
      }
    }

    return scope;
  }

  AstType *typeAst(std::optional<TypeId> type) {
    if (!type)
      return nullptr;
    return Luau::visit(TypeRehydrationVisitor(allocator, &syntheticNames),
                       (*type)->ty);
  }

  AstArray<Luau::AstType *> typeAstPack(TypePackId type) {
    const auto &[v, tail] = flatten(type);

    AstArray<AstType *> result;
    result.size = v.size();
    result.data = static_cast<AstType **>(
        allocator->allocate(sizeof(AstType *) * v.size()));
    for (size_t i = 0; i < v.size(); ++i) {
      result.data[i] = Luau::visit(
          TypeRehydrationVisitor(allocator, &syntheticNames), v[i]->ty);
    }
    return result;
  }

  virtual bool visit(AstStatLocal *al) override {
    for (size_t i = 0; i < al->vars.size; ++i) {
      visitLocal(al->vars.data[i]);
    }
    return true;
  }

  virtual bool visitLocal(AstLocal *local) {
    AstType *annotation = local->annotation;
    if (!annotation) {
      if (auto scope = getScope(local->location)) {
        if (auto result = scope->lookup(local))
          local->annotation = typeAst(*result);
      }
    }
    return true;
  }

  virtual bool visit(AstExprLocal *al) override {
    return visitLocal(al->local);
  }

  virtual bool visit(AstStatFor *stat) override {
    visitLocal(stat->var);
    return true;
  }

  virtual bool visit(AstStatForIn *stat) override {
    for (size_t i = 0; i < stat->vars.size; ++i)
      visitLocal(stat->vars.data[i]);
    return true;
  }

  virtual bool visit(AstExprFunction *fn) override {
    // TODO: add generics if the inferred type of the function is generic
    // CLI-39908
    for (size_t i = 0; i < fn->args.size; ++i) {
      AstLocal *arg = fn->args.data[i];
      visitLocal(arg);
    }

    if (!fn->returnAnnotation) {
      if (auto result = getScope(fn->body->location)) {
        TypePackId ret = result->returnType;

        AstTypePack *variadicAnnotation = nullptr;
        const auto &[v, tail] = flatten(ret);

        if (tail)
          variadicAnnotation =
              TypeRehydrationVisitor(allocator, &syntheticNames)
                  .rehydrate(*tail);

        fn->returnAnnotation =
            AstTypeList{typeAstPack(ret), variadicAnnotation};
      }
    }

    return true;
  }

private:
  Module &module;
  Allocator *allocator;
  SyntheticNames syntheticNames;
};

void attachTypeData(SourceModule &source, Module &result) {
  TypeAttacher ta(result, source.allocator.get());
  source.root->visit(&ta);
}

AstType *rehydrateAnnotation(TypeId type, Allocator *allocator,
                             const TypeRehydrationOptions &options) {
  SyntheticNames syntheticNames;
  return Luau::visit(
      TypeRehydrationVisitor(allocator, &syntheticNames, options), type->ty);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/RequireTracer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

namespace Luau {

struct RequireTracer : AstVisitor {
  RequireTracer(RequireTraceResult &result, FileResolver *fileResolver,
                const ModuleName &currentModuleName)
      : result(result), fileResolver(fileResolver),
        currentModuleName(currentModuleName), locals(nullptr) {}

  bool visit(AstExprTypeAssertion *expr) override {
    // suppress `require() :: any`
    return false;
  }

  bool visit(AstExprCall *expr) override {
    AstExprGlobal *global = expr->func->as<AstExprGlobal>();

    if (global && global->name == "require" && expr->args.size >= 1)
      requireCalls.push_back(expr);

    return true;
  }

  bool visit(AstStatLocal *stat) override {
    for (size_t i = 0; i < stat->vars.size && i < stat->values.size; ++i) {
      AstLocal *local = stat->vars.data[i];
      AstExpr *expr = stat->values.data[i];

      // track initializing expression to be able to trace modules through
      // locals
      locals[local] = expr;
    }

    return true;
  }

  bool visit(AstStatAssign *stat) override {
    for (size_t i = 0; i < stat->vars.size; ++i) {
      // locals that are assigned don't have a known expression
      if (AstExprLocal *expr = stat->vars.data[i]->as<AstExprLocal>())
        locals[expr->local] = nullptr;
    }

    return true;
  }

  bool visit(AstType *node) override {
    // allow resolving require inside `typeof` annotations
    return true;
  }

  AstExpr *getDependent(AstExpr *node) {
    if (AstExprLocal *expr = node->as<AstExprLocal>())
      return locals[expr->local];
    else if (AstExprIndexName *expr = node->as<AstExprIndexName>())
      return expr->expr;
    else if (AstExprIndexExpr *expr = node->as<AstExprIndexExpr>())
      return expr->expr;
    else if (AstExprCall *expr = node->as<AstExprCall>(); expr && expr->self)
      return expr->func->as<AstExprIndexName>()->expr;
    else
      return nullptr;
  }

  void process() {
    ModuleInfo moduleContext{currentModuleName};

    // seed worklist with require arguments
    work.reserve(requireCalls.size());

    for (AstExprCall *require : requireCalls)
      work.push_back(require->args.data[0]);

    // push all dependent expressions to the work stack; note that the vector is
    // modified during traversal
    for (size_t i = 0; i < work.size(); ++i)
      if (AstExpr *dep = getDependent(work[i]))
        work.push_back(dep);

    // resolve all expressions to a module info
    for (size_t i = work.size(); i > 0; --i) {
      AstExpr *expr = work[i - 1];

      // when multiple expressions depend on the same one we push it to work
      // queue multiple times
      if (result.exprs.contains(expr))
        continue;

      std::optional<ModuleInfo> info;

      if (AstExpr *dep = getDependent(expr)) {
        const ModuleInfo *context = result.exprs.find(dep);

        // locals just inherit their dependent context, no resolution required
        if (expr->is<AstExprLocal>())
          info = context ? std::optional<ModuleInfo>(*context) : std::nullopt;
        else
          info = fileResolver->resolveModule(context, expr);
      } else {
        info = fileResolver->resolveModule(&moduleContext, expr);
      }

      if (info)
        result.exprs[expr] = std::move(*info);
    }

    // resolve all requires according to their argument
    result.requireList.reserve(requireCalls.size());

    for (AstExprCall *require : requireCalls) {
      AstExpr *arg = require->args.data[0];

      if (const ModuleInfo *info = result.exprs.find(arg)) {
        result.requireList.push_back({info->name, require->location});

        ModuleInfo infoCopy =
            *info; // copy *info out since next line invalidates info!
        result.exprs[require] = std::move(infoCopy);
      } else {
        result.exprs[require] = {}; // mark require as unresolved
      }
    }
  }

  RequireTraceResult &result;
  FileResolver *fileResolver;
  ModuleName currentModuleName;

  DenseHashMap<AstLocal *, AstExpr *> locals;
  std::vector<AstExpr *> work;
  std::vector<AstExprCall *> requireCalls;
};

RequireTraceResult traceRequires(FileResolver *fileResolver, AstStatBlock *root,
                                 const ModuleName &currentModuleName) {
  RequireTraceResult result;
  RequireTracer tracer{result, fileResolver, currentModuleName};
  root->visit(&tracer);
  tracer.process();
  return result;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Frontend.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/BuiltinDefinitions.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Clone.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

#include "luau_config_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintGenerator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintSolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DataFlowGraph.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DcrLogger.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/FileResolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Parser.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TimeTrace.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// DONE : was aleready inlined <Luau/TypeChecker2.h>

// DONE : was aleready inlined <Luau/NonStrictTypeChecker.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// DONE : was aleready inlined <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@ PACK.lua : not found, likely and std header
#include <chrono>

// @@@ PACK.lua : not found, likely and std header
#include <condition_variable>

// @@@ PACK.lua : not found, likely and std header
#include <exception>

// @@@ PACK.lua : not found, likely and std header
#include <mutex>

// @@@@@ PACK.LUA : was already included! <stdexcept>

// @@@@@ PACK.LUA : was already included! <string>

LUAU_FASTINT(LuauTypeInferIterationLimit)
LUAU_FASTINT(LuauTypeInferRecursionLimit)
LUAU_FASTINT(LuauTarjanChildLimit)
LUAU_FASTFLAG(LuauInferInNoCheckMode)
LUAU_FASTFLAGVARIABLE(LuauKnowsTheDataModel3, false)
LUAU_FASTFLAGVARIABLE(LuauCancelFromProgress, false)
LUAU_FASTFLAGVARIABLE(LuauStoreCommentsForDefinitionFiles, false)
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)
LUAU_FASTFLAGVARIABLE(DebugLuauLogSolverToJson, false)
LUAU_FASTFLAGVARIABLE(DebugLuauLogSolverToJsonFile, false)
LUAU_FASTFLAGVARIABLE(DebugLuauForbidInternalTypes, false)
LUAU_FASTFLAGVARIABLE(DebugLuauForceStrictMode, false)
LUAU_FASTFLAGVARIABLE(DebugLuauForceNonStrictMode, false)
LUAU_FASTFLAGVARIABLE(LuauSourceModuleUpdatedWithSelectedMode, false)

namespace Luau {

struct BuildQueueItem {
  ModuleName name;
  ModuleName humanReadableName;

  // Parameters
  std::shared_ptr<SourceNode> sourceNode;
  std::shared_ptr<SourceModule> sourceModule;
  Config config;
  ScopePtr environmentScope;
  std::vector<RequireCycle> requireCycles;
  FrontendOptions options;
  bool recordJsonLog = false;

  // Queue state
  std::vector<size_t> reverseDeps;
  int dirtyDependencies = 0;
  bool processing = false;

  // Result
  std::exception_ptr exception;
  ModulePtr module;
  Frontend::Stats stats;
};

std::optional<Mode> parseMode(const std::vector<HotComment> &hotcomments) {
  for (const HotComment &hc : hotcomments) {
    if (!hc.header)
      continue;

    if (hc.content == "nocheck")
      return Mode::NoCheck;

    if (hc.content == "nonstrict")
      return Mode::Nonstrict;

    if (hc.content == "strict")
      return Mode::Strict;
  }

  return std::nullopt;
}

static void generateDocumentationSymbols(TypeId ty,
                                         const std::string &rootName) {
  // TODO: What do we do in this situation? This means that the definition
  // file is exporting a type that is also a persistent type.
  if (ty->persistent) {
    return;
  }

  asMutable(ty)->documentationSymbol = rootName;

  if (TableType *ttv = getMutable<TableType>(ty)) {
    for (auto &[name, prop] : ttv->props) {
      prop.documentationSymbol = rootName + "." + name;
    }
  } else if (ClassType *ctv = getMutable<ClassType>(ty)) {
    for (auto &[name, prop] : ctv->props) {
      prop.documentationSymbol = rootName + "." + name;
    }
  }
}

static ParseResult parseSourceForModule(std::string_view source,
                                        Luau::SourceModule &sourceModule,
                                        bool captureComments) {
  ParseOptions options;
  options.allowDeclarationSyntax = true;
  options.captureComments = captureComments;

  Luau::ParseResult parseResult =
      Luau::Parser::parse(source.data(), source.size(), *sourceModule.names,
                          *sourceModule.allocator, options);
  sourceModule.root = parseResult.root;
  sourceModule.mode = Mode::Definition;

  if (FFlag::LuauStoreCommentsForDefinitionFiles && options.captureComments) {
    sourceModule.hotcomments = parseResult.hotcomments;
    sourceModule.commentLocations = parseResult.commentLocations;
  }

  return parseResult;
}

static void persistCheckedTypes(ModulePtr checkedModule, GlobalTypes &globals,
                                ScopePtr targetScope,
                                const std::string &packageName) {
  CloneState cloneState{globals.builtinTypes};

  std::vector<TypeId> typesToPersist;
  typesToPersist.reserve(checkedModule->declaredGlobals.size() +
                         checkedModule->exportedTypeBindings.size());

  for (const auto &[name, ty] : checkedModule->declaredGlobals) {
    TypeId globalTy = clone(ty, globals.globalTypes, cloneState);
    std::string documentationSymbol = packageName + "/global/" + name;
    generateDocumentationSymbols(globalTy, documentationSymbol);
    targetScope->bindings[globals.globalNames.names->getOrAdd(name.c_str())] = {
        globalTy, Location(), false, {}, documentationSymbol};

    typesToPersist.push_back(globalTy);
  }

  for (const auto &[name, ty] : checkedModule->exportedTypeBindings) {
    TypeFun globalTy = clone(ty, globals.globalTypes, cloneState);
    std::string documentationSymbol = packageName + "/globaltype/" + name;
    generateDocumentationSymbols(globalTy.type, documentationSymbol);
    targetScope->exportedTypeBindings[name] = globalTy;

    typesToPersist.push_back(globalTy.type);
  }

  for (TypeId ty : typesToPersist) {
    persist(ty);
  }
}

LoadDefinitionFileResult Frontend::loadDefinitionFile(
    GlobalTypes &globals, ScopePtr targetScope, std::string_view source,
    const std::string &packageName, bool captureComments,
    bool typeCheckForAutocomplete) {
  LUAU_TIMETRACE_SCOPE("loadDefinitionFile", "Frontend");

  Luau::SourceModule sourceModule;
  sourceModule.name = packageName;
  sourceModule.humanReadableName = packageName;

  Luau::ParseResult parseResult =
      parseSourceForModule(source, sourceModule, captureComments);
  if (parseResult.errors.size() > 0)
    return LoadDefinitionFileResult{false, parseResult, sourceModule, nullptr};

  ModulePtr checkedModule =
      check(sourceModule, Mode::Definition, {}, std::nullopt,
            /*forAutocomplete*/ false, /*recordJsonLog*/ false, {});

  if (checkedModule->errors.size() > 0)
    return LoadDefinitionFileResult{false, parseResult, sourceModule,
                                    checkedModule};

  persistCheckedTypes(checkedModule, globals, targetScope, packageName);

  return LoadDefinitionFileResult{true, parseResult, sourceModule,
                                  checkedModule};
}

std::vector<std::string_view> parsePathExpr(const AstExpr &pathExpr) {
  const AstExprIndexName *indexName = pathExpr.as<AstExprIndexName>();
  if (!indexName)
    return {};

  std::vector<std::string_view> segments{indexName->index.value};

  while (true) {
    if (AstExprIndexName *in = indexName->expr->as<AstExprIndexName>()) {
      segments.push_back(in->index.value);
      indexName = in;
      continue;
    } else if (AstExprGlobal *indexNameAsGlobal =
                   indexName->expr->as<AstExprGlobal>()) {
      segments.push_back(indexNameAsGlobal->name.value);
      break;
    } else if (AstExprLocal *indexNameAsLocal =
                   indexName->expr->as<AstExprLocal>()) {
      segments.push_back(indexNameAsLocal->local->name.value);
      break;
    } else
      return {};
  }

  std::reverse(segments.begin(), segments.end());
  return segments;
}

std::optional<std::string>
pathExprToModuleName(const ModuleName &currentModuleName,
                     const std::vector<std::string_view> &segments) {
  if (segments.empty())
    return std::nullopt;

  std::vector<std::string_view> result;

  auto it = segments.begin();

  if (*it == "script" && !currentModuleName.empty()) {
    result = split(currentModuleName, '/');
    ++it;
  }

  for (; it != segments.end(); ++it) {
    if (result.size() > 1 && *it == "Parent")
      result.pop_back();
    else
      result.push_back(*it);
  }

  return join(result, "/");
}

std::optional<std::string>
pathExprToModuleName(const ModuleName &currentModuleName,
                     const AstExpr &pathExpr) {
  std::vector<std::string_view> segments = parsePathExpr(pathExpr);
  return pathExprToModuleName(currentModuleName, segments);
}

namespace {

static ErrorVec accumulateErrors(
    const std::unordered_map<ModuleName, std::shared_ptr<SourceNode>>
        &sourceNodes,
    ModuleResolver &moduleResolver, const ModuleName &name) {
  DenseHashSet<ModuleName> seen{{}};
  std::vector<ModuleName> queue{name};

  ErrorVec result;

  while (!queue.empty()) {
    ModuleName next = std::move(queue.back());
    queue.pop_back();

    if (seen.contains(next))
      continue;
    seen.insert(next);

    auto it = sourceNodes.find(next);
    if (it == sourceNodes.end())
      continue;

    const SourceNode &sourceNode = *it->second;
    queue.insert(queue.end(), sourceNode.requireSet.begin(),
                 sourceNode.requireSet.end());

    // FIXME: If a module has a syntax error, we won't be able to re-report it
    // here. The solution is probably to move errors from Module to SourceNode

    auto modulePtr = moduleResolver.getModule(next);
    if (!modulePtr)
      continue;

    Module &module = *modulePtr;

    std::sort(module.errors.begin(), module.errors.end(),
              [](const TypeError &e1, const TypeError &e2) -> bool {
                return e1.location.begin > e2.location.begin;
              });

    result.insert(result.end(), module.errors.begin(), module.errors.end());
  }

  std::reverse(result.begin(), result.end());

  return result;
}

static void filterLintOptions(LintOptions &lintOptions,
                              const std::vector<HotComment> &hotcomments,
                              Mode mode) {
  uint64_t ignoreLints = LintWarning::parseMask(hotcomments);

  lintOptions.warningMask &= ~ignoreLints;

  if (mode != Mode::NoCheck) {
    lintOptions.disableWarning(Luau::LintWarning::Code_UnknownGlobal);
  }

  if (mode == Mode::Strict) {
    lintOptions.disableWarning(Luau::LintWarning::Code_ImplicitReturn);
  }
}

// Given a source node (start), find all requires that start a transitive
// dependency path that ends back at start For each such path, record the full
// path and the location of the require in the starting module. Note that this
// is O(V^2) for a fully connected graph and produces O(V) paths of length O(V)
// However, when the graph is acyclic, this is O(V), as well as when only the
// first cycle is needed (stopAtFirst=true)
std::vector<RequireCycle> getRequireCycles(
    const FileResolver *resolver,
    const std::unordered_map<ModuleName, std::shared_ptr<SourceNode>>
        &sourceNodes,
    const SourceNode *start, bool stopAtFirst = false) {
  std::vector<RequireCycle> result;

  DenseHashSet<const SourceNode *> seen(nullptr);
  std::vector<const SourceNode *> stack;
  std::vector<const SourceNode *> path;

  for (const auto &[depName, depLocation] : start->requireLocations) {
    std::vector<ModuleName> cycle;

    auto dit = sourceNodes.find(depName);
    if (dit == sourceNodes.end())
      continue;

    stack.push_back(dit->second.get());

    while (!stack.empty()) {
      const SourceNode *top = stack.back();
      stack.pop_back();

      if (top == nullptr) {
        // special marker for post-order processing
        LUAU_ASSERT(!path.empty());
        top = path.back();
        path.pop_back();

        // we reached the node! path must form a cycle now
        if (top == start) {
          for (const SourceNode *node : path)
            cycle.push_back(node->name);

          cycle.push_back(top->name);
          break;
        }
      } else if (!seen.contains(top)) {
        seen.insert(top);

        // push marker for post-order processing
        path.push_back(top);
        stack.push_back(nullptr);

        // note: we push require edges in the opposite order
        // because it's a stack, the last edge to be pushed gets processed first
        // this ensures that the cyclic path we report is the first one in DFS
        // order
        for (size_t i = top->requireLocations.size(); i > 0; --i) {
          const ModuleName &reqName = top->requireLocations[i - 1].first;

          auto rit = sourceNodes.find(reqName);
          if (rit != sourceNodes.end())
            stack.push_back(rit->second.get());
        }
      }
    }

    path.clear();
    stack.clear();

    if (!cycle.empty()) {
      result.push_back({depLocation, std::move(cycle)});

      if (stopAtFirst)
        return result;

      // note: if we didn't find a cycle, all nodes that we've seen don't depend
      // [transitively] on start so it's safe to *only* clear seen vector when
      // we find a cycle if we don't do it, we will not have correct reporting
      // for some cycles
      seen.clear();
    }
  }

  return result;
}

double getTimestamp() {
  using namespace std::chrono;
  return double(duration_cast<nanoseconds>(
                    high_resolution_clock::now().time_since_epoch())
                    .count()) /
         1e9;
}

} // namespace

Frontend::Frontend(FileResolver *fileResolver, ConfigResolver *configResolver,
                   const FrontendOptions &options)
    : builtinTypes(NotNull{&builtinTypes_}), fileResolver(fileResolver),
      moduleResolver(this), moduleResolverForAutocomplete(this),
      globals(builtinTypes), globalsForAutocomplete(builtinTypes),
      configResolver(configResolver), options(options) {}

void Frontend::parse(const ModuleName &name) {
  LUAU_TIMETRACE_SCOPE("Frontend::parse", "Frontend");
  LUAU_TIMETRACE_ARGUMENT("name", name.c_str());

  if (getCheckResult(name, false, false))
    return;

  std::vector<ModuleName> buildQueue;
  parseGraph(buildQueue, name, false);
}

CheckResult Frontend::check(const ModuleName &name,
                            std::optional<FrontendOptions> optionOverride) {
  LUAU_TIMETRACE_SCOPE("Frontend::check", "Frontend");
  LUAU_TIMETRACE_ARGUMENT("name", name.c_str());

  FrontendOptions frontendOptions = optionOverride.value_or(options);
  if (FFlag::DebugLuauDeferredConstraintResolution)
    frontendOptions.forAutocomplete = false;

  if (std::optional<CheckResult> result =
          getCheckResult(name, true, frontendOptions.forAutocomplete))
    return std::move(*result);

  std::vector<ModuleName> buildQueue;
  bool cycleDetected =
      parseGraph(buildQueue, name, frontendOptions.forAutocomplete);

  DenseHashSet<Luau::ModuleName> seen{{}};
  std::vector<BuildQueueItem> buildQueueItems;
  addBuildQueueItems(buildQueueItems, buildQueue, cycleDetected, seen,
                     frontendOptions);
  LUAU_ASSERT(!buildQueueItems.empty());

  if (FFlag::DebugLuauLogSolverToJson) {
    LUAU_ASSERT(buildQueueItems.back().name == name);
    buildQueueItems.back().recordJsonLog = true;
  }

  checkBuildQueueItems(buildQueueItems);

  // Collect results only for checked modules, 'getCheckResult' produces a
  // different result
  CheckResult checkResult;

  for (const BuildQueueItem &item : buildQueueItems) {
    if (item.module->timeout)
      checkResult.timeoutHits.push_back(item.name);

    // If check was manually cancelled, do not return partial results
    if (item.module->cancelled)
      return {};

    checkResult.errors.insert(checkResult.errors.end(),
                              item.module->errors.begin(),
                              item.module->errors.end());

    if (item.name == name)
      checkResult.lintResult = item.module->lintResult;
  }

  return checkResult;
}

void Frontend::queueModuleCheck(const std::vector<ModuleName> &names) {
  moduleQueue.insert(moduleQueue.end(), names.begin(), names.end());
}

void Frontend::queueModuleCheck(const ModuleName &name) {
  moduleQueue.push_back(name);
}

std::vector<ModuleName> Frontend::checkQueuedModules(
    std::optional<FrontendOptions> optionOverride,
    std::function<void(std::function<void()> task)> executeTask,
    std::function<bool(size_t done, size_t total)> progress) {
  FrontendOptions frontendOptions = optionOverride.value_or(options);
  if (FFlag::DebugLuauDeferredConstraintResolution)
    frontendOptions.forAutocomplete = false;

  // By taking data into locals, we make sure queue is cleared at the end, even
  // if an ICE or a different exception is thrown
  std::vector<ModuleName> currModuleQueue;
  std::swap(currModuleQueue, moduleQueue);

  DenseHashSet<Luau::ModuleName> seen{{}};
  std::vector<BuildQueueItem> buildQueueItems;

  for (const ModuleName &name : currModuleQueue) {
    if (seen.contains(name))
      continue;

    if (!isDirty(name, frontendOptions.forAutocomplete)) {
      seen.insert(name);
      continue;
    }

    std::vector<ModuleName> queue;
    bool cycleDetected = parseGraph(
        queue, name, frontendOptions.forAutocomplete,
        [&seen](const ModuleName &name) { return seen.contains(name); });

    addBuildQueueItems(buildQueueItems, queue, cycleDetected, seen,
                       frontendOptions);
  }

  if (buildQueueItems.empty())
    return {};

  // We need a mapping from modules to build queue slots
  std::unordered_map<ModuleName, size_t> moduleNameToQueue;

  for (size_t i = 0; i < buildQueueItems.size(); i++) {
    BuildQueueItem &item = buildQueueItems[i];
    moduleNameToQueue[item.name] = i;
  }

  // Default task execution is single-threaded and immediate
  if (!executeTask) {
    executeTask = [](std::function<void()> task) { task(); };
  }

  std::mutex mtx;
  std::condition_variable cv;
  std::vector<size_t> readyQueueItems;

  size_t processing = 0;
  size_t remaining = buildQueueItems.size();

  auto itemTask = [&](size_t i) {
    BuildQueueItem &item = buildQueueItems[i];

    try {
      checkBuildQueueItem(item);
    } catch (...) {
      item.exception = std::current_exception();
    }

    {
      std::unique_lock guard(mtx);
      readyQueueItems.push_back(i);
    }

    cv.notify_one();
  };

  auto sendItemTask = [&](size_t i) {
    BuildQueueItem &item = buildQueueItems[i];

    item.processing = true;
    processing++;

    executeTask([&itemTask, i]() { itemTask(i); });
  };

  auto sendCycleItemTask = [&] {
    for (size_t i = 0; i < buildQueueItems.size(); i++) {
      BuildQueueItem &item = buildQueueItems[i];

      if (!item.processing) {
        sendItemTask(i);
        break;
      }
    }
  };

  // In a first pass, check modules that have no dependencies and record info of
  // those modules that wait
  for (size_t i = 0; i < buildQueueItems.size(); i++) {
    BuildQueueItem &item = buildQueueItems[i];

    for (const ModuleName &dep : item.sourceNode->requireSet) {
      if (auto it = sourceNodes.find(dep); it != sourceNodes.end()) {
        if (it->second->hasDirtyModule(frontendOptions.forAutocomplete)) {
          item.dirtyDependencies++;

          buildQueueItems[moduleNameToQueue[dep]].reverseDeps.push_back(i);
        }
      }
    }

    if (item.dirtyDependencies == 0)
      sendItemTask(i);
  }

  // Not a single item was found, a cycle in the graph was hit
  if (processing == 0)
    sendCycleItemTask();

  std::vector<size_t> nextItems;
  std::optional<size_t> itemWithException;
  bool cancelled = false;

  while (remaining != 0) {
    {
      std::unique_lock guard(mtx);

      // If nothing is ready yet, wait
      cv.wait(guard, [&readyQueueItems] { return !readyQueueItems.empty(); });

      // Handle checked items
      for (size_t i : readyQueueItems) {
        const BuildQueueItem &item = buildQueueItems[i];

        // If exception was thrown, stop adding new items and wait for
        // processing items to complete
        if (item.exception)
          itemWithException = i;

        if (item.module && item.module->cancelled)
          cancelled = true;

        if (itemWithException || cancelled)
          break;

        recordItemResult(item);

        // Notify items that were waiting for this dependency
        for (size_t reverseDep : item.reverseDeps) {
          BuildQueueItem &reverseDepItem = buildQueueItems[reverseDep];

          LUAU_ASSERT(reverseDepItem.dirtyDependencies != 0);
          reverseDepItem.dirtyDependencies--;

          // In case of a module cycle earlier, check if unlocked an item that
          // was already processed
          if (!reverseDepItem.processing &&
              reverseDepItem.dirtyDependencies == 0)
            nextItems.push_back(reverseDep);
        }
      }

      LUAU_ASSERT(processing >= readyQueueItems.size());
      processing -= readyQueueItems.size();

      LUAU_ASSERT(remaining >= readyQueueItems.size());
      remaining -= readyQueueItems.size();
      readyQueueItems.clear();
    }

    if (progress) {
      if (FFlag::LuauCancelFromProgress) {
        if (!progress(buildQueueItems.size() - remaining,
                      buildQueueItems.size()))
          cancelled = true;
      } else {
        progress(buildQueueItems.size() - remaining, buildQueueItems.size());
      }
    }

    // Items cannot be submitted while holding the lock
    for (size_t i : nextItems)
      sendItemTask(i);
    nextItems.clear();

    if (processing == 0) {
      // Typechecking might have been cancelled by user, don't return partial
      // results
      if (cancelled)
        return {};

      // We might have stopped because of a pending exception
      if (itemWithException)
        recordItemResult(buildQueueItems[*itemWithException]);
    }

    // If we aren't done, but don't have anything processing, we hit a cycle
    if (remaining != 0 && processing == 0)
      sendCycleItemTask();
  }

  std::vector<ModuleName> checkedModules;
  checkedModules.reserve(buildQueueItems.size());

  for (size_t i = 0; i < buildQueueItems.size(); i++)
    checkedModules.push_back(std::move(buildQueueItems[i].name));

  return checkedModules;
}

std::optional<CheckResult> Frontend::getCheckResult(const ModuleName &name,
                                                    bool accumulateNested,
                                                    bool forAutocomplete) {
  if (FFlag::DebugLuauDeferredConstraintResolution)
    forAutocomplete = false;

  auto it = sourceNodes.find(name);

  if (it == sourceNodes.end() || it->second->hasDirtyModule(forAutocomplete))
    return std::nullopt;

  auto &resolver =
      forAutocomplete ? moduleResolverForAutocomplete : moduleResolver;

  ModulePtr module = resolver.getModule(name);

  if (module == nullptr)
    throw InternalCompilerError("Frontend does not have module: " + name, name);

  CheckResult checkResult;

  if (module->timeout)
    checkResult.timeoutHits.push_back(name);

  if (accumulateNested)
    checkResult.errors = accumulateErrors(sourceNodes, resolver, name);
  else
    checkResult.errors.insert(checkResult.errors.end(), module->errors.begin(),
                              module->errors.end());

  // Get lint result only for top checked module
  checkResult.lintResult = module->lintResult;

  return checkResult;
}

bool Frontend::parseGraph(std::vector<ModuleName> &buildQueue,
                          const ModuleName &root, bool forAutocomplete,
                          std::function<bool(const ModuleName &)> canSkip) {
  LUAU_TIMETRACE_SCOPE("Frontend::parseGraph", "Frontend");
  LUAU_TIMETRACE_ARGUMENT("root", root.c_str());

  // https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search
  enum Mark { None, Temporary, Permanent };

  DenseHashMap<SourceNode *, Mark> seen(nullptr);
  std::vector<SourceNode *> stack;
  std::vector<SourceNode *> path;
  bool cyclic = false;

  {
    auto [sourceNode, _] = getSourceNode(root);
    if (sourceNode)
      stack.push_back(sourceNode);
  }

  while (!stack.empty()) {
    SourceNode *top = stack.back();
    stack.pop_back();

    if (top == nullptr) {
      // special marker for post-order processing
      LUAU_ASSERT(!path.empty());

      top = path.back();
      path.pop_back();

      // note: topseen ref gets invalidated in any seen[] access, beware - only
      // one seen[] access per iteration!
      Mark &topseen = seen[top];
      LUAU_ASSERT(topseen == Temporary);
      topseen = Permanent;

      buildQueue.push_back(top->name);
    } else {
      // note: topseen ref gets invalidated in any seen[] access, beware - only
      // one seen[] access per iteration!
      Mark &topseen = seen[top];

      if (topseen != None) {
        cyclic |= topseen == Temporary;
        continue;
      }

      topseen = Temporary;

      // push marker for post-order processing
      stack.push_back(nullptr);
      path.push_back(top);

      // push children
      for (const ModuleName &dep : top->requireSet) {
        auto it = sourceNodes.find(dep);
        if (it != sourceNodes.end()) {
          // this is a critical optimization: we do *not* traverse non-dirty
          // subtrees. this relies on the fact that markDirty marks
          // reverse-dependencies dirty as well thus if a node is not dirty, all
          // its transitive deps aren't dirty, which means that they won't ever
          // need to be built, *and* can't form a cycle with any nodes we did
          // process.
          if (!it->second->hasDirtyModule(forAutocomplete))
            continue;

          // This module might already be in the outside build queue
          if (canSkip && canSkip(dep))
            continue;

          // note: this check is technically redundant *except* that
          // getSourceNode has somewhat broken memoization calling getSourceNode
          // twice in succession will reparse the file, since getSourceNode
          // leaves dirty flag set
          if (seen.contains(it->second.get())) {
            stack.push_back(it->second.get());
            continue;
          }
        }

        auto [sourceNode, _] = getSourceNode(dep);
        if (sourceNode) {
          stack.push_back(sourceNode);

          // note: this assignment is paired with .contains() check above and
          // effectively deduplicates getSourceNode()
          seen[sourceNode] = None;
        }
      }
    }
  }

  return cyclic;
}

void Frontend::addBuildQueueItems(std::vector<BuildQueueItem> &items,
                                  std::vector<ModuleName> &buildQueue,
                                  bool cycleDetected,
                                  DenseHashSet<Luau::ModuleName> &seen,
                                  const FrontendOptions &frontendOptions) {
  for (const ModuleName &moduleName : buildQueue) {
    if (seen.contains(moduleName))
      continue;
    seen.insert(moduleName);

    LUAU_ASSERT(sourceNodes.count(moduleName));
    std::shared_ptr<SourceNode> &sourceNode = sourceNodes[moduleName];

    if (!sourceNode->hasDirtyModule(frontendOptions.forAutocomplete))
      continue;

    LUAU_ASSERT(sourceModules.count(moduleName));
    std::shared_ptr<SourceModule> &sourceModule = sourceModules[moduleName];

    BuildQueueItem data{moduleName,
                        fileResolver->getHumanReadableModuleName(moduleName),
                        sourceNode, sourceModule};

    data.config = configResolver->getConfig(moduleName);
    data.environmentScope = getModuleEnvironment(
        *sourceModule, data.config, frontendOptions.forAutocomplete);
    data.recordJsonLog = FFlag::DebugLuauLogSolverToJson;

    Mode mode = sourceModule->mode.value_or(data.config.mode);

    // in NoCheck mode we only need to compute the value of .cyclic for typeck
    // in the future we could replace toposort with an algorithm that can flag
    // cyclic nodes by itself however, for now getRequireCycles isn't expensive
    // in practice on the cases we care about, and long term all correct
    // programs must be acyclic so this code triggers rarely
    if (cycleDetected)
      data.requireCycles = getRequireCycles(
          fileResolver, sourceNodes, sourceNode.get(), mode == Mode::NoCheck);

    data.options = frontendOptions;

    // This is used by the type checker to replace the resulting type of cyclic
    // modules with any
    sourceModule->cyclic = !data.requireCycles.empty();

    items.push_back(std::move(data));
  }
}

static void applyInternalLimitScaling(SourceNode &sourceNode,
                                      const ModulePtr module, double limit) {
  if (module->timeout)
    sourceNode.autocompleteLimitsMult = sourceNode.autocompleteLimitsMult / 2.0;
  else if (module->checkDurationSec < limit / 2.0)
    sourceNode.autocompleteLimitsMult =
        std::min(sourceNode.autocompleteLimitsMult * 2.0, 1.0);
}

void Frontend::checkBuildQueueItem(BuildQueueItem &item) {
  SourceNode &sourceNode = *item.sourceNode;
  const SourceModule &sourceModule = *item.sourceModule;
  const Config &config = item.config;
  Mode mode;
  if (FFlag::DebugLuauForceStrictMode)
    mode = Mode::Strict;
  else if (FFlag::DebugLuauForceNonStrictMode)
    mode = Mode::Nonstrict;
  else
    mode = sourceModule.mode.value_or(config.mode);

  if (FFlag::LuauSourceModuleUpdatedWithSelectedMode)
    item.sourceModule->mode = {mode};
  ScopePtr environmentScope = item.environmentScope;
  double timestamp = getTimestamp();
  const std::vector<RequireCycle> &requireCycles = item.requireCycles;

  TypeCheckLimits typeCheckLimits;

  if (item.options.moduleTimeLimitSec)
    typeCheckLimits.finishTime =
        TimeTrace::getClock() + *item.options.moduleTimeLimitSec;
  else
    typeCheckLimits.finishTime = std::nullopt;

  // TODO: This is a dirty ad hoc solution for autocomplete timeouts
  // We are trying to dynamically adjust our existing limits to lower total
  // typechecking time under the limit so that we'll have type information for
  // the whole file at lower quality instead of a full abort in the middle
  if (item.options.applyInternalLimitScaling) {
    if (FInt::LuauTarjanChildLimit > 0)
      typeCheckLimits.instantiationChildLimit =
          std::max(1, int(FInt::LuauTarjanChildLimit *
                          sourceNode.autocompleteLimitsMult));
    else
      typeCheckLimits.instantiationChildLimit = std::nullopt;

    if (FInt::LuauTypeInferIterationLimit > 0)
      typeCheckLimits.unifierIterationLimit =
          std::max(1, int(FInt::LuauTypeInferIterationLimit *
                          sourceNode.autocompleteLimitsMult));
    else
      typeCheckLimits.unifierIterationLimit = std::nullopt;
  }

  typeCheckLimits.cancellationToken = item.options.cancellationToken;

  if (item.options.forAutocomplete) {
    // The autocomplete typecheck is always in strict mode with DM awareness to
    // provide better type information for IDE features
    ModulePtr moduleForAutocomplete =
        check(sourceModule, Mode::Strict, requireCycles, environmentScope,
              /*forAutocomplete*/ true,
              /*recordJsonLog*/ false, typeCheckLimits);

    double duration = getTimestamp() - timestamp;

    moduleForAutocomplete->checkDurationSec = duration;

    if (item.options.moduleTimeLimitSec &&
        item.options.applyInternalLimitScaling)
      applyInternalLimitScaling(sourceNode, moduleForAutocomplete,
                                *item.options.moduleTimeLimitSec);

    item.stats.timeCheck += duration;
    item.stats.filesStrict += 1;

    item.module = moduleForAutocomplete;
    return;
  }

  ModulePtr module =
      check(sourceModule, mode, requireCycles, environmentScope,
            /*forAutocomplete*/ false, item.recordJsonLog, typeCheckLimits);

  double duration = getTimestamp() - timestamp;

  module->checkDurationSec = duration;

  if (item.options.moduleTimeLimitSec && item.options.applyInternalLimitScaling)
    applyInternalLimitScaling(sourceNode, module,
                              *item.options.moduleTimeLimitSec);

  item.stats.timeCheck += duration;
  item.stats.filesStrict += mode == Mode::Strict;
  item.stats.filesNonstrict += mode == Mode::Nonstrict;

  if (module == nullptr)
    throw InternalCompilerError(
        "Frontend::check produced a nullptr module for " + item.name,
        item.name);

  if (FFlag::DebugLuauDeferredConstraintResolution && mode == Mode::NoCheck)
    module->errors.clear();

  if (item.options.runLintChecks) {
    LUAU_TIMETRACE_SCOPE("lint", "Frontend");

    LintOptions lintOptions =
        item.options.enabledLintWarnings.value_or(config.enabledLint);
    filterLintOptions(lintOptions, sourceModule.hotcomments, mode);

    double timestamp = getTimestamp();

    std::vector<LintWarning> warnings =
        Luau::lint(sourceModule.root, *sourceModule.names, environmentScope,
                   module.get(), sourceModule.hotcomments, lintOptions);

    item.stats.timeLint += getTimestamp() - timestamp;

    module->lintResult = classifyLints(warnings, config);
  }

  if (!item.options.retainFullTypeGraphs) {
    // copyErrors needs to allocate into interfaceTypes as it copies
    // types out of internalTypes, so we unfreeze it here.
    unfreeze(module->interfaceTypes);
    copyErrors(module->errors, module->interfaceTypes, builtinTypes);
    freeze(module->interfaceTypes);

    module->internalTypes.clear();

    module->astTypes.clear();
    module->astTypePacks.clear();
    module->astExpectedTypes.clear();
    module->astOriginalCallTypes.clear();
    module->astOverloadResolvedTypes.clear();
    module->astForInNextTypes.clear();
    module->astResolvedTypes.clear();
    module->astResolvedTypePacks.clear();
    module->astCompoundAssignResultTypes.clear();
    module->astScopes.clear();
    module->upperBoundContributors.clear();
    module->scopes.clear();
  }

  if (mode != Mode::NoCheck) {
    for (const RequireCycle &cyc : requireCycles) {
      TypeError te{cyc.location, item.name,
                   ModuleHasCyclicDependency{cyc.path}};

      module->errors.push_back(te);
    }
  }

  ErrorVec parseErrors;

  for (const ParseError &pe : sourceModule.parseErrors)
    parseErrors.push_back(
        TypeError{pe.getLocation(), item.name, SyntaxError{pe.what()}});

  module->errors.insert(module->errors.begin(), parseErrors.begin(),
                        parseErrors.end());

  item.module = module;
}

void Frontend::checkBuildQueueItems(std::vector<BuildQueueItem> &items) {
  for (BuildQueueItem &item : items) {
    checkBuildQueueItem(item);

    if (item.module && item.module->cancelled)
      break;

    recordItemResult(item);
  }
}

void Frontend::recordItemResult(const BuildQueueItem &item) {
  if (item.exception)
    std::rethrow_exception(item.exception);

  if (item.options.forAutocomplete) {
    moduleResolverForAutocomplete.setModule(item.name, item.module);
    item.sourceNode->dirtyModuleForAutocomplete = false;
  } else {
    moduleResolver.setModule(item.name, item.module);
    item.sourceNode->dirtyModule = false;
  }

  stats.timeCheck += item.stats.timeCheck;
  stats.timeLint += item.stats.timeLint;

  stats.filesStrict += item.stats.filesStrict;
  stats.filesNonstrict += item.stats.filesNonstrict;
}

ScopePtr Frontend::getModuleEnvironment(const SourceModule &module,
                                        const Config &config,
                                        bool forAutocomplete) const {
  ScopePtr result;
  if (forAutocomplete)
    result = globalsForAutocomplete.globalScope;
  else
    result = globals.globalScope;

  if (module.environmentName)
    result = getEnvironmentScope(*module.environmentName);

  if (!config.globals.empty()) {
    result = std::make_shared<Scope>(result);

    for (const std::string &global : config.globals) {
      AstName name = module.names->get(global.c_str());

      if (name.value)
        result->bindings[name].typeId = builtinTypes->anyType;
    }
  }

  return result;
}

bool Frontend::isDirty(const ModuleName &name, bool forAutocomplete) const {
  auto it = sourceNodes.find(name);
  return it == sourceNodes.end() || it->second->hasDirtyModule(forAutocomplete);
}

/*
 * Mark a file as requiring rechecking before its type information can be safely
 * used again.
 *
 * I am not particularly pleased with the way each dirty() operation involves a
 * BFS on reverse dependencies. It would be nice for this function to be O(1)
 */
void Frontend::markDirty(const ModuleName &name,
                         std::vector<ModuleName> *markedDirty) {
  if (sourceNodes.count(name) == 0)
    return;

  std::unordered_map<ModuleName, std::vector<ModuleName>> reverseDeps;
  for (const auto &module : sourceNodes) {
    for (const auto &dep : module.second->requireSet)
      reverseDeps[dep].push_back(module.first);
  }

  std::vector<ModuleName> queue{name};

  while (!queue.empty()) {
    ModuleName next = std::move(queue.back());
    queue.pop_back();

    LUAU_ASSERT(sourceNodes.count(next) > 0);
    SourceNode &sourceNode = *sourceNodes[next];

    if (markedDirty)
      markedDirty->push_back(next);

    if (sourceNode.dirtySourceModule && sourceNode.dirtyModule &&
        sourceNode.dirtyModuleForAutocomplete)
      continue;

    sourceNode.dirtySourceModule = true;
    sourceNode.dirtyModule = true;
    sourceNode.dirtyModuleForAutocomplete = true;

    if (0 == reverseDeps.count(next))
      continue;

    sourceModules.erase(next);

    const std::vector<ModuleName> &dependents = reverseDeps[next];
    queue.insert(queue.end(), dependents.begin(), dependents.end());
  }
}

SourceModule *Frontend::getSourceModule(const ModuleName &moduleName) {
  auto it = sourceModules.find(moduleName);
  if (it != sourceModules.end())
    return it->second.get();
  else
    return nullptr;
}

const SourceModule *
Frontend::getSourceModule(const ModuleName &moduleName) const {
  return const_cast<Frontend *>(this)->getSourceModule(moduleName);
}

ModulePtr
check(const SourceModule &sourceModule, Mode mode,
      const std::vector<RequireCycle> &requireCycles,
      NotNull<BuiltinTypes> builtinTypes,
      NotNull<InternalErrorReporter> iceHandler,
      NotNull<ModuleResolver> moduleResolver,
      NotNull<FileResolver> fileResolver, const ScopePtr &parentScope,
      std::function<void(const ModuleName &, const ScopePtr &)>
          prepareModuleScope,
      FrontendOptions options, TypeCheckLimits limits,
      std::function<void(const ModuleName &, std::string)> writeJsonLog) {
  const bool recordJsonLog = FFlag::DebugLuauLogSolverToJson;
  return check(sourceModule, mode, requireCycles, builtinTypes, iceHandler,
               moduleResolver, fileResolver, parentScope,
               std::move(prepareModuleScope), options, limits, recordJsonLog,
               writeJsonLog);
}

struct InternalTypeFinder : TypeOnceVisitor {
  bool visit(TypeId, const ClassType &) override { return false; }

  bool visit(TypeId, const BlockedType &) override {
    LUAU_ASSERT(false);
    return false;
  }

  bool visit(TypeId, const FreeType &) override {
    LUAU_ASSERT(false);
    return false;
  }

  bool visit(TypeId, const PendingExpansionType &) override {
    LUAU_ASSERT(false);
    return false;
  }

  bool visit(TypePackId, const BlockedTypePack &) override {
    LUAU_ASSERT(false);
    return false;
  }

  bool visit(TypePackId, const FreeTypePack &) override {
    LUAU_ASSERT(false);
    return false;
  }

  bool visit(TypePackId, const TypeFunctionInstanceTypePack &) override {
    LUAU_ASSERT(false);
    return false;
  }
};

ModulePtr
check(const SourceModule &sourceModule, Mode mode,
      const std::vector<RequireCycle> &requireCycles,
      NotNull<BuiltinTypes> builtinTypes,
      NotNull<InternalErrorReporter> iceHandler,
      NotNull<ModuleResolver> moduleResolver,
      NotNull<FileResolver> fileResolver, const ScopePtr &parentScope,
      std::function<void(const ModuleName &, const ScopePtr &)>
          prepareModuleScope,
      FrontendOptions options, TypeCheckLimits limits, bool recordJsonLog,
      std::function<void(const ModuleName &, std::string)> writeJsonLog) {
  ModulePtr result = std::make_shared<Module>();
  result->name = sourceModule.name;
  result->humanReadableName = sourceModule.humanReadableName;
  result->mode = mode;
  result->internalTypes.owningModule = result.get();
  result->interfaceTypes.owningModule = result.get();

  iceHandler->moduleName = sourceModule.name;

  std::unique_ptr<DcrLogger> logger;
  if (recordJsonLog) {
    logger = std::make_unique<DcrLogger>();
    std::optional<SourceCode> source = fileResolver->readSource(result->name);
    if (source) {
      logger->captureSource(source->source);
    }
  }

  DataFlowGraph dfg =
      DataFlowGraphBuilder::build(sourceModule.root, iceHandler);

  UnifierSharedState unifierState{iceHandler};
  unifierState.counters.recursionLimit = FInt::LuauTypeInferRecursionLimit;
  unifierState.counters.iterationLimit =
      limits.unifierIterationLimit.value_or(FInt::LuauTypeInferIterationLimit);

  Normalizer normalizer{&result->internalTypes, builtinTypes,
                        NotNull{&unifierState}};

  ConstraintGenerator cg{result,
                         NotNull{&normalizer},
                         moduleResolver,
                         builtinTypes,
                         iceHandler,
                         parentScope,
                         std::move(prepareModuleScope),
                         logger.get(),
                         NotNull{&dfg},
                         requireCycles};

  cg.visitModuleRoot(sourceModule.root);
  result->errors = std::move(cg.errors);

  ConstraintSolver cs{NotNull{&normalizer},
                      NotNull(cg.rootScope),
                      borrowConstraints(cg.constraints),
                      result->name,
                      moduleResolver,
                      requireCycles,
                      logger.get(),
                      limits};

  if (options.randomizeConstraintResolutionSeed)
    cs.randomize(*options.randomizeConstraintResolutionSeed);

  try {
    cs.run();
  } catch (const TimeLimitError &) {
    result->timeout = true;
  } catch (const UserCancelError &) {
    result->cancelled = true;
  }

  if (recordJsonLog) {
    std::string output = logger->compileOutput();
    if (FFlag::DebugLuauLogSolverToJsonFile && writeJsonLog)
      writeJsonLog(sourceModule.name, std::move(output));
    else
      printf("%s\n", output.c_str());
  }

  for (TypeError &e : cs.errors)
    result->errors.emplace_back(std::move(e));

  result->scopes = std::move(cg.scopes);
  result->type = sourceModule.type;
  result->upperBoundContributors = std::move(cs.upperBoundContributors);

  if (result->timeout || result->cancelled) {
    // If solver was interrupted, skip typechecking and replace all module
    // results with error-supressing types to avoid leaking blocked/pending
    // types
    ScopePtr moduleScope = result->getModuleScope();
    moduleScope->returnType = builtinTypes->errorRecoveryTypePack();

    for (auto &[name, ty] : result->declaredGlobals)
      ty = builtinTypes->errorRecoveryType();

    for (auto &[name, tf] : result->exportedTypeBindings)
      tf.type = builtinTypes->errorRecoveryType();
  } else {
    switch (mode) {
    case Mode::Nonstrict:
      Luau::checkNonStrict(builtinTypes, iceHandler, NotNull{&unifierState},
                           NotNull{&dfg}, NotNull{&limits}, sourceModule,
                           result.get());
      break;
    case Mode::Definition:
      // fallthrough intentional
    case Mode::Strict:
      Luau::check(builtinTypes, NotNull{&unifierState}, NotNull{&limits},
                  logger.get(), sourceModule, result.get());
      break;
    case Mode::NoCheck:
      break;
    };
  }

  unfreeze(result->interfaceTypes);
  result->clonePublicInterface(builtinTypes, *iceHandler);

  if (FFlag::DebugLuauForbidInternalTypes) {
    InternalTypeFinder finder;

    finder.traverse(result->returnType);

    for (const auto &[_, binding] : result->exportedTypeBindings)
      finder.traverse(binding.type);

    for (const auto &[_, ty] : result->astTypes)
      finder.traverse(ty);

    for (const auto &[_, ty] : result->astExpectedTypes)
      finder.traverse(ty);

    for (const auto &[_, tp] : result->astTypePacks)
      finder.traverse(tp);

    for (const auto &[_, ty] : result->astResolvedTypes)
      finder.traverse(ty);

    for (const auto &[_, ty] : result->astOverloadResolvedTypes)
      finder.traverse(ty);

    for (const auto &[_, tp] : result->astResolvedTypePacks)
      finder.traverse(tp);
  }

  // It would be nice if we could freeze the arenas before doing type
  // checking, but we'll have to do some work to get there.
  //
  // TypeChecker2 sometimes needs to allocate TypePacks via extendTypePack()
  // in order to do its thing.  We can rework that code to instead allocate
  // into a temporary arena as long as we can prove that the allocated types
  // and packs can never find their way into an error.
  //
  // Notably, we would first need to get to a place where TypeChecker2 is
  // never in the position of dealing with a FreeType.  They should all be
  // bound to something by the time constraints are solved.
  freeze(result->internalTypes);
  freeze(result->interfaceTypes);

  return result;
}

ModulePtr Frontend::check(const SourceModule &sourceModule, Mode mode,
                          std::vector<RequireCycle> requireCycles,
                          std::optional<ScopePtr> environmentScope,
                          bool forAutocomplete, bool recordJsonLog,
                          TypeCheckLimits typeCheckLimits) {
  if (FFlag::DebugLuauDeferredConstraintResolution) {
    auto prepareModuleScopeWrap =
        [this, forAutocomplete](const ModuleName &name, const ScopePtr &scope) {
          if (prepareModuleScope)
            prepareModuleScope(name, scope, forAutocomplete);
        };

    try {
      return Luau::check(
          sourceModule, mode, requireCycles, builtinTypes, NotNull{&iceHandler},
          NotNull{forAutocomplete ? &moduleResolverForAutocomplete
                                  : &moduleResolver},
          NotNull{fileResolver},
          environmentScope ? *environmentScope : globals.globalScope,
          prepareModuleScopeWrap, options, typeCheckLimits, recordJsonLog,
          writeJsonLog);
    } catch (const InternalCompilerError &err) {
      InternalCompilerError augmented =
          err.location.has_value()
              ? InternalCompilerError{err.message, sourceModule.name,
                                      *err.location}
              : InternalCompilerError{err.message, sourceModule.name};
      throw augmented;
    }
  } else {
    TypeChecker typeChecker(forAutocomplete ? globalsForAutocomplete.globalScope
                                            : globals.globalScope,
                            forAutocomplete ? &moduleResolverForAutocomplete
                                            : &moduleResolver,
                            builtinTypes, &iceHandler);

    if (prepareModuleScope) {
      typeChecker.prepareModuleScope =
          [this, forAutocomplete](const ModuleName &name,
                                  const ScopePtr &scope) {
            prepareModuleScope(name, scope, forAutocomplete);
          };
    }

    typeChecker.requireCycles = requireCycles;
    typeChecker.finishTime = typeCheckLimits.finishTime;
    typeChecker.instantiationChildLimit =
        typeCheckLimits.instantiationChildLimit;
    typeChecker.unifierIterationLimit = typeCheckLimits.unifierIterationLimit;
    typeChecker.cancellationToken = typeCheckLimits.cancellationToken;

    return typeChecker.check(sourceModule, mode, environmentScope);
  }
}

// Read AST into sourceModules if necessary.  Trace require()s.  Report parse
// errors.
std::pair<SourceNode *, SourceModule *>
Frontend::getSourceNode(const ModuleName &name) {
  auto it = sourceNodes.find(name);
  if (it != sourceNodes.end() && !it->second->hasDirtySourceModule()) {
    auto moduleIt = sourceModules.find(name);
    if (moduleIt != sourceModules.end())
      return {it->second.get(), moduleIt->second.get()};
    else {
      LUAU_ASSERT(!"Everything in sourceNodes should also be in sourceModules");
      return {it->second.get(), nullptr};
    }
  }

  LUAU_TIMETRACE_SCOPE("Frontend::getSourceNode", "Frontend");
  LUAU_TIMETRACE_ARGUMENT("name", name.c_str());

  double timestamp = getTimestamp();

  std::optional<SourceCode> source = fileResolver->readSource(name);
  std::optional<std::string> environmentName =
      fileResolver->getEnvironmentForModule(name);

  stats.timeRead += getTimestamp() - timestamp;

  if (!source) {
    sourceModules.erase(name);
    return {nullptr, nullptr};
  }

  const Config &config = configResolver->getConfig(name);
  ParseOptions opts = config.parseOptions;
  opts.captureComments = true;
  SourceModule result = parse(name, source->source, opts);
  result.type = source->type;

  RequireTraceResult &require = requireTrace[name];
  require = traceRequires(fileResolver, result.root, name);

  std::shared_ptr<SourceNode> &sourceNode = sourceNodes[name];

  if (!sourceNode)
    sourceNode = std::make_shared<SourceNode>();

  std::shared_ptr<SourceModule> &sourceModule = sourceModules[name];

  if (!sourceModule)
    sourceModule = std::make_shared<SourceModule>();

  *sourceModule = std::move(result);
  sourceModule->environmentName = environmentName;

  sourceNode->name = sourceModule->name;
  sourceNode->humanReadableName = sourceModule->humanReadableName;
  sourceNode->requireSet.clear();
  sourceNode->requireLocations.clear();
  sourceNode->dirtySourceModule = false;

  if (it == sourceNodes.end()) {
    sourceNode->dirtyModule = true;
    sourceNode->dirtyModuleForAutocomplete = true;
  }

  for (const auto &[moduleName, location] : require.requireList)
    sourceNode->requireSet.insert(moduleName);

  sourceNode->requireLocations = require.requireList;

  return {sourceNode.get(), sourceModule.get()};
}

/** Try to parse a source file into a SourceModule.
 *
 * The logic here is a little bit more complicated than we'd like it to be.
 *
 * If a file does not exist, we return none to prevent the Frontend from
 * creating knowledge that this module exists. If the Frontend thinks that the
 * file exists, it will not produce an "Unknown require" error.
 *
 * If the file has syntax errors, we report them and synthesize an empty AST if
 * it's not available. This suppresses the Unknown require error and allows us
 * to make a best effort to typecheck code that require()s something that has
 * broken syntax. We also translate Luau::ParseError into a Luau::TypeError so
 * that we can use a vector<TypeError> to describe the result of the check()
 */
SourceModule Frontend::parse(const ModuleName &name, std::string_view src,
                             const ParseOptions &parseOptions) {
  LUAU_TIMETRACE_SCOPE("Frontend::parse", "Frontend");
  LUAU_TIMETRACE_ARGUMENT("name", name.c_str());

  SourceModule sourceModule;

  double timestamp = getTimestamp();

  Luau::ParseResult parseResult =
      Luau::Parser::parse(src.data(), src.size(), *sourceModule.names,
                          *sourceModule.allocator, parseOptions);

  stats.timeParse += getTimestamp() - timestamp;
  stats.files++;
  stats.lines += parseResult.lines;

  if (!parseResult.errors.empty())
    sourceModule.parseErrors.insert(sourceModule.parseErrors.end(),
                                    parseResult.errors.begin(),
                                    parseResult.errors.end());

  if (parseResult.errors.empty() || parseResult.root) {
    sourceModule.root = parseResult.root;
    sourceModule.mode = parseMode(parseResult.hotcomments);
  } else {
    sourceModule.root = sourceModule.allocator->alloc<AstStatBlock>(
        Location{}, AstArray<AstStat *>{nullptr, 0});
    sourceModule.mode = Mode::NoCheck;
  }

  sourceModule.name = name;
  sourceModule.humanReadableName =
      fileResolver->getHumanReadableModuleName(name);

  if (parseOptions.captureComments) {
    sourceModule.commentLocations = std::move(parseResult.commentLocations);
    sourceModule.hotcomments = std::move(parseResult.hotcomments);
  }

  return sourceModule;
}

FrontendModuleResolver::FrontendModuleResolver(Frontend *frontend)
    : frontend(frontend) {}

std::optional<ModuleInfo>
FrontendModuleResolver::resolveModuleInfo(const ModuleName &currentModuleName,
                                          const AstExpr &pathExpr) {
  // FIXME I think this can be pushed into the FileResolver.
  auto it = frontend->requireTrace.find(currentModuleName);
  if (it == frontend->requireTrace.end()) {
    // CLI-43699
    // If we can't find the current module name, that's because we bypassed the
    // frontend's initializer and called typeChecker.check directly. In that
    // case, requires will always fail.
    return std::nullopt;
  }

  const auto &exprs = it->second.exprs;

  const ModuleInfo *info = exprs.find(&pathExpr);
  if (!info)
    return std::nullopt;

  return *info;
}

const ModulePtr
FrontendModuleResolver::getModule(const ModuleName &moduleName) const {
  std::scoped_lock lock(moduleMutex);

  auto it = modules.find(moduleName);
  if (it != modules.end())
    return it->second;
  else
    return nullptr;
}

bool FrontendModuleResolver::moduleExists(const ModuleName &moduleName) const {
  return frontend->sourceNodes.count(moduleName) != 0;
}

std::string FrontendModuleResolver::getHumanReadableModuleName(
    const ModuleName &moduleName) const {
  return frontend->fileResolver->getHumanReadableModuleName(moduleName);
}

void FrontendModuleResolver::setModule(const ModuleName &moduleName,
                                       ModulePtr module) {
  std::scoped_lock lock(moduleMutex);

  modules[moduleName] = std::move(module);
}

void FrontendModuleResolver::clearModules() {
  std::scoped_lock lock(moduleMutex);

  modules.clear();
}

ScopePtr Frontend::addEnvironment(const std::string &environmentName) {
  LUAU_ASSERT(environments.count(environmentName) == 0);

  if (environments.count(environmentName) == 0) {
    ScopePtr scope = std::make_shared<Scope>(globals.globalScope);
    environments[environmentName] = scope;
    return scope;
  } else
    return environments[environmentName];
}

ScopePtr
Frontend::getEnvironmentScope(const std::string &environmentName) const {
  if (auto it = environments.find(environmentName); it != environments.end())
    return it->second;

  LUAU_ASSERT(!"environment doesn't exist");
  return {};
}

void Frontend::registerBuiltinDefinition(
    const std::string &name,
    std::function<void(Frontend &, GlobalTypes &, ScopePtr)> applicator) {
  LUAU_ASSERT(builtinDefinitions.count(name) == 0);

  if (builtinDefinitions.count(name) == 0)
    builtinDefinitions[name] = applicator;
}

void Frontend::applyBuiltinDefinitionToEnvironment(
    const std::string &environmentName, const std::string &definitionName) {
  LUAU_ASSERT(builtinDefinitions.count(definitionName) > 0);

  if (builtinDefinitions.count(definitionName) > 0)
    builtinDefinitions[definitionName](*this, globals,
                                       getEnvironmentScope(environmentName));
}

LintResult Frontend::classifyLints(const std::vector<LintWarning> &warnings,
                                   const Config &config) {
  LintResult result;
  for (const auto &w : warnings) {
    if (config.lintErrors || config.fatalLint.isEnabled(w.code))
      result.errors.push_back(w);
    else
      result.warnings.push_back(w);
  }

  return result;
}

void Frontend::clearStats() { stats = {}; }

void Frontend::clear() {
  sourceNodes.clear();
  sourceModules.clear();
  moduleResolver.clearModules();
  moduleResolverForAutocomplete.clearModules();
  requireTrace.clear();
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintSolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Anyification.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ApplyTypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DcrLogger.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Generalization.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation.h>

// DONE : was aleready inlined <Luau/Instantiation2.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ModuleResolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/OverloadResolution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Quantify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TableLiteralInference.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TimeTrace.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifier2.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <utility>

LUAU_FASTFLAGVARIABLE(DebugLuauLogSolver, false);
LUAU_FASTFLAGVARIABLE(DebugLuauLogSolverIncludeDependencies, false)
LUAU_FASTFLAGVARIABLE(DebugLuauLogBindings, false);
LUAU_FASTINTVARIABLE(LuauSolverRecursionLimit, 500);

namespace Luau {

size_t
HashBlockedConstraintId::operator()(const BlockedConstraintId &bci) const {
  size_t result = 0;

  if (const TypeId *ty = get_if<TypeId>(&bci))
    result = std::hash<TypeId>()(*ty);
  else if (const TypePackId *tp = get_if<TypePackId>(&bci))
    result = std::hash<TypePackId>()(*tp);
  else if (Constraint const *const *c = get_if<const Constraint *>(&bci))
    result = std::hash<const Constraint *>()(*c);
  else
    LUAU_ASSERT(!"Should be unreachable");

  return result;
}

[[maybe_unused]] static void dumpBindings(NotNull<Scope> scope,
                                          ToStringOptions &opts) {
  for (const auto &[k, v] : scope->bindings) {
    auto d = toString(v.typeId, opts);
    printf("\t%s : %s\n", k.c_str(), d.c_str());
  }

  for (NotNull<Scope> child : scope->children)
    dumpBindings(child, opts);
}

// used only in asserts
[[maybe_unused]] static bool canMutate(TypeId ty,
                                       NotNull<const Constraint> constraint) {
  if (auto blocked = get<BlockedType>(ty)) {
    Constraint *owner = blocked->getOwner();
    LUAU_ASSERT(owner);
    return owner == constraint;
  }

  return true;
}

// used only in asserts
[[maybe_unused]] static bool canMutate(TypePackId tp,
                                       NotNull<const Constraint> constraint) {
  if (auto blocked = get<BlockedTypePack>(tp)) {
    Constraint *owner = blocked->owner;
    LUAU_ASSERT(owner);
    return owner == constraint;
  }

  return true;
}

static std::pair<std::vector<TypeId>, std::vector<TypePackId>>
saturateArguments(TypeArena *arena, NotNull<BuiltinTypes> builtinTypes,
                  const TypeFun &fn,
                  const std::vector<TypeId> &rawTypeArguments,
                  const std::vector<TypePackId> &rawPackArguments) {
  std::vector<TypeId> saturatedTypeArguments;
  std::vector<TypeId> extraTypes;
  std::vector<TypePackId> saturatedPackArguments;

  for (size_t i = 0; i < rawTypeArguments.size(); ++i) {
    TypeId ty = rawTypeArguments[i];

    if (i < fn.typeParams.size())
      saturatedTypeArguments.push_back(ty);
    else
      extraTypes.push_back(ty);
  }

  // If we collected extra types, put them in a type pack now. This case is
  // mutually exclusive with the type pack -> type conversion we do below:
  // extraTypes will only have elements in it if we have more types than we
  // have parameter slots for them to go into.
  if (!extraTypes.empty() && !fn.typePackParams.empty()) {
    saturatedPackArguments.push_back(arena->addTypePack(extraTypes));
  }

  for (size_t i = 0; i < rawPackArguments.size(); ++i) {
    TypePackId tp = rawPackArguments[i];

    // If we are short on regular type saturatedTypeArguments and we have a
    // single element type pack, we can decompose that to the type it contains
    // and use that as a type parameter.
    if (saturatedTypeArguments.size() < fn.typeParams.size() && size(tp) == 1 &&
        finite(tp) && first(tp) && saturatedPackArguments.empty()) {
      saturatedTypeArguments.push_back(*first(tp));
    } else if (saturatedPackArguments.size() < fn.typePackParams.size()) {
      saturatedPackArguments.push_back(tp);
    }
  }

  size_t typesProvided = saturatedTypeArguments.size();
  size_t typesRequired = fn.typeParams.size();

  size_t packsProvided = saturatedPackArguments.size();
  size_t packsRequired = fn.typePackParams.size();

  // Extra types should be accumulated in extraTypes, not
  // saturatedTypeArguments. Extra packs will be accumulated in
  // saturatedPackArguments, so we don't have an assertion for that.
  LUAU_ASSERT(typesProvided <= typesRequired);

  // If we didn't provide enough types, but we did provide a type pack, we
  // don't want to use defaults. The rationale for this is that if the user
  // provides a pack but doesn't provide enough types, we want to report an
  // error, rather than simply using the default saturatedTypeArguments, if they
  // exist. If they did provide enough types, but not enough packs, we of course
  // want to use the default packs.
  bool needsDefaults =
      (typesProvided < typesRequired && packsProvided == 0) ||
      (typesProvided == typesRequired && packsProvided < packsRequired);

  if (needsDefaults) {
    // Default types can reference earlier types. It's legal to write
    // something like
    // type T<A, B = A> = (A, B) -> number
    // and we need to respect that. We use an ApplyTypeFunction for this.
    ApplyTypeFunction atf{arena};

    for (size_t i = 0; i < typesProvided; ++i)
      atf.typeArguments[fn.typeParams[i].ty] = saturatedTypeArguments[i];

    for (size_t i = typesProvided; i < typesRequired; ++i) {
      TypeId defaultTy = fn.typeParams[i].defaultValue.value_or(nullptr);

      // We will fill this in with the error type later.
      if (!defaultTy)
        break;

      TypeId instantiatedDefault =
          atf.substitute(defaultTy).value_or(builtinTypes->errorRecoveryType());
      atf.typeArguments[fn.typeParams[i].ty] = instantiatedDefault;
      saturatedTypeArguments.push_back(instantiatedDefault);
    }

    for (size_t i = 0; i < packsProvided; ++i) {
      atf.typePackArguments[fn.typePackParams[i].tp] =
          saturatedPackArguments[i];
    }

    for (size_t i = packsProvided; i < packsRequired; ++i) {
      TypePackId defaultTp =
          fn.typePackParams[i].defaultValue.value_or(nullptr);

      // We will fill this in with the error type pack later.
      if (!defaultTp)
        break;

      TypePackId instantiatedDefault = atf.substitute(defaultTp).value_or(
          builtinTypes->errorRecoveryTypePack());
      atf.typePackArguments[fn.typePackParams[i].tp] = instantiatedDefault;
      saturatedPackArguments.push_back(instantiatedDefault);
    }
  }

  // If we didn't create an extra type pack from overflowing parameter packs,
  // and we're still missing a type pack, plug in an empty type pack as the
  // value of the empty packs.
  if (extraTypes.empty() &&
      saturatedPackArguments.size() + 1 == fn.typePackParams.size()) {
    saturatedPackArguments.push_back(arena->addTypePack({}));
  }

  // We need to have _something_ when we substitute the generic
  // saturatedTypeArguments, even if they're missing, so we use the error type
  // as a filler.
  for (size_t i = saturatedTypeArguments.size(); i < typesRequired; ++i) {
    saturatedTypeArguments.push_back(builtinTypes->errorRecoveryType());
  }

  for (size_t i = saturatedPackArguments.size(); i < packsRequired; ++i) {
    saturatedPackArguments.push_back(builtinTypes->errorRecoveryTypePack());
  }

  for (TypeId &arg : saturatedTypeArguments)
    arg = follow(arg);

  for (TypePackId &pack : saturatedPackArguments)
    pack = follow(pack);

  // At this point, these two conditions should be true. If they aren't we
  // will run into access violations.
  LUAU_ASSERT(saturatedTypeArguments.size() == fn.typeParams.size());
  LUAU_ASSERT(saturatedPackArguments.size() == fn.typePackParams.size());

  return {saturatedTypeArguments, saturatedPackArguments};
}

bool InstantiationSignature::operator==(
    const InstantiationSignature &rhs) const {
  return fn == rhs.fn && arguments == rhs.arguments &&
         packArguments == rhs.packArguments;
}

size_t HashInstantiationSignature::operator()(
    const InstantiationSignature &signature) const {
  size_t hash = std::hash<TypeId>{}(signature.fn.type);
  for (const GenericTypeDefinition &p : signature.fn.typeParams) {
    hash ^= (std::hash<TypeId>{}(p.ty) << 1);
  }

  for (const GenericTypePackDefinition &p : signature.fn.typePackParams) {
    hash ^= (std::hash<TypePackId>{}(p.tp) << 1);
  }

  for (const TypeId a : signature.arguments) {
    hash ^= (std::hash<TypeId>{}(a) << 1);
  }

  for (const TypePackId a : signature.packArguments) {
    hash ^= (std::hash<TypePackId>{}(a) << 1);
  }

  return hash;
}

void dump(ConstraintSolver *cs, ToStringOptions &opts) {
  printf("constraints:\n");
  for (NotNull<const Constraint> c : cs->unsolvedConstraints) {
    auto it = cs->blockedConstraints.find(c);
    int blockCount = it == cs->blockedConstraints.end() ? 0 : int(it->second);
    printf("\t%d\t%s\n", blockCount, toString(*c, opts).c_str());

    if (FFlag::DebugLuauLogSolverIncludeDependencies) {
      for (NotNull<Constraint> dep : c->dependencies) {
        if (std::find(cs->unsolvedConstraints.begin(),
                      cs->unsolvedConstraints.end(),
                      dep) != cs->unsolvedConstraints.end())
          printf("\t\t|\t%s\n", toString(*dep, opts).c_str());
      }
    }
  }
}

struct InstantiationQueuer : TypeOnceVisitor {
  ConstraintSolver *solver;
  NotNull<Scope> scope;
  Location location;

  explicit InstantiationQueuer(NotNull<Scope> scope, const Location &location,
                               ConstraintSolver *solver)
      : solver(solver), scope(scope), location(location) {}

  bool visit(TypeId ty, const PendingExpansionType &petv) override {
    solver->pushConstraint(scope, location, TypeAliasExpansionConstraint{ty});
    return false;
  }

  bool visit(TypeId ty, const TypeFunctionInstanceType &) override {
    solver->pushConstraint(scope, location, ReduceConstraint{ty});
    return true;
  }

  bool visit(TypeId ty, const ClassType &ctv) override { return false; }
};

ConstraintSolver::ConstraintSolver(NotNull<Normalizer> normalizer,
                                   NotNull<Scope> rootScope,
                                   std::vector<NotNull<Constraint>> constraints,
                                   ModuleName moduleName,
                                   NotNull<ModuleResolver> moduleResolver,
                                   std::vector<RequireCycle> requireCycles,
                                   DcrLogger *logger, TypeCheckLimits limits)
    : arena(normalizer->arena), builtinTypes(normalizer->builtinTypes),
      normalizer(normalizer), constraints(std::move(constraints)),
      rootScope(rootScope), currentModuleName(std::move(moduleName)),
      moduleResolver(moduleResolver), requireCycles(requireCycles),
      logger(logger), limits(std::move(limits)) {
  opts.exhaustive = true;

  for (NotNull<Constraint> c : this->constraints) {
    unsolvedConstraints.push_back(c);

    // initialize the reference counts for the free types in this constraint.
    for (auto ty : c->getMaybeMutatedFreeTypes()) {
      // increment the reference count for `ty`
      auto [refCount, _] = unresolvedConstraints.try_insert(ty, 0);
      refCount += 1;
    }

    for (NotNull<const Constraint> dep : c->dependencies) {
      block(dep, c);
    }
  }
}

void ConstraintSolver::randomize(unsigned seed) {
  if (unsolvedConstraints.empty())
    return;

  unsigned int rng = seed;

  for (size_t i = unsolvedConstraints.size() - 1; i > 0; --i) {
    // Fisher-Yates shuffle
    size_t j = rng % (i + 1);

    std::swap(unsolvedConstraints[i], unsolvedConstraints[j]);

    // LCG RNG, constants from Numerical Recipes
    // This may occasionally result in skewed shuffles due to distribution
    // properties, but this is a debugging tool so it should be good enough
    rng = rng * 1664525 + 1013904223;
  }
}

void ConstraintSolver::run() {
  if (isDone())
    return;

  if (FFlag::DebugLuauLogSolver) {
    printf(
        "Starting solver for module %s (%s)\n",
        moduleResolver->getHumanReadableModuleName(currentModuleName).c_str(),
        currentModuleName.c_str());
    dump(this, opts);
    printf("Bindings:\n");
    dumpBindings(rootScope, opts);
  }

  if (logger) {
    logger->captureInitialSolverState(rootScope, unsolvedConstraints);
  }

  auto runSolverPass = [&](bool force) {
    bool progress = false;

    size_t i = 0;
    while (i < unsolvedConstraints.size()) {
      NotNull<const Constraint> c = unsolvedConstraints[i];
      if (!force && isBlocked(c)) {
        ++i;
        continue;
      }

      if (limits.finishTime && TimeTrace::getClock() > *limits.finishTime)
        throwTimeLimitError();
      if (limits.cancellationToken && limits.cancellationToken->requested())
        throwUserCancelError();

      std::string saveMe =
          FFlag::DebugLuauLogSolver ? toString(*c, opts) : std::string{};
      StepSnapshot snapshot;

      if (logger) {
        snapshot = logger->prepareStepSnapshot(rootScope, c, force,
                                               unsolvedConstraints);
      }

      bool success = tryDispatch(c, force);

      progress |= success;

      if (success) {
        unblock(c);
        unsolvedConstraints.erase(unsolvedConstraints.begin() + i);

        // decrement the referenced free types for this constraint if we
        // dispatched successfully!
        for (auto ty : c->getMaybeMutatedFreeTypes()) {
          size_t &refCount = unresolvedConstraints[ty];
          if (refCount > 0)
            refCount -= 1;

          // We have two constraints that are designed to wait for the
          // refCount on a free type to be equal to 1: the
          // PrimitiveTypeConstraint and ReduceConstraint. We
          // therefore wake any constraint waiting for a free type's
          // refcount to be 1 or 0.
          if (refCount <= 1)
            unblock(ty, Location{});
        }

        if (logger) {
          logger->commitStepSnapshot(snapshot);
        }

        if (FFlag::DebugLuauLogSolver) {
          if (force)
            printf("Force ");
          printf("Dispatched\n\t%s\n", saveMe.c_str());

          if (force) {
            printf("Blocked on:\n");

            for (const auto &[bci, cv] : blocked) {
              if (end(cv) == std::find(begin(cv), end(cv), c))
                continue;

              if (auto bty = get_if<TypeId>(&bci))
                printf("\tType %s\n", toString(*bty, opts).c_str());
              else if (auto btp = get_if<TypePackId>(&bci))
                printf("\tPack %s\n", toString(*btp, opts).c_str());
              else if (auto cc = get_if<const Constraint *>(&bci))
                printf("\tCons %s\n", toString(**cc, opts).c_str());
              else
                LUAU_ASSERT(!"Unreachable??");
            }
          }

          dump(this, opts);
        }
      } else
        ++i;

      if (force && success)
        return true;
    }

    return progress;
  };

  bool progress = false;
  do {
    progress = runSolverPass(false);
    if (!progress)
      progress |= runSolverPass(true);
  } while (progress);

  if (!unsolvedConstraints.empty())
    reportError(InternalError{"Type inference failed to complete, you may see "
                              "some confusing types and type errors."},
                Location{});

  // After we have run all the constraints, type families should be generalized
  // At this point, we can try to perform one final simplification to suss out
  // whether type families are truly uninhabited or if they can reduce

  finalizeTypeFamilies();

  if (FFlag::DebugLuauLogSolver || FFlag::DebugLuauLogBindings)
    dumpBindings(rootScope, opts);

  if (logger) {
    logger->captureFinalSolverState(rootScope, unsolvedConstraints);
  }
}

void ConstraintSolver::finalizeTypeFamilies() {
  // At this point, we've generalized. Let's try to finish reducing as much as
  // we can, we'll leave warning to the typechecker
  for (auto [t, constraint] : typeFamiliesToFinalize) {
    TypeId ty = follow(t);
    if (get<TypeFunctionInstanceType>(ty)) {
      FunctionGraphReductionResult result = reduceTypeFunctions(
          t, constraint->location,
          TypeFunctionContext{NotNull{this}, constraint->scope,
                              NotNull{constraint}},
          true);

      for (TypeId r : result.reducedTypes)
        unblock(r, constraint->location);
      for (TypePackId r : result.reducedPacks)
        unblock(r, constraint->location);
    }
  }
}

bool ConstraintSolver::isDone() { return unsolvedConstraints.empty(); }

namespace {

struct TypeAndLocation {
  TypeId typeId;
  Location location;
};

} // namespace

void ConstraintSolver::bind(NotNull<const Constraint> constraint, TypeId ty,
                            TypeId boundTo) {
  LUAU_ASSERT(get<BlockedType>(ty) || get<FreeType>(ty) ||
              get<PendingExpansionType>(ty));
  LUAU_ASSERT(canMutate(ty, constraint));

  boundTo = follow(boundTo);
  if (get<BlockedType>(ty) && ty == boundTo)
    return emplace<FreeType>(constraint, ty, constraint->scope,
                             builtinTypes->neverType,
                             builtinTypes->unknownType);

  shiftReferences(ty, boundTo);
  emplaceType<BoundType>(asMutable(ty), boundTo);
  unblock(ty, constraint->location);
}

void ConstraintSolver::bind(NotNull<const Constraint> constraint, TypePackId tp,
                            TypePackId boundTo) {
  LUAU_ASSERT(get<BlockedTypePack>(tp) || get<FreeTypePack>(tp));
  LUAU_ASSERT(canMutate(tp, constraint));

  boundTo = follow(boundTo);
  LUAU_ASSERT(tp != boundTo);

  emplaceTypePack<BoundTypePack>(asMutable(tp), boundTo);
  unblock(tp, constraint->location);
}

template <typename T, typename... Args>
void ConstraintSolver::emplace(NotNull<const Constraint> constraint, TypeId ty,
                               Args &&...args) {
  static_assert(!std::is_same_v<T, BoundType>,
                "cannot use `emplace<BoundType>`! use `bind`");

  LUAU_ASSERT(get<BlockedType>(ty) || get<FreeType>(ty) ||
              get<PendingExpansionType>(ty));
  LUAU_ASSERT(canMutate(ty, constraint));

  emplaceType<T>(asMutable(ty), std::forward<Args>(args)...);
  unblock(ty, constraint->location);
}

template <typename T, typename... Args>
void ConstraintSolver::emplace(NotNull<const Constraint> constraint,
                               TypePackId tp, Args &&...args) {
  static_assert(!std::is_same_v<T, BoundTypePack>,
                "cannot use `emplace<BoundTypePack>`! use `bind`");

  LUAU_ASSERT(get<BlockedTypePack>(tp) || get<FreeTypePack>(tp));
  LUAU_ASSERT(canMutate(tp, constraint));

  emplaceTypePack<T>(asMutable(tp), std::forward<Args>(args)...);
  unblock(tp, constraint->location);
}

bool ConstraintSolver::tryDispatch(NotNull<const Constraint> constraint,
                                   bool force) {
  if (!force && isBlocked(constraint))
    return false;

  bool success = false;

  if (auto sc = get<SubtypeConstraint>(*constraint))
    success = tryDispatch(*sc, constraint, force);
  else if (auto psc = get<PackSubtypeConstraint>(*constraint))
    success = tryDispatch(*psc, constraint, force);
  else if (auto gc = get<GeneralizationConstraint>(*constraint))
    success = tryDispatch(*gc, constraint, force);
  else if (auto ic = get<IterableConstraint>(*constraint))
    success = tryDispatch(*ic, constraint, force);
  else if (auto nc = get<NameConstraint>(*constraint))
    success = tryDispatch(*nc, constraint);
  else if (auto taec = get<TypeAliasExpansionConstraint>(*constraint))
    success = tryDispatch(*taec, constraint);
  else if (auto fcc = get<FunctionCallConstraint>(*constraint))
    success = tryDispatch(*fcc, constraint);
  else if (auto fcc = get<FunctionCheckConstraint>(*constraint))
    success = tryDispatch(*fcc, constraint);
  else if (auto fcc = get<PrimitiveTypeConstraint>(*constraint))
    success = tryDispatch(*fcc, constraint);
  else if (auto hpc = get<HasPropConstraint>(*constraint))
    success = tryDispatch(*hpc, constraint);
  else if (auto spc = get<HasIndexerConstraint>(*constraint))
    success = tryDispatch(*spc, constraint);
  else if (auto uc = get<AssignPropConstraint>(*constraint))
    success = tryDispatch(*uc, constraint);
  else if (auto uc = get<AssignIndexConstraint>(*constraint))
    success = tryDispatch(*uc, constraint);
  else if (auto uc = get<UnpackConstraint>(*constraint))
    success = tryDispatch(*uc, constraint);
  else if (auto rc = get<ReduceConstraint>(*constraint))
    success = tryDispatch(*rc, constraint, force);
  else if (auto rpc = get<ReducePackConstraint>(*constraint))
    success = tryDispatch(*rpc, constraint, force);
  else if (auto eqc = get<EqualityConstraint>(*constraint))
    success = tryDispatch(*eqc, constraint, force);
  else
    LUAU_ASSERT(false);

  return success;
}

bool ConstraintSolver::tryDispatch(const SubtypeConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  if (isBlocked(c.subType))
    return block(c.subType, constraint);
  else if (isBlocked(c.superType))
    return block(c.superType, constraint);

  unify(constraint, c.subType, c.superType);

  return true;
}

bool ConstraintSolver::tryDispatch(const PackSubtypeConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  if (isBlocked(c.subPack))
    return block(c.subPack, constraint);
  else if (isBlocked(c.superPack))
    return block(c.superPack, constraint);

  unify(constraint, c.subPack, c.superPack);

  return true;
}

bool ConstraintSolver::tryDispatch(const GeneralizationConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  TypeId generalizedType = follow(c.generalizedType);

  if (isBlocked(c.sourceType))
    return block(c.sourceType, constraint);
  else if (get<PendingExpansionType>(generalizedType))
    return block(generalizedType, constraint);

  std::optional<QuantifierResult> generalized;

  std::optional<TypeId> generalizedTy =
      generalize(NotNull{arena}, builtinTypes, constraint->scope,
                 generalizedTypes, c.sourceType);
  if (generalizedTy)
    generalized = QuantifierResult{
        *generalizedTy}; // FIXME insertedGenerics and insertedGenericPacks
  else
    reportError(CodeTooComplex{}, constraint->location);

  if (generalized) {
    if (get<BlockedType>(generalizedType))
      bind(constraint, generalizedType, generalized->result);
    else
      unify(constraint, generalizedType, generalized->result);

    for (auto [free, gen] : generalized->insertedGenerics.pairings)
      unify(constraint, free, gen);

    for (auto [free, gen] : generalized->insertedGenericPacks.pairings)
      unify(constraint, free, gen);
  } else {
    reportError(CodeTooComplex{}, constraint->location);
    bind(constraint, c.generalizedType, builtinTypes->errorRecoveryType());
  }

  for (TypeId ty : c.interiorTypes)
    generalize(NotNull{arena}, builtinTypes, constraint->scope,
               generalizedTypes, ty, /* avoidSealingTables */ false);

  return true;
}

bool ConstraintSolver::tryDispatch(const IterableConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  /*
   * for .. in loops can play out in a bunch of different ways depending on
   * the shape of iteratee.
   *
   * iteratee might be:
   *  * (nextFn)
   *  * (nextFn, table)
   *  * (nextFn, table, firstIndex)
   *  * table with a metatable and __index
   *  * table with a metatable and __call but no __index (if the metatable has
   *    both, __index takes precedence)
   *  * table with an indexer but no __index or __call (or no metatable)
   *
   * To dispatch this constraint, we need first to know enough about iteratee
   * to figure out which of the above shapes we are actually working with.
   *
   * If `force` is true and we still do not know, we must flag a warning. Type
   * families are the fix for this.
   *
   * Since we need to know all of this stuff about the types of the iteratee,
   * we have no choice but for ConstraintSolver to also be the thing that
   * applies constraints to the types of the iterators.
   */

  auto block_ = [&](auto &&t) {
    if (force) {
      // If we haven't figured out the type of the iteratee by now,
      // there's nothing we can do.
      return true;
    }

    block(t, constraint);
    return false;
  };

  TypePack iterator = extendTypePack(*arena, builtinTypes, c.iterator, 3);
  if (iterator.head.size() < 3 && iterator.tail && isBlocked(*iterator.tail))
    return block_(*iterator.tail);

  {
    bool blocked = false;
    for (TypeId t : iterator.head) {
      if (isBlocked(t)) {
        block(t, constraint);
        blocked = true;
      }
    }

    if (blocked)
      return false;
  }

  if (0 == iterator.head.size()) {
    for (TypeId ty : c.variables)
      unify(constraint, builtinTypes->errorRecoveryType(), ty);

    return true;
  }

  TypeId nextTy = follow(iterator.head[0]);
  if (get<FreeType>(nextTy)) {
    TypeId keyTy = freshType(arena, builtinTypes, constraint->scope);
    TypeId valueTy = freshType(arena, builtinTypes, constraint->scope);
    TypeId tableTy = arena->addType(
        TableType{TableType::Props{}, TableIndexer{keyTy, valueTy}, TypeLevel{},
                  constraint->scope, TableState::Free});

    unify(constraint, nextTy, tableTy);

    auto it = begin(c.variables);
    auto endIt = end(c.variables);

    if (it != endIt) {
      bind(constraint, *it, keyTy);
      ++it;
    }
    if (it != endIt) {
      bind(constraint, *it, valueTy);
      ++it;
    }

    while (it != endIt) {
      bind(constraint, *it, builtinTypes->nilType);
      ++it;
    }

    return true;
  }

  if (get<FunctionType>(nextTy)) {
    TypeId tableTy = builtinTypes->nilType;
    if (iterator.head.size() >= 2)
      tableTy = iterator.head[1];

    return tryDispatchIterableFunction(nextTy, tableTy, c, constraint, force);
  }

  else
    return tryDispatchIterableTable(iterator.head[0], c, constraint, force);

  return true;
}

bool ConstraintSolver::tryDispatch(const NameConstraint &c,
                                   NotNull<const Constraint> constraint) {
  if (isBlocked(c.namedType))
    return block(c.namedType, constraint);

  TypeId target = follow(c.namedType);

  if (target->persistent || target->owningArena != arena)
    return true;

  if (TableType *ttv = getMutable<TableType>(target)) {
    if (c.synthetic && !ttv->name)
      ttv->syntheticName = c.name;
    else {
      ttv->name = c.name;
      ttv->instantiatedTypeParams = c.typeParameters;
      ttv->instantiatedTypePackParams = c.typePackParameters;
    }
  } else if (MetatableType *mtv = getMutable<MetatableType>(target))
    mtv->syntheticName = c.name;
  else if (get<IntersectionType>(target) || get<UnionType>(target)) {
    // nothing (yet)
  }

  return true;
}

struct InfiniteTypeFinder : TypeOnceVisitor {
  ConstraintSolver *solver;
  const InstantiationSignature &signature;
  NotNull<Scope> scope;
  bool foundInfiniteType = false;

  explicit InfiniteTypeFinder(ConstraintSolver *solver,
                              const InstantiationSignature &signature,
                              NotNull<Scope> scope)
      : solver(solver), signature(signature), scope(scope) {}

  bool visit(TypeId ty, const PendingExpansionType &petv) override {
    std::optional<TypeFun> tf =
        (petv.prefix)
            ? scope->lookupImportedType(petv.prefix->value, petv.name.value)
            : scope->lookupType(petv.name.value);

    if (!tf.has_value())
      return true;

    auto [typeArguments, packArguments] =
        saturateArguments(solver->arena, solver->builtinTypes, *tf,
                          petv.typeArguments, petv.packArguments);

    if (follow(tf->type) == follow(signature.fn.type) &&
        (signature.arguments != typeArguments ||
         signature.packArguments != packArguments)) {
      foundInfiniteType = true;
      return false;
    }

    return true;
  }
};

bool ConstraintSolver::tryDispatch(const TypeAliasExpansionConstraint &c,
                                   NotNull<const Constraint> constraint) {
  const PendingExpansionType *petv =
      get<PendingExpansionType>(follow(c.target));
  if (!petv) {
    unblock(c.target,
            constraint->location); // TODO: do we need this? any re-entrancy?
    return true;
  }

  auto bindResult = [this, &c, constraint](TypeId result) {
    LUAU_ASSERT(get<PendingExpansionType>(c.target));
    shiftReferences(c.target, result);
    bind(constraint, c.target, result);
  };

  std::optional<TypeFun> tf =
      (petv->prefix) ? constraint->scope->lookupImportedType(
                           petv->prefix->value, petv->name.value)
                     : constraint->scope->lookupType(petv->name.value);

  if (!tf.has_value()) {
    reportError(UnknownSymbol{petv->name.value, UnknownSymbol::Context::Type},
                constraint->location);
    bindResult(errorRecoveryType());
    return true;
  }

  // If there are no parameters to the type function we can just use the type
  // directly.
  if (tf->typeParams.empty() && tf->typePackParams.empty()) {
    bindResult(tf->type);
    return true;
  }

  // Due to how pending expansion types and TypeFun's are created
  // If this check passes, we have created a cyclic / corecursive type alias
  // of size 0
  TypeId lhs = c.target;
  TypeId rhs = tf->type;
  if (occursCheck(lhs, rhs)) {
    reportError(OccursCheckFailed{}, constraint->location);
    bindResult(errorRecoveryType());
    return true;
  }

  auto [typeArguments, packArguments] = saturateArguments(
      arena, builtinTypes, *tf, petv->typeArguments, petv->packArguments);

  bool sameTypes = std::equal(typeArguments.begin(), typeArguments.end(),
                              tf->typeParams.begin(), tf->typeParams.end(),
                              [](auto &&itp, auto &&p) { return itp == p.ty; });

  bool samePacks =
      std::equal(packArguments.begin(), packArguments.end(),
                 tf->typePackParams.begin(), tf->typePackParams.end(),
                 [](auto &&itp, auto &&p) { return itp == p.tp; });

  // If we're instantiating the type with its generic saturatedTypeArguments we
  // are performing the identity substitution. We can just short-circuit and
  // bind to the TypeFun's type.
  if (sameTypes && samePacks) {
    bindResult(tf->type);
    return true;
  }

  InstantiationSignature signature{
      *tf,
      typeArguments,
      packArguments,
  };

  // If we use the same signature, we don't need to bother trying to
  // instantiate the alias again, since the instantiation should be
  // deterministic.
  if (TypeId *cached = instantiatedAliases.find(signature)) {
    bindResult(*cached);
    return true;
  }

  // In order to prevent infinite types from being expanded and causing us to
  // cycle infinitely, we need to scan the type function for cases where we
  // expand the same alias with different type saturatedTypeArguments. See
  // https://github.com/luau-lang/luau/pull/68 for the RFC responsible for
  // this. This is a little nicer than using a recursion limit because we can
  // catch the infinite expansion before actually trying to expand it.
  InfiniteTypeFinder itf{this, signature, constraint->scope};
  itf.traverse(tf->type);

  if (itf.foundInfiniteType) {
    // TODO (CLI-56761): Report an error.
    bindResult(errorRecoveryType());
    reportError(
        GenericError{"Recursive type being used with different parameters"},
        constraint->location);
    return true;
  }

  ApplyTypeFunction applyTypeFunction{arena};
  for (size_t i = 0; i < typeArguments.size(); ++i) {
    applyTypeFunction.typeArguments[tf->typeParams[i].ty] = typeArguments[i];
  }

  for (size_t i = 0; i < packArguments.size(); ++i) {
    applyTypeFunction.typePackArguments[tf->typePackParams[i].tp] =
        packArguments[i];
  }

  std::optional<TypeId> maybeInstantiated =
      applyTypeFunction.substitute(tf->type);
  // Note that ApplyTypeFunction::encounteredForwardedType is never set in
  // DCR, because we do not use free types for forward-declared generic
  // aliases.

  if (!maybeInstantiated.has_value()) {
    // TODO (CLI-56761): Report an error.
    bindResult(errorRecoveryType());
    return true;
  }

  TypeId instantiated = *maybeInstantiated;
  TypeId target = follow(instantiated);

  // The application is not recursive, so we need to queue up application of
  // any child type function instantiations within the result in order for it
  // to be complete.
  InstantiationQueuer queuer{constraint->scope, constraint->location, this};
  queuer.traverse(target);

  if (target->persistent || target->owningArena != arena) {
    bindResult(target);
    return true;
  }

  // Type function application will happily give us the exact same type if
  // there are e.g. generic saturatedTypeArguments that go unused.
  const TableType *tfTable = getTableType(tf->type);

  //clang-format off
  bool needsClone =
      follow(tf->type) == target ||
      (tfTable != nullptr && tfTable == getTableType(target)) ||
      std::any_of(typeArguments.begin(), typeArguments.end(),
                  [&](const auto &other) { return other == target; });
  //clang-format on

  // Only tables have the properties we're trying to set.
  TableType *ttv = getMutableTableType(target);

  if (ttv) {
    if (needsClone) {
      // Substitution::clone is a shallow clone. If this is a
      // metatable type, we want to mutate its table, so we need to
      // explicitly clone that table as well. If we don't, we will
      // mutate another module's type surface and cause a
      // use-after-free.
      if (get<MetatableType>(target)) {
        instantiated = applyTypeFunction.clone(target);
        MetatableType *mtv = getMutable<MetatableType>(instantiated);
        mtv->table = applyTypeFunction.clone(mtv->table);
        ttv = getMutable<TableType>(mtv->table);
      } else if (get<TableType>(target)) {
        instantiated = applyTypeFunction.clone(target);
        ttv = getMutable<TableType>(instantiated);
      }

      target = follow(instantiated);
    }

    ttv->instantiatedTypeParams = typeArguments;
    ttv->instantiatedTypePackParams = packArguments;
    // TODO: Fill in definitionModuleName.
  }

  bindResult(target);

  instantiatedAliases[signature] = target;

  return true;
}

bool ConstraintSolver::tryDispatch(const FunctionCallConstraint &c,
                                   NotNull<const Constraint> constraint) {
  TypeId fn = follow(c.fn);
  TypePackId argsPack = follow(c.argsPack);
  TypePackId result = follow(c.result);

  if (isBlocked(fn) || hasUnresolvedConstraints(fn)) {
    return block(c.fn, constraint);
  }

  if (get<AnyType>(fn)) {
    emplaceTypePack<BoundTypePack>(asMutable(c.result),
                                   builtinTypes->anyTypePack);
    unblock(c.result, constraint->location);
    return true;
  }

  // if we're calling an error type, the result is an error type, and that's
  // that.
  if (get<ErrorType>(fn)) {
    bind(constraint, c.result, builtinTypes->errorRecoveryTypePack());
    return true;
  }

  if (get<NeverType>(fn)) {
    bind(constraint, c.result, builtinTypes->neverTypePack);
    return true;
  }

  auto [argsHead, argsTail] = flatten(argsPack);

  bool blocked = false;
  for (TypeId t : argsHead) {
    if (isBlocked(t)) {
      block(t, constraint);
      blocked = true;
    }
  }

  if (argsTail && isBlocked(*argsTail)) {
    block(*argsTail, constraint);
    blocked = true;
  }

  if (blocked)
    return false;

  auto collapse = [](const auto *t) -> std::optional<TypeId> {
    auto it = begin(t);
    auto endIt = end(t);

    LUAU_ASSERT(it != endIt);
    TypeId fst = follow(*it);
    while (it != endIt) {
      if (follow(*it) != fst)
        return std::nullopt;
      ++it;
    }

    return fst;
  };

  // Sometimes the `fn` type is a union/intersection, but whose constituents are
  // all the same pointer.
  if (auto ut = get<UnionType>(fn))
    fn = collapse(ut).value_or(fn);
  else if (auto it = get<IntersectionType>(fn))
    fn = collapse(it).value_or(fn);

  // We don't support magic __call metamethods.
  if (std::optional<TypeId> callMm = findMetatableEntry(
          builtinTypes, errors, fn, "__call", constraint->location)) {
    argsHead.insert(argsHead.begin(), fn);

    if (argsTail && isBlocked(*argsTail))
      return block(*argsTail, constraint);

    argsPack = arena->addTypePack(TypePack{std::move(argsHead), argsTail});
    fn = follow(*callMm);
    emplace<FreeTypePack>(constraint, c.result, constraint->scope);
  } else {
    const FunctionType *ftv = get<FunctionType>(fn);
    bool usedMagic = false;

    if (ftv) {
      if (ftv->dcrMagicFunction)
        usedMagic = ftv->dcrMagicFunction(MagicFunctionCallContext{
            NotNull{this}, constraint, c.callSite, c.argsPack, result});

      if (ftv->dcrMagicRefinement)
        ftv->dcrMagicRefinement(MagicRefinementContext{
            constraint->scope, c.callSite, c.discriminantTypes});
    }

    if (!usedMagic)
      emplace<FreeTypePack>(constraint, c.result, constraint->scope);
  }

  for (std::optional<TypeId> ty : c.discriminantTypes) {
    if (!ty)
      continue;

    // If the discriminant type has been transmuted, we need to unblock them.
    if (!isBlocked(*ty)) {
      unblock(*ty, constraint->location);
      continue;
    }

    // We use `any` here because the discriminant type may be pointed at by both
    // branches, where the discriminant type is not negated, and the other where
    // it is negated, i.e. `unknown ~ unknown` and `~unknown ~ never`, so `T &
    // unknown ~ T` and `T & ~unknown ~ never` v.s. `any ~ any` and `~any ~
    // any`, so `T & any ~ T` and `T & ~any ~ T`
    //
    // In practice, users cannot negate `any`, so this is an implementation
    // detail we can always change.
    emplaceType<BoundType>(asMutable(follow(*ty)), builtinTypes->anyType);
  }

  OverloadResolver resolver{
      builtinTypes,        NotNull{arena},        normalizer,
      constraint->scope,   NotNull{&iceReporter}, NotNull{&limits},
      constraint->location};
  auto [status, overload] = resolver.selectOverload(fn, argsPack);
  TypeId overloadToUse = fn;
  if (status == OverloadResolver::Analysis::Ok)
    overloadToUse = overload;

  TypeId inferredTy = arena->addType(
      FunctionType{TypeLevel{}, constraint->scope.get(), argsPack, c.result});
  Unifier2 u2{NotNull{arena}, builtinTypes, constraint->scope,
              NotNull{&iceReporter}};

  const bool occursCheckPassed = u2.unify(overloadToUse, inferredTy);

  if (!u2.genericSubstitutions.empty() ||
      !u2.genericPackSubstitutions.empty()) {
    std::optional<TypePackId> subst =
        instantiate2(arena, std::move(u2.genericSubstitutions),
                     std::move(u2.genericPackSubstitutions), result);
    if (!subst) {
      reportError(CodeTooComplex{}, constraint->location);
      result = builtinTypes->errorTypePack;
    } else
      result = *subst;

    if (c.result != result)
      emplaceTypePack<BoundTypePack>(asMutable(c.result), result);
  }

  for (const auto &[expanded, additions] : u2.expandedFreeTypes) {
    for (TypeId addition : additions)
      upperBoundContributors[expanded].push_back(
          std::make_pair(constraint->location, addition));
  }

  if (occursCheckPassed && c.callSite)
    (*c.astOverloadResolvedTypes)[c.callSite] = inferredTy;

  InstantiationQueuer queuer{constraint->scope, constraint->location, this};
  queuer.traverse(overloadToUse);
  queuer.traverse(inferredTy);

  unblock(c.result, constraint->location);

  return true;
}

bool ConstraintSolver::tryDispatch(const FunctionCheckConstraint &c,
                                   NotNull<const Constraint> constraint) {
  TypeId fn = follow(c.fn);
  const TypePackId argsPack = follow(c.argsPack);

  if (isBlocked(fn))
    return block(fn, constraint);

  if (isBlocked(argsPack))
    return true;

  // We know the type of the function and the arguments it expects to receive.
  // We also know the TypeIds of the actual arguments that will be passed.
  //
  // Bidirectional type checking: Force those TypeIds to be the expected
  // arguments. If something is incoherent, we'll spot it in type checking.
  //
  // Most important detail: If a function argument is a lambda, we also want
  // to force unannotated argument types of that lambda to be the expected
  // types.

  // FIXME: Bidirectional type checking of overloaded functions is not yet
  // supported.
  const FunctionType *ftv = get<FunctionType>(fn);
  if (!ftv)
    return true;

  DenseHashMap<TypeId, TypeId> replacements{nullptr};
  DenseHashMap<TypePackId, TypePackId> replacementPacks{nullptr};

  for (auto generic : ftv->generics)
    replacements[generic] = builtinTypes->unknownType;

  for (auto genericPack : ftv->genericPacks)
    replacementPacks[genericPack] = builtinTypes->unknownTypePack;

  // If the type of the function has generics, we don't actually want to push
  // any of the generics themselves into the argument types as expected types
  // because this creates an unnecessary loop. Instead, we want to replace these
  // types with `unknown` (and `...unknown`) to keep any structure but not
  // create the cycle.
  if (!replacements.empty() || !replacementPacks.empty()) {
    Replacer replacer{arena, std::move(replacements),
                      std::move(replacementPacks)};

    std::optional<TypeId> res = replacer.substitute(fn);
    if (res) {
      if (*res != fn) {
        FunctionType *ftvMut = getMutable<FunctionType>(*res);
        LUAU_ASSERT(ftvMut);
        ftvMut->generics.clear();
        ftvMut->genericPacks.clear();
      }

      fn = *res;
      ftv = get<FunctionType>(*res);
      LUAU_ASSERT(ftv);

      // we've potentially copied type families here, so we need to reproduce
      // their reduce constraint.
      reproduceConstraints(constraint->scope, constraint->location, replacer);
    }
  }

  const std::vector<TypeId> expectedArgs = flatten(ftv->argTypes).first;
  const std::vector<TypeId> argPackHead = flatten(argsPack).first;

  // If this is a self call, the types will have more elements than the AST
  // call. We don't attempt to perform bidirectional inference on the self type.
  const size_t typeOffset = c.callSite->self ? 1 : 0;

  for (size_t i = 0;
       i < c.callSite->args.size && i + typeOffset < expectedArgs.size() &&
       i + typeOffset < argPackHead.size();
       ++i) {
    const TypeId expectedArgTy = follow(expectedArgs[i + typeOffset]);
    const TypeId actualArgTy = follow(argPackHead[i + typeOffset]);
    const AstExpr *expr = c.callSite->args.data[i];

    (*c.astExpectedTypes)[expr] = expectedArgTy;

    const FunctionType *expectedLambdaTy = get<FunctionType>(expectedArgTy);
    const FunctionType *lambdaTy = get<FunctionType>(actualArgTy);
    const AstExprFunction *lambdaExpr = expr->as<AstExprFunction>();

    if (expectedLambdaTy && lambdaTy && lambdaExpr) {
      const std::vector<TypeId> expectedLambdaArgTys =
          flatten(expectedLambdaTy->argTypes).first;
      const std::vector<TypeId> lambdaArgTys =
          flatten(lambdaTy->argTypes).first;

      for (size_t j = 0; j < expectedLambdaArgTys.size() &&
                         j < lambdaArgTys.size() && j < lambdaExpr->args.size;
           ++j) {
        if (!lambdaExpr->args.data[j]->annotation &&
            get<FreeType>(follow(lambdaArgTys[j]))) {
          shiftReferences(lambdaArgTys[j], expectedLambdaArgTys[j]);
          bind(constraint, lambdaArgTys[j], expectedLambdaArgTys[j]);
        }
      }
    } else if (expr->is<AstExprConstantBool>() ||
               expr->is<AstExprConstantString>() ||
               expr->is<AstExprConstantNumber>() ||
               expr->is<AstExprConstantNil>()) {
      Unifier2 u2{arena, builtinTypes, constraint->scope,
                  NotNull{&iceReporter}};
      u2.unify(actualArgTy, expectedArgTy);
    } else if (expr->is<AstExprTable>()) {
      Unifier2 u2{arena, builtinTypes, constraint->scope,
                  NotNull{&iceReporter}};
      std::vector<TypeId> toBlock;
      (void)matchLiteralType(c.astTypes, c.astExpectedTypes, builtinTypes,
                             arena, NotNull{&u2}, expectedArgTy, actualArgTy,
                             expr, toBlock);
      for (auto t : toBlock)
        block(t, constraint);
      if (!toBlock.empty())
        return false;
    }
  }

  return true;
}

bool ConstraintSolver::tryDispatch(const PrimitiveTypeConstraint &c,
                                   NotNull<const Constraint> constraint) {
  std::optional<TypeId> expectedType =
      c.expectedType ? std::make_optional<TypeId>(follow(*c.expectedType))
                     : std::nullopt;
  if (expectedType &&
      (isBlocked(*expectedType) || get<PendingExpansionType>(*expectedType)))
    return block(*expectedType, constraint);

  const FreeType *freeType = get<FreeType>(follow(c.freeType));

  // if this is no longer a free type, then we're done.
  if (!freeType)
    return true;

  // We will wait if there are any other references to the free type mentioned
  // here. This is probably the only thing that makes this not insane to do.
  if (auto refCount = unresolvedConstraints.find(c.freeType);
      refCount && *refCount > 1) {
    block(c.freeType, constraint);
    return false;
  }

  TypeId bindTo = c.primitiveType;

  if (freeType->upperBound != c.primitiveType &&
      maybeSingleton(freeType->upperBound))
    bindTo = freeType->lowerBound;
  else if (expectedType && maybeSingleton(*expectedType))
    bindTo = freeType->lowerBound;

  shiftReferences(c.freeType, bindTo);
  bind(constraint, c.freeType, bindTo);

  return true;
}

bool ConstraintSolver::tryDispatch(const HasPropConstraint &c,
                                   NotNull<const Constraint> constraint) {
  const TypeId subjectType = follow(c.subjectType);
  const TypeId resultType = follow(c.resultType);

  LUAU_ASSERT(get<BlockedType>(resultType));
  LUAU_ASSERT(canMutate(resultType, constraint));

  if (isBlocked(subjectType) || get<PendingExpansionType>(subjectType) ||
      get<TypeFunctionInstanceType>(subjectType))
    return block(subjectType, constraint);

  if (const TableType *subjectTable = getTableType(subjectType)) {
    if (subjectTable->state == TableState::Unsealed &&
        subjectTable->remainingProps > 0 &&
        subjectTable->props.count(c.prop) == 0) {
      return block(subjectType, constraint);
    }
  }

  auto [blocked, result] =
      lookupTableProp(constraint, subjectType, c.prop, c.context,
                      c.inConditional, c.suppressSimplification);
  if (!blocked.empty()) {
    for (TypeId blocked : blocked)
      block(blocked, constraint);

    return false;
  }

  bind(constraint, resultType, result.value_or(builtinTypes->anyType));
  return true;
}

bool ConstraintSolver::tryDispatchHasIndexer(
    int &recursionDepth, NotNull<const Constraint> constraint,
    TypeId subjectType, TypeId indexType, TypeId resultType,
    Set<TypeId> &seen) {
  RecursionLimiter _rl{&recursionDepth, FInt::LuauSolverRecursionLimit};

  subjectType = follow(subjectType);
  indexType = follow(indexType);

  if (seen.contains(subjectType))
    return false;
  seen.insert(subjectType);

  LUAU_ASSERT(get<BlockedType>(resultType));
  LUAU_ASSERT(canMutate(resultType, constraint));

  if (get<AnyType>(subjectType)) {
    bind(constraint, resultType, builtinTypes->anyType);
    return true;
  }

  if (auto ft = get<FreeType>(subjectType)) {
    if (auto tbl = get<TableType>(follow(ft->upperBound));
        tbl && tbl->indexer) {
      unify(constraint, indexType, tbl->indexer->indexType);
      bind(constraint, resultType, tbl->indexer->indexResultType);
      return true;
    } else if (auto mt = get<MetatableType>(follow(ft->upperBound)))
      return tryDispatchHasIndexer(recursionDepth, constraint, mt->table,
                                   indexType, resultType, seen);

    FreeType freeResult{ft->scope, builtinTypes->neverType,
                        builtinTypes->unknownType};
    emplace<FreeType>(constraint, resultType, freeResult);

    TypeId upperBound = arena->addType(
        TableType{/* props */ {}, TableIndexer{indexType, resultType},
                  TypeLevel{}, TableState::Unsealed});

    unify(constraint, subjectType, upperBound);

    return true;
  } else if (auto tt = getMutable<TableType>(subjectType)) {
    if (auto indexer = tt->indexer) {
      unify(constraint, indexType, indexer->indexType);
      bind(constraint, resultType, indexer->indexResultType);
      return true;
    }

    if (tt->state == TableState::Unsealed) {
      // FIXME this is greedy.

      FreeType freeResult{tt->scope, builtinTypes->neverType,
                          builtinTypes->unknownType};
      emplace<FreeType>(constraint, resultType, freeResult);

      tt->indexer = TableIndexer{indexType, resultType};
      return true;
    }
  } else if (auto mt = get<MetatableType>(subjectType))
    return tryDispatchHasIndexer(recursionDepth, constraint, mt->table,
                                 indexType, resultType, seen);
  else if (auto ct = get<ClassType>(subjectType)) {
    if (auto indexer = ct->indexer) {
      unify(constraint, indexType, indexer->indexType);
      bind(constraint, resultType, indexer->indexResultType);
      return true;
    } else if (isString(indexType)) {
      bind(constraint, resultType, builtinTypes->unknownType);
      return true;
    }
  } else if (auto it = get<IntersectionType>(subjectType)) {
    // subjectType <: {[indexType]: resultType}
    //
    // 'a & ~(false | nil) <: {[indexType]: resultType}
    //
    // 'a <: {[indexType]: resultType}
    // ~(false | nil) <: {[indexType]: resultType}

    Set<TypeId> parts{nullptr};
    for (TypeId part : it)
      parts.insert(follow(part));

    Set<TypeId> results{nullptr};

    for (TypeId part : parts) {
      TypeId r = arena->addType(BlockedType{});
      getMutable<BlockedType>(r)->setOwner(
          const_cast<Constraint *>(constraint.get()));

      bool ok = tryDispatchHasIndexer(recursionDepth, constraint, part,
                                      indexType, r, seen);
      // If we've cut a recursive loop short, skip it.
      if (!ok)
        continue;

      r = follow(r);
      if (!get<ErrorType>(r))
        results.insert(r);
    }

    if (0 == results.size())
      bind(constraint, resultType, builtinTypes->errorType);
    else if (1 == results.size())
      bind(constraint, resultType, *results.begin());
    else
      emplace<IntersectionType>(constraint, resultType,
                                std::vector(results.begin(), results.end()));

    return true;
  } else if (auto ut = get<UnionType>(subjectType)) {
    Set<TypeId> parts{nullptr};
    for (TypeId part : ut)
      parts.insert(follow(part));

    Set<TypeId> results{nullptr};

    for (TypeId part : parts) {
      TypeId r = arena->addType(BlockedType{});
      getMutable<BlockedType>(r)->setOwner(
          const_cast<Constraint *>(constraint.get()));

      bool ok = tryDispatchHasIndexer(recursionDepth, constraint, part,
                                      indexType, r, seen);
      // If we've cut a recursive loop short, skip it.
      if (!ok)
        continue;

      r = follow(r);
      if (!get<ErrorType>(r))
        results.insert(r);
    }

    if (0 == results.size())
      bind(constraint, resultType, builtinTypes->errorType);
    else if (1 == results.size()) {
      TypeId firstResult = *results.begin();
      shiftReferences(resultType, firstResult);
      bind(constraint, resultType, firstResult);
    } else
      emplace<UnionType>(constraint, resultType,
                         std::vector(results.begin(), results.end()));

    return true;
  }

  bind(constraint, resultType, builtinTypes->errorType);

  return true;
}

namespace {

struct BlockedTypeFinder : TypeOnceVisitor {
  std::optional<TypeId> blocked;

  bool visit(TypeId ty) override {
    // If we've already found one, stop traversing.
    return !blocked.has_value();
  }

  bool visit(TypeId ty, const BlockedType &) override {
    blocked = ty;
    return false;
  }
};

} // namespace

bool ConstraintSolver::tryDispatch(const HasIndexerConstraint &c,
                                   NotNull<const Constraint> constraint) {
  const TypeId subjectType = follow(c.subjectType);
  const TypeId indexType = follow(c.indexType);

  if (isBlocked(subjectType))
    return block(subjectType, constraint);

  if (isBlocked(indexType))
    return block(indexType, constraint);

  BlockedTypeFinder btf;

  btf.visit(subjectType);

  if (btf.blocked)
    return block(*btf.blocked, constraint);
  int recursionDepth = 0;

  Set<TypeId> seen{nullptr};

  return tryDispatchHasIndexer(recursionDepth, constraint, subjectType,
                               indexType, c.resultType, seen);
}

bool ConstraintSolver::tryDispatch(const AssignPropConstraint &c,
                                   NotNull<const Constraint> constraint) {
  TypeId lhsType = follow(c.lhsType);
  const std::string &propName = c.propName;
  const TypeId rhsType = follow(c.rhsType);

  if (isBlocked(lhsType))
    return block(lhsType, constraint);

  // 1. lhsType is a class that already has the prop
  // 2. lhsType is a table that already has the prop (or a union or
  //    intersection that has the prop in aggregate)
  // 3. lhsType has a metatable that already has the prop
  // 4. lhsType is an unsealed table that does not have the prop, but has a
  //    string indexer
  // 5. lhsType is an unsealed table that does not have the prop or a string
  //    indexer

  // Important: In every codepath through this function, the type `c.propType`
  // must be bound to something, even if it's just the errorType.

  if (auto lhsClass = get<ClassType>(lhsType)) {
    const Property *prop = lookupClassProp(lhsClass, propName);
    if (!prop || !prop->writeTy.has_value())
      return true;

    bind(constraint, c.propType, *prop->writeTy);
    unify(constraint, rhsType, *prop->writeTy);
    return true;
  }

  if (auto lhsFree = getMutable<FreeType>(lhsType)) {
    if (get<TableType>(lhsFree->upperBound) ||
        get<MetatableType>(lhsFree->upperBound))
      lhsType = lhsFree->upperBound;
    else {
      TypeId newUpperBound = arena->addType(
          TableType{TableState::Free, TypeLevel{}, constraint->scope});
      TableType *upperTable = getMutable<TableType>(newUpperBound);
      LUAU_ASSERT(upperTable);

      upperTable->props[c.propName] = rhsType;

      // Food for thought: Could we block if simplification encounters a blocked
      // type?
      lhsFree->upperBound =
          simplifyIntersection(builtinTypes, arena, lhsFree->upperBound,
                               newUpperBound)
              .result;

      bind(constraint, c.propType, rhsType);
      return true;
    }
  }

  // Handle the case that lhsType is a table that already has the property or
  // a matching indexer. This also handles unions and intersections.
  const auto [blocked, maybeTy] =
      lookupTableProp(constraint, lhsType, propName, ValueContext::LValue);
  if (!blocked.empty()) {
    for (TypeId t : blocked)
      block(t, constraint);
    return false;
  }

  if (maybeTy) {
    const TypeId propTy = *maybeTy;
    bind(constraint, c.propType, propTy);
    unify(constraint, rhsType, propTy);
    return true;
  }

  if (auto lhsMeta = get<MetatableType>(lhsType))
    lhsType = follow(lhsMeta->table);

  // Handle the case where the lhs type is a table that does not have the
  // named property. It could be a table with a string indexer, or an unsealed
  // or free table that can grow.
  if (auto lhsTable = getMutable<TableType>(lhsType)) {
    if (auto it = lhsTable->props.find(propName); it != lhsTable->props.end()) {
      Property &prop = it->second;

      if (prop.writeTy.has_value()) {
        bind(constraint, c.propType, *prop.writeTy);
        unify(constraint, rhsType, *prop.writeTy);
        return true;
      } else {
        LUAU_ASSERT(prop.isReadOnly());
        if (lhsTable->state == TableState::Unsealed ||
            lhsTable->state == TableState::Free) {
          prop.writeTy = prop.readTy;
          bind(constraint, c.propType, *prop.writeTy);
          unify(constraint, rhsType, *prop.writeTy);
          return true;
        } else {
          bind(constraint, c.propType, builtinTypes->errorType);
          return true;
        }
      }
    }

    if (lhsTable->indexer && maybeString(lhsTable->indexer->indexType)) {
      bind(constraint, c.propType, rhsType);
      unify(constraint, rhsType, lhsTable->indexer->indexResultType);
      return true;
    }

    if (lhsTable->state == TableState::Unsealed ||
        lhsTable->state == TableState::Free) {
      bind(constraint, c.propType, rhsType);
      Property &newProp = lhsTable->props[propName];
      newProp.readTy = rhsType;
      newProp.writeTy = rhsType;
      newProp.location = c.propLocation;

      if (lhsTable->state == TableState::Unsealed && c.decrementPropCount) {
        LUAU_ASSERT(lhsTable->remainingProps > 0);
        lhsTable->remainingProps -= 1;
      }

      return true;
    }
  }

  bind(constraint, c.propType, builtinTypes->errorType);

  return true;
}

bool ConstraintSolver::tryDispatch(const AssignIndexConstraint &c,
                                   NotNull<const Constraint> constraint) {
  const TypeId lhsType = follow(c.lhsType);
  const TypeId indexType = follow(c.indexType);
  const TypeId rhsType = follow(c.rhsType);

  if (isBlocked(lhsType))
    return block(lhsType, constraint);

  // 0. lhsType could be an intersection or union.
  // 1. lhsType is a class with an indexer
  // 2. lhsType is a table with an indexer, or it has a metatable that has an
  // indexer
  // 3. lhsType is a free or unsealed table and can grow an indexer

  // Important: In every codepath through this function, the type `c.propType`
  // must be bound to something, even if it's just the errorType.

  auto tableStuff = [&](TableType *lhsTable) -> std::optional<bool> {
    if (lhsTable->indexer) {
      unify(constraint, indexType, lhsTable->indexer->indexType);
      unify(constraint, rhsType, lhsTable->indexer->indexResultType);
      bind(constraint, c.propType, lhsTable->indexer->indexResultType);
      return true;
    }

    if (lhsTable->state == TableState::Unsealed ||
        lhsTable->state == TableState::Free) {
      lhsTable->indexer = TableIndexer{indexType, rhsType};
      bind(constraint, c.propType, rhsType);
      return true;
    }

    return {};
  };

  if (auto lhsFree = getMutable<FreeType>(lhsType)) {
    if (auto lhsTable = getMutable<TableType>(lhsFree->upperBound)) {
      if (auto res = tableStuff(lhsTable))
        return *res;
    }

    TypeId newUpperBound = arena->addType(
        TableType{/*props*/ {}, TableIndexer{indexType, rhsType}, TypeLevel{},
                  constraint->scope, TableState::Free});
    const TableType *newTable = get<TableType>(newUpperBound);
    LUAU_ASSERT(newTable);

    unify(constraint, lhsType, newUpperBound);

    LUAU_ASSERT(newTable->indexer);
    bind(constraint, c.propType, newTable->indexer->indexResultType);
    return true;
  }

  if (auto lhsTable = getMutable<TableType>(lhsType)) {
    std::optional<bool> res = tableStuff(lhsTable);
    if (res.has_value())
      return *res;
  }

  if (auto lhsClass = get<ClassType>(lhsType)) {
    while (true) {
      if (lhsClass->indexer) {
        unify(constraint, indexType, lhsClass->indexer->indexType);
        unify(constraint, rhsType, lhsClass->indexer->indexResultType);
        bind(constraint, c.propType, lhsClass->indexer->indexResultType);
        return true;
      }

      if (lhsClass->parent)
        lhsClass = get<ClassType>(lhsClass->parent);
      else
        break;
    }
    return true;
  }

  if (auto lhsIntersection = getMutable<IntersectionType>(lhsType)) {
    std::set<TypeId> parts;

    for (TypeId t : lhsIntersection) {
      if (auto tbl = getMutable<TableType>(follow(t))) {
        if (tbl->indexer) {
          unify(constraint, indexType, tbl->indexer->indexType);
          parts.insert(tbl->indexer->indexResultType);
        }

        if (tbl->state == TableState::Unsealed ||
            tbl->state == TableState::Free) {
          tbl->indexer = TableIndexer{indexType, rhsType};
          parts.insert(rhsType);
        }
      } else if (auto cls = get<ClassType>(follow(t))) {
        while (true) {
          if (cls->indexer) {
            unify(constraint, indexType, cls->indexer->indexType);
            parts.insert(cls->indexer->indexResultType);
            break;
          }

          if (cls->parent)
            cls = get<ClassType>(cls->parent);
          else
            break;
        }
      }
    }

    TypeId res =
        simplifyIntersection(builtinTypes, arena, std::move(parts)).result;

    unify(constraint, rhsType, res);
  }

  // Other types do not support index assignment.
  bind(constraint, c.propType, builtinTypes->errorType);

  return true;
}

bool ConstraintSolver::tryDispatch(const UnpackConstraint &c,
                                   NotNull<const Constraint> constraint) {
  TypePackId sourcePack = follow(c.sourcePack);

  if (isBlocked(sourcePack))
    return block(sourcePack, constraint);

  TypePack srcPack =
      extendTypePack(*arena, builtinTypes, sourcePack, c.resultPack.size());

  auto resultIter = begin(c.resultPack);
  auto resultEnd = end(c.resultPack);

  size_t i = 0;
  while (resultIter != resultEnd) {
    if (i >= srcPack.head.size())
      break;

    TypeId srcTy = follow(srcPack.head[i]);
    TypeId resultTy = follow(*resultIter);

    LUAU_ASSERT(get<BlockedType>(resultTy));
    LUAU_ASSERT(canMutate(resultTy, constraint));

    if (get<BlockedType>(resultTy)) {
      if (follow(srcTy) == resultTy) {
        // It is sometimes the case that we find that a blocked type
        // is only blocked on itself. This doesn't actually
        // constitute any meaningful constraint, so we replace it
        // with a free type.
        TypeId f = freshType(arena, builtinTypes, constraint->scope);
        shiftReferences(resultTy, f);
        emplaceType<BoundType>(asMutable(resultTy), f);
      } else
        bind(constraint, resultTy, srcTy);
    } else
      unify(constraint, srcTy, resultTy);

    unblock(resultTy, constraint->location);

    ++resultIter;
    ++i;
  }

  // We know that resultPack does not have a tail, but we don't know if
  // sourcePack is long enough to fill every value.  Replace every remaining
  // result TypeId with `nil`.

  while (resultIter != resultEnd) {
    TypeId resultTy = follow(*resultIter);
    LUAU_ASSERT(canMutate(resultTy, constraint));
    if (get<BlockedType>(resultTy) || get<PendingExpansionType>(resultTy)) {
      bind(constraint, resultTy, builtinTypes->nilType);
    }

    ++resultIter;
  }

  return true;
}

bool ConstraintSolver::tryDispatch(const ReduceConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  TypeId ty = follow(c.ty);
  FunctionGraphReductionResult result = reduceTypeFunctions(
      ty, constraint->location,
      TypeFunctionContext{NotNull{this}, constraint->scope, constraint}, force);

  for (TypeId r : result.reducedTypes)
    unblock(r, constraint->location);

  for (TypePackId r : result.reducedPacks)
    unblock(r, constraint->location);

  bool reductionFinished =
      result.blockedTypes.empty() && result.blockedPacks.empty();

  ty = follow(ty);
  // If we couldn't reduce this type function, stick it in the set!
  if (get<TypeFunctionInstanceType>(ty))
    typeFamiliesToFinalize[ty] = constraint;

  if (force || reductionFinished) {
    // if we're completely dispatching this constraint, we want to record any
    // uninhabited type families to unblock.
    for (auto error : result.errors) {
      if (auto utf = get<UninhabitedTypeFunction>(error))
        uninhabitedTypeFamilies.insert(utf->ty);
      else if (auto utpf = get<UninhabitedTypePackFunction>(error))
        uninhabitedTypeFamilies.insert(utpf->tp);
    }
  }

  if (force)
    return true;

  for (TypeId b : result.blockedTypes)
    block(b, constraint);

  for (TypePackId b : result.blockedPacks)
    block(b, constraint);

  return reductionFinished;
}

bool ConstraintSolver::tryDispatch(const ReducePackConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  TypePackId tp = follow(c.tp);
  FunctionGraphReductionResult result = reduceTypeFunctions(
      tp, constraint->location,
      TypeFunctionContext{NotNull{this}, constraint->scope, constraint}, force);

  for (TypeId r : result.reducedTypes)
    unblock(r, constraint->location);

  for (TypePackId r : result.reducedPacks)
    unblock(r, constraint->location);

  bool reductionFinished =
      result.blockedTypes.empty() && result.blockedPacks.empty();

  if (force || reductionFinished) {
    // if we're completely dispatching this constraint, we want to record any
    // uninhabited type families to unblock.
    for (auto error : result.errors) {
      if (auto utf = get<UninhabitedTypeFunction>(error))
        uninhabitedTypeFamilies.insert(utf->ty);
      else if (auto utpf = get<UninhabitedTypePackFunction>(error))
        uninhabitedTypeFamilies.insert(utpf->tp);
    }
  }

  if (force)
    return true;

  for (TypeId b : result.blockedTypes)
    block(b, constraint);

  for (TypePackId b : result.blockedPacks)
    block(b, constraint);

  return reductionFinished;
}

bool ConstraintSolver::tryDispatch(const EqualityConstraint &c,
                                   NotNull<const Constraint> constraint,
                                   bool force) {
  unify(constraint, c.resultType, c.assignmentType);
  unify(constraint, c.assignmentType, c.resultType);
  return true;
}

bool ConstraintSolver::tryDispatchIterableTable(
    TypeId iteratorTy, const IterableConstraint &c,
    NotNull<const Constraint> constraint, bool force) {
  iteratorTy = follow(iteratorTy);

  if (get<FreeType>(iteratorTy)) {
    TypeId keyTy = freshType(arena, builtinTypes, constraint->scope);
    TypeId valueTy = freshType(arena, builtinTypes, constraint->scope);
    TypeId tableTy =
        arena->addType(TableType{TableState::Sealed, {}, constraint->scope});
    getMutable<TableType>(tableTy)->indexer = TableIndexer{keyTy, valueTy};

    pushConstraint(constraint->scope, constraint->location,
                   SubtypeConstraint{iteratorTy, tableTy});

    auto it = begin(c.variables);
    auto endIt = end(c.variables);
    if (it != endIt) {
      bind(constraint, *it, keyTy);
      ++it;
    }
    if (it != endIt)
      bind(constraint, *it, valueTy);

    return true;
  }

  auto unpack = [&](TypeId ty) {
    for (TypeId varTy : c.variables) {
      LUAU_ASSERT(get<BlockedType>(varTy));
      LUAU_ASSERT(varTy != ty);
      bind(constraint, varTy, ty);
    }
  };

  if (get<AnyType>(iteratorTy)) {
    unpack(builtinTypes->anyType);
    return true;
  }

  if (get<ErrorType>(iteratorTy)) {
    unpack(builtinTypes->errorType);
    return true;
  }

  if (get<NeverType>(iteratorTy)) {
    unpack(builtinTypes->neverType);
    return true;
  }

  // Irksome: I don't think we have any way to guarantee that this table
  // type never has a metatable.

  if (auto iteratorTable = get<TableType>(iteratorTy)) {
    /*
     * We try not to dispatch IterableConstraints over free tables because
     * it's possible that there are other constraints on the table that will
     * clarify what we should do.
     *
     * We should eventually introduce a type function to talk about iteration.
     */
    if (iteratorTable->state == TableState::Free && !force)
      return block(iteratorTy, constraint);

    if (iteratorTable->indexer) {
      std::vector<TypeId> expectedVariables{
          iteratorTable->indexer->indexType,
          iteratorTable->indexer->indexResultType};
      while (c.variables.size() >= expectedVariables.size())
        expectedVariables.push_back(builtinTypes->errorRecoveryType());

      for (size_t i = 0; i < c.variables.size(); ++i) {
        LUAU_ASSERT(c.variables[i] != expectedVariables[i]);

        unify(constraint, c.variables[i], expectedVariables[i]);

        bind(constraint, c.variables[i], expectedVariables[i]);
      }
    } else
      unpack(builtinTypes->errorType);
  } else if (std::optional<TypeId> iterFn = findMetatableEntry(
                 builtinTypes, errors, iteratorTy, "__iter", Location{})) {
    if (isBlocked(*iterFn)) {
      return block(*iterFn, constraint);
    }

    if (std::optional<TypeId> instantiatedIterFn =
            instantiate(builtinTypes, arena, NotNull{&limits},
                        constraint->scope, *iterFn)) {
      if (auto iterFtv = get<FunctionType>(*instantiatedIterFn)) {
        TypePackId expectedIterArgs = arena->addTypePack({iteratorTy});
        unify(constraint, iterFtv->argTypes, expectedIterArgs);

        TypePack iterRets =
            extendTypePack(*arena, builtinTypes, iterFtv->retTypes, 2);

        if (iterRets.head.size() < 1) {
          // We've done what we can; this will get reported as an
          // error by the type checker.
          return true;
        }

        TypeId nextFn = iterRets.head[0];

        if (std::optional<TypeId> instantiatedNextFn =
                instantiate(builtinTypes, arena, NotNull{&limits},
                            constraint->scope, nextFn)) {
          const FunctionType *nextFn = get<FunctionType>(*instantiatedNextFn);

          // If nextFn is nullptr, then the iterator function has an improper
          // signature.
          if (nextFn)
            unpackAndAssign(c.variables, nextFn->retTypes, constraint);

          return true;
        } else {
          reportError(UnificationTooComplex{}, constraint->location);
        }
      } else {
        // TODO: Support __call and function overloads (what does an overload
        // even mean for this?)
      }
    } else {
      reportError(UnificationTooComplex{}, constraint->location);
    }
  } else if (auto iteratorMetatable = get<MetatableType>(iteratorTy)) {
    // If the metatable does not contain a `__iter` metamethod, then we iterate
    // over the table part of the metatable.
    return tryDispatchIterableTable(iteratorMetatable->table, c, constraint,
                                    force);
  } else if (auto primitiveTy = get<PrimitiveType>(iteratorTy);
             primitiveTy && primitiveTy->type == PrimitiveType::Type::Table)
    unpack(builtinTypes->unknownType);
  else {
    unpack(builtinTypes->errorType);
  }

  return true;
}

bool ConstraintSolver::tryDispatchIterableFunction(
    TypeId nextTy, TypeId tableTy, const IterableConstraint &c,
    NotNull<const Constraint> constraint, bool force) {
  const FunctionType *nextFn = get<FunctionType>(nextTy);
  // If this does not hold, we should've never called
  // `tryDispatchIterableFunction` in the first place.
  LUAU_ASSERT(nextFn);
  const TypePackId nextRetPack = nextFn->retTypes;

  // the type of the `nextAstFragment` is the `nextTy`.
  (*c.astForInNextTypes)[c.nextAstFragment] = nextTy;

  auto it = begin(nextRetPack);
  std::vector<TypeId> modifiedNextRetHead;

  // The first value is never nil in the context of the loop, even if it's nil
  // in the next function's return type, because the loop will not advance if
  // it's nil.
  if (it != end(nextRetPack)) {
    TypeId firstRet = *it;
    TypeId modifiedFirstRet = stripNil(builtinTypes, *arena, firstRet);
    modifiedNextRetHead.push_back(modifiedFirstRet);
    ++it;
  }

  for (; it != end(nextRetPack); ++it)
    modifiedNextRetHead.push_back(*it);

  TypePackId modifiedNextRetPack =
      arena->addTypePack(std::move(modifiedNextRetHead), it.tail());

  auto unpackConstraint =
      unpackAndAssign(c.variables, modifiedNextRetPack, constraint);

  inheritBlocks(constraint, unpackConstraint);

  return true;
}

NotNull<const Constraint>
ConstraintSolver::unpackAndAssign(const std::vector<TypeId> destTypes,
                                  TypePackId srcTypes,
                                  NotNull<const Constraint> constraint) {
  auto c = pushConstraint(constraint->scope, constraint->location,
                          UnpackConstraint{destTypes, srcTypes});

  for (TypeId t : destTypes) {
    BlockedType *bt = getMutable<BlockedType>(t);
    LUAU_ASSERT(bt);
    bt->replaceOwner(c);
  }

  return c;
}

std::pair<std::vector<TypeId>, std::optional<TypeId>>
ConstraintSolver::lookupTableProp(NotNull<const Constraint> constraint,
                                  TypeId subjectType,
                                  const std::string &propName,
                                  ValueContext context, bool inConditional,
                                  bool suppressSimplification) {
  DenseHashSet<TypeId> seen{nullptr};
  return lookupTableProp(constraint, subjectType, propName, context,
                         inConditional, suppressSimplification, seen);
}

std::pair<std::vector<TypeId>, std::optional<TypeId>>
ConstraintSolver::lookupTableProp(NotNull<const Constraint> constraint,
                                  TypeId subjectType,
                                  const std::string &propName,
                                  ValueContext context, bool inConditional,
                                  bool suppressSimplification,
                                  DenseHashSet<TypeId> &seen) {
  if (seen.contains(subjectType))
    return {};
  seen.insert(subjectType);

  subjectType = follow(subjectType);

  if (isBlocked(subjectType))
    return {{subjectType}, std::nullopt};
  else if (get<AnyType>(subjectType) || get<NeverType>(subjectType)) {
    return {{}, subjectType};
  } else if (auto ttv = getMutable<TableType>(subjectType)) {
    if (auto prop = ttv->props.find(propName); prop != ttv->props.end()) {
      switch (context) {
      case ValueContext::RValue:
        if (auto rt = prop->second.readTy)
          return {{}, rt};
        break;
      case ValueContext::LValue:
        if (auto wt = prop->second.writeTy)
          return {{}, wt};
        break;
      }
    }

    if (ttv->indexer && maybeString(ttv->indexer->indexType))
      return {{}, ttv->indexer->indexResultType};

    if (ttv->state == TableState::Free) {
      TypeId result = freshType(arena, builtinTypes, ttv->scope);
      switch (context) {
      case ValueContext::RValue:
        ttv->props[propName].readTy = result;
        break;
      case ValueContext::LValue:
        if (auto it = ttv->props.find(propName);
            it != ttv->props.end() && it->second.isReadOnly()) {
          // We do infer read-only properties, but we do not infer
          // separate read and write types.
          //
          // If we encounter a case where a free table has a read-only
          // property that we subsequently sense a write to, we make
          // the judgement that the property is read-write and that
          // both the read and write types are the same.

          Property &prop = it->second;

          prop.writeTy = prop.readTy;
          return {{}, *prop.readTy};
        } else
          ttv->props[propName] = Property::rw(result);

        break;
      }
      return {{}, result};
    }

    // if we are in a conditional context, we treat the property as present and
    // `unknown` because we may be _refining_ a table to include that property.
    // we will want to revisit this a bit in the future once luau has support
    // for exact tables since this only applies when inexact.
    if (inConditional)
      return {{}, builtinTypes->unknownType};
  } else if (auto mt = get<MetatableType>(subjectType);
             mt && context == ValueContext::RValue) {
    auto [blocked, result] =
        lookupTableProp(constraint, mt->table, propName, context, inConditional,
                        suppressSimplification, seen);
    if (!blocked.empty() || result)
      return {blocked, result};

    TypeId mtt = follow(mt->metatable);

    if (get<BlockedType>(mtt))
      return {{mtt}, std::nullopt};
    else if (auto metatable = get<TableType>(mtt)) {
      auto indexProp = metatable->props.find("__index");
      if (indexProp == metatable->props.end())
        return {{}, result};

      // TODO: __index can be an overloaded function.

      TypeId indexType = follow(indexProp->second.type());

      if (auto ft = get<FunctionType>(indexType)) {
        TypePack rets = extendTypePack(*arena, builtinTypes, ft->retTypes, 1);
        if (1 == rets.head.size())
          return {{}, rets.head[0]};
        else {
          // This should probably be an error: We need the first result of the
          // MT.__index method, but it returns 0 values.  See CLI-68672
          return {{}, builtinTypes->nilType};
        }
      } else
        return lookupTableProp(constraint, indexType, propName, context,
                               inConditional, suppressSimplification, seen);
    } else if (get<MetatableType>(mtt))
      return lookupTableProp(constraint, mtt, propName, context, inConditional,
                             suppressSimplification, seen);
  } else if (auto ct = get<ClassType>(subjectType)) {
    if (auto p = lookupClassProp(ct, propName))
      return {{}, context == ValueContext::RValue ? p->readTy : p->writeTy};
    if (ct->indexer) {
      return {{}, ct->indexer->indexResultType};
    }
  } else if (auto pt = get<PrimitiveType>(subjectType); pt && pt->metatable) {
    const TableType *metatable = get<TableType>(follow(*pt->metatable));
    LUAU_ASSERT(metatable);

    auto indexProp = metatable->props.find("__index");
    if (indexProp == metatable->props.end())
      return {{}, std::nullopt};

    return lookupTableProp(constraint, indexProp->second.type(), propName,
                           context, inConditional, suppressSimplification,
                           seen);
  } else if (auto ft = get<FreeType>(subjectType)) {
    const TypeId upperBound = follow(ft->upperBound);

    if (get<TableType>(upperBound) || get<PrimitiveType>(upperBound))
      return lookupTableProp(constraint, upperBound, propName, context,
                             inConditional, suppressSimplification, seen);

    // TODO: The upper bound could be an intersection that contains suitable
    // tables or classes.

    NotNull<Scope> scope{ft->scope};

    const TypeId newUpperBound =
        arena->addType(TableType{TableState::Free, TypeLevel{}, scope});
    TableType *tt = getMutable<TableType>(newUpperBound);
    LUAU_ASSERT(tt);
    TypeId propType = freshType(arena, builtinTypes, scope);

    switch (context) {
    case ValueContext::RValue:
      tt->props[propName] = Property::readonly(propType);
      break;
    case ValueContext::LValue:
      tt->props[propName] = Property::rw(propType);
      break;
    }

    unify(constraint, subjectType, newUpperBound);

    return {{}, propType};
  } else if (auto utv = get<UnionType>(subjectType)) {
    std::vector<TypeId> blocked;
    std::set<TypeId> options;

    for (TypeId ty : utv) {
      auto [innerBlocked, innerResult] =
          lookupTableProp(constraint, ty, propName, context, inConditional,
                          suppressSimplification, seen);
      blocked.insert(blocked.end(), innerBlocked.begin(), innerBlocked.end());
      if (innerResult)
        options.insert(*innerResult);
    }

    if (!blocked.empty())
      return {blocked, std::nullopt};

    if (options.empty())
      return {{}, std::nullopt};
    else if (options.size() == 1)
      return {{}, *begin(options)};
    else if (options.size() == 2 && !suppressSimplification) {
      TypeId one = *begin(options);
      TypeId two = *(++begin(options));

      // if we're in an lvalue context, we need the _common_ type here.
      if (context == ValueContext::LValue)
        return {{}, simplifyIntersection(builtinTypes, arena, one, two).result};

      return {{}, simplifyUnion(builtinTypes, arena, one, two).result};
    }
    // if we're in an lvalue context, we need the _common_ type here.
    else if (context == ValueContext::LValue)
      return {{},
              arena->addType(IntersectionType{
                  std::vector<TypeId>(begin(options), end(options))})};
    else
      return {{},
              arena->addType(UnionType{
                  std::vector<TypeId>(begin(options), end(options))})};
  } else if (auto itv = get<IntersectionType>(subjectType)) {
    std::vector<TypeId> blocked;
    std::set<TypeId> options;

    for (TypeId ty : itv) {
      auto [innerBlocked, innerResult] =
          lookupTableProp(constraint, ty, propName, context, inConditional,
                          suppressSimplification, seen);
      blocked.insert(blocked.end(), innerBlocked.begin(), innerBlocked.end());
      if (innerResult)
        options.insert(*innerResult);
    }

    if (!blocked.empty())
      return {blocked, std::nullopt};

    if (options.empty())
      return {{}, std::nullopt};
    else if (options.size() == 1)
      return {{}, *begin(options)};
    else if (options.size() == 2 && !suppressSimplification) {
      TypeId one = *begin(options);
      TypeId two = *(++begin(options));
      return {{}, simplifyIntersection(builtinTypes, arena, one, two).result};
    } else
      return {{},
              arena->addType(IntersectionType{
                  std::vector<TypeId>(begin(options), end(options))})};
  } else if (auto pt = get<PrimitiveType>(subjectType)) {
    // if we are in a conditional context, we treat the property as present and
    // `unknown` because we may be _refining_ a table to include that property.
    // we will want to revisit this a bit in the future once luau has support
    // for exact tables since this only applies when inexact.
    if (inConditional && pt->type == PrimitiveType::Table)
      return {{}, builtinTypes->unknownType};
  }

  return {{}, std::nullopt};
}

template <typename TID>
bool ConstraintSolver::unify(NotNull<const Constraint> constraint, TID subTy,
                             TID superTy) {
  Unifier2 u2{NotNull{arena}, builtinTypes, constraint->scope,
              NotNull{&iceReporter}, &uninhabitedTypeFamilies};

  const bool ok = u2.unify(subTy, superTy);

  for (ConstraintV &c : u2.incompleteSubtypes) {
    NotNull<Constraint> addition =
        pushConstraint(constraint->scope, constraint->location, std::move(c));
    inheritBlocks(constraint, addition);
  }

  if (ok) {
    for (const auto &[expanded, additions] : u2.expandedFreeTypes) {
      for (TypeId addition : additions)
        upperBoundContributors[expanded].push_back(
            std::make_pair(constraint->location, addition));
    }
  } else {
    reportError(OccursCheckFailed{}, constraint->location);
    return false;
  }

  return true;
}

bool ConstraintSolver::block_(BlockedConstraintId target,
                              NotNull<const Constraint> constraint) {
  // If a set is not present for the target, construct a new DenseHashSet for
  // it, else grab the address of the existing set.
  auto [iter, inserted] = blocked.try_emplace(target, nullptr);
  auto &[key, blockVec] = *iter;

  if (blockVec.find(constraint))
    return false;

  blockVec.insert(constraint);

  size_t &count = blockedConstraints[constraint];
  count += 1;

  return true;
}

void ConstraintSolver::block(NotNull<const Constraint> target,
                             NotNull<const Constraint> constraint) {
  const bool newBlock = block_(target.get(), constraint);
  if (newBlock) {
    if (logger)
      logger->pushBlock(constraint, target);

    if (FFlag::DebugLuauLogSolver)
      printf("%s depends on constraint %s\n",
             toString(*constraint, opts).c_str(),
             toString(*target, opts).c_str());
  }
}

bool ConstraintSolver::block(TypeId target,
                             NotNull<const Constraint> constraint) {
  const bool newBlock = block_(follow(target), constraint);
  if (newBlock) {
    if (logger)
      logger->pushBlock(constraint, target);

    if (FFlag::DebugLuauLogSolver)
      printf("%s depends on TypeId %s\n", toString(*constraint, opts).c_str(),
             toString(target, opts).c_str());
  }

  return false;
}

bool ConstraintSolver::block(TypePackId target,
                             NotNull<const Constraint> constraint) {
  const bool newBlock = block_(target, constraint);
  if (newBlock) {
    if (logger)
      logger->pushBlock(constraint, target);

    if (FFlag::DebugLuauLogSolver)
      printf("%s depends on TypePackId %s\n",
             toString(*constraint, opts).c_str(),
             toString(target, opts).c_str());
  }

  return false;
}

void ConstraintSolver::inheritBlocks(NotNull<const Constraint> source,
                                     NotNull<const Constraint> addition) {
  // Anything that is blocked on this constraint must also be blocked on our
  // synthesized constraints.
  auto blockedIt = blocked.find(source.get());
  if (blockedIt != blocked.end()) {
    for (const Constraint *blockedConstraint : blockedIt->second) {
      block(addition, NotNull{blockedConstraint});
    }
  }
}

struct Blocker : TypeOnceVisitor {
  NotNull<ConstraintSolver> solver;
  NotNull<const Constraint> constraint;

  bool blocked = false;

  explicit Blocker(NotNull<ConstraintSolver> solver,
                   NotNull<const Constraint> constraint)
      : solver(solver), constraint(constraint) {}

  bool visit(TypeId ty, const PendingExpansionType &) override {
    blocked = true;
    solver->block(ty, constraint);
    return false;
  }

  bool visit(TypeId ty, const ClassType &) override { return false; }
};

bool ConstraintSolver::blockOnPendingTypes(
    TypeId target, NotNull<const Constraint> constraint) {
  Blocker blocker{NotNull{this}, constraint};
  blocker.traverse(target);
  return !blocker.blocked;
}

bool ConstraintSolver::blockOnPendingTypes(
    TypePackId pack, NotNull<const Constraint> constraint) {
  Blocker blocker{NotNull{this}, constraint};
  blocker.traverse(pack);
  return !blocker.blocked;
}

void ConstraintSolver::unblock_(BlockedConstraintId progressed) {
  auto it = blocked.find(progressed);
  if (it == blocked.end())
    return;

  // unblocked should contain a value always, because of the above check
  for (const Constraint *unblockedConstraint : it->second) {
    auto &count = blockedConstraints[NotNull{unblockedConstraint}];
    if (FFlag::DebugLuauLogSolver)
      printf("Unblocking count=%d\t%s\n", int(count),
             toString(*unblockedConstraint, opts).c_str());

    // This assertion being hit indicates that `blocked` and
    // `blockedConstraints` desynchronized at some point. This is problematic
    // because we rely on this count being correct to skip over blocked
    // constraints.
    LUAU_ASSERT(count > 0);
    count -= 1;
  }

  blocked.erase(it);
}

void ConstraintSolver::unblock(NotNull<const Constraint> progressed) {
  if (logger)
    logger->popBlock(progressed);

  return unblock_(progressed.get());
}

void ConstraintSolver::unblock(TypeId ty, Location location) {
  DenseHashSet<TypeId> seen{nullptr};

  TypeId progressed = ty;
  while (true) {
    if (seen.find(progressed))
      iceReporter.ice(
          "ConstraintSolver::unblock encountered a self-bound type!", location);
    seen.insert(progressed);

    if (logger)
      logger->popBlock(progressed);

    unblock_(progressed);

    if (auto bt = get<BoundType>(progressed))
      progressed = bt->boundTo;
    else
      break;
  }
}

void ConstraintSolver::unblock(TypePackId progressed, Location) {
  if (logger)
    logger->popBlock(progressed);

  return unblock_(progressed);
}

void ConstraintSolver::unblock(const std::vector<TypeId> &types,
                               Location location) {
  for (TypeId t : types)
    unblock(t, location);
}

void ConstraintSolver::unblock(const std::vector<TypePackId> &packs,
                               Location location) {
  for (TypePackId t : packs)
    unblock(t, location);
}

void ConstraintSolver::reproduceConstraints(NotNull<Scope> scope,
                                            const Location &location,
                                            const Substitution &subst) {
  for (auto [_, newTy] : subst.newTypes) {
    if (get<TypeFunctionInstanceType>(newTy))
      pushConstraint(scope, location, ReduceConstraint{newTy});
  }

  for (auto [_, newPack] : subst.newPacks) {
    if (get<TypeFunctionInstanceTypePack>(newPack))
      pushConstraint(scope, location, ReducePackConstraint{newPack});
  }
}

bool ConstraintSolver::isBlocked(TypeId ty) {
  ty = follow(ty);

  if (auto tfit = get<TypeFunctionInstanceType>(ty))
    return uninhabitedTypeFamilies.contains(ty) == false;

  return nullptr != get<BlockedType>(ty) ||
         nullptr != get<PendingExpansionType>(ty);
}

bool ConstraintSolver::isBlocked(TypePackId tp) {
  tp = follow(tp);

  if (auto tfitp = get<TypeFunctionInstanceTypePack>(tp))
    return uninhabitedTypeFamilies.contains(tp) == false;

  return nullptr != get<BlockedTypePack>(tp);
}

bool ConstraintSolver::isBlocked(NotNull<const Constraint> constraint) {
  auto blockedIt = blockedConstraints.find(constraint);
  return blockedIt != blockedConstraints.end() && blockedIt->second > 0;
}

NotNull<Constraint> ConstraintSolver::pushConstraint(NotNull<Scope> scope,
                                                     const Location &location,
                                                     ConstraintV cv) {
  std::unique_ptr<Constraint> c =
      std::make_unique<Constraint>(scope, location, std::move(cv));
  NotNull<Constraint> borrow = NotNull(c.get());
  solverConstraints.push_back(std::move(c));
  unsolvedConstraints.push_back(borrow);

  return borrow;
}

TypeId ConstraintSolver::resolveModule(const ModuleInfo &info,
                                       const Location &location) {
  if (info.name.empty()) {
    reportError(UnknownRequire{}, location);
    return errorRecoveryType();
  }

  for (const auto &[location, path] : requireCycles) {
    if (!path.empty() && path.front() == info.name)
      return builtinTypes->anyType;
  }

  ModulePtr module = moduleResolver->getModule(info.name);
  if (!module) {
    if (!moduleResolver->moduleExists(info.name) && !info.optional)
      reportError(
          UnknownRequire{moduleResolver->getHumanReadableModuleName(info.name)},
          location);

    return errorRecoveryType();
  }

  if (module->type != SourceCode::Type::Module) {
    reportError(
        IllegalRequire{module->humanReadableName,
                       "Module is not a ModuleScript. It cannot be required."},
        location);
    return errorRecoveryType();
  }

  TypePackId modulePack = module->returnType;
  if (get<Unifiable::Error>(modulePack))
    return errorRecoveryType();

  std::optional<TypeId> moduleType = first(modulePack);
  if (!moduleType) {
    reportError(
        IllegalRequire{
            module->humanReadableName,
            "Module does not return exactly 1 value. It cannot be required."},
        location);
    return errorRecoveryType();
  }

  return *moduleType;
}

void ConstraintSolver::reportError(TypeErrorData &&data,
                                   const Location &location) {
  errors.emplace_back(location, std::move(data));
  errors.back().moduleName = currentModuleName;
}

void ConstraintSolver::reportError(TypeError e) {
  errors.emplace_back(std::move(e));
  errors.back().moduleName = currentModuleName;
}

void ConstraintSolver::shiftReferences(TypeId source, TypeId target) {
  target = follow(target);

  // if the target isn't a reference counted type, there's nothing to do.
  // this stops us from keeping unnecessary counts for e.g. primitive types.
  if (!isReferenceCountedType(target))
    return;

  auto sourceRefs = unresolvedConstraints.find(source);
  if (!sourceRefs)
    return;

  // we read out the count before proceeding to avoid hash invalidation issues.
  size_t count = *sourceRefs;

  auto [targetRefs, _] = unresolvedConstraints.try_insert(target, 0);
  targetRefs += count;
}

std::optional<TypeId>
ConstraintSolver::generalizeFreeType(NotNull<Scope> scope, TypeId type,
                                     bool avoidSealingTables) {
  TypeId t = follow(type);
  if (get<FreeType>(t)) {
    auto refCount = unresolvedConstraints.find(t);
    if (refCount && *refCount > 0)
      return {};

    // if no reference count is present, then that means the only constraints
    // referring to this free type need only for it to be generalized. in
    // principle, this means we could have actually never generated the free
    // type in the first place, but we couldn't know that until all constraint
    // generation is complete.
  }

  return generalize(NotNull{arena}, builtinTypes, scope, generalizedTypes, type,
                    avoidSealingTables);
}

bool ConstraintSolver::hasUnresolvedConstraints(TypeId ty) {
  if (auto refCount = unresolvedConstraints.find(ty))
    return *refCount > 0;

  return false;
}

TypeId ConstraintSolver::errorRecoveryType() const {
  return builtinTypes->errorRecoveryType();
}

TypePackId ConstraintSolver::errorRecoveryTypePack() const {
  return builtinTypes->errorRecoveryTypePack();
}

TypePackId ConstraintSolver::anyifyModuleReturnTypePackGenerics(TypePackId tp) {
  tp = follow(tp);

  if (const VariadicTypePack *vtp = get<VariadicTypePack>(tp)) {
    TypeId ty = follow(vtp->ty);
    return get<GenericType>(ty) ? builtinTypes->anyTypePack : tp;
  }

  if (!get<TypePack>(follow(tp)))
    return tp;

  std::vector<TypeId> resultTypes;
  std::optional<TypePackId> resultTail;

  TypePackIterator it = begin(tp);

  for (TypePackIterator e = end(tp); it != e; ++it) {
    TypeId ty = follow(*it);
    resultTypes.push_back(get<GenericType>(ty) ? builtinTypes->anyType : ty);
  }

  if (std::optional<TypePackId> tail = it.tail())
    resultTail = anyifyModuleReturnTypePackGenerics(*tail);

  return arena->addTypePack(resultTypes, resultTail);
}

LUAU_NOINLINE void ConstraintSolver::throwTimeLimitError() {
  throw TimeLimitError(currentModuleName);
}

LUAU_NOINLINE void ConstraintSolver::throwUserCancelError() {
  throw UserCancelError(currentModuleName);
}

// Instantiate private template implementations for external callers
template bool ConstraintSolver::unify(NotNull<const Constraint> constraint,
                                      TypeId subTy, TypeId superTy);
template bool ConstraintSolver::unify(NotNull<const Constraint> constraint,
                                      TypePackId subTy, TypePackId superTy);

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Clone.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintGenerator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);
LUAU_FASTFLAGVARIABLE(LuauSkipEmptyInstantiations, false);

namespace Luau {

static bool contains(Position pos, Comment comment) {
  if (comment.location.contains(pos))
    return true;
  else if (comment.type == Lexeme::BrokenComment &&
           comment.location.begin <=
               pos) // Broken comments are broken specifically because they
                    // don't have an end
    return true;
  else if (comment.type == Lexeme::Comment && comment.location.end == pos)
    return true;
  else
    return false;
}

static bool isWithinComment(const std::vector<Comment> &commentLocations,
                            Position pos) {
  auto iter = std::lower_bound(commentLocations.begin(), commentLocations.end(),
                               Comment{Lexeme::Comment, Location{pos, pos}},
                               [](const Comment &a, const Comment &b) {
                                 return a.location.end < b.location.end;
                               });

  if (iter == commentLocations.end())
    return false;

  if (contains(pos, *iter))
    return true;

  // Due to the nature of std::lower_bound, it is possible that iter points at a
  // comment that ends at pos.  We'll try the next comment, if it exists.
  ++iter;
  if (iter == commentLocations.end())
    return false;

  return contains(pos, *iter);
}

bool isWithinComment(const SourceModule &sourceModule, Position pos) {
  return isWithinComment(sourceModule.commentLocations, pos);
}

bool isWithinComment(const ParseResult &result, Position pos) {
  return isWithinComment(result.commentLocations, pos);
}

struct ClonePublicInterface : Substitution {
  NotNull<BuiltinTypes> builtinTypes;
  NotNull<Module> module;

  ClonePublicInterface(const TxnLog *log, NotNull<BuiltinTypes> builtinTypes,
                       Module *module)
      : Substitution(log, &module->interfaceTypes), builtinTypes(builtinTypes),
        module(module) {
    LUAU_ASSERT(module);
  }

  bool isDirty(TypeId ty) override {
    if (ty->owningArena == &module->internalTypes)
      return true;

    if (const FunctionType *ftv = get<FunctionType>(ty))
      return ftv->level.level != 0;
    if (const TableType *ttv = get<TableType>(ty))
      return ttv->level.level != 0;
    return false;
  }

  bool isDirty(TypePackId tp) override {
    return tp->owningArena == &module->internalTypes;
  }

  bool ignoreChildrenVisit(TypeId ty) override {
    if (ty->owningArena != &module->internalTypes)
      return true;

    return false;
  }

  bool ignoreChildrenVisit(TypePackId tp) override {
    if (tp->owningArena != &module->internalTypes)
      return true;

    return false;
  }

  TypeId clean(TypeId ty) override {
    TypeId result = clone(ty);

    if (FunctionType *ftv = getMutable<FunctionType>(result)) {
      if (FFlag::LuauSkipEmptyInstantiations && ftv->generics.empty() &&
          ftv->genericPacks.empty()) {
        GenericTypeFinder marker;
        marker.traverse(result);

        if (!marker.found)
          ftv->hasNoFreeOrGenericTypes = true;
      }

      ftv->level = TypeLevel{0, 0};
    } else if (TableType *ttv = getMutable<TableType>(result)) {
      ttv->level = TypeLevel{0, 0};
    }

    return result;
  }

  TypePackId clean(TypePackId tp) override { return clone(tp); }

  TypeId cloneType(TypeId ty) {
    std::optional<TypeId> result = substitute(ty);
    if (result) {
      return *result;
    } else {
      module->errors.push_back(
          TypeError{module->scopes[0].first, UnificationTooComplex{}});
      return builtinTypes->errorRecoveryType();
    }
  }

  TypePackId cloneTypePack(TypePackId tp) {
    std::optional<TypePackId> result = substitute(tp);
    if (result) {
      return *result;
    } else {
      module->errors.push_back(
          TypeError{module->scopes[0].first, UnificationTooComplex{}});
      return builtinTypes->errorRecoveryTypePack();
    }
  }

  TypeFun cloneTypeFun(const TypeFun &tf) {
    std::vector<GenericTypeDefinition> typeParams;
    std::vector<GenericTypePackDefinition> typePackParams;

    for (GenericTypeDefinition typeParam : tf.typeParams) {
      TypeId ty = cloneType(typeParam.ty);
      std::optional<TypeId> defaultValue;

      if (typeParam.defaultValue)
        defaultValue = cloneType(*typeParam.defaultValue);

      typeParams.push_back(GenericTypeDefinition{ty, defaultValue});
    }

    for (GenericTypePackDefinition typePackParam : tf.typePackParams) {
      TypePackId tp = cloneTypePack(typePackParam.tp);
      std::optional<TypePackId> defaultValue;

      if (typePackParam.defaultValue)
        defaultValue = cloneTypePack(*typePackParam.defaultValue);

      typePackParams.push_back(GenericTypePackDefinition{tp, defaultValue});
    }

    TypeId type = cloneType(tf.type);

    return TypeFun{typeParams, typePackParams, type};
  }
};

Module::~Module() {
  unfreeze(interfaceTypes);
  unfreeze(internalTypes);
}

void Module::clonePublicInterface(NotNull<BuiltinTypes> builtinTypes,
                                  InternalErrorReporter &ice) {
  CloneState cloneState{builtinTypes};

  ScopePtr moduleScope = getModuleScope();

  TypePackId returnType = moduleScope->returnType;
  std::optional<TypePackId> varargPack =
      FFlag::DebugLuauDeferredConstraintResolution ? std::nullopt
                                                   : moduleScope->varargPack;

  TxnLog log;
  ClonePublicInterface clonePublicInterface{&log, builtinTypes, this};

  returnType = clonePublicInterface.cloneTypePack(returnType);

  moduleScope->returnType = returnType;
  if (varargPack) {
    varargPack = clonePublicInterface.cloneTypePack(*varargPack);
    moduleScope->varargPack = varargPack;
  }

  for (auto &[name, tf] : moduleScope->exportedTypeBindings) {
    tf = clonePublicInterface.cloneTypeFun(tf);
  }

  for (auto &[name, ty] : declaredGlobals) {
    ty = clonePublicInterface.cloneType(ty);
  }

  // Copy external stuff over to Module itself
  this->returnType = moduleScope->returnType;
  this->exportedTypeBindings = moduleScope->exportedTypeBindings;
}

bool Module::hasModuleScope() const { return !scopes.empty(); }

ScopePtr Module::getModuleScope() const {
  LUAU_ASSERT(hasModuleScope());
  return scopes.front().second;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation2.h>
// including for `Replacer` which was stolen since it will be kept in the new
// solver
// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)
LUAU_FASTFLAG(LuauReusableSubstitutions)

namespace Luau {

void Instantiation::resetState(const TxnLog *log, TypeArena *arena,
                               NotNull<BuiltinTypes> builtinTypes,
                               TypeLevel level, Scope *scope) {
  LUAU_ASSERT(FFlag::LuauReusableSubstitutions);

  Substitution::resetState(log, arena);

  this->builtinTypes = builtinTypes;

  this->level = level;
  this->scope = scope;
}

bool Instantiation::isDirty(TypeId ty) {
  if (const FunctionType *ftv = log->getMutable<FunctionType>(ty)) {
    if (ftv->hasNoFreeOrGenericTypes)
      return false;

    return true;
  } else {
    return false;
  }
}

bool Instantiation::isDirty(TypePackId tp) { return false; }

bool Instantiation::ignoreChildren(TypeId ty) {
  if (log->getMutable<FunctionType>(ty))
    return true;
  else if (get<ClassType>(ty))
    return true;
  else
    return false;
}

TypeId Instantiation::clean(TypeId ty) {
  const FunctionType *ftv = log->getMutable<FunctionType>(ty);
  LUAU_ASSERT(ftv);

  FunctionType clone =
      FunctionType{level,         scope,           ftv->argTypes,
                   ftv->retTypes, ftv->definition, ftv->hasSelf};
  clone.magicFunction = ftv->magicFunction;
  clone.dcrMagicFunction = ftv->dcrMagicFunction;
  clone.dcrMagicRefinement = ftv->dcrMagicRefinement;
  clone.tags = ftv->tags;
  clone.argNames = ftv->argNames;
  TypeId result = addType(std::move(clone));

  if (FFlag::LuauReusableSubstitutions) {
    // Annoyingly, we have to do this even if there are no generics,
    // to replace any generic tables.
    reusableReplaceGenerics.resetState(log, arena, builtinTypes, level, scope,
                                       ftv->generics, ftv->genericPacks);

    // TODO: What to do if this returns nullopt?
    // We don't have access to the error-reporting machinery
    result = reusableReplaceGenerics.substitute(result).value_or(result);
  } else {
    // Annoyingly, we have to do this even if there are no generics,
    // to replace any generic tables.
    ReplaceGenerics replaceGenerics{
        log,   arena,         builtinTypes,     level,
        scope, ftv->generics, ftv->genericPacks};

    // TODO: What to do if this returns nullopt?
    // We don't have access to the error-reporting machinery
    result = replaceGenerics.substitute(result).value_or(result);
  }

  asMutable(result)->documentationSymbol = ty->documentationSymbol;
  return result;
}

TypePackId Instantiation::clean(TypePackId tp) {
  LUAU_ASSERT(false);
  return tp;
}

void ReplaceGenerics::resetState(const TxnLog *log, TypeArena *arena,
                                 NotNull<BuiltinTypes> builtinTypes,
                                 TypeLevel level, Scope *scope,
                                 const std::vector<TypeId> &generics,
                                 const std::vector<TypePackId> &genericPacks) {
  LUAU_ASSERT(FFlag::LuauReusableSubstitutions);

  Substitution::resetState(log, arena);

  this->builtinTypes = builtinTypes;

  this->level = level;
  this->scope = scope;

  this->generics = generics;
  this->genericPacks = genericPacks;
}

bool ReplaceGenerics::ignoreChildren(TypeId ty) {
  if (const FunctionType *ftv = log->getMutable<FunctionType>(ty)) {
    if (ftv->hasNoFreeOrGenericTypes)
      return true;

    // We aren't recursing in the case of a generic function which
    // binds the same generics. This can happen if, for example, there's
    // recursive types. If T = <a>(a,T)->T then instantiating T should produce
    // T' = (X,T)->T not T' = (X,T')->T'. It's OK to use vector equality here,
    // since we always generate fresh generics whenever we quantify, so the
    // vectors overlap if and only if they are equal.
    return (!generics.empty() || !genericPacks.empty()) &&
           (ftv->generics == generics) && (ftv->genericPacks == genericPacks);
  } else if (get<ClassType>(ty))
    return true;
  else {
    return false;
  }
}

bool ReplaceGenerics::isDirty(TypeId ty) {
  if (const TableType *ttv = log->getMutable<TableType>(ty))
    return ttv->state == TableState::Generic;
  else if (log->getMutable<GenericType>(ty))
    return std::find(generics.begin(), generics.end(), ty) != generics.end();
  else
    return false;
}

bool ReplaceGenerics::isDirty(TypePackId tp) {
  if (log->getMutable<GenericTypePack>(tp))
    return std::find(genericPacks.begin(), genericPacks.end(), tp) !=
           genericPacks.end();
  else
    return false;
}

TypeId ReplaceGenerics::clean(TypeId ty) {
  LUAU_ASSERT(isDirty(ty));
  if (const TableType *ttv = log->getMutable<TableType>(ty)) {
    TableType clone =
        TableType{ttv->props, ttv->indexer, level, scope, TableState::Free};
    clone.definitionModuleName = ttv->definitionModuleName;
    clone.definitionLocation = ttv->definitionLocation;
    return addType(std::move(clone));
  } else if (FFlag::DebugLuauDeferredConstraintResolution) {
    TypeId res = freshType(NotNull{arena}, builtinTypes, scope);
    getMutable<FreeType>(res)->level = level;
    return res;
  } else {
    return addType(FreeType{scope, level});
  }
}

TypePackId ReplaceGenerics::clean(TypePackId tp) {
  LUAU_ASSERT(isDirty(tp));
  return addTypePack(TypePackVar(FreeTypePack{scope, level}));
}

std::optional<TypeId> instantiate(NotNull<BuiltinTypes> builtinTypes,
                                  NotNull<TypeArena> arena,
                                  NotNull<TypeCheckLimits> limits,
                                  NotNull<Scope> scope, TypeId ty) {
  ty = follow(ty);

  const FunctionType *ft = get<FunctionType>(ty);
  if (!ft)
    return ty;

  if (ft->generics.empty() && ft->genericPacks.empty())
    return ty;

  DenseHashMap<TypeId, TypeId> replacements{nullptr};
  DenseHashMap<TypePackId, TypePackId> replacementPacks{nullptr};

  for (TypeId g : ft->generics)
    replacements[g] = freshType(arena, builtinTypes, scope);

  for (TypePackId g : ft->genericPacks)
    replacementPacks[g] = arena->freshTypePack(scope);

  Replacer r{arena, std::move(replacements), std::move(replacementPacks)};

  if (limits->instantiationChildLimit)
    r.childLimit = *limits->instantiationChildLimit;

  std::optional<TypeId> res = r.substitute(ty);
  if (!res)
    return res;

  FunctionType *ft2 = getMutable<FunctionType>(*res);
  LUAU_ASSERT(ft != ft2);

  ft2->generics.clear();
  ft2->genericPacks.clear();

  return res;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifier2.h>

namespace Luau {

static bool isLiteral(const AstExpr *expr) {
  return (expr->is<AstExprTable>() || expr->is<AstExprFunction>() ||
          expr->is<AstExprConstantNumber>() ||
          expr->is<AstExprConstantString>() ||
          expr->is<AstExprConstantBool>() || expr->is<AstExprConstantNil>());
}

// A fast approximation of subTy <: superTy
static bool fastIsSubtype(TypeId subTy, TypeId superTy) {
  Relation r = relate(superTy, subTy);
  return r == Relation::Coincident || r == Relation::Superset;
}

static bool isRecord(const AstExprTable::Item &item) {
  if (item.kind == AstExprTable::Item::Record)
    return true;
  else if (item.kind == AstExprTable::Item::General &&
           item.key->is<AstExprConstantString>())
    return true;
  else
    return false;
}

static std::optional<TypeId>
extractMatchingTableType(std::vector<TypeId> &tables, TypeId exprType,
                         NotNull<BuiltinTypes> builtinTypes) {
  if (tables.empty())
    return std::nullopt;

  const TableType *exprTable = get<TableType>(follow(exprType));
  if (!exprTable)
    return std::nullopt;

  size_t tableCount = 0;
  std::optional<TypeId> firstTable;

  for (TypeId ty : tables) {
    ty = follow(ty);
    if (auto tt = get<TableType>(ty)) {
      // If the expected table has a key whose type is a string or boolean
      // singleton and the corresponding exprType property does not match,
      // then skip this table.

      if (!firstTable)
        firstTable = ty;
      ++tableCount;

      for (const auto &[name, expectedProp] : tt->props) {
        if (!expectedProp.readTy)
          continue;

        const TypeId expectedType = follow(*expectedProp.readTy);

        auto st = get<SingletonType>(expectedType);
        if (!st)
          continue;

        auto it = exprTable->props.find(name);
        if (it == exprTable->props.end())
          continue;

        const auto &[_name, exprProp] = *it;

        if (!exprProp.readTy)
          continue;

        const TypeId propType = follow(*exprProp.readTy);

        const FreeType *ft = get<FreeType>(propType);

        if (ft && get<SingletonType>(ft->lowerBound)) {
          if (fastIsSubtype(builtinTypes->booleanType, ft->upperBound) &&
              fastIsSubtype(expectedType, builtinTypes->booleanType)) {
            return ty;
          }

          if (fastIsSubtype(builtinTypes->stringType, ft->upperBound) &&
              fastIsSubtype(expectedType, ft->lowerBound)) {
            return ty;
          }
        }
      }
    }
  }

  if (tableCount == 1) {
    LUAU_ASSERT(firstTable);
    return firstTable;
  }

  return std::nullopt;
}

TypeId matchLiteralType(
    NotNull<DenseHashMap<const AstExpr *, TypeId>> astTypes,
    NotNull<DenseHashMap<const AstExpr *, TypeId>> astExpectedTypes,
    NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena,
    NotNull<Unifier2> unifier, TypeId expectedType, TypeId exprType,
    const AstExpr *expr, std::vector<TypeId> &toBlock) {
  /*
   * Table types that arise from literal table expressions have some
   * properties that make this algorithm much simpler.
   *
   * Most importantly, the parts of the type that arise directly from the
   * table expression are guaranteed to be acyclic.  This means we can do all
   * kinds of naive depth first traversal shenanigans and not worry about
   * nasty details like aliasing or reentrancy.
   *
   * We are therefore completely free to mutate these portions of the
   * TableType however we choose!  We'll take advantage of this property to do
   * things like replace explicit named properties with indexers as required
   * by the expected type.
   */
  if (!isLiteral(expr))
    return exprType;

  expectedType = follow(expectedType);
  exprType = follow(exprType);

  if (get<AnyType>(expectedType) || get<UnknownType>(expectedType)) {
    // "Narrowing" to unknown or any is not going to do anything useful.
    return exprType;
  }

  if (expr->is<AstExprConstantString>()) {
    auto ft = get<FreeType>(exprType);
    if (ft && get<SingletonType>(ft->lowerBound) &&
        fastIsSubtype(builtinTypes->stringType, ft->upperBound) &&
        fastIsSubtype(ft->lowerBound, builtinTypes->stringType)) {
      // if the upper bound is a subtype of the expected type, we can push the
      // expected type in
      Relation upperBoundRelation = relate(ft->upperBound, expectedType);
      if (upperBoundRelation == Relation::Subset ||
          upperBoundRelation == Relation::Coincident) {
        emplaceType<BoundType>(asMutable(exprType), expectedType);
        return exprType;
      }

      // likewise, if the lower bound is a subtype, we can force the expected
      // type in if this is the case and the previous relation failed, it means
      // that the primitive type constraint was going to have to select the
      // lower bound for this type anyway.
      Relation lowerBoundRelation = relate(ft->lowerBound, expectedType);
      if (lowerBoundRelation == Relation::Subset ||
          lowerBoundRelation == Relation::Coincident) {
        emplaceType<BoundType>(asMutable(exprType), expectedType);
        return exprType;
      }
    }
  } else if (expr->is<AstExprConstantBool>()) {
    auto ft = get<FreeType>(exprType);
    if (ft && get<SingletonType>(ft->lowerBound) &&
        fastIsSubtype(builtinTypes->booleanType, ft->upperBound) &&
        fastIsSubtype(ft->lowerBound, builtinTypes->booleanType)) {
      // if the upper bound is a subtype of the expected type, we can push the
      // expected type in
      Relation upperBoundRelation = relate(ft->upperBound, expectedType);
      if (upperBoundRelation == Relation::Subset ||
          upperBoundRelation == Relation::Coincident) {
        emplaceType<BoundType>(asMutable(exprType), expectedType);
        return exprType;
      }

      // likewise, if the lower bound is a subtype, we can force the expected
      // type in if this is the case and the previous relation failed, it means
      // that the primitive type constraint was going to have to select the
      // lower bound for this type anyway.
      Relation lowerBoundRelation = relate(ft->lowerBound, expectedType);
      if (lowerBoundRelation == Relation::Subset ||
          lowerBoundRelation == Relation::Coincident) {
        emplaceType<BoundType>(asMutable(exprType), expectedType);
        return exprType;
      }
    }
  }

  if (expr->is<AstExprConstantString>() || expr->is<AstExprConstantNumber>() ||
      expr->is<AstExprConstantBool>() || expr->is<AstExprConstantNil>()) {
    if (auto ft = get<FreeType>(exprType);
        ft && fastIsSubtype(ft->upperBound, expectedType)) {
      emplaceType<BoundType>(asMutable(exprType), expectedType);
      return exprType;
    }

    Relation r = relate(exprType, expectedType);
    if (r == Relation::Coincident || r == Relation::Subset)
      return expectedType;

    return exprType;
  }

  // TODO: lambdas

  if (auto exprTable = expr->as<AstExprTable>()) {
    TableType *tableTy = getMutable<TableType>(exprType);
    LUAU_ASSERT(tableTy);

    const TableType *expectedTableTy = get<TableType>(expectedType);

    if (!expectedTableTy) {
      if (auto utv = get<UnionType>(expectedType)) {
        std::vector<TypeId> parts{begin(utv), end(utv)};

        std::optional<TypeId> tt =
            extractMatchingTableType(parts, exprType, builtinTypes);

        if (tt) {
          TypeId res =
              matchLiteralType(astTypes, astExpectedTypes, builtinTypes, arena,
                               unifier, *tt, exprType, expr, toBlock);

          parts.push_back(res);
          return arena->addType(UnionType{std::move(parts)});
        }
      }

      return exprType;
    }

    for (const AstExprTable::Item &item : exprTable->items) {
      if (isRecord(item)) {
        const AstArray<char> &s = item.key->as<AstExprConstantString>()->value;
        std::string keyStr{s.data, s.data + s.size};
        auto it = tableTy->props.find(keyStr);
        LUAU_ASSERT(it != tableTy->props.end());

        Property &prop = it->second;

        // Table literals always initially result in shared read-write types
        LUAU_ASSERT(prop.isShared());
        TypeId propTy = *prop.readTy;

        auto it2 = expectedTableTy->props.find(keyStr);

        if (it2 == expectedTableTy->props.end()) {
          // expectedType may instead have an indexer.  This is
          // kind of interesting because it means we clip the prop
          // from the exprType and fold it into the indexer.
          if (expectedTableTy->indexer &&
              isString(expectedTableTy->indexer->indexType)) {
            (*astExpectedTypes)[item.key] = expectedTableTy->indexer->indexType;
            (*astExpectedTypes)[item.value] =
                expectedTableTy->indexer->indexResultType;

            TypeId matchedType = matchLiteralType(
                astTypes, astExpectedTypes, builtinTypes, arena, unifier,
                expectedTableTy->indexer->indexResultType, propTy, item.value,
                toBlock);

            if (tableTy->indexer)
              unifier->unify(matchedType, tableTy->indexer->indexResultType);
            else
              tableTy->indexer = TableIndexer{
                  expectedTableTy->indexer->indexType, matchedType};

            tableTy->props.erase(keyStr);
          }

          // If it's just an extra property and the expected type
          // has no indexer, there's no work to do here.

          continue;
        }

        LUAU_ASSERT(it2 != expectedTableTy->props.end());

        const Property &expectedProp = it2->second;

        std::optional<TypeId> expectedReadTy = expectedProp.readTy;
        std::optional<TypeId> expectedWriteTy = expectedProp.writeTy;

        TypeId matchedType = nullptr;

        // Important optimization: If we traverse into the read and
        // write types separately even when they are shared, we go
        // quadratic in a hurry.
        if (expectedProp.isShared()) {
          matchedType = matchLiteralType(
              astTypes, astExpectedTypes, builtinTypes, arena, unifier,
              *expectedReadTy, propTy, item.value, toBlock);
          prop.readTy = matchedType;
          prop.writeTy = matchedType;
        } else if (expectedReadTy) {
          matchedType = matchLiteralType(
              astTypes, astExpectedTypes, builtinTypes, arena, unifier,
              *expectedReadTy, propTy, item.value, toBlock);
          prop.readTy = matchedType;
          prop.writeTy.reset();
        } else if (expectedWriteTy) {
          matchedType = matchLiteralType(
              astTypes, astExpectedTypes, builtinTypes, arena, unifier,
              *expectedWriteTy, propTy, item.value, toBlock);
          prop.readTy.reset();
          prop.writeTy = matchedType;
        } else {
          // Also important: It is presently the case that all
          // table properties are either read-only, or have the
          // same read and write types.
          LUAU_ASSERT(!"Should be unreachable");
        }

        LUAU_ASSERT(prop.readTy || prop.writeTy);

        LUAU_ASSERT(matchedType);

        (*astExpectedTypes)[item.value] = matchedType;
      } else if (item.kind == AstExprTable::Item::List) {
        LUAU_ASSERT(tableTy->indexer);

        if (expectedTableTy->indexer) {
          const TypeId *propTy = astTypes->find(item.value);
          LUAU_ASSERT(propTy);

          unifier->unify(expectedTableTy->indexer->indexType,
                         builtinTypes->numberType);
          TypeId matchedType = matchLiteralType(
              astTypes, astExpectedTypes, builtinTypes, arena, unifier,
              expectedTableTy->indexer->indexResultType, *propTy, item.value,
              toBlock);

          // if the index result type is the prop type, we can replace it with
          // the matched type here.
          if (tableTy->indexer->indexResultType == *propTy)
            tableTy->indexer->indexResultType = matchedType;
        }
      } else if (item.kind == AstExprTable::Item::General) {

        // We have { ..., [blocked] : somePropExpr, ...}
        // If blocked resolves to a string, we will then take care of this above
        // If it resolves to some other kind of expression, we don't have a way
        // of folding this information into indexer because there is no named
        // prop to remove We should just block here
        const TypeId *keyTy = astTypes->find(item.key);
        LUAU_ASSERT(keyTy);
        TypeId tKey = follow(*keyTy);
        if (get<BlockedType>(tKey))
          toBlock.push_back(tKey);

        const TypeId *propTy = astTypes->find(item.value);
        LUAU_ASSERT(propTy);
        TypeId tProp = follow(*propTy);
        if (get<BlockedType>(tProp))
          toBlock.push_back(tProp);
      } else
        LUAU_ASSERT(!"Unexpected");
    }

    // Keys that the expectedType says we should have, but that aren't
    // specified by the AST fragment.
    //
    // If any such keys are options, then we'll add them to the expression
    // type.
    //
    // We use std::optional<std::string> here because the empty string is a
    // perfectly reasonable value to insert into the set.  We'll use
    // std::nullopt as our sentinel value.
    Set<std::optional<std::string>> missingKeys{{}};
    for (const auto &[name, _] : expectedTableTy->props)
      missingKeys.insert(name);

    for (const AstExprTable::Item &item : exprTable->items) {
      if (item.key) {
        if (const auto str = item.key->as<AstExprConstantString>()) {
          missingKeys.erase(std::string(str->value.data, str->value.size));
        }
      }
    }

    for (const auto &key : missingKeys) {
      LUAU_ASSERT(key.has_value());

      auto it = expectedTableTy->props.find(*key);
      LUAU_ASSERT(it != expectedTableTy->props.end());

      const Property &expectedProp = it->second;

      Property exprProp;

      if (expectedProp.readTy && isOptional(*expectedProp.readTy))
        exprProp.readTy = *expectedProp.readTy;
      if (expectedProp.writeTy && isOptional(*expectedProp.writeTy))
        exprProp.writeTy = *expectedProp.writeTy;

      // If the property isn't actually optional, do nothing.
      if (exprProp.readTy || exprProp.writeTy)
        tableTy->props[*key] = std::move(exprProp);
    }
  }

  return exprType;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Constraint.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

namespace Luau {

Constraint::Constraint(NotNull<Scope> scope, const Location &location,
                       ConstraintV &&c)
    : scope(scope), location(location), c(std::move(c)) {}

struct ReferenceCountInitializer : TypeOnceVisitor {

  DenseHashSet<TypeId> *result;

  ReferenceCountInitializer(DenseHashSet<TypeId> *result) : result(result) {}

  bool visit(TypeId ty, const FreeType &) override {
    result->insert(ty);
    return false;
  }

  bool visit(TypeId ty, const BlockedType &) override {
    result->insert(ty);
    return false;
  }

  bool visit(TypeId ty, const PendingExpansionType &) override {
    result->insert(ty);
    return false;
  }

  bool visit(TypeId ty, const ClassType &) override {
    // ClassTypes never contain free types.
    return false;
  }
};

bool isReferenceCountedType(const TypeId typ) {
  // n.b. this should match whatever `ReferenceCountInitializer` includes.
  return get<FreeType>(typ) || get<BlockedType>(typ) ||
         get<PendingExpansionType>(typ);
}

DenseHashSet<TypeId> Constraint::getMaybeMutatedFreeTypes() const {
  // For the purpose of this function and reference counting in general, we are
  // only considering mutations that affect the _bounds_ of the free type, and
  // not something that may bind the free type itself to a new type. As such,
  // `ReduceConstraint` and `GeneralizationConstraint` have no contribution to
  // the output set here.

  DenseHashSet<TypeId> types{{}};
  ReferenceCountInitializer rci{&types};

  if (auto ec = get<EqualityConstraint>(*this)) {
    rci.traverse(ec->resultType);
    // `EqualityConstraints` should not mutate `assignmentType`.
  } else if (auto sc = get<SubtypeConstraint>(*this)) {
    rci.traverse(sc->subType);
    rci.traverse(sc->superType);
  } else if (auto psc = get<PackSubtypeConstraint>(*this)) {
    rci.traverse(psc->subPack);
    rci.traverse(psc->superPack);
  } else if (auto itc = get<IterableConstraint>(*this)) {
    for (TypeId ty : itc->variables)
      rci.traverse(ty);
    // `IterableConstraints` should not mutate `iterator`.
  } else if (auto nc = get<NameConstraint>(*this)) {
    rci.traverse(nc->namedType);
  } else if (auto taec = get<TypeAliasExpansionConstraint>(*this)) {
    rci.traverse(taec->target);
  } else if (auto fchc = get<FunctionCheckConstraint>(*this)) {
    rci.traverse(fchc->argsPack);
  } else if (auto ptc = get<PrimitiveTypeConstraint>(*this)) {
    rci.traverse(ptc->freeType);
  } else if (auto hpc = get<HasPropConstraint>(*this)) {
    rci.traverse(hpc->resultType);
    // `HasPropConstraints` should not mutate `subjectType`.
  } else if (auto hic = get<HasIndexerConstraint>(*this)) {
    rci.traverse(hic->resultType);
    // `HasIndexerConstraint` should not mutate `subjectType` or `indexType`.
  } else if (auto apc = get<AssignPropConstraint>(*this)) {
    rci.traverse(apc->lhsType);
    rci.traverse(apc->rhsType);
  } else if (auto aic = get<AssignIndexConstraint>(*this)) {
    rci.traverse(aic->lhsType);
    rci.traverse(aic->indexType);
    rci.traverse(aic->rhsType);
  } else if (auto uc = get<UnpackConstraint>(*this)) {
    for (TypeId ty : uc->resultPack)
      rci.traverse(ty);
    // `UnpackConstraint` should not mutate `sourcePack`.
  } else if (auto rpc = get<ReducePackConstraint>(*this)) {
    rci.traverse(rpc->tp);
  }

  return types;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Clone.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <stdexcept>

LUAU_FASTINTVARIABLE(LuauTarjanChildLimit, 10000)
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);
LUAU_FASTINTVARIABLE(LuauTarjanPreallocationSize, 256);
LUAU_FASTFLAG(LuauReusableSubstitutions)

namespace Luau {

static TypeId shallowClone(TypeId ty, TypeArena &dest, const TxnLog *log,
                           bool alwaysClone) {
  auto go = [ty, &dest, alwaysClone](auto &&a) {
    using T = std::decay_t<decltype(a)>;

    // The pointer identities of free and local types is very important.
    // We decline to copy them.
    if constexpr (std::is_same_v<T, FreeType>)
      return ty;
    else if constexpr (std::is_same_v<T, BoundType>) {
      // This should never happen, but visit() cannot see it.
      LUAU_ASSERT(!"shallowClone didn't follow its argument!");
      return dest.addType(BoundType{a.boundTo});
    } else if constexpr (std::is_same_v<T, GenericType>)
      return dest.addType(a);
    else if constexpr (std::is_same_v<T, BlockedType>)
      return dest.addType(a);
    else if constexpr (std::is_same_v<T, PrimitiveType>) {
      LUAU_ASSERT(ty->persistent);
      return ty;
    } else if constexpr (std::is_same_v<T, PendingExpansionType>) {
      PendingExpansionType clone = PendingExpansionType{
          a.prefix, a.name, a.typeArguments, a.packArguments};
      return dest.addType(std::move(clone));
    } else if constexpr (std::is_same_v<T, AnyType>) {
      LUAU_ASSERT(ty->persistent);
      return ty;
    } else if constexpr (std::is_same_v<T, ErrorType>) {
      LUAU_ASSERT(ty->persistent);
      return ty;
    } else if constexpr (std::is_same_v<T, UnknownType>) {
      LUAU_ASSERT(ty->persistent);
      return ty;
    } else if constexpr (std::is_same_v<T, NeverType>) {
      LUAU_ASSERT(ty->persistent);
      return ty;
    } else if constexpr (std::is_same_v<T, LazyType>)
      return ty;
    else if constexpr (std::is_same_v<T, SingletonType>)
      return dest.addType(a);
    else if constexpr (std::is_same_v<T, FunctionType>) {
      FunctionType clone = FunctionType{a.level,    a.scope,      a.argTypes,
                                        a.retTypes, a.definition, a.hasSelf};
      clone.generics = a.generics;
      clone.genericPacks = a.genericPacks;
      clone.magicFunction = a.magicFunction;
      clone.dcrMagicFunction = a.dcrMagicFunction;
      clone.dcrMagicRefinement = a.dcrMagicRefinement;
      clone.tags = a.tags;
      clone.argNames = a.argNames;
      clone.isCheckedFunction = a.isCheckedFunction;
      return dest.addType(std::move(clone));
    } else if constexpr (std::is_same_v<T, TableType>) {
      LUAU_ASSERT(!a.boundTo);
      TableType clone =
          TableType{a.props, a.indexer, a.level, a.scope, a.state};
      clone.definitionModuleName = a.definitionModuleName;
      clone.definitionLocation = a.definitionLocation;
      clone.name = a.name;
      clone.syntheticName = a.syntheticName;
      clone.instantiatedTypeParams = a.instantiatedTypeParams;
      clone.instantiatedTypePackParams = a.instantiatedTypePackParams;
      clone.tags = a.tags;
      return dest.addType(std::move(clone));
    } else if constexpr (std::is_same_v<T, MetatableType>) {
      MetatableType clone = MetatableType{a.table, a.metatable};
      clone.syntheticName = a.syntheticName;
      return dest.addType(std::move(clone));
    } else if constexpr (std::is_same_v<T, UnionType>) {
      UnionType clone;
      clone.options = a.options;
      return dest.addType(std::move(clone));
    } else if constexpr (std::is_same_v<T, IntersectionType>) {
      IntersectionType clone;
      clone.parts = a.parts;
      return dest.addType(std::move(clone));
    } else if constexpr (std::is_same_v<T, ClassType>) {
      if (alwaysClone) {
        ClassType clone{a.name,
                        a.props,
                        a.parent,
                        a.metatable,
                        a.tags,
                        a.userData,
                        a.definitionModuleName,
                        a.indexer};
        return dest.addType(std::move(clone));
      } else
        return ty;
    } else if constexpr (std::is_same_v<T, NegationType>)
      return dest.addType(NegationType{a.ty});
    else if constexpr (std::is_same_v<T, TypeFunctionInstanceType>) {
      TypeFunctionInstanceType clone{a.family, a.typeArguments,
                                     a.packArguments};
      return dest.addType(std::move(clone));
    } else
      static_assert(always_false_v<T>, "Non-exhaustive shallowClone switch");
  };

  ty = log->follow(ty);

  if (auto pty = log->pending(ty))
    ty = &pty->pending;

  TypeId resTy = visit(go, ty->ty);
  if (resTy != ty)
    asMutable(resTy)->documentationSymbol = ty->documentationSymbol;

  return resTy;
}

Tarjan::Tarjan()
    : typeToIndex(nullptr, FFlag::LuauReusableSubstitutions
                               ? FInt::LuauTarjanPreallocationSize
                               : 0),
      packToIndex(nullptr, FFlag::LuauReusableSubstitutions
                               ? FInt::LuauTarjanPreallocationSize
                               : 0) {
  nodes.reserve(FInt::LuauTarjanPreallocationSize);
  stack.reserve(FInt::LuauTarjanPreallocationSize);
  edgesTy.reserve(FInt::LuauTarjanPreallocationSize);
  edgesTp.reserve(FInt::LuauTarjanPreallocationSize);
  worklist.reserve(FInt::LuauTarjanPreallocationSize);
}

void Tarjan::visitChildren(TypeId ty, int index) {
  LUAU_ASSERT(ty == log->follow(ty));

  if (ignoreChildrenVisit(ty))
    return;

  if (auto pty = log->pending(ty))
    ty = &pty->pending;

  if (const FunctionType *ftv = get<FunctionType>(ty)) {
    for (TypeId generic : ftv->generics)
      visitChild(generic);
    for (TypePackId genericPack : ftv->genericPacks)
      visitChild(genericPack);

    visitChild(ftv->argTypes);
    visitChild(ftv->retTypes);
  } else if (const TableType *ttv = get<TableType>(ty)) {
    LUAU_ASSERT(!ttv->boundTo);
    for (const auto &[name, prop] : ttv->props) {
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        visitChild(prop.readTy);
        visitChild(prop.writeTy);
      } else
        visitChild(prop.type());
    }

    if (ttv->indexer) {
      visitChild(ttv->indexer->indexType);
      visitChild(ttv->indexer->indexResultType);
    }

    for (TypeId itp : ttv->instantiatedTypeParams)
      visitChild(itp);

    for (TypePackId itp : ttv->instantiatedTypePackParams)
      visitChild(itp);
  } else if (const MetatableType *mtv = get<MetatableType>(ty)) {
    visitChild(mtv->table);
    visitChild(mtv->metatable);
  } else if (const UnionType *utv = get<UnionType>(ty)) {
    for (TypeId opt : utv->options)
      visitChild(opt);
  } else if (const IntersectionType *itv = get<IntersectionType>(ty)) {
    for (TypeId part : itv->parts)
      visitChild(part);
  } else if (const PendingExpansionType *petv = get<PendingExpansionType>(ty)) {
    for (TypeId a : petv->typeArguments)
      visitChild(a);

    for (TypePackId a : petv->packArguments)
      visitChild(a);
  } else if (const TypeFunctionInstanceType *tfit =
                 get<TypeFunctionInstanceType>(ty)) {
    for (TypeId a : tfit->typeArguments)
      visitChild(a);

    for (TypePackId a : tfit->packArguments)
      visitChild(a);
  } else if (const ClassType *ctv = get<ClassType>(ty)) {
    for (const auto &[name, prop] : ctv->props)
      visitChild(prop.type());

    if (ctv->parent)
      visitChild(*ctv->parent);

    if (ctv->metatable)
      visitChild(*ctv->metatable);

    if (ctv->indexer) {
      visitChild(ctv->indexer->indexType);
      visitChild(ctv->indexer->indexResultType);
    }
  } else if (const NegationType *ntv = get<NegationType>(ty)) {
    visitChild(ntv->ty);
  }
}

void Tarjan::visitChildren(TypePackId tp, int index) {
  LUAU_ASSERT(tp == log->follow(tp));

  if (ignoreChildrenVisit(tp))
    return;

  if (auto ptp = log->pending(tp))
    tp = &ptp->pending;

  if (const TypePack *tpp = get<TypePack>(tp)) {
    for (TypeId tv : tpp->head)
      visitChild(tv);
    if (tpp->tail)
      visitChild(*tpp->tail);
  } else if (const VariadicTypePack *vtp = get<VariadicTypePack>(tp)) {
    visitChild(vtp->ty);
  }
}

std::pair<int, bool> Tarjan::indexify(TypeId ty) {
  ty = log->follow(ty);

  auto [index, fresh] = typeToIndex.try_insert(ty, false);

  if (fresh) {
    index = int(nodes.size());
    nodes.push_back({ty, nullptr, false, false, index});
  }

  return {index, fresh};
}

std::pair<int, bool> Tarjan::indexify(TypePackId tp) {
  tp = log->follow(tp);

  auto [index, fresh] = packToIndex.try_insert(tp, false);

  if (fresh) {
    index = int(nodes.size());
    nodes.push_back({nullptr, tp, false, false, index});
  }

  return {index, fresh};
}

void Tarjan::visitChild(TypeId ty) {
  ty = log->follow(ty);

  edgesTy.push_back(ty);
  edgesTp.push_back(nullptr);
}

void Tarjan::visitChild(TypePackId tp) {
  tp = log->follow(tp);

  edgesTy.push_back(nullptr);
  edgesTp.push_back(tp);
}

TarjanResult Tarjan::loop() {
  // Normally Tarjan is presented recursively, but this is a hot loop, so worth
  // optimizing
  while (!worklist.empty()) {
    auto [index, currEdge, lastEdge] = worklist.back();

    // First visit
    if (currEdge == -1) {
      ++childCount;
      if (childLimit > 0 && childLimit <= childCount)
        return TarjanResult::TooManyChildren;

      stack.push_back(index);

      nodes[index].onStack = true;

      currEdge = int(edgesTy.size());

      // Fill in edge list of this vertex
      if (TypeId ty = nodes[index].ty)
        visitChildren(ty, index);
      else if (TypePackId tp = nodes[index].tp)
        visitChildren(tp, index);

      lastEdge = int(edgesTy.size());
    }

    // Visit children
    bool foundFresh = false;

    for (; currEdge < lastEdge; currEdge++) {
      int childIndex = -1;
      bool fresh = false;

      if (auto ty = edgesTy[currEdge])
        std::tie(childIndex, fresh) = indexify(ty);
      else if (auto tp = edgesTp[currEdge])
        std::tie(childIndex, fresh) = indexify(tp);
      else
        LUAU_ASSERT(false);

      if (fresh) {
        // Original recursion point, update the parent continuation point and
        // start the new element
        worklist.back() = {index, currEdge + 1, lastEdge};
        worklist.push_back({childIndex, -1, -1});

        // We need to continue the top-level loop from the start with the new
        // worklist element
        foundFresh = true;
        break;
      } else if (nodes[childIndex].onStack) {
        nodes[index].lowlink = std::min(nodes[index].lowlink, childIndex);
      }

      visitEdge(childIndex, index);
    }

    if (foundFresh)
      continue;

    if (nodes[index].lowlink == index) {
      visitSCC(index);
      while (!stack.empty()) {
        int popped = stack.back();
        stack.pop_back();
        nodes[popped].onStack = false;
        if (popped == index)
          break;
      }
    }

    worklist.pop_back();

    // Original return from recursion into a child
    if (!worklist.empty()) {
      auto [parentIndex, _, parentEndEdge] = worklist.back();

      // No need to keep child edges around
      edgesTy.resize(parentEndEdge);
      edgesTp.resize(parentEndEdge);

      nodes[parentIndex].lowlink =
          std::min(nodes[parentIndex].lowlink, nodes[index].lowlink);
      visitEdge(index, parentIndex);
    }
  }

  return TarjanResult::Ok;
}

TarjanResult Tarjan::visitRoot(TypeId ty) {
  childCount = 0;
  if (childLimit == 0)
    childLimit = FInt::LuauTarjanChildLimit;

  ty = log->follow(ty);

  auto [index, fresh] = indexify(ty);
  worklist.push_back({index, -1, -1});
  return loop();
}

TarjanResult Tarjan::visitRoot(TypePackId tp) {
  childCount = 0;
  if (childLimit == 0)
    childLimit = FInt::LuauTarjanChildLimit;

  tp = log->follow(tp);

  auto [index, fresh] = indexify(tp);
  worklist.push_back({index, -1, -1});
  return loop();
}

void Tarjan::clearTarjan(const TxnLog *log) {
  if (FFlag::LuauReusableSubstitutions) {
    typeToIndex.clear(~0u);
    packToIndex.clear(~0u);
  } else {
    typeToIndex.clear();
    packToIndex.clear();
  }

  nodes.clear();

  stack.clear();

  if (FFlag::LuauReusableSubstitutions) {
    childCount = 0;
    // childLimit setting stays the same

    this->log = log;
  }

  edgesTy.clear();
  edgesTp.clear();
  worklist.clear();
}

bool Tarjan::getDirty(int index) {
  LUAU_ASSERT(size_t(index) < nodes.size());
  return nodes[index].dirty;
}

void Tarjan::setDirty(int index, bool d) {
  LUAU_ASSERT(size_t(index) < nodes.size());
  nodes[index].dirty = d;
}

void Tarjan::visitEdge(int index, int parentIndex) {
  if (getDirty(index))
    setDirty(parentIndex, true);
}

void Tarjan::visitSCC(int index) {
  bool d = getDirty(index);

  for (auto it = stack.rbegin(); !d && it != stack.rend(); it++) {
    TarjanNode &node = nodes[*it];

    if (TypeId ty = node.ty)
      d = isDirty(ty);
    else if (TypePackId tp = node.tp)
      d = isDirty(tp);

    if (*it == index)
      break;
  }

  if (!d)
    return;

  for (auto it = stack.rbegin(); it != stack.rend(); it++) {
    setDirty(*it, true);

    TarjanNode &node = nodes[*it];

    if (TypeId ty = node.ty)
      foundDirty(ty);
    else if (TypePackId tp = node.tp)
      foundDirty(tp);

    if (*it == index)
      return;
  }
}

TarjanResult Tarjan::findDirty(TypeId ty) { return visitRoot(ty); }

TarjanResult Tarjan::findDirty(TypePackId tp) { return visitRoot(tp); }

Substitution::Substitution(const TxnLog *log_, TypeArena *arena)
    : arena(arena) {
  log = log_;
  LUAU_ASSERT(log);
}

void Substitution::dontTraverseInto(TypeId ty) { noTraverseTypes.insert(ty); }

void Substitution::dontTraverseInto(TypePackId tp) {
  noTraverseTypePacks.insert(tp);
}

std::optional<TypeId> Substitution::substitute(TypeId ty) {
  ty = log->follow(ty);

  // clear algorithm state for reentrancy
  clearTarjan(log);

  auto result = findDirty(ty);
  if (result != TarjanResult::Ok)
    return std::nullopt;

  for (auto [oldTy, newTy] : newTypes) {
    if (!ignoreChildren(oldTy) && !replacedTypes.contains(newTy)) {
      if (!noTraverseTypes.contains(newTy))
        replaceChildren(newTy);
      replacedTypes.insert(newTy);
    }
  }
  for (auto [oldTp, newTp] : newPacks) {
    if (!ignoreChildren(oldTp) && !replacedTypePacks.contains(newTp)) {
      if (!noTraverseTypePacks.contains(newTp))
        replaceChildren(newTp);
      replacedTypePacks.insert(newTp);
    }
  }
  TypeId newTy = replace(ty);
  return newTy;
}

std::optional<TypePackId> Substitution::substitute(TypePackId tp) {
  tp = log->follow(tp);

  // clear algorithm state for reentrancy
  clearTarjan(log);

  auto result = findDirty(tp);
  if (result != TarjanResult::Ok)
    return std::nullopt;

  for (auto [oldTy, newTy] : newTypes) {
    if (!ignoreChildren(oldTy) && !replacedTypes.contains(newTy)) {
      if (!noTraverseTypes.contains(newTy))
        replaceChildren(newTy);
      replacedTypes.insert(newTy);
    }
  }
  for (auto [oldTp, newTp] : newPacks) {
    if (!ignoreChildren(oldTp) && !replacedTypePacks.contains(newTp)) {
      if (!noTraverseTypePacks.contains(newTp))
        replaceChildren(newTp);
      replacedTypePacks.insert(newTp);
    }
  }
  TypePackId newTp = replace(tp);
  return newTp;
}

void Substitution::resetState(const TxnLog *log, TypeArena *arena) {
  LUAU_ASSERT(FFlag::LuauReusableSubstitutions);

  clearTarjan(log);

  this->arena = arena;

  newTypes.clear();
  newPacks.clear();
  replacedTypes.clear();
  replacedTypePacks.clear();

  noTraverseTypes.clear();
  noTraverseTypePacks.clear();
}

TypeId Substitution::clone(TypeId ty) {
  return shallowClone(ty, *arena, log, /* alwaysClone */ true);
}

TypePackId Substitution::clone(TypePackId tp) {
  tp = log->follow(tp);

  if (auto ptp = log->pending(tp))
    tp = &ptp->pending;

  if (const TypePack *tpp = get<TypePack>(tp)) {
    TypePack clone;
    clone.head = tpp->head;
    clone.tail = tpp->tail;
    return addTypePack(std::move(clone));
  } else if (const VariadicTypePack *vtp = get<VariadicTypePack>(tp)) {
    VariadicTypePack clone;
    clone.ty = vtp->ty;
    clone.hidden = vtp->hidden;
    return addTypePack(std::move(clone));
  } else if (const TypeFunctionInstanceTypePack *tfitp =
                 get<TypeFunctionInstanceTypePack>(tp)) {
    TypeFunctionInstanceTypePack clone{
        tfitp->family, std::vector<TypeId>(tfitp->typeArguments.size()),
        std::vector<TypePackId>(tfitp->packArguments.size())};
    clone.typeArguments.assign(tfitp->typeArguments.begin(),
                               tfitp->typeArguments.end());
    clone.packArguments.assign(tfitp->packArguments.begin(),
                               tfitp->packArguments.end());
    return addTypePack(std::move(clone));
  } else
    return addTypePack(*tp);
}

void Substitution::foundDirty(TypeId ty) {
  ty = log->follow(ty);

  if (newTypes.contains(ty))
    return;

  if (isDirty(ty))
    newTypes[ty] = follow(clean(ty));
  else
    newTypes[ty] = follow(clone(ty));
}

void Substitution::foundDirty(TypePackId tp) {
  tp = log->follow(tp);

  if (newPacks.contains(tp))
    return;

  if (isDirty(tp))
    newPacks[tp] = follow(clean(tp));
  else
    newPacks[tp] = follow(clone(tp));
}

TypeId Substitution::replace(TypeId ty) {
  ty = log->follow(ty);

  if (TypeId *prevTy = newTypes.find(ty))
    return *prevTy;
  else
    return ty;
}

TypePackId Substitution::replace(TypePackId tp) {
  tp = log->follow(tp);

  if (TypePackId *prevTp = newPacks.find(tp))
    return *prevTp;
  else
    return tp;
}

void Substitution::replaceChildren(TypeId ty) {
  LUAU_ASSERT(ty == log->follow(ty));

  if (ignoreChildren(ty))
    return;

  if (ty->owningArena != arena)
    return;

  if (FunctionType *ftv = getMutable<FunctionType>(ty)) {
    for (TypeId &generic : ftv->generics)
      generic = replace(generic);
    for (TypePackId &genericPack : ftv->genericPacks)
      genericPack = replace(genericPack);

    ftv->argTypes = replace(ftv->argTypes);
    ftv->retTypes = replace(ftv->retTypes);
  } else if (TableType *ttv = getMutable<TableType>(ty)) {
    LUAU_ASSERT(!ttv->boundTo);
    for (auto &[name, prop] : ttv->props) {
      if (FFlag::DebugLuauDeferredConstraintResolution) {
        if (prop.readTy)
          prop.readTy = replace(prop.readTy);
        if (prop.writeTy)
          prop.writeTy = replace(prop.writeTy);
      } else
        prop.setType(replace(prop.type()));
    }

    if (ttv->indexer) {
      ttv->indexer->indexType = replace(ttv->indexer->indexType);
      ttv->indexer->indexResultType = replace(ttv->indexer->indexResultType);
    }

    for (TypeId &itp : ttv->instantiatedTypeParams)
      itp = replace(itp);

    for (TypePackId &itp : ttv->instantiatedTypePackParams)
      itp = replace(itp);
  } else if (MetatableType *mtv = getMutable<MetatableType>(ty)) {
    mtv->table = replace(mtv->table);
    mtv->metatable = replace(mtv->metatable);
  } else if (UnionType *utv = getMutable<UnionType>(ty)) {
    for (TypeId &opt : utv->options)
      opt = replace(opt);
  } else if (IntersectionType *itv = getMutable<IntersectionType>(ty)) {
    for (TypeId &part : itv->parts)
      part = replace(part);
  } else if (PendingExpansionType *petv =
                 getMutable<PendingExpansionType>(ty)) {
    for (TypeId &a : petv->typeArguments)
      a = replace(a);

    for (TypePackId &a : petv->packArguments)
      a = replace(a);
  } else if (TypeFunctionInstanceType *tfit =
                 getMutable<TypeFunctionInstanceType>(ty)) {
    for (TypeId &a : tfit->typeArguments)
      a = replace(a);

    for (TypePackId &a : tfit->packArguments)
      a = replace(a);
  } else if (ClassType *ctv = getMutable<ClassType>(ty)) {
    for (auto &[name, prop] : ctv->props)
      prop.setType(replace(prop.type()));

    if (ctv->parent)
      ctv->parent = replace(*ctv->parent);

    if (ctv->metatable)
      ctv->metatable = replace(*ctv->metatable);

    if (ctv->indexer) {
      ctv->indexer->indexType = replace(ctv->indexer->indexType);
      ctv->indexer->indexResultType = replace(ctv->indexer->indexResultType);
    }
  } else if (NegationType *ntv = getMutable<NegationType>(ty)) {
    ntv->ty = replace(ntv->ty);
  }
}

void Substitution::replaceChildren(TypePackId tp) {
  LUAU_ASSERT(tp == log->follow(tp));

  if (ignoreChildren(tp))
    return;

  if (tp->owningArena != arena)
    return;

  if (TypePack *tpp = getMutable<TypePack>(tp)) {
    for (TypeId &tv : tpp->head)
      tv = replace(tv);
    if (tpp->tail)
      tpp->tail = replace(*tpp->tail);
  } else if (VariadicTypePack *vtp = getMutable<VariadicTypePack>(tp)) {
    vtp->ty = replace(vtp->ty);
  } else if (TypeFunctionInstanceTypePack *tfitp =
                 getMutable<TypeFunctionInstanceTypePack>(tp)) {
    for (TypeId &t : tfitp->typeArguments)
      t = replace(t);

    for (TypePackId &t : tfitp->packArguments)
      t = replace(t);
  }
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Refinement.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

namespace Luau {

RefinementId RefinementArena::variadic(const std::vector<RefinementId> &refis) {
  bool hasRefinements = false;
  for (RefinementId r : refis)
    hasRefinements |= bool(r);

  if (!hasRefinements)
    return nullptr;

  return NotNull{allocator.allocate(Variadic{refis})};
}

RefinementId RefinementArena::negation(RefinementId refinement) {
  if (!refinement)
    return nullptr;

  return NotNull{allocator.allocate(Negation{refinement})};
}

RefinementId RefinementArena::conjunction(RefinementId lhs, RefinementId rhs) {
  if (!lhs && !rhs)
    return nullptr;

  return NotNull{allocator.allocate(Conjunction{lhs, rhs})};
}

RefinementId RefinementArena::disjunction(RefinementId lhs, RefinementId rhs) {
  if (!lhs && !rhs)
    return nullptr;

  return NotNull{allocator.allocate(Disjunction{lhs, rhs})};
}

RefinementId RefinementArena::equivalence(RefinementId lhs, RefinementId rhs) {
  if (!lhs && !rhs)
    return nullptr;

  return NotNull{allocator.allocate(Equivalence{lhs, rhs})};
}

RefinementId RefinementArena::proposition(const RefinementKey *key,
                                          TypeId discriminantTy) {
  if (!key)
    return nullptr;

  return NotNull{allocator.allocate(Proposition{key, discriminantTy})};
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/OverloadResolution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation2.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifier2.h>

namespace Luau {

OverloadResolver::OverloadResolver(NotNull<BuiltinTypes> builtinTypes,
                                   NotNull<TypeArena> arena,
                                   NotNull<Normalizer> normalizer,
                                   NotNull<Scope> scope,
                                   NotNull<InternalErrorReporter> reporter,
                                   NotNull<TypeCheckLimits> limits,
                                   Location callLocation)
    : builtinTypes(builtinTypes), arena(arena), normalizer(normalizer),
      scope(scope), ice(reporter), limits(limits),
      subtyping({builtinTypes, arena, normalizer, ice, scope}),
      callLoc(callLocation) {}

std::pair<OverloadResolver::Analysis, TypeId>
OverloadResolver::selectOverload(TypeId ty, TypePackId argsPack) {
  auto tryOne = [&](TypeId f) {
    if (auto ftv = get<FunctionType>(f)) {
      SubtypingResult r = subtyping.isSubtype(argsPack, ftv->argTypes);
      if (r.isSubtype)
        return true;
    }

    return false;
  };

  TypeId t = follow(ty);

  if (tryOne(ty))
    return {Analysis::Ok, ty};

  if (auto it = get<IntersectionType>(t)) {
    for (TypeId component : it) {
      if (tryOne(component))
        return {Analysis::Ok, component};
    }
  }

  return {Analysis::OverloadIsNonviable, ty};
}

void OverloadResolver::resolve(TypeId fnTy, const TypePack *args,
                               AstExpr *selfExpr,
                               const std::vector<AstExpr *> *argExprs) {
  fnTy = follow(fnTy);

  auto it = get<IntersectionType>(fnTy);
  if (!it) {
    auto [analysis, errors] = checkOverload(fnTy, args, selfExpr, argExprs);
    add(analysis, fnTy, std::move(errors));
    return;
  }

  for (TypeId ty : it) {
    if (resolution.find(ty) != resolution.end())
      continue;

    auto [analysis, errors] = checkOverload(ty, args, selfExpr, argExprs);
    add(analysis, ty, std::move(errors));
  }
}

std::optional<ErrorVec>
OverloadResolver::testIsSubtype(const Location &location, TypeId subTy,
                                TypeId superTy) {
  auto r = subtyping.isSubtype(subTy, superTy);
  ErrorVec errors;

  if (r.normalizationTooComplex)
    errors.emplace_back(location, NormalizationTooComplex{});

  if (!r.isSubtype) {
    switch (shouldSuppressErrors(normalizer, subTy)
                .orElse(shouldSuppressErrors(normalizer, superTy))) {
    case ErrorSuppression::Suppress:
      break;
    case ErrorSuppression::NormalizationFailed:
      errors.emplace_back(location, NormalizationTooComplex{});
      // intentionally fallthrough here since we couldn't prove this was
      // error-suppressing
    case ErrorSuppression::DoNotSuppress:
      errors.emplace_back(location, TypeMismatch{superTy, subTy});
      break;
    }
  }

  if (errors.empty())
    return std::nullopt;

  return errors;
}

std::optional<ErrorVec>
OverloadResolver::testIsSubtype(const Location &location, TypePackId subTy,
                                TypePackId superTy) {
  auto r = subtyping.isSubtype(subTy, superTy);
  ErrorVec errors;

  if (r.normalizationTooComplex)
    errors.emplace_back(location, NormalizationTooComplex{});

  if (!r.isSubtype) {
    switch (shouldSuppressErrors(normalizer, subTy)
                .orElse(shouldSuppressErrors(normalizer, superTy))) {
    case ErrorSuppression::Suppress:
      break;
    case ErrorSuppression::NormalizationFailed:
      errors.emplace_back(location, NormalizationTooComplex{});
      // intentionally fallthrough here since we couldn't prove this was
      // error-suppressing
    case ErrorSuppression::DoNotSuppress:
      errors.emplace_back(location, TypePackMismatch{superTy, subTy});
      break;
    }
  }

  if (errors.empty())
    return std::nullopt;

  return errors;
}

std::pair<OverloadResolver::Analysis, ErrorVec> OverloadResolver::checkOverload(
    TypeId fnTy, const TypePack *args, AstExpr *fnLoc,
    const std::vector<AstExpr *> *argExprs, bool callMetamethodOk) {
  fnTy = follow(fnTy);

  ErrorVec discard;
  if (get<AnyType>(fnTy) || get<ErrorType>(fnTy) || get<NeverType>(fnTy))
    return {Ok, {}};
  else if (auto fn = get<FunctionType>(fnTy))
    return checkOverload_(fnTy, fn, args, fnLoc,
                          argExprs); // Intentionally split to reduce the stack
                                     // pressure of this function.
  else if (auto callMm = findMetatableEntry(builtinTypes, discard, fnTy,
                                            "__call", callLoc);
           callMm && callMetamethodOk) {
    // Calling a metamethod forwards the `fnTy` as self.
    TypePack withSelf = *args;
    withSelf.head.insert(withSelf.head.begin(), fnTy);

    std::vector<AstExpr *> withSelfExprs = *argExprs;
    withSelfExprs.insert(withSelfExprs.begin(), fnLoc);

    return checkOverload(*callMm, &withSelf, fnLoc, &withSelfExprs,
                         /*callMetamethodOk=*/false);
  } else
    return {TypeIsNotAFunction, {}}; // Intentionally empty. We can just
                                     // fabricate the type error later on.
}

bool OverloadResolver::isLiteral(AstExpr *expr) {
  if (auto group = expr->as<AstExprGroup>())
    return isLiteral(group->expr);
  else if (auto assertion = expr->as<AstExprTypeAssertion>())
    return isLiteral(assertion->expr);

  return expr->is<AstExprConstantNil>() || expr->is<AstExprConstantBool>() ||
         expr->is<AstExprConstantNumber>() ||
         expr->is<AstExprConstantString>() || expr->is<AstExprFunction>() ||
         expr->is<AstExprTable>();
}

std::pair<OverloadResolver::Analysis, ErrorVec>
OverloadResolver::checkOverload_(TypeId fnTy, const FunctionType *fn,
                                 const TypePack *args, AstExpr *fnExpr,
                                 const std::vector<AstExpr *> *argExprs) {
  FunctionGraphReductionResult result = reduceTypeFunctions(
      fnTy, callLoc,
      TypeFunctionContext{arena, builtinTypes, scope, normalizer, ice, limits},
      /*force=*/true);
  if (!result.errors.empty())
    return {OverloadIsNonviable, result.errors};

  ErrorVec argumentErrors;
  TypePackId typ = arena->addTypePack(*args);

  TypeId prospectiveFunction =
      arena->addType(FunctionType{typ, builtinTypes->anyTypePack});
  SubtypingResult sr = subtyping.isSubtype(fnTy, prospectiveFunction);

  if (sr.isSubtype)
    return {Analysis::Ok, {}};

  if (1 == sr.reasoning.size()) {
    const SubtypingReasoning &reason = *sr.reasoning.begin();

    const TypePath::Path justArguments{TypePath::PackField::Arguments};

    if (reason.subPath == justArguments && reason.superPath == justArguments) {
      // If the subtype test failed only due to an arity mismatch,
      // it is still possible that this function call is okay.
      // Subtype testing does not know anything about optional
      // function arguments.
      //
      // This can only happen if the actual function call has a
      // finite set of arguments which is too short for the
      // function being called.  If all of those unsatisfied
      // function arguments are options, then this function call
      // is ok.

      const size_t firstUnsatisfiedArgument = argExprs->size();
      const auto [requiredHead, _requiredTail] = flatten(fn->argTypes);

      // If too many arguments were supplied, this overload
      // definitely does not match.
      if (args->head.size() > requiredHead.size()) {
        auto [minParams, optMaxParams] =
            getParameterExtents(TxnLog::empty(), fn->argTypes);
        TypeError error{fnExpr->location,
                        CountMismatch{minParams, optMaxParams,
                                      args->head.size(), CountMismatch::Arg,
                                      false}};

        return {Analysis::ArityMismatch, {error}};
      }

      // If any of the unsatisfied arguments are not supertypes of
      // nil, then this overload does not match.
      for (size_t i = firstUnsatisfiedArgument; i < requiredHead.size(); ++i) {
        if (!subtyping.isSubtype(builtinTypes->nilType, requiredHead[i])
                 .isSubtype) {
          auto [minParams, optMaxParams] =
              getParameterExtents(TxnLog::empty(), fn->argTypes);
          TypeError error{fnExpr->location,
                          CountMismatch{minParams, optMaxParams,
                                        args->head.size(), CountMismatch::Arg,
                                        false}};

          return {Analysis::ArityMismatch, {error}};
        }
      }

      return {Analysis::Ok, {}};
    }
  }

  ErrorVec errors;

  for (const SubtypingReasoning &reason : sr.reasoning) {
    /* The return type of our prospective function is always
     * any... so any subtype failures here can only arise from
     * argument type mismatches.
     */

    Location argLocation;
    if (reason.superPath.components.size() <= 1)
      break;

    if (const Luau::TypePath::Index *pathIndexComponent =
            get_if<Luau::TypePath::Index>(&reason.superPath.components.at(1))) {
      size_t nthArgument = pathIndexComponent->index;
      // if the nth type argument to the function is less than the number of ast
      // expressions we passed to the function we should be able to pull out the
      // location of the argument If the nth type argument to the function is
      // out of range of the ast expressions we passed to the function e.g.
      // table.pack(functionThatReturnsMultipleArguments(arg1, arg2, ....)),
      // default to the location of the last passed expression If we passed no
      // expression arguments to the call, default to the location of the
      // function expression.
      argLocation = nthArgument < argExprs->size()
                        ? argExprs->at(nthArgument)->location
                    : argExprs->size() != 0 ? argExprs->back()->location
                                            : fnExpr->location;

      std::optional<TypeId> failedSubTy =
          traverseForType(fnTy, reason.subPath, builtinTypes);
      std::optional<TypeId> failedSuperTy =
          traverseForType(prospectiveFunction, reason.superPath, builtinTypes);

      if (failedSubTy && failedSuperTy) {

        switch (shouldSuppressErrors(normalizer, *failedSubTy)
                    .orElse(shouldSuppressErrors(normalizer, *failedSuperTy))) {
        case ErrorSuppression::Suppress:
          break;
        case ErrorSuppression::NormalizationFailed:
          errors.emplace_back(argLocation, NormalizationTooComplex{});
          // intentionally fallthrough here since we couldn't prove this was
          // error-suppressing
        case ErrorSuppression::DoNotSuppress:
          // TODO extract location from the SubtypingResult path and argExprs
          switch (reason.variance) {
          case SubtypingVariance::Covariant:
          case SubtypingVariance::Contravariant:
            errors.emplace_back(argLocation,
                                TypeMismatch{*failedSubTy, *failedSuperTy,
                                             TypeMismatch::CovariantContext});
            break;
          case SubtypingVariance::Invariant:
            errors.emplace_back(argLocation,
                                TypeMismatch{*failedSubTy, *failedSuperTy,
                                             TypeMismatch::InvariantContext});
            break;
          default:
            LUAU_ASSERT(0);
            break;
          }
        }
      }
    }

    std::optional<TypePackId> failedSubPack =
        traverseForPack(fnTy, reason.subPath, builtinTypes);
    std::optional<TypePackId> failedSuperPack =
        traverseForPack(prospectiveFunction, reason.superPath, builtinTypes);

    if (failedSubPack && failedSuperPack) {
      // If a bug in type inference occurs, we may have a mismatch in the return
      // packs. This happens when inference incorrectly leaves the result type
      // of a function free. If this happens, we don't want to explode, so we'll
      // use the function's location.
      if (argExprs->empty())
        argLocation = fnExpr->location;
      else
        argLocation = argExprs->at(argExprs->size() - 1)->location;

      // TODO extract location from the SubtypingResult path and argExprs
      switch (reason.variance) {
      case SubtypingVariance::Covariant:
        errors.emplace_back(argLocation,
                            TypePackMismatch{*failedSubPack, *failedSuperPack});
        break;
      case SubtypingVariance::Contravariant:
        errors.emplace_back(argLocation,
                            TypePackMismatch{*failedSuperPack, *failedSubPack});
        break;
      case SubtypingVariance::Invariant:
        errors.emplace_back(argLocation,
                            TypePackMismatch{*failedSubPack, *failedSuperPack});
        break;
      default:
        LUAU_ASSERT(0);
        break;
      }
    }
  }

  return {Analysis::OverloadIsNonviable, std::move(errors)};
}

size_t OverloadResolver::indexof(Analysis analysis) {
  switch (analysis) {
  case Ok:
    return ok.size();
  case TypeIsNotAFunction:
    return nonFunctions.size();
  case ArityMismatch:
    return arityMismatches.size();
  case OverloadIsNonviable:
    return nonviableOverloads.size();
  }

  ice->ice("Inexhaustive switch in FunctionCallResolver::indexof");
}

void OverloadResolver::add(Analysis analysis, TypeId ty, ErrorVec &&errors) {
  resolution.insert(ty, {analysis, indexof(analysis)});

  switch (analysis) {
  case Ok:
    LUAU_ASSERT(errors.empty());
    ok.push_back(ty);
    break;
  case TypeIsNotAFunction:
    LUAU_ASSERT(errors.empty());
    nonFunctions.push_back(ty);
    break;
  case ArityMismatch:
    LUAU_ASSERT(!errors.empty());
    arityMismatches.emplace_back(ty, std::move(errors));
    break;
  case OverloadIsNonviable:
    nonviableOverloads.emplace_back(ty, std::move(errors));
    break;
  }
}

// we wrap calling the overload resolver in a separate function to reduce
// overall stack pressure in `solveFunctionCall`. this limits the lifetime of
// `OverloadResolver`, a large type, to only as long as it is actually needed.
std::optional<TypeId>
selectOverload(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena,
               NotNull<Normalizer> normalizer, NotNull<Scope> scope,
               NotNull<InternalErrorReporter> iceReporter,
               NotNull<TypeCheckLimits> limits, const Location &location,
               TypeId fn, TypePackId argsPack) {
  OverloadResolver resolver{builtinTypes, arena,  normalizer, scope,
                            iceReporter,  limits, location};
  auto [status, overload] = resolver.selectOverload(fn, argsPack);

  if (status == OverloadResolver::Analysis::Ok)
    return overload;

  if (get<AnyType>(fn) || get<FreeType>(fn))
    return fn;

  return {};
}

SolveResult solveFunctionCall(NotNull<TypeArena> arena,
                              NotNull<BuiltinTypes> builtinTypes,
                              NotNull<Normalizer> normalizer,
                              NotNull<InternalErrorReporter> iceReporter,
                              NotNull<TypeCheckLimits> limits,
                              NotNull<Scope> scope, const Location &location,
                              TypeId fn, TypePackId argsPack) {
  std::optional<TypeId> overloadToUse =
      selectOverload(builtinTypes, arena, normalizer, scope, iceReporter,
                     limits, location, fn, argsPack);
  if (!overloadToUse)
    return {SolveResult::NoMatchingOverload};

  TypePackId resultPack = arena->freshTypePack(scope);

  TypeId inferredTy = arena->addType(
      FunctionType{TypeLevel{}, scope.get(), argsPack, resultPack});
  Unifier2 u2{NotNull{arena}, builtinTypes, scope, iceReporter};

  const bool occursCheckPassed = u2.unify(*overloadToUse, inferredTy);

  if (!u2.genericSubstitutions.empty() ||
      !u2.genericPackSubstitutions.empty()) {
    Instantiation2 instantiation{arena, std::move(u2.genericSubstitutions),
                                 std::move(u2.genericPackSubstitutions)};

    std::optional<TypePackId> subst = instantiation.substitute(resultPack);

    if (!subst)
      return {SolveResult::CodeTooComplex};
    else
      resultPack = *subst;
  }

  if (!occursCheckPassed)
    return {SolveResult::OccursCheckFailed};

  SolveResult result;
  result.result = SolveResult::Ok;
  result.typePackId = resultPack;

  LUAU_ASSERT(overloadToUse);
  result.overloadToUse = *overloadToUse;
  result.inferredTy = inferredTy;
  result.expandedFreeTypes = std::move(u2.expandedFreeTypes);

  return result;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation2.h>

namespace Luau {

bool Instantiation2::ignoreChildren(TypeId ty) {
  if (get<ClassType>(ty))
    return true;
  return false;
}

bool Instantiation2::isDirty(TypeId ty) {
  return get<GenericType>(ty) && genericSubstitutions.contains(ty);
}

bool Instantiation2::isDirty(TypePackId tp) {
  return get<GenericTypePack>(tp) && genericPackSubstitutions.contains(tp);
}

TypeId Instantiation2::clean(TypeId ty) {
  TypeId substTy = follow(genericSubstitutions[ty]);
  const FreeType *ft = get<FreeType>(substTy);

  // violation of the substitution invariant if this is not a free type.
  LUAU_ASSERT(ft);

  // if we didn't learn anything about the lower bound, we pick the upper bound
  // instead. we default to the lower bound which represents the most specific
  // type for the free type.
  TypeId res = get<NeverType>(ft->lowerBound) ? ft->upperBound : ft->lowerBound;

  // Instantiation should not traverse into the type that we are substituting
  // for.
  dontTraverseInto(res);

  return res;
}

TypePackId Instantiation2::clean(TypePackId tp) {
  TypePackId res = genericPackSubstitutions[tp];
  dontTraverseInto(res);
  return res;
}

std::optional<TypeId> instantiate2(
    TypeArena *arena, DenseHashMap<TypeId, TypeId> genericSubstitutions,
    DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions, TypeId ty) {
  Instantiation2 instantiation{arena, std::move(genericSubstitutions),
                               std::move(genericPackSubstitutions)};
  return instantiation.substitute(ty);
}

std::optional<TypePackId>
instantiate2(TypeArena *arena,
             DenseHashMap<TypeId, TypeId> genericSubstitutions,
             DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions,
             TypePackId tp) {
  Instantiation2 instantiation{arena, std::move(genericSubstitutions),
                               std::move(genericPackSubstitutions)};
  return instantiation.substitute(tp);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/ApplyTypeFunction.h>

namespace Luau {

bool ApplyTypeFunction::isDirty(TypeId ty) {
  if (typeArguments.count(ty))
    return true;
  else if (const FreeType *ftv = get<FreeType>(ty)) {
    if (ftv->forwardedTypeAlias)
      encounteredForwardedType = true;
    return false;
  } else
    return false;
}

bool ApplyTypeFunction::isDirty(TypePackId tp) {
  if (typePackArguments.count(tp))
    return true;
  else
    return false;
}

bool ApplyTypeFunction::ignoreChildren(TypeId ty) {
  if (get<GenericType>(ty))
    return true;
  else if (get<ClassType>(ty))
    return true;
  else
    return false;
}

bool ApplyTypeFunction::ignoreChildren(TypePackId tp) {
  if (get<GenericTypePack>(tp))
    return true;
  else
    return false;
}

TypeId ApplyTypeFunction::clean(TypeId ty) {
  TypeId &arg = typeArguments[ty];
  LUAU_ASSERT(arg);
  return arg;
}

TypePackId ApplyTypeFunction::clean(TypePackId tp) {
  TypePackId &arg = typePackArguments[tp];
  LUAU_ASSERT(arg);
  return arg;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included!
// <Luau/TypeFunctionReductionGuesser.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VecDeque.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@ PACK.lua : not found, likely and std header
#include <iostream>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@ PACK.lua : not found, likely and std header
#include <ostream>

namespace Luau {
struct InstanceCollector2 : TypeOnceVisitor {
  VecDeque<TypeId> tys;
  VecDeque<TypePackId> tps;
  DenseHashSet<TypeId> cyclicInstance{nullptr};
  DenseHashSet<TypeId> instanceArguments{nullptr};

  bool visit(TypeId ty, const TypeFunctionInstanceType &it) override {
    // TypeOnceVisitor performs a depth-first traversal in the absence of
    // cycles. This means that by pushing to the front of the queue, we will
    // try to reduce deeper instances first if we start with the first thing
    // in the queue. Consider Add<Add<Add<number, number>, number>, number>:
    // we want to reduce the innermost Add<number, number> instantiation
    // first.
    tys.push_front(ty);
    for (auto t : it.typeArguments)
      instanceArguments.insert(follow(t));
    return true;
  }

  void cycle(TypeId ty) override {
    /// Detected cyclic type pack
    TypeId t = follow(ty);
    if (get<TypeFunctionInstanceType>(t))
      cyclicInstance.insert(t);
  }

  bool visit(TypeId ty, const ClassType &) override { return false; }

  bool visit(TypePackId tp, const TypeFunctionInstanceTypePack &) override {
    // TypeOnceVisitor performs a depth-first traversal in the absence of
    // cycles. This means that by pushing to the front of the queue, we will
    // try to reduce deeper instances first if we start with the first thing
    // in the queue. Consider Add<Add<Add<number, number>, number>, number>:
    // we want to reduce the innermost Add<number, number> instantiation
    // first.
    tps.push_front(tp);
    return true;
  }
};

TypeFunctionReductionGuesser::TypeFunctionReductionGuesser(
    NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtins,
    NotNull<Normalizer> normalizer)
    : arena(arena), builtins(builtins), normalizer(normalizer) {}

bool TypeFunctionReductionGuesser::isFunctionGenericsSaturated(
    const FunctionType &ftv, DenseHashSet<TypeId> &argsUsed) {
  bool sameSize = ftv.generics.size() == argsUsed.size();
  bool allGenericsAppear = true;
  for (auto gt : ftv.generics)
    allGenericsAppear = allGenericsAppear || argsUsed.contains(gt);
  return sameSize && allGenericsAppear;
}

void TypeFunctionReductionGuesser::dumpGuesses() {
  for (auto [tf, t] : familyReducesTo)
    printf("Type family %s ~~> %s\n", toString(tf).c_str(),
           toString(t).c_str());
  for (auto [t, t_] : substitutable)
    printf("Substitute %s for %s\n", toString(t).c_str(), toString(t_).c_str());
}

std::optional<TypeId> TypeFunctionReductionGuesser::guess(TypeId typ) {
  std::optional<TypeId> guessedType = guessType(typ);

  if (!guessedType.has_value())
    return {};

  TypeId guess = follow(*guessedType);
  if (get<TypeFunctionInstanceType>(guess))
    return {};

  return guess;
}

std::optional<TypePackId> TypeFunctionReductionGuesser::guess(TypePackId tp) {
  auto [head, tail] = flatten(tp);

  std::vector<TypeId> guessedHead;
  guessedHead.reserve(head.size());

  for (auto typ : head) {
    std::optional<TypeId> guessedType = guessType(typ);

    if (!guessedType.has_value())
      return {};

    TypeId guess = follow(*guessedType);
    if (get<TypeFunctionInstanceType>(guess))
      return {};

    guessedHead.push_back(*guessedType);
  }

  return arena->addTypePack(TypePack{guessedHead, tail});
}

TypeFunctionReductionGuessResult
TypeFunctionReductionGuesser::guessTypeFunctionReductionForFunctionExpr(
    const AstExprFunction &expr, const FunctionType *ftv, TypeId retTy) {
  InstanceCollector2 collector;
  collector.traverse(retTy);
  toInfer = std::move(collector.tys);
  cyclicInstances = std::move(collector.cyclicInstance);

  if (isFunctionGenericsSaturated(*ftv, collector.instanceArguments))
    return TypeFunctionReductionGuessResult{{}, nullptr, false};
  infer();

  std::vector<std::pair<std::string, TypeId>> results;
  std::vector<TypeId> args;
  for (TypeId t : ftv->argTypes)
    args.push_back(t);

  //    Submit a guess for arg types
  for (size_t i = 0; i < expr.args.size; i++) {
    TypeId argTy;
    AstLocal *local = expr.args.data[i];
    if (i >= args.size())
      continue;

    argTy = args[i];
    std::optional<TypeId> guessedType = guessType(argTy);
    if (!guessedType.has_value())
      continue;
    TypeId guess = follow(*guessedType);
    if (get<TypeFunctionInstanceType>(guess))
      continue;

    results.push_back({local->name.value, guess});
  }

  // Submit a guess for return types
  TypeId recommendedAnnotation;
  std::optional<TypeId> guessedReturnType = guessType(retTy);
  if (!guessedReturnType.has_value())
    recommendedAnnotation = builtins->unknownType;
  else
    recommendedAnnotation = follow(*guessedReturnType);
  if (auto t = get<TypeFunctionInstanceType>(recommendedAnnotation))
    recommendedAnnotation = builtins->unknownType;

  toInfer.clear();
  cyclicInstances.clear();
  familyReducesTo.clear();
  substitutable.clear();

  return TypeFunctionReductionGuessResult{results, recommendedAnnotation};
}

std::optional<TypeId> TypeFunctionReductionGuesser::guessType(TypeId arg) {
  TypeId t = follow(arg);
  if (substitutable.contains(t)) {
    TypeId subst = follow(substitutable[t]);
    if (subst == t || substitutable.contains(subst))
      return subst;
    else if (!get<TypeFunctionInstanceType>(subst))
      return subst;
    else
      return guessType(subst);
  }
  if (get<TypeFunctionInstanceType>(t)) {
    if (familyReducesTo.contains(t))
      return familyReducesTo[t];
  }
  return {};
}

bool TypeFunctionReductionGuesser::isNumericBinopFamily(
    const TypeFunctionInstanceType &instance) {
  return instance.family->name == "add" || instance.family->name == "sub" ||
         instance.family->name == "mul" || instance.family->name == "div" ||
         instance.family->name == "idiv" || instance.family->name == "pow" ||
         instance.family->name == "mod";
}

bool TypeFunctionReductionGuesser::isComparisonFamily(
    const TypeFunctionInstanceType &instance) {
  return instance.family->name == "lt" || instance.family->name == "le" ||
         instance.family->name == "eq";
}

bool TypeFunctionReductionGuesser::isOrAndFamily(
    const TypeFunctionInstanceType &instance) {
  return instance.family->name == "or" || instance.family->name == "and";
}

bool TypeFunctionReductionGuesser::isNotFamily(
    const TypeFunctionInstanceType &instance) {
  return instance.family->name == "not";
}

bool TypeFunctionReductionGuesser::isLenFamily(
    const TypeFunctionInstanceType &instance) {
  return instance.family->name == "len";
}

bool TypeFunctionReductionGuesser::isUnaryMinus(
    const TypeFunctionInstanceType &instance) {
  return instance.family->name == "unm";
}

// Operand is assignable if it looks like a cyclic family instance, or a generic
// type
bool TypeFunctionReductionGuesser::operandIsAssignable(TypeId ty) {
  if (get<TypeFunctionInstanceType>(ty))
    return true;
  if (get<GenericType>(ty))
    return true;
  if (cyclicInstances.contains(ty))
    return true;
  return false;
}

std::shared_ptr<const NormalizedType>
TypeFunctionReductionGuesser::normalize(TypeId ty) {
  return normalizer->normalize(ty);
}

std::optional<TypeId>
TypeFunctionReductionGuesser::tryAssignOperandType(TypeId ty) {
  // Because we collect innermost instances first, if we see a type function
  // instance as an operand, We try to check if we guessed a type for it
  if (auto tfit = get<TypeFunctionInstanceType>(ty)) {
    if (familyReducesTo.contains(ty))
      return {familyReducesTo[ty]};
  }

  // If ty is a generic, we need to check if we inferred a substitution
  if (auto gt = get<GenericType>(ty)) {
    if (substitutable.contains(ty))
      return {substitutable[ty]};
  }

  // If we cannot substitute a type for this value, we return an empty optional
  return {};
}

void TypeFunctionReductionGuesser::step() {
  TypeId t = toInfer.front();
  toInfer.pop_front();
  t = follow(t);
  if (auto tf = get<TypeFunctionInstanceType>(t))
    inferTypeFunctionSubstitutions(t, tf);
}

void TypeFunctionReductionGuesser::infer() {
  while (!done())
    step();
}

bool TypeFunctionReductionGuesser::done() { return toInfer.empty(); }

void TypeFunctionReductionGuesser::inferTypeFunctionSubstitutions(
    TypeId ty, const TypeFunctionInstanceType *instance) {

  TypeFunctionInferenceResult result;
  LUAU_ASSERT(instance);
  // TODO: Make an inexhaustive version of this warn in the compiler?
  if (isNumericBinopFamily(*instance))
    result = inferNumericBinopFamily(instance);
  else if (isComparisonFamily(*instance))
    result = inferComparisonFamily(instance);
  else if (isOrAndFamily(*instance))
    result = inferOrAndFamily(instance);
  else if (isNotFamily(*instance))
    result = inferNotFamily(instance);
  else if (isLenFamily(*instance))
    result = inferLenFamily(instance);
  else if (isUnaryMinus(*instance))
    result = inferUnaryMinusFamily(instance);
  else
    result = {{}, builtins->unknownType};

  TypeId resultInference = follow(result.familyResultInference);
  if (!familyReducesTo.contains(resultInference))
    familyReducesTo[ty] = resultInference;

  for (size_t i = 0; i < instance->typeArguments.size(); i++) {
    if (i < result.operandInference.size()) {
      TypeId arg = follow(instance->typeArguments[i]);
      TypeId inference = follow(result.operandInference[i]);
      if (auto tfit = get<TypeFunctionInstanceType>(arg)) {
        if (!familyReducesTo.contains(arg))
          familyReducesTo.try_insert(arg, inference);
      } else if (auto gt = get<GenericType>(arg))
        substitutable[arg] = inference;
    }
  }
}

TypeFunctionInferenceResult
TypeFunctionReductionGuesser::inferNumericBinopFamily(
    const TypeFunctionInstanceType *instance) {
  LUAU_ASSERT(instance->typeArguments.size() == 2);
  TypeFunctionInferenceResult defaultNumericBinopInference{
      {builtins->numberType, builtins->numberType}, builtins->numberType};
  return defaultNumericBinopInference;
}

TypeFunctionInferenceResult TypeFunctionReductionGuesser::inferComparisonFamily(
    const TypeFunctionInstanceType *instance) {
  LUAU_ASSERT(instance->typeArguments.size() == 2);
  // Comparison families are lt/le/eq.
  // Heuristic: these are type functions from t -> t -> bool

  TypeId lhsTy = follow(instance->typeArguments[0]);
  TypeId rhsTy = follow(instance->typeArguments[1]);

  auto comparisonInference = [&](TypeId op) -> TypeFunctionInferenceResult {
    return TypeFunctionInferenceResult{{op, op}, builtins->booleanType};
  };

  if (std::optional<TypeId> ty = tryAssignOperandType(lhsTy))
    lhsTy = follow(*ty);
  if (std::optional<TypeId> ty = tryAssignOperandType(rhsTy))
    rhsTy = follow(*ty);
  if (operandIsAssignable(lhsTy) && !operandIsAssignable(rhsTy))
    return comparisonInference(rhsTy);
  if (operandIsAssignable(rhsTy) && !operandIsAssignable(lhsTy))
    return comparisonInference(lhsTy);
  return comparisonInference(builtins->numberType);
}

TypeFunctionInferenceResult TypeFunctionReductionGuesser::inferOrAndFamily(
    const TypeFunctionInstanceType *instance) {

  LUAU_ASSERT(instance->typeArguments.size() == 2);

  TypeId lhsTy = follow(instance->typeArguments[0]);
  TypeId rhsTy = follow(instance->typeArguments[1]);

  if (std::optional<TypeId> ty = tryAssignOperandType(lhsTy))
    lhsTy = follow(*ty);
  if (std::optional<TypeId> ty = tryAssignOperandType(rhsTy))
    rhsTy = follow(*ty);
  TypeFunctionInferenceResult defaultAndOrInference{
      {builtins->unknownType, builtins->unknownType}, builtins->booleanType};

  std::shared_ptr<const NormalizedType> lty = normalize(lhsTy);
  std::shared_ptr<const NormalizedType> rty = normalize(lhsTy);
  bool lhsTruthy = lty ? lty->isTruthy() : false;
  bool rhsTruthy = rty ? rty->isTruthy() : false;
  // If at the end, we still don't have good substitutions, return the default
  // type
  if (instance->family->name == "or") {
    if (operandIsAssignable(lhsTy) && operandIsAssignable(rhsTy))
      return defaultAndOrInference;
    if (operandIsAssignable(lhsTy))
      return TypeFunctionInferenceResult{{builtins->unknownType, rhsTy}, rhsTy};
    if (operandIsAssignable(rhsTy))
      return TypeFunctionInferenceResult{{lhsTy, builtins->unknownType}, lhsTy};
    if (lhsTruthy)
      return {{lhsTy, rhsTy}, lhsTy};
    if (rhsTruthy)
      return {{builtins->unknownType, rhsTy}, rhsTy};
  }

  if (instance->family->name == "and") {

    if (operandIsAssignable(lhsTy) && operandIsAssignable(rhsTy))
      return defaultAndOrInference;
    if (operandIsAssignable(lhsTy))
      return TypeFunctionInferenceResult{{}, rhsTy};
    if (operandIsAssignable(rhsTy))
      return TypeFunctionInferenceResult{{}, lhsTy};
    if (lhsTruthy)
      return {{lhsTy, rhsTy}, rhsTy};
    else
      return {{lhsTy, rhsTy}, lhsTy};
  }

  return defaultAndOrInference;
}

TypeFunctionInferenceResult TypeFunctionReductionGuesser::inferNotFamily(
    const TypeFunctionInstanceType *instance) {
  LUAU_ASSERT(instance->typeArguments.size() == 1);
  TypeId opTy = follow(instance->typeArguments[0]);
  if (std::optional<TypeId> ty = tryAssignOperandType(opTy))
    opTy = follow(*ty);
  return {{opTy}, builtins->booleanType};
}

TypeFunctionInferenceResult TypeFunctionReductionGuesser::inferLenFamily(
    const TypeFunctionInstanceType *instance) {
  LUAU_ASSERT(instance->typeArguments.size() == 1);
  TypeId opTy = follow(instance->typeArguments[0]);
  if (std::optional<TypeId> ty = tryAssignOperandType(opTy))
    opTy = follow(*ty);
  return {{opTy}, builtins->numberType};
}

TypeFunctionInferenceResult TypeFunctionReductionGuesser::inferUnaryMinusFamily(
    const TypeFunctionInstanceType *instance) {
  LUAU_ASSERT(instance->typeArguments.size() == 1);
  TypeId opTy = follow(instance->typeArguments[0]);
  if (std::optional<TypeId> ty = tryAssignOperandType(opTy))
    opTy = follow(*ty);
  if (isNumber(opTy))
    return {{builtins->numberType}, builtins->numberType};
  return {{builtins->unknownType}, builtins->numberType};
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePath.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

LUAU_FASTFLAGVARIABLE(DebugLuauSubtypingCheckPathValidity, false);

namespace Luau {

struct VarianceFlipper {
  Subtyping::Variance *variance;
  Subtyping::Variance oldValue;

  VarianceFlipper(Subtyping::Variance *v) : variance(v), oldValue(*v) {
    switch (oldValue) {
    case Subtyping::Variance::Covariant:
      *variance = Subtyping::Variance::Contravariant;
      break;
    case Subtyping::Variance::Contravariant:
      *variance = Subtyping::Variance::Covariant;
      break;
    }
  }

  ~VarianceFlipper() { *variance = oldValue; }
};

bool SubtypingReasoning::operator==(const SubtypingReasoning &other) const {
  return subPath == other.subPath && superPath == other.superPath &&
         variance == other.variance;
}

size_t SubtypingReasoningHash::operator()(const SubtypingReasoning &r) const {
  return TypePath::PathHash()(r.subPath) ^
         (TypePath::PathHash()(r.superPath) << 1) ^
         (static_cast<size_t>(r.variance) << 1);
}

template <typename TID>
static void assertReasoningValid(TID subTy, TID superTy,
                                 const SubtypingResult &result,
                                 NotNull<BuiltinTypes> builtinTypes) {
  if (!FFlag::DebugLuauSubtypingCheckPathValidity)
    return;

  for (const SubtypingReasoning &reasoning : result.reasoning) {
    LUAU_ASSERT(traverse(subTy, reasoning.subPath, builtinTypes));
    LUAU_ASSERT(traverse(superTy, reasoning.superPath, builtinTypes));
  }
}

template <>
void assertReasoningValid<TableIndexer>(TableIndexer subIdx,
                                        TableIndexer superIdx,
                                        const SubtypingResult &result,
                                        NotNull<BuiltinTypes> builtinTypes) {
  // Empty method to satisfy the compiler.
}

static SubtypingReasonings mergeReasonings(const SubtypingReasonings &a,
                                           const SubtypingReasonings &b) {
  SubtypingReasonings result{kEmptyReasoning};

  for (const SubtypingReasoning &r : a) {
    if (r.variance == SubtypingVariance::Invariant)
      result.insert(r);
    else if (r.variance == SubtypingVariance::Covariant ||
             r.variance == SubtypingVariance::Contravariant) {
      SubtypingReasoning inverseReasoning =
          SubtypingReasoning{r.subPath, r.superPath,
                             r.variance == SubtypingVariance::Covariant
                                 ? SubtypingVariance::Contravariant
                                 : SubtypingVariance::Covariant};
      if (b.contains(inverseReasoning))
        result.insert(SubtypingReasoning{r.subPath, r.superPath,
                                         SubtypingVariance::Invariant});
      else
        result.insert(r);
    }
  }

  for (const SubtypingReasoning &r : b) {
    if (r.variance == SubtypingVariance::Invariant)
      result.insert(r);
    else if (r.variance == SubtypingVariance::Covariant ||
             r.variance == SubtypingVariance::Contravariant) {
      SubtypingReasoning inverseReasoning =
          SubtypingReasoning{r.subPath, r.superPath,
                             r.variance == SubtypingVariance::Covariant
                                 ? SubtypingVariance::Contravariant
                                 : SubtypingVariance::Covariant};
      if (a.contains(inverseReasoning))
        result.insert(SubtypingReasoning{r.subPath, r.superPath,
                                         SubtypingVariance::Invariant});
      else
        result.insert(r);
    }
  }

  return result;
}

SubtypingResult &SubtypingResult::andAlso(const SubtypingResult &other) {
  // If the other result is not a subtype, we want to join all of its
  // reasonings to this one. If this result already has reasonings of its own,
  // those need to be attributed here whenever this _also_ failed.
  if (!other.isSubtype)
    reasoning = isSubtype ? std::move(other.reasoning)
                          : mergeReasonings(reasoning, other.reasoning);

  isSubtype &= other.isSubtype;
  normalizationTooComplex |= other.normalizationTooComplex;
  isCacheable &= other.isCacheable;
  errors.insert(errors.end(), other.errors.begin(), other.errors.end());

  return *this;
}

SubtypingResult &SubtypingResult::orElse(const SubtypingResult &other) {
  // If this result is a subtype, we do not join the reasoning lists. If this
  // result is not a subtype, but the other is a subtype, we want to _clear_
  // our reasoning list. If both results are not subtypes, we join the
  // reasoning lists.
  if (!isSubtype) {
    if (other.isSubtype)
      reasoning.clear();
    else
      reasoning = mergeReasonings(reasoning, other.reasoning);
  }

  isSubtype |= other.isSubtype;
  normalizationTooComplex |= other.normalizationTooComplex;
  isCacheable &= other.isCacheable;
  errors.insert(errors.end(), other.errors.begin(), other.errors.end());

  return *this;
}

SubtypingResult &
SubtypingResult::withBothComponent(TypePath::Component component) {
  return withSubComponent(component).withSuperComponent(component);
}

SubtypingResult &
SubtypingResult::withSubComponent(TypePath::Component component) {
  if (reasoning.empty())
    reasoning.insert(SubtypingReasoning{Path(component), TypePath::kEmpty});
  else {
    for (auto &r : reasoning)
      r.subPath = r.subPath.push_front(component);
  }

  return *this;
}

SubtypingResult &
SubtypingResult::withSuperComponent(TypePath::Component component) {
  if (reasoning.empty())
    reasoning.insert(SubtypingReasoning{TypePath::kEmpty, Path(component)});
  else {
    for (auto &r : reasoning)
      r.superPath = r.superPath.push_front(component);
  }

  return *this;
}

SubtypingResult &SubtypingResult::withBothPath(TypePath::Path path) {
  return withSubPath(path).withSuperPath(path);
}

SubtypingResult &SubtypingResult::withSubPath(TypePath::Path path) {
  if (reasoning.empty())
    reasoning.insert(SubtypingReasoning{path, TypePath::kEmpty});
  else {
    for (auto &r : reasoning)
      r.subPath = path.append(r.subPath);
  }

  return *this;
}

SubtypingResult &SubtypingResult::withSuperPath(TypePath::Path path) {
  if (reasoning.empty())
    reasoning.insert(SubtypingReasoning{TypePath::kEmpty, path});
  else {
    for (auto &r : reasoning)
      r.superPath = path.append(r.superPath);
  }

  return *this;
}

SubtypingResult &SubtypingResult::withErrors(ErrorVec &err) {
  for (TypeError &e : err)
    errors.emplace_back(e);
  return *this;
}

SubtypingResult &SubtypingResult::withError(TypeError err) {
  errors.push_back(std::move(err));
  return *this;
}

SubtypingResult SubtypingResult::negate(const SubtypingResult &result) {
  return SubtypingResult{
      !result.isSubtype,
      result.normalizationTooComplex,
  };
}

SubtypingResult
SubtypingResult::all(const std::vector<SubtypingResult> &results) {
  SubtypingResult acc{true};
  for (const SubtypingResult &current : results)
    acc.andAlso(current);
  return acc;
}

SubtypingResult
SubtypingResult::any(const std::vector<SubtypingResult> &results) {
  SubtypingResult acc{false};
  for (const SubtypingResult &current : results)
    acc.orElse(current);
  return acc;
}

struct ApplyMappedGenerics : Substitution {
  using MappedGenerics =
      DenseHashMap<TypeId, SubtypingEnvironment::GenericBounds>;
  using MappedGenericPacks = DenseHashMap<TypePackId, TypePackId>;

  NotNull<BuiltinTypes> builtinTypes;
  NotNull<TypeArena> arena;

  MappedGenerics &mappedGenerics;
  MappedGenericPacks &mappedGenericPacks;

  ApplyMappedGenerics(NotNull<BuiltinTypes> builtinTypes,
                      NotNull<TypeArena> arena, MappedGenerics &mappedGenerics,
                      MappedGenericPacks &mappedGenericPacks)
      : Substitution(TxnLog::empty(), arena), builtinTypes(builtinTypes),
        arena(arena), mappedGenerics(mappedGenerics),
        mappedGenericPacks(mappedGenericPacks) {}

  bool isDirty(TypeId ty) override { return mappedGenerics.contains(ty); }

  bool isDirty(TypePackId tp) override {
    return mappedGenericPacks.contains(tp);
  }

  TypeId clean(TypeId ty) override {
    const auto &bounds = mappedGenerics[ty];

    if (bounds.upperBound.empty())
      return builtinTypes->unknownType;

    if (bounds.upperBound.size() == 1)
      return *begin(bounds.upperBound);

    return arena->addType(IntersectionType{
        std::vector<TypeId>(begin(bounds.upperBound), end(bounds.upperBound))});
  }

  TypePackId clean(TypePackId tp) override { return mappedGenericPacks[tp]; }

  bool ignoreChildren(TypeId ty) override {
    if (get<ClassType>(ty))
      return true;

    return ty->persistent;
  }
  bool ignoreChildren(TypePackId ty) override { return ty->persistent; }
};

std::optional<TypeId>
SubtypingEnvironment::applyMappedGenerics(NotNull<BuiltinTypes> builtinTypes,
                                          NotNull<TypeArena> arena, TypeId ty) {
  ApplyMappedGenerics amg{builtinTypes, arena, mappedGenerics,
                          mappedGenericPacks};
  return amg.substitute(ty);
}

Subtyping::Subtyping(NotNull<BuiltinTypes> builtinTypes,
                     NotNull<TypeArena> typeArena,
                     NotNull<Normalizer> normalizer,
                     NotNull<InternalErrorReporter> iceReporter,
                     NotNull<Scope> scope)
    : builtinTypes(builtinTypes), arena(typeArena), normalizer(normalizer),
      iceReporter(iceReporter), scope(scope) {}

SubtypingResult Subtyping::isSubtype(TypeId subTy, TypeId superTy) {
  SubtypingEnvironment env;

  SubtypingResult result = isCovariantWith(env, subTy, superTy);

  for (const auto &[subTy, bounds] : env.mappedGenerics) {
    const auto &lb = bounds.lowerBound;
    const auto &ub = bounds.upperBound;

    TypeId lowerBound =
        makeAggregateType<UnionType>(lb, builtinTypes->neverType);
    TypeId upperBound =
        makeAggregateType<IntersectionType>(ub, builtinTypes->unknownType);

    std::shared_ptr<const NormalizedType> nt =
        normalizer->normalize(upperBound);
    // we say that the result is true if normalization failed because complex
    // types are likely to be inhabited.
    NormalizationResult res =
        nt ? normalizer->isInhabited(nt.get()) : NormalizationResult::True;

    if (!nt || res == NormalizationResult::HitLimits)
      result.normalizationTooComplex = true;
    else if (res == NormalizationResult::False) {
      /* If the normalized upper bound we're mapping to a generic is
       * uninhabited, then we must consider the subtyping relation not to
       * hold.
       *
       * This happens eg in <T>() -> (T, T) <: () -> (string, number)
       *
       * T appears in covariant position and would have to be both string
       * and number at once.
       *
       * No actual value is both a string and a number, so the test fails.
       *
       * TODO: We'll need to add explanitory context here.
       */
      result.isSubtype = false;
    }

    SubtypingResult boundsResult = isCovariantWith(env, lowerBound, upperBound);
    boundsResult.reasoning.clear();

    result.andAlso(boundsResult);
  }

  /* TODO: We presently don't store subtype test results in the persistent
   * cache if the left-side type is a generic function.
   *
   * The implementation would be a bit tricky and we haven't seen any material
   * impact on benchmarks.
   *
   * What we would want to do is to remember points within the type where
   * mapped generics are introduced.  When all the contingent generics are
   * introduced at which we're doing the test, we can mark the result as
   * cacheable.
   */

  if (result.isCacheable)
    resultCache[{subTy, superTy}] = result;

  return result;
}

SubtypingResult Subtyping::isSubtype(TypePackId subTp, TypePackId superTp) {
  SubtypingEnvironment env;
  return isCovariantWith(env, subTp, superTp);
}

SubtypingResult Subtyping::cache(SubtypingEnvironment &env,
                                 SubtypingResult result, TypeId subTy,
                                 TypeId superTy) {
  const std::pair<TypeId, TypeId> p{subTy, superTy};
  if (result.isCacheable)
    resultCache[p] = result;
  else
    env.ephemeralCache[p] = result;

  return result;
}

namespace {
struct SeenSetPopper {
  Subtyping::SeenSet *seenTypes;
  std::pair<TypeId, TypeId> pair;

  SeenSetPopper(Subtyping::SeenSet *seenTypes, std::pair<TypeId, TypeId> pair)
      : seenTypes(seenTypes), pair(pair) {}

  ~SeenSetPopper() { seenTypes->erase(pair); }
};
} // namespace

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           TypeId subTy, TypeId superTy) {
  subTy = follow(subTy);
  superTy = follow(superTy);

  if (TypeId *subIt = env.substitutions.find(subTy); subIt && *subIt)
    subTy = *subIt;

  if (TypeId *superIt = env.substitutions.find(superTy); superIt && *superIt)
    superTy = *superIt;

  SubtypingResult *cachedResult = resultCache.find({subTy, superTy});
  if (cachedResult)
    return *cachedResult;

  cachedResult = env.ephemeralCache.find({subTy, superTy});
  if (cachedResult)
    return *cachedResult;

  // TODO: Do we care about returning a proof that this is error-suppressing?
  // e.g. given `a | error <: a | error` where both operands are pointer equal,
  // then should it also carry the information that it's error-suppressing?
  // If it should, then `error <: error` should also do the same.
  if (subTy == superTy)
    return {true};

  std::pair<TypeId, TypeId> typePair{subTy, superTy};
  if (!seenTypes.insert(typePair)) {
    /* TODO: Caching results for recursive types is really tricky to think
     * about.
     *
     * We'd like to cache at the outermost level where we encounter the
     * recursive type, but we do not want to cache interior results that
     * involve the cycle.
     *
     * Presently, we stop at cycles and assume that the subtype check will
     * succeed because we'll eventually get there if it won't. However, if
     * that cyclic type turns out not to have the asked-for subtyping
     * relation, then all the intermediate cached results that were
     * contingent on that assumption need to be evicted from the cache, or
     * not entered into the cache, or something.
     *
     * For now, we do the conservative thing and refuse to cache anything
     * that touches a cycle.
     */
    SubtypingResult res;
    res.isSubtype = true;
    res.isCacheable = false;
    return res;
  }

  SeenSetPopper ssp{&seenTypes, typePair};

  // Within the scope to which a generic belongs, that generic should be
  // tested as though it were its upper bounds.  We do not yet support bounded
  // generics, so the upper bound is always unknown.
  if (auto subGeneric = get<GenericType>(subTy);
      subGeneric && subsumes(subGeneric->scope, scope))
    return isCovariantWith(env, builtinTypes->neverType, superTy);
  if (auto superGeneric = get<GenericType>(superTy);
      superGeneric && subsumes(superGeneric->scope, scope))
    return isCovariantWith(env, subTy, builtinTypes->unknownType);

  SubtypingResult result;

  if (auto subUnion = get<UnionType>(subTy))
    result = isCovariantWith(env, subUnion, superTy);
  else if (auto superUnion = get<UnionType>(superTy)) {
    result = isCovariantWith(env, subTy, superUnion);
    if (!result.isSubtype && !result.normalizationTooComplex) {
      SubtypingResult semantic = isCovariantWith(
          env, normalizer->normalize(subTy), normalizer->normalize(superTy));
      if (semantic.isSubtype) {
        semantic.reasoning.clear();
        result = semantic;
      }
    }
  } else if (auto superIntersection = get<IntersectionType>(superTy))
    result = isCovariantWith(env, subTy, superIntersection);
  else if (auto subIntersection = get<IntersectionType>(subTy)) {
    result = isCovariantWith(env, subIntersection, superTy);
    if (!result.isSubtype && !result.normalizationTooComplex) {
      SubtypingResult semantic = isCovariantWith(
          env, normalizer->normalize(subTy), normalizer->normalize(superTy));
      if (semantic.isSubtype) {
        // Clear the semantic reasoning, as any reasonings within
        // potentially contain invalid paths.
        semantic.reasoning.clear();
        result = semantic;
      }
    }
  } else if (get<AnyType>(superTy))
    result = {true};
  else if (get<AnyType>(subTy)) {
    // any = unknown | error, so we rewrite this to match.
    // As per TAPL: A | B <: T iff A <: T && B <: T
    result =
        isCovariantWith(env, builtinTypes->unknownType, superTy)
            .andAlso(isCovariantWith(env, builtinTypes->errorType, superTy));
  } else if (get<UnknownType>(superTy)) {
    LUAU_ASSERT(!get<AnyType>(subTy));          // TODO: replace with ice.
    LUAU_ASSERT(!get<UnionType>(subTy));        // TODO: replace with ice.
    LUAU_ASSERT(!get<IntersectionType>(subTy)); // TODO: replace with ice.

    bool errorSuppressing = get<ErrorType>(subTy);
    result = {!errorSuppressing};
  } else if (get<NeverType>(subTy))
    result = {true};
  else if (get<ErrorType>(superTy))
    result = {false};
  else if (get<ErrorType>(subTy))
    result = {false};
  else if (auto p = get2<NegationType, NegationType>(subTy, superTy))
    result = isCovariantWith(env, p.first->ty, p.second->ty)
                 .withBothComponent(TypePath::TypeField::Negated);
  else if (auto subNegation = get<NegationType>(subTy)) {
    result = isCovariantWith(env, subNegation, superTy);
    if (!result.isSubtype && !result.normalizationTooComplex) {
      SubtypingResult semantic = isCovariantWith(
          env, normalizer->normalize(subTy), normalizer->normalize(superTy));
      if (semantic.isSubtype) {
        semantic.reasoning.clear();
        result = semantic;
      }
    }
  } else if (auto superNegation = get<NegationType>(superTy)) {
    result = isCovariantWith(env, subTy, superNegation);
    if (!result.isSubtype && !result.normalizationTooComplex) {
      SubtypingResult semantic = isCovariantWith(
          env, normalizer->normalize(subTy), normalizer->normalize(superTy));
      if (semantic.isSubtype) {
        semantic.reasoning.clear();
        result = semantic;
      }
    }
  } else if (auto subTypeFunctionInstance =
                 get<TypeFunctionInstanceType>(subTy)) {
    if (auto substSubTy = env.applyMappedGenerics(builtinTypes, arena, subTy))
      subTypeFunctionInstance = get<TypeFunctionInstanceType>(*substSubTy);

    result = isCovariantWith(env, subTypeFunctionInstance, superTy);
  } else if (auto superTypeFunctionInstance =
                 get<TypeFunctionInstanceType>(superTy)) {
    if (auto substSuperTy =
            env.applyMappedGenerics(builtinTypes, arena, superTy))
      superTypeFunctionInstance = get<TypeFunctionInstanceType>(*substSuperTy);

    result = isCovariantWith(env, subTy, superTypeFunctionInstance);
  } else if (auto subGeneric = get<GenericType>(subTy);
             subGeneric && variance == Variance::Covariant) {
    bool ok = bindGeneric(env, subTy, superTy);
    result.isSubtype = ok;
    result.isCacheable = false;
  } else if (auto superGeneric = get<GenericType>(superTy);
             superGeneric && variance == Variance::Contravariant) {
    bool ok = bindGeneric(env, subTy, superTy);
    result.isSubtype = ok;
    result.isCacheable = false;
  } else if (auto p = get2<PrimitiveType, PrimitiveType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<SingletonType, PrimitiveType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<SingletonType, SingletonType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<FunctionType, FunctionType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<TableType, TableType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<MetatableType, MetatableType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<MetatableType, TableType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<ClassType, ClassType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<ClassType, TableType>(subTy, superTy))
    result = isCovariantWith(env, subTy, p.first, superTy, p.second);
  else if (auto p = get2<PrimitiveType, TableType>(subTy, superTy))
    result = isCovariantWith(env, p);
  else if (auto p = get2<SingletonType, TableType>(subTy, superTy))
    result = isCovariantWith(env, p);

  assertReasoningValid(subTy, superTy, result, builtinTypes);

  return cache(env, result, subTy, superTy);
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           TypePackId subTp,
                                           TypePackId superTp) {
  subTp = follow(subTp);
  superTp = follow(superTp);

  auto [subHead, subTail] = flatten(subTp);
  auto [superHead, superTail] = flatten(superTp);

  const size_t headSize = std::min(subHead.size(), superHead.size());

  std::vector<SubtypingResult> results;
  results.reserve(std::max(subHead.size(), superHead.size()) + 1);

  if (subTp == superTp)
    return {true};

  // Match head types pairwise

  for (size_t i = 0; i < headSize; ++i)
    results.push_back(isCovariantWith(env, subHead[i], superHead[i])
                          .withBothComponent(TypePath::Index{i}));

  // Handle mismatched head sizes

  if (subHead.size() < superHead.size()) {
    if (subTail) {
      if (auto vt = get<VariadicTypePack>(*subTail)) {
        for (size_t i = headSize; i < superHead.size(); ++i)
          results.push_back(
              isCovariantWith(env, vt->ty, superHead[i])
                  .withSubPath(
                      TypePath::PathBuilder().tail().variadic().build())
                  .withSuperComponent(TypePath::Index{i}));
      } else if (auto gt = get<GenericTypePack>(*subTail)) {
        if (variance == Variance::Covariant) {
          // For any non-generic type T:
          //
          // <X>(X) -> () <: (T) -> ()

          // Possible optimization: If headSize == 0 then we can just use subTp
          // as-is.
          std::vector<TypeId> headSlice(begin(superHead),
                                        begin(superHead) + headSize);
          TypePackId superTailPack =
              arena->addTypePack(std::move(headSlice), superTail);

          if (TypePackId *other = env.mappedGenericPacks.find(*subTail))
            // TODO: TypePath can't express "slice of a pack + its tail".
            results.push_back(isCovariantWith(env, *other, superTailPack)
                                  .withSubComponent(TypePath::PackField::Tail));
          else
            env.mappedGenericPacks.try_insert(*subTail, superTailPack);

          // FIXME? Not a fan of the early return here.  It makes the
          // control flow harder to reason about.
          return SubtypingResult::all(results);
        } else {
          // For any non-generic type T:
          //
          // (T) -> () </: <X>(X) -> ()
          //
          return SubtypingResult{false}.withSubComponent(
              TypePath::PackField::Tail);
        }
      } else if (get<ErrorTypePack>(*subTail))
        return SubtypingResult{true}.withSubComponent(
            TypePath::PackField::Tail);
      else
        return SubtypingResult{false}
            .withSubComponent(TypePath::PackField::Tail)
            .withError(
                {scope->location, UnexpectedTypePackInSubtyping{*subTail}});
    } else {
      results.push_back({false});
      return SubtypingResult::all(results);
    }
  } else if (subHead.size() > superHead.size()) {
    if (superTail) {
      if (auto vt = get<VariadicTypePack>(*superTail)) {
        for (size_t i = headSize; i < subHead.size(); ++i)
          results.push_back(
              isCovariantWith(env, subHead[i], vt->ty)
                  .withSubComponent(TypePath::Index{i})
                  .withSuperPath(
                      TypePath::PathBuilder().tail().variadic().build()));
      } else if (auto gt = get<GenericTypePack>(*superTail)) {
        if (variance == Variance::Contravariant) {
          // For any non-generic type T:
          //
          // <X...>(X...) -> () <: (T) -> ()

          // Possible optimization: If headSize == 0 then we can just use subTp
          // as-is.
          std::vector<TypeId> headSlice(begin(subHead),
                                        begin(subHead) + headSize);
          TypePackId subTailPack =
              arena->addTypePack(std::move(headSlice), subTail);

          if (TypePackId *other = env.mappedGenericPacks.find(*superTail))
            // TODO: TypePath can't express "slice of a pack + its tail".
            results.push_back(
                isContravariantWith(env, subTailPack, *other)
                    .withSuperComponent(TypePath::PackField::Tail));
          else
            env.mappedGenericPacks.try_insert(*superTail, subTailPack);

          // FIXME? Not a fan of the early return here.  It makes the
          // control flow harder to reason about.
          return SubtypingResult::all(results);
        } else {
          // For any non-generic type T:
          //
          // () -> T </: <X...>() -> X...
          return SubtypingResult{false}.withSuperComponent(
              TypePath::PackField::Tail);
        }
      } else if (get<ErrorTypePack>(*superTail))
        return SubtypingResult{true}.withSuperComponent(
            TypePath::PackField::Tail);
      else
        return SubtypingResult{false}
            .withSuperComponent(TypePath::PackField::Tail)
            .withError(
                {scope->location, UnexpectedTypePackInSubtyping{*subTail}});
    } else
      return {false};
  }

  // Handle tails

  if (subTail && superTail) {
    if (auto p =
            get2<VariadicTypePack, VariadicTypePack>(*subTail, *superTail)) {
      // Variadic component is added by the isCovariantWith
      // implementation; no need to add it here.
      results.push_back(
          isCovariantWith(env, p).withBothComponent(TypePath::PackField::Tail));
    } else if (auto p = get2<GenericTypePack, GenericTypePack>(*subTail,
                                                               *superTail)) {
      bool ok = bindGeneric(env, *subTail, *superTail);
      results.push_back(
          SubtypingResult{ok}.withBothComponent(TypePath::PackField::Tail));
    } else if (auto p = get2<VariadicTypePack, GenericTypePack>(*subTail,
                                                                *superTail)) {
      if (variance == Variance::Contravariant) {
        // <A...>(A...) -> number <: (...number) -> number
        bool ok = bindGeneric(env, *subTail, *superTail);
        results.push_back(
            SubtypingResult{ok}.withBothComponent(TypePath::PackField::Tail));
      } else {
        // (number) -> ...number </: <A...>(number) -> A...
        results.push_back(SubtypingResult{false}.withBothComponent(
            TypePath::PackField::Tail));
      }
    } else if (auto p = get2<GenericTypePack, VariadicTypePack>(*subTail,
                                                                *superTail)) {
      if (TypeId t = follow(p.second->ty);
          get<AnyType>(t) || get<UnknownType>(t)) {
        // Extra magic rule:
        // T... <: ...any
        // T... <: ...unknown
        //
        // See https://github.com/luau-lang/luau/issues/767
      } else if (variance == Variance::Contravariant) {
        // (...number) -> number </: <A...>(A...) -> number
        results.push_back(SubtypingResult{false}.withBothComponent(
            TypePath::PackField::Tail));
      } else {
        // <A...>() -> A... <: () -> ...number
        bool ok = bindGeneric(env, *subTail, *superTail);
        results.push_back(
            SubtypingResult{ok}.withBothComponent(TypePath::PackField::Tail));
      }
    } else if (get<ErrorTypePack>(*subTail) || get<ErrorTypePack>(*superTail))
      // error type is fine on either side
      results.push_back(
          SubtypingResult{true}.withBothComponent(TypePath::PackField::Tail));
    else
      return SubtypingResult{false}
          .withBothComponent(TypePath::PackField::Tail)
          .withError({scope->location, UnexpectedTypePackInSubtyping{*subTail}})
          .withError(
              {scope->location, UnexpectedTypePackInSubtyping{*superTail}});
  } else if (subTail) {
    if (get<VariadicTypePack>(*subTail)) {
      return SubtypingResult{false}.withSubComponent(TypePath::PackField::Tail);
    } else if (get<GenericTypePack>(*subTail)) {
      bool ok = bindGeneric(env, *subTail, builtinTypes->emptyTypePack);
      return SubtypingResult{ok}.withSubComponent(TypePath::PackField::Tail);
    } else
      return SubtypingResult{false}
          .withSubComponent(TypePath::PackField::Tail)
          .withError(
              {scope->location, UnexpectedTypePackInSubtyping{*subTail}});
  } else if (superTail) {
    if (get<VariadicTypePack>(*superTail)) {
      /*
       * A variadic type pack ...T can be thought of as an infinite union of
       * finite type packs.
       *     () | (T) | (T, T) | (T, T, T) | ...
       *
       * And, per TAPL:
       *     T <: A | B iff T <: A or T <: B
       *
       * All variadic type packs are therefore supertypes of the empty type
       * pack.
       */
    } else if (get<GenericTypePack>(*superTail)) {
      if (variance == Variance::Contravariant) {
        bool ok = bindGeneric(env, builtinTypes->emptyTypePack, *superTail);
        results.push_back(
            SubtypingResult{ok}.withSuperComponent(TypePath::PackField::Tail));
      } else
        results.push_back(SubtypingResult{false}.withSuperComponent(
            TypePath::PackField::Tail));
    } else
      return SubtypingResult{false}
          .withSuperComponent(TypePath::PackField::Tail)
          .withError(
              {scope->location, UnexpectedTypePackInSubtyping{*superTail}});
  }

  SubtypingResult result = SubtypingResult::all(results);
  assertReasoningValid(subTp, superTp, result, builtinTypes);

  return result;
}

template <typename SubTy, typename SuperTy>
SubtypingResult Subtyping::isContravariantWith(SubtypingEnvironment &env,
                                               SubTy &&subTy,
                                               SuperTy &&superTy) {
  VarianceFlipper vf{&variance};

  SubtypingResult result = isCovariantWith(env, superTy, subTy);
  if (result.reasoning.empty())
    result.reasoning.insert(SubtypingReasoning{
        TypePath::kEmpty, TypePath::kEmpty, SubtypingVariance::Contravariant});
  else {
    // If we don't swap the paths here, we will end up producing an invalid path
    // whenever we involve contravariance. We'll end up appending path
    // components that should belong to the supertype to the subtype, and vice
    // versa.
    for (auto &reasoning : result.reasoning) {
      std::swap(reasoning.subPath, reasoning.superPath);

      // Also swap covariant/contravariant, since those are also the other way
      // around.
      if (reasoning.variance == SubtypingVariance::Covariant)
        reasoning.variance = SubtypingVariance::Contravariant;
      else if (reasoning.variance == SubtypingVariance::Contravariant)
        reasoning.variance = SubtypingVariance::Covariant;
    }
  }

  assertReasoningValid(subTy, superTy, result, builtinTypes);

  return result;
}

template <typename SubTy, typename SuperTy>
SubtypingResult Subtyping::isInvariantWith(SubtypingEnvironment &env,
                                           SubTy &&subTy, SuperTy &&superTy) {
  SubtypingResult result =
      isCovariantWith(env, subTy, superTy)
          .andAlso(isContravariantWith(env, subTy, superTy));

  if (result.reasoning.empty())
    result.reasoning.insert(SubtypingReasoning{
        TypePath::kEmpty, TypePath::kEmpty, SubtypingVariance::Invariant});
  else {
    for (auto &reasoning : result.reasoning)
      reasoning.variance = SubtypingVariance::Invariant;
  }

  assertReasoningValid(subTy, superTy, result, builtinTypes);
  return result;
}

template <typename SubTy, typename SuperTy>
SubtypingResult Subtyping::isCovariantWith(
    SubtypingEnvironment &env,
    const TryPair<const SubTy *, const SuperTy *> &pair) {
  return isCovariantWith(env, pair.first, pair.second);
}

template <typename SubTy, typename SuperTy>
SubtypingResult Subtyping::isContravariantWith(
    SubtypingEnvironment &env,
    const TryPair<const SubTy *, const SuperTy *> &pair) {
  return isContravariantWith(env, pair.first, pair.second);
}

template <typename SubTy, typename SuperTy>
SubtypingResult Subtyping::isInvariantWith(
    SubtypingEnvironment &env,
    const TryPair<const SubTy *, const SuperTy *> &pair) {
  return isInvariantWith(env, pair.first, pair.second);
}

/*
 * This is much simpler than the Unifier implementation because we don't
 * actually care about potential "cross-talk" between union parts that match the
 * left side.
 *
 * In fact, we're very limited in what we can do: If multiple choices match, but
 * all of them have non-overlapping constraints, then we're stuck with an "or"
 * conjunction of constraints.  Solving this in the general case is quite
 * difficult.
 *
 * For example, we cannot dispatch anything from this constraint:
 *
 * {x: number, y: string} <: {x: number, y: 'a} | {x: 'b, y: string}
 *
 * From this constraint, we can know that either string <: 'a or number <: 'b,
 * but we don't know which!
 *
 * However:
 *
 * {x: number, y: string} <: {x: number, y: 'a} | {x: number, y: string}
 *
 * We can dispatch this constraint because there is no 'or' conjunction.  One of
 * the arms requires 0 matches.
 *
 * {x: number, y: string, z: boolean} | {x: number, y: 'a, z: 'b} | {x: number,
 * y: string, z: 'b}
 *
 * Here, we have two matches.  One asks for string ~ 'a and boolean ~ 'b.  The
 * other just asks for boolean ~ 'b. We can dispatch this and only commit
 * boolean ~ 'b.  This constraint does not teach us anything about 'a.
 */
SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           TypeId subTy,
                                           const UnionType *superUnion) {
  // As per TAPL: T <: A | B iff T <: A || T <: B

  for (TypeId ty : superUnion) {
    SubtypingResult next = isCovariantWith(env, subTy, ty);
    if (next.isSubtype)
      return SubtypingResult{true};
  }

  /*
   * TODO: Is it possible here to use the context produced by the above
   * isCovariantWith() calls to produce a richer, more helpful result in the
   * case that the subtyping relation does not hold?
   */
  return SubtypingResult{false};
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const UnionType *subUnion,
                                           TypeId superTy) {
  // As per TAPL: A | B <: T iff A <: T && B <: T
  std::vector<SubtypingResult> subtypings;
  size_t i = 0;
  for (TypeId ty : subUnion)
    subtypings.push_back(isCovariantWith(env, ty, superTy)
                             .withSubComponent(TypePath::Index{i++}));
  return SubtypingResult::all(subtypings);
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env, TypeId subTy,
                           const IntersectionType *superIntersection) {
  // As per TAPL: T <: A & B iff T <: A && T <: B
  std::vector<SubtypingResult> subtypings;
  size_t i = 0;
  for (TypeId ty : superIntersection)
    subtypings.push_back(isCovariantWith(env, subTy, ty)
                             .withSuperComponent(TypePath::Index{i++}));
  return SubtypingResult::all(subtypings);
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const IntersectionType *subIntersection,
                           TypeId superTy) {
  // As per TAPL: A & B <: T iff A <: T || B <: T
  std::vector<SubtypingResult> subtypings;
  size_t i = 0;
  for (TypeId ty : subIntersection)
    subtypings.push_back(isCovariantWith(env, ty, superTy)
                             .withSubComponent(TypePath::Index{i++}));
  return SubtypingResult::any(subtypings);
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const NegationType *subNegation,
                                           TypeId superTy) {
  TypeId negatedTy = follow(subNegation->ty);

  SubtypingResult result;

  // In order to follow a consistent codepath, rather than folding the
  // isCovariantWith test down to its conclusion here, we test the subtyping
  // test of the result of negating the type for never, unknown, any, and error.
  if (is<NeverType>(negatedTy)) {
    // never ~ unknown
    result = isCovariantWith(env, builtinTypes->unknownType, superTy)
                 .withSubComponent(TypePath::TypeField::Negated);
  } else if (is<UnknownType>(negatedTy)) {
    // unknown ~ never
    result = isCovariantWith(env, builtinTypes->neverType, superTy)
                 .withSubComponent(TypePath::TypeField::Negated);
  } else if (is<AnyType>(negatedTy)) {
    // any ~ any
    result = isCovariantWith(env, negatedTy, superTy)
                 .withSubComponent(TypePath::TypeField::Negated);
  } else if (auto u = get<UnionType>(negatedTy)) {
    // (A  B) ~ A  B
    // follow intersection rules: A & B <: T iff A <: T && B <: T
    std::vector<SubtypingResult> subtypings;

    for (TypeId ty : u) {
      if (auto negatedPart = get<NegationType>(follow(ty)))
        subtypings.push_back(
            isCovariantWith(env, negatedPart->ty, superTy)
                .withSubComponent(TypePath::TypeField::Negated));
      else {
        NegationType negatedTmp{ty};
        subtypings.push_back(isCovariantWith(env, &negatedTmp, superTy));
      }
    }

    result = SubtypingResult::all(subtypings);
  } else if (auto i = get<IntersectionType>(negatedTy)) {
    // (A  B) ~ A  B
    // follow union rules: A | B <: T iff A <: T || B <: T
    std::vector<SubtypingResult> subtypings;

    for (TypeId ty : i) {
      if (auto negatedPart = get<NegationType>(follow(ty)))
        subtypings.push_back(
            isCovariantWith(env, negatedPart->ty, superTy)
                .withSubComponent(TypePath::TypeField::Negated));
      else {
        NegationType negatedTmp{ty};
        subtypings.push_back(isCovariantWith(env, &negatedTmp, superTy));
      }
    }

    result = SubtypingResult::any(subtypings);
  } else if (is<ErrorType, FunctionType, TableType, MetatableType>(negatedTy)) {
    iceReporter->ice("attempting to negate a non-testable type");
  }
  // negating a different subtype will get you a very wide type that's not a
  // subtype of other stuff.
  else {
    result =
        SubtypingResult{false}.withSubComponent(TypePath::TypeField::Negated);
  }

  return result;
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const TypeId subTy,
                                           const NegationType *superNegation) {
  TypeId negatedTy = follow(superNegation->ty);

  SubtypingResult result;

  if (is<NeverType>(negatedTy)) {
    // never ~ unknown
    result = isCovariantWith(env, subTy, builtinTypes->unknownType);
  } else if (is<UnknownType>(negatedTy)) {
    // unknown ~ never
    result = isCovariantWith(env, subTy, builtinTypes->neverType);
  } else if (is<AnyType>(negatedTy)) {
    // any ~ any
    result = isSubtype(subTy, negatedTy);
  } else if (auto u = get<UnionType>(negatedTy)) {
    // (A  B) ~ A  B
    // follow intersection rules: A & B <: T iff A <: T && B <: T
    std::vector<SubtypingResult> subtypings;

    for (TypeId ty : u) {
      if (auto negatedPart = get<NegationType>(follow(ty)))
        subtypings.push_back(isCovariantWith(env, subTy, negatedPart->ty));
      else {
        NegationType negatedTmp{ty};
        subtypings.push_back(isCovariantWith(env, subTy, &negatedTmp));
      }
    }

    return SubtypingResult::all(subtypings);
  } else if (auto i = get<IntersectionType>(negatedTy)) {
    // (A  B) ~ A  B
    // follow union rules: A | B <: T iff A <: T || B <: T
    std::vector<SubtypingResult> subtypings;

    for (TypeId ty : i) {
      if (auto negatedPart = get<NegationType>(follow(ty)))
        subtypings.push_back(isCovariantWith(env, subTy, negatedPart->ty));
      else {
        NegationType negatedTmp{ty};
        subtypings.push_back(isCovariantWith(env, subTy, &negatedTmp));
      }
    }

    return SubtypingResult::any(subtypings);
  } else if (auto p = get2<PrimitiveType, PrimitiveType>(subTy, negatedTy)) {
    // number <: boolean
    // number </: number
    result = {p.first->type != p.second->type};
  } else if (auto p = get2<SingletonType, PrimitiveType>(subTy, negatedTy)) {
    // "foo" </: string
    if (get<StringSingleton>(p.first) &&
        p.second->type == PrimitiveType::String)
      result = {false};
    // false </: boolean
    else if (get<BooleanSingleton>(p.first) &&
             p.second->type == PrimitiveType::Boolean)
      result = {false};
    // other cases are true
    else
      result = {true};
  } else if (auto p = get2<PrimitiveType, SingletonType>(subTy, negatedTy)) {
    if (p.first->type == PrimitiveType::String &&
        get<StringSingleton>(p.second))
      result = {false};
    else if (p.first->type == PrimitiveType::Boolean &&
             get<BooleanSingleton>(p.second))
      result = {false};
    else
      result = {true};
  }
  // the top class type is not actually a primitive type, so the negation of
  // any one of them includes the top class type.
  else if (auto p = get2<ClassType, PrimitiveType>(subTy, negatedTy))
    result = {true};
  else if (auto p = get<PrimitiveType>(negatedTy);
           p && is<TableType, MetatableType>(subTy))
    result = {p->type != PrimitiveType::Table};
  else if (auto p = get2<FunctionType, PrimitiveType>(subTy, negatedTy))
    result = {p.second->type != PrimitiveType::Function};
  else if (auto p = get2<SingletonType, SingletonType>(subTy, negatedTy))
    result = {*p.first != *p.second};
  else if (auto p = get2<ClassType, ClassType>(subTy, negatedTy))
    result = SubtypingResult::negate(isCovariantWith(env, p.first, p.second));
  else if (get2<FunctionType, ClassType>(subTy, negatedTy))
    result = {true};
  else if (is<ErrorType, FunctionType, TableType, MetatableType>(negatedTy))
    iceReporter->ice("attempting to negate a non-testable type");
  else
    result = {false};

  return result.withSuperComponent(TypePath::TypeField::Negated);
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const PrimitiveType *subPrim,
                                           const PrimitiveType *superPrim) {
  return {subPrim->type == superPrim->type};
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const SingletonType *subSingleton,
                                           const PrimitiveType *superPrim) {
  if (get<StringSingleton>(subSingleton) &&
      superPrim->type == PrimitiveType::String)
    return {true};
  else if (get<BooleanSingleton>(subSingleton) &&
           superPrim->type == PrimitiveType::Boolean)
    return {true};
  else
    return {false};
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const SingletonType *subSingleton,
                           const SingletonType *superSingleton) {
  return {*subSingleton == *superSingleton};
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const TableType *subTable,
                                           const TableType *superTable) {
  SubtypingResult result{true};

  if (subTable->props.empty() && !subTable->indexer && superTable->indexer)
    return {false};

  for (const auto &[name, superProp] : superTable->props) {
    std::vector<SubtypingResult> results;
    if (auto subIter = subTable->props.find(name);
        subIter != subTable->props.end())
      results.push_back(isCovariantWith(env, subIter->second, superProp, name));

    if (subTable->indexer) {
      if (isCovariantWith(env, builtinTypes->stringType,
                          subTable->indexer->indexType)
              .isSubtype) {
        if (superProp.isShared())
          results.push_back(
              isInvariantWith(env, subTable->indexer->indexResultType,
                              superProp.type())
                  .withSubComponent(TypePath::TypeField::IndexResult)
                  .withSuperComponent(TypePath::Property::read(name)));
        else {
          if (superProp.readTy)
            results.push_back(
                isCovariantWith(env, subTable->indexer->indexResultType,
                                *superProp.readTy)
                    .withSubComponent(TypePath::TypeField::IndexResult)
                    .withSuperComponent(TypePath::Property::read(name)));
          if (superProp.writeTy)
            results.push_back(
                isContravariantWith(env, subTable->indexer->indexResultType,
                                    *superProp.writeTy)
                    .withSubComponent(TypePath::TypeField::IndexResult)
                    .withSuperComponent(TypePath::Property::write(name)));
        }
      }
    }

    if (results.empty())
      return SubtypingResult{false};

    result.andAlso(SubtypingResult::all(results));
  }

  if (superTable->indexer) {
    if (subTable->indexer)
      result.andAlso(
          isInvariantWith(env, *subTable->indexer, *superTable->indexer));
    else
      return {false};
  }

  return result;
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const MetatableType *subMt,
                                           const MetatableType *superMt) {
  return isCovariantWith(env, subMt->table, superMt->table)
      .andAlso(isCovariantWith(env, subMt->metatable, superMt->metatable)
                   .withBothComponent(TypePath::TypeField::Metatable));
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const MetatableType *subMt,
                                           const TableType *superTable) {
  if (auto subTable = get<TableType>(follow(subMt->table))) {
    // Metatables cannot erase properties from the table they're attached to, so
    // the subtyping rule for this is just if the table component is a subtype
    // of the supertype table.
    //
    // There's a flaw here in that if the __index metamethod contributes a new
    // field that would satisfy the subtyping relationship, we'll erronously say
    // that the metatable isn't a subtype of the table, even though they have
    // compatible properties/shapes. We'll revisit this later when we have a
    // better understanding of how important this is.
    return isCovariantWith(env, subTable, superTable);
  } else {
    // TODO: This may be a case we actually hit?
    return {false};
  }
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const ClassType *subClass,
                                           const ClassType *superClass) {
  return {isSubclass(subClass, superClass)};
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           TypeId subTy,
                                           const ClassType *subClass,
                                           TypeId superTy,
                                           const TableType *superTable) {
  SubtypingResult result{true};

  env.substitutions[superTy] = subTy;

  for (const auto &[name, prop] : superTable->props) {
    if (auto classProp = lookupClassProp(subClass, name)) {
      result.andAlso(isCovariantWith(env, *classProp, prop, name));
    } else {
      result = {false};
      break;
    }
  }

  env.substitutions[superTy] = nullptr;

  return result;
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const FunctionType *subFunction,
                                           const FunctionType *superFunction) {
  SubtypingResult result;
  {
    result.orElse(
        isContravariantWith(env, subFunction->argTypes, superFunction->argTypes)
            .withBothComponent(TypePath::PackField::Arguments));
  }

  result.andAlso(
      isCovariantWith(env, subFunction->retTypes, superFunction->retTypes)
          .withBothComponent(TypePath::PackField::Returns));

  return result;
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const PrimitiveType *subPrim,
                                           const TableType *superTable) {
  SubtypingResult result{false};
  if (subPrim->type == PrimitiveType::String) {
    if (auto metatable = getMetatable(builtinTypes->stringType, builtinTypes)) {
      if (auto mttv = get<TableType>(follow(metatable))) {
        if (auto it = mttv->props.find("__index"); it != mttv->props.end()) {
          if (auto stringTable = get<TableType>(it->second.type()))
            result.orElse(isCovariantWith(env, stringTable, superTable)
                              .withSubPath(TypePath::PathBuilder()
                                               .mt()
                                               .readProp("__index")
                                               .build()));
        }
      }
    }
  }

  return result;
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const SingletonType *subSingleton,
                                           const TableType *superTable) {
  SubtypingResult result{false};
  if (auto stringleton = get<StringSingleton>(subSingleton)) {
    if (auto metatable = getMetatable(builtinTypes->stringType, builtinTypes)) {
      if (auto mttv = get<TableType>(follow(metatable))) {
        if (auto it = mttv->props.find("__index"); it != mttv->props.end()) {
          if (auto stringTable = get<TableType>(it->second.type()))
            result.orElse(isCovariantWith(env, stringTable, superTable)
                              .withSubPath(TypePath::PathBuilder()
                                               .mt()
                                               .readProp("__index")
                                               .build()));
        }
      }
    }
  }
  return result;
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const TableIndexer &subIndexer,
                                           const TableIndexer &superIndexer) {
  return isInvariantWith(env, subIndexer.indexType, superIndexer.indexType)
      .withBothComponent(TypePath::TypeField::IndexLookup)
      .andAlso(isInvariantWith(env, subIndexer.indexResultType,
                               superIndexer.indexResultType)
                   .withBothComponent(TypePath::TypeField::IndexResult));
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const Property &subProp,
                                           const Property &superProp,
                                           const std::string &name) {
  SubtypingResult res{true};

  if (superProp.isShared() && subProp.isShared())
    res.andAlso(isInvariantWith(env, subProp.type(), superProp.type())
                    .withBothComponent(TypePath::Property::read(name)));
  else {
    if (superProp.readTy.has_value() && subProp.readTy.has_value())
      res.andAlso(isCovariantWith(env, *subProp.readTy, *superProp.readTy)
                      .withBothComponent(TypePath::Property::read(name)));
    if (superProp.writeTy.has_value() && subProp.writeTy.has_value())
      res.andAlso(isContravariantWith(env, *subProp.writeTy, *superProp.writeTy)
                      .withBothComponent(TypePath::Property::write(name)));

    if (superProp.isReadWrite()) {
      if (subProp.isReadOnly())
        res.andAlso(SubtypingResult{false}.withBothComponent(
            TypePath::Property::read(name)));
      else if (subProp.isWriteOnly())
        res.andAlso(SubtypingResult{false}.withBothComponent(
            TypePath::Property::write(name)));
    }
  }

  return res;
}

SubtypingResult Subtyping::isCovariantWith(
    SubtypingEnvironment &env,
    const std::shared_ptr<const NormalizedType> &subNorm,
    const std::shared_ptr<const NormalizedType> &superNorm) {
  if (!subNorm || !superNorm)
    return {false, true};

  SubtypingResult result = isCovariantWith(env, subNorm->tops, superNorm->tops);
  result.andAlso(isCovariantWith(env, subNorm->booleans, superNorm->booleans));
  result.andAlso(
      isCovariantWith(env, subNorm->classes, superNorm->classes)
          .orElse(isCovariantWith(env, subNorm->classes, superNorm->tables)));
  result.andAlso(isCovariantWith(env, subNorm->errors, superNorm->errors));
  result.andAlso(isCovariantWith(env, subNorm->nils, superNorm->nils));
  result.andAlso(isCovariantWith(env, subNorm->numbers, superNorm->numbers));
  result.andAlso(isCovariantWith(env, subNorm->strings, superNorm->strings));
  result.andAlso(isCovariantWith(env, subNorm->strings, superNorm->tables));
  result.andAlso(isCovariantWith(env, subNorm->threads, superNorm->threads));
  result.andAlso(isCovariantWith(env, subNorm->buffers, superNorm->buffers));
  result.andAlso(isCovariantWith(env, subNorm->tables, superNorm->tables));
  result.andAlso(
      isCovariantWith(env, subNorm->functions, superNorm->functions));
  // isCovariantWith(subNorm->tyvars, superNorm->tyvars);
  return result;
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const NormalizedClassType &subClass,
                           const NormalizedClassType &superClass) {
  for (const auto &[subClassTy, _] : subClass.classes) {
    SubtypingResult result;

    for (const auto &[superClassTy, superNegations] : superClass.classes) {
      result.orElse(isCovariantWith(env, subClassTy, superClassTy));
      if (!result.isSubtype)
        continue;

      for (TypeId negation : superNegations) {
        result.andAlso(SubtypingResult::negate(
            isCovariantWith(env, subClassTy, negation)));
        if (result.isSubtype)
          break;
      }
    }

    if (!result.isSubtype)
      return result;
  }

  return {true};
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const NormalizedClassType &subClass,
                                           const TypeIds &superTables) {
  for (const auto &[subClassTy, _] : subClass.classes) {
    SubtypingResult result;

    for (TypeId superTableTy : superTables)
      result.orElse(isCovariantWith(env, subClassTy, superTableTy));

    if (!result.isSubtype)
      return result;
  }

  return {true};
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const NormalizedStringType &subString,
                           const NormalizedStringType &superString) {
  bool isSubtype = Luau::isSubtype(subString, superString);
  return {isSubtype};
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const NormalizedStringType &subString,
                           const TypeIds &superTables) {
  if (subString.isNever())
    return {true};

  if (subString.isCofinite) {
    SubtypingResult result;
    for (const auto &superTable : superTables) {
      result.orElse(isCovariantWith(env, builtinTypes->stringType, superTable));
      if (result.isSubtype)
        return result;
    }
    return result;
  }

  // Finite case
  // S = s1 | s2 | s3 ... sn <: t1 | t2 | ... | tn
  // iff for some ti, S <: ti
  // iff for all sj, sj <: ti
  for (const auto &superTable : superTables) {
    SubtypingResult result{true};
    for (const auto &[_, subString] : subString.singletons) {
      result.andAlso(isCovariantWith(env, subString, superTable));
      if (!result.isSubtype)
        break;
    }

    if (!result.isSubtype)
      continue;
    else
      return result;
  }

  return {false};
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const NormalizedFunctionType &subFunction,
                           const NormalizedFunctionType &superFunction) {
  if (subFunction.isNever())
    return {true};
  else if (superFunction.isTop)
    return {true};
  else
    return isCovariantWith(env, subFunction.parts, superFunction.parts);
}

SubtypingResult Subtyping::isCovariantWith(SubtypingEnvironment &env,
                                           const TypeIds &subTypes,
                                           const TypeIds &superTypes) {
  std::vector<SubtypingResult> results;

  for (TypeId subTy : subTypes) {
    results.emplace_back();
    for (TypeId superTy : superTypes)
      results.back().orElse(isCovariantWith(env, subTy, superTy));
  }

  return SubtypingResult::all(results);
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const VariadicTypePack *subVariadic,
                           const VariadicTypePack *superVariadic) {
  return isCovariantWith(env, subVariadic->ty, superVariadic->ty)
      .withBothComponent(TypePath::TypeField::Variadic);
}

bool Subtyping::bindGeneric(SubtypingEnvironment &env, TypeId subTy,
                            TypeId superTy) {
  if (variance == Variance::Covariant) {
    if (!get<GenericType>(subTy))
      return false;

    env.mappedGenerics[subTy].upperBound.insert(superTy);
  } else {
    if (!get<GenericType>(superTy))
      return false;

    env.mappedGenerics[superTy].lowerBound.insert(subTy);
  }

  return true;
}

SubtypingResult
Subtyping::isCovariantWith(SubtypingEnvironment &env,
                           const TypeFunctionInstanceType *subFamilyInstance,
                           const TypeId superTy) {
  // Reduce the type function instance
  auto [ty, errors] = handleTypeFunctionReductionResult(subFamilyInstance);

  // If we return optional, that means the type function was irreducible - we
  // can reduce that to never
  return isCovariantWith(env, ty, superTy)
      .withErrors(errors)
      .withSubComponent(TypePath::Reduction{ty});
}

SubtypingResult Subtyping::isCovariantWith(
    SubtypingEnvironment &env, const TypeId subTy,
    const TypeFunctionInstanceType *superFamilyInstance) {
  // Reduce the type function instance
  auto [ty, errors] = handleTypeFunctionReductionResult(superFamilyInstance);
  return isCovariantWith(env, subTy, ty)
      .withErrors(errors)
      .withSuperComponent(TypePath::Reduction{ty});
}

/*
 * If, when performing a subtyping test, we encounter a generic on the left
 * side, it is permissible to tentatively bind that generic to the right side
 * type.
 */
bool Subtyping::bindGeneric(SubtypingEnvironment &env, TypePackId subTp,
                            TypePackId superTp) {
  if (variance == Variance::Contravariant)
    std::swap(superTp, subTp);

  if (!get<GenericTypePack>(subTp))
    return false;

  if (TypePackId *m = env.mappedGenericPacks.find(subTp))
    return *m == superTp;

  env.mappedGenericPacks[subTp] = superTp;

  return true;
}

template <typename T, typename Container>
TypeId Subtyping::makeAggregateType(const Container &container, TypeId orElse) {
  if (container.empty())
    return orElse;
  else if (container.size() == 1)
    return *begin(container);
  else
    return arena->addType(
        T{std::vector<TypeId>(begin(container), end(container))});
}

std::pair<TypeId, ErrorVec> Subtyping::handleTypeFunctionReductionResult(
    const TypeFunctionInstanceType *familyInstance) {
  TypeFunctionContext context{arena,      builtinTypes, scope,
                              normalizer, iceReporter,  NotNull{&limits}};
  TypeId family = arena->addType(*familyInstance);
  FunctionGraphReductionResult result =
      reduceTypeFunctions(family, {}, context, true);
  ErrorVec errors;
  if (result.blockedTypes.size() != 0 || result.blockedPacks.size() != 0) {
    errors.push_back(TypeError{{}, UninhabitedTypeFunction{family}});
    return {builtinTypes->neverType, errors};
  }
  if (result.reducedTypes.contains(family))
    return {family, errors};
  return {builtinTypes->neverType, errors};
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/BuiltinDefinitions.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintSolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/RecursionCounter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VecDeque.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <stdexcept>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <unordered_set>

LUAU_FASTFLAG(DebugLuauFreezeArena)

LUAU_FASTINTVARIABLE(LuauTypeMaximumStringifierLength, 500)
LUAU_FASTINTVARIABLE(LuauTableTypeMaximumStringifierLength, 0)
LUAU_FASTINT(LuauTypeInferRecursionLimit)
LUAU_FASTFLAG(LuauInstantiateInSubtyping)

namespace Luau {

// LUAU_NOINLINE prevents unwrapLazy from being inlined into advance below;
// advance is important to keep inlineable
static LUAU_NOINLINE TypeId unwrapLazy(LazyType *ltv) {
  TypeId unwrapped = ltv->unwrapped.load();

  if (unwrapped)
    return unwrapped;

  ltv->unwrap(*ltv);
  unwrapped = ltv->unwrapped.load();

  if (!unwrapped)
    throw InternalCompilerError(
        "Lazy Type didn't fill in unwrapped type field");

  if (get<LazyType>(unwrapped))
    throw InternalCompilerError(
        "Lazy Type cannot resolve to another Lazy Type");

  return unwrapped;
}

TypeId follow(TypeId t) { return follow(t, FollowOption::Normal); }

TypeId follow(TypeId t, FollowOption followOption) {
  return follow(t, followOption, nullptr,
                [](const void *, TypeId t) -> TypeId { return t; });
}

TypeId follow(TypeId t, const void *context,
              TypeId (*mapper)(const void *, TypeId)) {
  return follow(t, FollowOption::Normal, context, mapper);
}

TypeId follow(TypeId t, FollowOption followOption, const void *context,
              TypeId (*mapper)(const void *, TypeId)) {
  auto advance = [followOption, context,
                  mapper](TypeId ty) -> std::optional<TypeId> {
    TypeId mapped = mapper(context, ty);

    if (auto btv = get<Unifiable::Bound<TypeId>>(mapped))
      return btv->boundTo;

    if (auto ttv = get<TableType>(mapped))
      return ttv->boundTo;

    if (auto ltv = getMutable<LazyType>(mapped);
        ltv && followOption != FollowOption::DisableLazyTypeThunks)
      return unwrapLazy(ltv);

    return std::nullopt;
  };

  TypeId cycleTester = t; // Null once we've determined that there is no cycle
  if (auto a = advance(cycleTester))
    cycleTester = *a;
  else
    return t;

  if (!advance(cycleTester)) // Short circuit traversal for the rather common
                             // case when advance(advance(t)) == null
    return cycleTester;

  while (true) {
    auto a1 = advance(t);
    if (a1)
      t = *a1;
    else
      return t;

    if (nullptr != cycleTester) {
      auto a2 = advance(cycleTester);
      if (a2) {
        auto a3 = advance(*a2);
        if (a3)
          cycleTester = *a3;
        else
          cycleTester = nullptr;
      } else
        cycleTester = nullptr;

      if (t == cycleTester)
        throw InternalCompilerError("Luau::follow detected a Type cycle!!");
    }
  }
}

std::vector<TypeId> flattenIntersection(TypeId ty) {
  if (!get<IntersectionType>(follow(ty)))
    return {ty};

  std::unordered_set<TypeId> seen;
  VecDeque<TypeId> queue{ty};

  std::vector<TypeId> result;

  while (!queue.empty()) {
    TypeId current = follow(queue.front());
    queue.pop_front();

    if (seen.find(current) != seen.end())
      continue;

    seen.insert(current);

    if (auto itv = get<IntersectionType>(current)) {
      for (TypeId ty : itv->parts)
        queue.push_back(ty);
    } else
      result.push_back(current);
  }

  return result;
}

bool isPrim(TypeId ty, PrimitiveType::Type primType) {
  auto p = get<PrimitiveType>(follow(ty));
  return p && p->type == primType;
}

bool isNil(TypeId ty) { return isPrim(ty, PrimitiveType::NilType); }

bool isBoolean(TypeId ty) {
  if (isPrim(ty, PrimitiveType::Boolean) ||
      get<BooleanSingleton>(get<SingletonType>(follow(ty))))
    return true;

  if (auto utv = get<UnionType>(follow(ty)))
    return std::all_of(begin(utv), end(utv), isBoolean);

  return false;
}

bool isNumber(TypeId ty) { return isPrim(ty, PrimitiveType::Number); }

// Returns true when ty is a subtype of string
bool isString(TypeId ty) {
  ty = follow(ty);

  if (isPrim(ty, PrimitiveType::String) ||
      get<StringSingleton>(get<SingletonType>(ty)))
    return true;

  if (auto utv = get<UnionType>(ty))
    return std::all_of(begin(utv), end(utv), isString);

  return false;
}

// Returns true when ty is a supertype of string
bool maybeString(TypeId ty) {
  ty = follow(ty);

  if (isPrim(ty, PrimitiveType::String) || get<AnyType>(ty))
    return true;

  if (auto utv = get<UnionType>(ty))
    return std::any_of(begin(utv), end(utv), maybeString);

  return false;
}

bool isThread(TypeId ty) { return isPrim(ty, PrimitiveType::Thread); }

bool isBuffer(TypeId ty) { return isPrim(ty, PrimitiveType::Buffer); }

bool isOptional(TypeId ty) {
  if (isNil(ty))
    return true;

  ty = follow(ty);

  if (get<AnyType>(ty) || get<UnknownType>(ty))
    return true;

  auto utv = get<UnionType>(ty);
  if (!utv)
    return false;

  return std::any_of(begin(utv), end(utv), isOptional);
}

bool isTableIntersection(TypeId ty) {
  if (!get<IntersectionType>(follow(ty)))
    return false;

  std::vector<TypeId> parts = flattenIntersection(ty);
  return std::all_of(parts.begin(), parts.end(), getTableType);
}

bool isTableUnion(TypeId ty) {
  const UnionType *ut = get<UnionType>(follow(ty));
  if (!ut)
    return false;

  return std::all_of(begin(ut), end(ut), getTableType);
}

bool isOverloadedFunction(TypeId ty) {
  if (!get<IntersectionType>(follow(ty)))
    return false;

  auto isFunction = [](TypeId part) -> bool { return get<FunctionType>(part); };

  std::vector<TypeId> parts = flattenIntersection(ty);
  return std::all_of(parts.begin(), parts.end(), isFunction);
}

std::optional<TypeId> getMetatable(TypeId type,
                                   NotNull<BuiltinTypes> builtinTypes) {
  type = follow(type);

  if (const MetatableType *mtType = get<MetatableType>(type))
    return mtType->metatable;
  else if (const ClassType *classType = get<ClassType>(type))
    return classType->metatable;
  else if (isString(type)) {
    auto ptv = get<PrimitiveType>(builtinTypes->stringType);
    LUAU_ASSERT(ptv && ptv->metatable);
    return ptv->metatable;
  }

  return std::nullopt;
}

const TableType *getTableType(TypeId type) {
  type = follow(type);

  if (const TableType *ttv = get<TableType>(type))
    return ttv;
  else if (const MetatableType *mtv = get<MetatableType>(type))
    return get<TableType>(follow(mtv->table));
  else
    return nullptr;
}

TableType *getMutableTableType(TypeId type) {
  return const_cast<TableType *>(getTableType(type));
}

const std::string *getName(TypeId type) {
  type = follow(type);
  if (auto mtv = get<MetatableType>(type)) {
    if (mtv->syntheticName)
      return &*mtv->syntheticName;
    type = follow(mtv->table);
  }

  if (auto ttv = get<TableType>(type)) {
    if (ttv->name)
      return &*ttv->name;
    if (ttv->syntheticName)
      return &*ttv->syntheticName;
  }

  return nullptr;
}

std::optional<ModuleName> getDefinitionModuleName(TypeId type) {
  type = follow(type);

  if (auto ttv = get<TableType>(type)) {
    if (!ttv->definitionModuleName.empty())
      return ttv->definitionModuleName;
  } else if (auto ftv = get<FunctionType>(type)) {
    if (ftv->definition)
      return ftv->definition->definitionModuleName;
  } else if (auto ctv = get<ClassType>(type)) {
    if (!ctv->definitionModuleName.empty())
      return ctv->definitionModuleName;
  }

  return std::nullopt;
}

bool isSubset(const UnionType &super, const UnionType &sub) {
  std::unordered_set<TypeId> superTypes;

  for (TypeId id : super.options)
    superTypes.insert(id);

  for (TypeId id : sub.options) {
    if (superTypes.find(id) == superTypes.end())
      return false;
  }

  return true;
}
bool hasPrimitiveTypeInIntersection(TypeId ty, PrimitiveType::Type primTy) {
  TypeId tf = follow(ty);
  if (isPrim(tf, primTy))
    return true;

  for (auto t : flattenIntersection(tf))
    return isPrim(follow(t), primTy);
  return false;
}
// When typechecking an assignment `x = e`, we typecheck `x:T` and `e:U`,
// then instantiate U if `isGeneric(U)` is true, and `maybeGeneric(T)` is false.
bool isGeneric(TypeId ty) {
  LUAU_ASSERT(!FFlag::LuauInstantiateInSubtyping);

  ty = follow(ty);
  if (auto ftv = get<FunctionType>(ty))
    return ftv->generics.size() > 0 || ftv->genericPacks.size() > 0;
  else
    // TODO: recurse on type synonyms CLI-39914
    // TODO: recurse on table types CLI-39914
    return false;
}

bool maybeGeneric(TypeId ty) {
  LUAU_ASSERT(!FFlag::LuauInstantiateInSubtyping);

  ty = follow(ty);

  if (get<FreeType>(ty))
    return true;

  if (auto ttv = get<TableType>(ty)) {
    // TODO: recurse on table types CLI-39914
    (void)ttv;
    return true;
  }

  if (auto itv = get<IntersectionType>(ty)) {
    return std::any_of(begin(itv), end(itv), maybeGeneric);
  }

  return isGeneric(ty);
}

bool maybeSingleton(TypeId ty) {
  ty = follow(ty);
  if (get<SingletonType>(ty))
    return true;
  if (const UnionType *utv = get<UnionType>(ty))
    for (TypeId option : utv)
      if (get<SingletonType>(follow(option)))
        return true;
  if (const IntersectionType *itv = get<IntersectionType>(ty))
    for (TypeId part : itv)
      if (maybeSingleton(part)) // will i regret this?
        return true;
  if (const TypeFunctionInstanceType *tfit = get<TypeFunctionInstanceType>(ty))
    if (tfit->family->name == "keyof" || tfit->family->name == "rawkeyof")
      return true;
  return false;
}

bool hasLength(TypeId ty, DenseHashSet<TypeId> &seen, int *recursionCount) {
  RecursionLimiter _rl(recursionCount, FInt::LuauTypeInferRecursionLimit);

  ty = follow(ty);

  if (seen.contains(ty))
    return true;

  if (isString(ty) || isPrim(ty, PrimitiveType::Table) || get<AnyType>(ty) ||
      get<TableType>(ty) || get<MetatableType>(ty))
    return true;

  if (auto uty = get<UnionType>(ty)) {
    seen.insert(ty);

    for (TypeId part : uty->options) {
      if (!hasLength(part, seen, recursionCount))
        return false;
    }

    return true;
  }

  if (auto ity = get<IntersectionType>(ty)) {
    seen.insert(ty);

    for (TypeId part : ity->parts) {
      if (hasLength(part, seen, recursionCount))
        return true;
    }

    return false;
  }

  return false;
}

FreeType::FreeType(TypeLevel level)
    : index(Unifiable::freshIndex()), level(level), scope(nullptr) {}

FreeType::FreeType(Scope *scope)
    : index(Unifiable::freshIndex()), level{}, scope(scope) {}

FreeType::FreeType(Scope *scope, TypeLevel level)
    : index(Unifiable::freshIndex()), level(level), scope(scope) {}

FreeType::FreeType(Scope *scope, TypeId lowerBound, TypeId upperBound)
    : index(Unifiable::freshIndex()), scope(scope), lowerBound(lowerBound),
      upperBound(upperBound) {}

GenericType::GenericType()
    : index(Unifiable::freshIndex()), name("g" + std::to_string(index)) {}

GenericType::GenericType(TypeLevel level)
    : index(Unifiable::freshIndex()), level(level),
      name("g" + std::to_string(index)) {}

GenericType::GenericType(const Name &name)
    : index(Unifiable::freshIndex()), name(name), explicitName(true) {}

GenericType::GenericType(Scope *scope)
    : index(Unifiable::freshIndex()), scope(scope) {}

GenericType::GenericType(TypeLevel level, const Name &name)
    : index(Unifiable::freshIndex()), level(level), name(name),
      explicitName(true) {}

GenericType::GenericType(Scope *scope, const Name &name)
    : index(Unifiable::freshIndex()), scope(scope), name(name),
      explicitName(true) {}

BlockedType::BlockedType() : index(Unifiable::freshIndex()) {}

Constraint *BlockedType::getOwner() const { return owner; }

void BlockedType::setOwner(Constraint *newOwner) {
  LUAU_ASSERT(owner == nullptr);

  if (owner != nullptr)
    return;

  owner = newOwner;
}

void BlockedType::replaceOwner(Constraint *newOwner) { owner = newOwner; }

PendingExpansionType::PendingExpansionType(
    std::optional<AstName> prefix, AstName name,
    std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments)
    : prefix(prefix), name(name), typeArguments(typeArguments),
      packArguments(packArguments), index(++nextIndex) {}

size_t PendingExpansionType::nextIndex = 0;

FunctionType::FunctionType(TypePackId argTypes, TypePackId retTypes,
                           std::optional<FunctionDefinition> defn, bool hasSelf)
    : definition(std::move(defn)), argTypes(argTypes), retTypes(retTypes),
      hasSelf(hasSelf) {}

FunctionType::FunctionType(TypeLevel level, TypePackId argTypes,
                           TypePackId retTypes,
                           std::optional<FunctionDefinition> defn, bool hasSelf)
    : definition(std::move(defn)), level(level), argTypes(argTypes),
      retTypes(retTypes), hasSelf(hasSelf) {}

FunctionType::FunctionType(TypeLevel level, Scope *scope, TypePackId argTypes,
                           TypePackId retTypes,
                           std::optional<FunctionDefinition> defn, bool hasSelf)
    : definition(std::move(defn)), level(level), scope(scope),
      argTypes(argTypes), retTypes(retTypes), hasSelf(hasSelf) {}

FunctionType::FunctionType(std::vector<TypeId> generics,
                           std::vector<TypePackId> genericPacks,
                           TypePackId argTypes, TypePackId retTypes,
                           std::optional<FunctionDefinition> defn, bool hasSelf)
    : definition(std::move(defn)), generics(generics),
      genericPacks(genericPacks), argTypes(argTypes), retTypes(retTypes),
      hasSelf(hasSelf) {}

FunctionType::FunctionType(TypeLevel level, std::vector<TypeId> generics,
                           std::vector<TypePackId> genericPacks,
                           TypePackId argTypes, TypePackId retTypes,
                           std::optional<FunctionDefinition> defn, bool hasSelf)
    : definition(std::move(defn)), generics(generics),
      genericPacks(genericPacks), level(level), argTypes(argTypes),
      retTypes(retTypes), hasSelf(hasSelf) {}

FunctionType::FunctionType(TypeLevel level, Scope *scope,
                           std::vector<TypeId> generics,
                           std::vector<TypePackId> genericPacks,
                           TypePackId argTypes, TypePackId retTypes,
                           std::optional<FunctionDefinition> defn, bool hasSelf)
    : definition(std::move(defn)), generics(generics),
      genericPacks(genericPacks), level(level), scope(scope),
      argTypes(argTypes), retTypes(retTypes), hasSelf(hasSelf) {}

Property::Property() {}

Property::Property(TypeId readTy, bool deprecated,
                   const std::string &deprecatedSuggestion,
                   std::optional<Location> location, const Tags &tags,
                   const std::optional<std::string> &documentationSymbol,
                   std::optional<Location> typeLocation)
    : deprecated(deprecated), deprecatedSuggestion(deprecatedSuggestion),
      location(location), typeLocation(typeLocation), tags(tags),
      documentationSymbol(documentationSymbol), readTy(readTy),
      writeTy(readTy) {}

Property Property::readonly(TypeId ty) {
  Property p;
  p.readTy = ty;
  return p;
}

Property Property::writeonly(TypeId ty) {
  Property p;
  p.writeTy = ty;
  return p;
}

Property Property::rw(TypeId ty) { return Property::rw(ty, ty); }

Property Property::rw(TypeId read, TypeId write) {
  Property p;
  p.readTy = read;
  p.writeTy = write;
  return p;
}

Property Property::create(std::optional<TypeId> read,
                          std::optional<TypeId> write) {
  if (read && !write)
    return Property::readonly(*read);
  else if (!read && write)
    return Property::writeonly(*write);
  else {
    LUAU_ASSERT(read && write);
    return Property::rw(*read, *write);
  }
}

TypeId Property::type() const {
  LUAU_ASSERT(readTy);
  return *readTy;
}

void Property::setType(TypeId ty) {
  readTy = ty;
  if (FFlag::DebugLuauDeferredConstraintResolution)
    writeTy = ty;
}

void Property::makeShared() {
  if (writeTy)
    writeTy = readTy;
}

bool Property::isShared() const {
  return readTy && writeTy && readTy == writeTy;
}

bool Property::isReadOnly() const { return readTy && !writeTy; }

bool Property::isWriteOnly() const { return !readTy && writeTy; }

bool Property::isReadWrite() const { return readTy && writeTy; }

TableType::TableType(TableState state, TypeLevel level, Scope *scope)
    : state(state), level(level), scope(scope) {}

TableType::TableType(const Props &props,
                     const std::optional<TableIndexer> &indexer,
                     TypeLevel level, TableState state)
    : props(props), indexer(indexer), state(state), level(level) {}

TableType::TableType(const Props &props,
                     const std::optional<TableIndexer> &indexer,
                     TypeLevel level, Scope *scope, TableState state)
    : props(props), indexer(indexer), state(state), level(level), scope(scope) {
}

// Test Types for equivalence
// More complex than we'd like because Types can self-reference.

bool areSeen(SeenSet &seen, const void *lhs, const void *rhs) {
  if (lhs == rhs)
    return true;

  auto p = std::make_pair(const_cast<void *>(lhs), const_cast<void *>(rhs));
  if (seen.find(p) != seen.end())
    return true;

  seen.insert(p);
  return false;
}

bool areEqual(SeenSet &seen, const FunctionType &lhs, const FunctionType &rhs) {
  if (areSeen(seen, &lhs, &rhs))
    return true;

  // TODO: check generics CLI-39915

  if (!areEqual(seen, *lhs.argTypes, *rhs.argTypes))
    return false;

  if (!areEqual(seen, *lhs.retTypes, *rhs.retTypes))
    return false;

  return true;
}

bool areEqual(SeenSet &seen, const TableType &lhs, const TableType &rhs) {
  if (areSeen(seen, &lhs, &rhs))
    return true;

  if (lhs.state != rhs.state)
    return false;

  if (lhs.props.size() != rhs.props.size())
    return false;

  if (bool(lhs.indexer) != bool(rhs.indexer))
    return false;

  if (lhs.indexer && rhs.indexer) {
    if (!areEqual(seen, *lhs.indexer->indexType, *rhs.indexer->indexType))
      return false;

    if (!areEqual(seen, *lhs.indexer->indexResultType,
                  *rhs.indexer->indexResultType))
      return false;
  }

  auto l = lhs.props.begin();
  auto r = rhs.props.begin();

  while (l != lhs.props.end()) {
    if (l->first != r->first)
      return false;

    if (!areEqual(seen, *l->second.type(), *r->second.type()))
      return false;
    ++l;
    ++r;
  }

  return true;
}

static bool areEqual(SeenSet &seen, const MetatableType &lhs,
                     const MetatableType &rhs) {
  if (areSeen(seen, &lhs, &rhs))
    return true;

  return areEqual(seen, *lhs.table, *rhs.table) &&
         areEqual(seen, *lhs.metatable, *rhs.metatable);
}

bool areEqual(SeenSet &seen, const Type &lhs, const Type &rhs) {
  if (auto bound = get_if<BoundType>(&lhs.ty))
    return areEqual(seen, *bound->boundTo, rhs);

  if (auto bound = get_if<BoundType>(&rhs.ty))
    return areEqual(seen, lhs, *bound->boundTo);

  if (lhs.ty.index() != rhs.ty.index())
    return false;

  {
    const FreeType *lf = get_if<FreeType>(&lhs.ty);
    const FreeType *rf = get_if<FreeType>(&rhs.ty);
    if (lf && rf)
      return lf->index == rf->index;
  }

  {
    const GenericType *lg = get_if<GenericType>(&lhs.ty);
    const GenericType *rg = get_if<GenericType>(&rhs.ty);
    if (lg && rg)
      return lg->index == rg->index;
  }

  {
    const PrimitiveType *lp = get_if<PrimitiveType>(&lhs.ty);
    const PrimitiveType *rp = get_if<PrimitiveType>(&rhs.ty);
    if (lp && rp)
      return lp->type == rp->type;
  }

  {
    const GenericType *lg = get_if<GenericType>(&lhs.ty);
    const GenericType *rg = get_if<GenericType>(&rhs.ty);
    if (lg && rg)
      return lg->index == rg->index;
  }

  {
    const ErrorType *le = get_if<ErrorType>(&lhs.ty);
    const ErrorType *re = get_if<ErrorType>(&rhs.ty);
    if (le && re)
      return le->index == re->index;
  }

  {
    const FunctionType *lf = get_if<FunctionType>(&lhs.ty);
    const FunctionType *rf = get_if<FunctionType>(&rhs.ty);
    if (lf && rf)
      return areEqual(seen, *lf, *rf);
  }

  {
    const TableType *lt = get_if<TableType>(&lhs.ty);
    const TableType *rt = get_if<TableType>(&rhs.ty);
    if (lt && rt)
      return areEqual(seen, *lt, *rt);
  }

  {
    const MetatableType *lmt = get_if<MetatableType>(&lhs.ty);
    const MetatableType *rmt = get_if<MetatableType>(&rhs.ty);

    if (lmt && rmt)
      return areEqual(seen, *lmt, *rmt);
  }

  if (get_if<AnyType>(&lhs.ty) && get_if<AnyType>(&rhs.ty))
    return true;

  return false;
}

Type *asMutable(TypeId ty) { return const_cast<Type *>(ty); }

bool Type::operator==(const Type &rhs) const {
  SeenSet seen;
  return areEqual(seen, *this, rhs);
}

bool Type::operator!=(const Type &rhs) const {
  SeenSet seen;
  return !areEqual(seen, *this, rhs);
}

Type &Type::operator=(const TypeVariant &rhs) {
  ty = rhs;
  return *this;
}

Type &Type::operator=(TypeVariant &&rhs) {
  ty = std::move(rhs);
  return *this;
}

Type &Type::operator=(const Type &rhs) {
  LUAU_ASSERT(owningArena == rhs.owningArena);
  LUAU_ASSERT(!rhs.persistent);

  reassign(rhs);

  return *this;
}

TypeId makeFunction(TypeArena &arena, std::optional<TypeId> selfType,
                    std::initializer_list<TypeId> generics,
                    std::initializer_list<TypePackId> genericPacks,
                    std::initializer_list<TypeId> paramTypes,
                    std::initializer_list<std::string> paramNames,
                    std::initializer_list<TypeId> retTypes);

TypeId makeStringMetatable(
    NotNull<BuiltinTypes> builtinTypes); // BuiltinDefinitions.cpp

BuiltinTypes::BuiltinTypes()
    : arena(new TypeArena), debugFreezeArena(FFlag::DebugLuauFreezeArena),
      nilType(arena->addType(
          Type{PrimitiveType{PrimitiveType::NilType}, /*persistent*/ true})),
      numberType(arena->addType(
          Type{PrimitiveType{PrimitiveType::Number}, /*persistent*/ true})),
      stringType(arena->addType(
          Type{PrimitiveType{PrimitiveType::String}, /*persistent*/ true})),
      booleanType(arena->addType(
          Type{PrimitiveType{PrimitiveType::Boolean}, /*persistent*/ true})),
      threadType(arena->addType(
          Type{PrimitiveType{PrimitiveType::Thread}, /*persistent*/ true})),
      bufferType(arena->addType(
          Type{PrimitiveType{PrimitiveType::Buffer}, /*persistent*/ true})),
      functionType(arena->addType(
          Type{PrimitiveType{PrimitiveType::Function}, /*persistent*/ true})),
      classType(arena->addType(
          Type{ClassType{"class", {}, std::nullopt, std::nullopt, {}, {}, {}},
               /*persistent*/ true})),
      tableType(arena->addType(
          Type{PrimitiveType{PrimitiveType::Table}, /*persistent*/ true})),
      emptyTableType(arena->addType(
          Type{TableType{TableState::Sealed, TypeLevel{}, nullptr},
               /*persistent*/ true})),
      trueType(arena->addType(
          Type{SingletonType{BooleanSingleton{true}}, /*persistent*/ true})),
      falseType(arena->addType(
          Type{SingletonType{BooleanSingleton{false}}, /*persistent*/ true})),
      anyType(arena->addType(Type{AnyType{}, /*persistent*/ true})),
      unknownType(arena->addType(Type{UnknownType{}, /*persistent*/ true})),
      neverType(arena->addType(Type{NeverType{}, /*persistent*/ true})),
      errorType(arena->addType(Type{ErrorType{}, /*persistent*/ true})),
      falsyType(arena->addType(
          Type{UnionType{{falseType, nilType}}, /*persistent*/ true})),
      truthyType(
          arena->addType(Type{NegationType{falsyType}, /*persistent*/ true})),
      optionalNumberType(arena->addType(
          Type{UnionType{{numberType, nilType}}, /*persistent*/ true})),
      optionalStringType(arena->addType(
          Type{UnionType{{stringType, nilType}}, /*persistent*/ true})),
      emptyTypePack(
          arena->addTypePack(TypePackVar{TypePack{{}}, /*persistent*/ true})),
      anyTypePack(arena->addTypePack(
          TypePackVar{VariadicTypePack{anyType}, /*persistent*/ true})),
      unknownTypePack(arena->addTypePack(
          TypePackVar{VariadicTypePack{unknownType}, /*persistent*/ true})),
      neverTypePack(arena->addTypePack(
          TypePackVar{VariadicTypePack{neverType}, /*persistent*/ true})),
      uninhabitableTypePack(arena->addTypePack(TypePackVar{
          TypePack{{neverType}, neverTypePack}, /*persistent*/ true})),
      errorTypePack(arena->addTypePack(
          TypePackVar{Unifiable::Error{}, /*persistent*/ true})) {
  freeze(*arena);
}

BuiltinTypes::~BuiltinTypes() {
  // Destroy the arena with the same memory management flags it was created with
  bool prevFlag = FFlag::DebugLuauFreezeArena;
  FFlag::DebugLuauFreezeArena.value = debugFreezeArena;

  unfreeze(*arena);
  arena.reset(nullptr);

  FFlag::DebugLuauFreezeArena.value = prevFlag;
}

TypeId BuiltinTypes::errorRecoveryType() const { return errorType; }

TypePackId BuiltinTypes::errorRecoveryTypePack() const { return errorTypePack; }

TypeId BuiltinTypes::errorRecoveryType(TypeId guess) const { return guess; }

TypePackId BuiltinTypes::errorRecoveryTypePack(TypePackId guess) const {
  return guess;
}

void persist(TypeId ty) {
  VecDeque<TypeId> queue{ty};

  while (!queue.empty()) {
    TypeId t = queue.front();
    queue.pop_front();

    if (t->persistent)
      continue;

    asMutable(t)->persistent = true;

    if (auto btv = get<BoundType>(t))
      queue.push_back(btv->boundTo);
    else if (auto ftv = get<FunctionType>(t)) {
      persist(ftv->argTypes);
      persist(ftv->retTypes);
    } else if (auto ttv = get<TableType>(t)) {
      LUAU_ASSERT(ttv->state != TableState::Free &&
                  ttv->state != TableState::Unsealed);

      for (const auto &[_name, prop] : ttv->props)
        queue.push_back(prop.type());

      if (ttv->indexer) {
        queue.push_back(ttv->indexer->indexType);
        queue.push_back(ttv->indexer->indexResultType);
      }
    } else if (auto ctv = get<ClassType>(t)) {
      for (const auto &[_name, prop] : ctv->props)
        queue.push_back(prop.type());
    } else if (auto utv = get<UnionType>(t)) {
      for (TypeId opt : utv->options)
        queue.push_back(opt);
    } else if (auto itv = get<IntersectionType>(t)) {
      for (TypeId opt : itv->parts)
        queue.push_back(opt);
    } else if (auto mtv = get<MetatableType>(t)) {
      queue.push_back(mtv->table);
      queue.push_back(mtv->metatable);
    } else if (get<GenericType>(t) || get<AnyType>(t) || get<FreeType>(t) ||
               get<SingletonType>(t) || get<PrimitiveType>(t) ||
               get<NegationType>(t)) {
    } else if (auto tfit = get<TypeFunctionInstanceType>(t)) {
      for (auto ty : tfit->typeArguments)
        queue.push_back(ty);

      for (auto tp : tfit->packArguments)
        persist(tp);
    } else {
      LUAU_ASSERT(!"TypeId is not supported in a persist call");
    }
  }
}

void persist(TypePackId tp) {
  if (tp->persistent)
    return;

  asMutable(tp)->persistent = true;

  if (auto p = get<TypePack>(tp)) {
    for (TypeId ty : p->head)
      persist(ty);
    if (p->tail)
      persist(*p->tail);
  } else if (auto vtp = get<VariadicTypePack>(tp)) {
    persist(vtp->ty);
  } else if (get<GenericTypePack>(tp)) {
  } else if (auto tfitp = get<TypeFunctionInstanceTypePack>(tp)) {
    for (auto ty : tfitp->typeArguments)
      persist(ty);

    for (auto tp : tfitp->packArguments)
      persist(tp);
  } else {
    LUAU_ASSERT(!"TypePackId is not supported in a persist call");
  }
}

const TypeLevel *getLevel(TypeId ty) {
  ty = follow(ty);

  if (auto ftv = get<FreeType>(ty))
    return &ftv->level;
  else if (auto ttv = get<TableType>(ty))
    return &ttv->level;
  else if (auto ftv = get<FunctionType>(ty))
    return &ftv->level;
  else
    return nullptr;
}

TypeLevel *getMutableLevel(TypeId ty) {
  return const_cast<TypeLevel *>(getLevel(ty));
}

std::optional<TypeLevel> getLevel(TypePackId tp) {
  tp = follow(tp);

  if (auto ftv = get<FreeTypePack>(tp))
    return ftv->level;
  else
    return std::nullopt;
}

const Property *lookupClassProp(const ClassType *cls, const Name &name) {
  while (cls) {
    auto it = cls->props.find(name);
    if (it != cls->props.end())
      return &it->second;

    if (cls->parent)
      cls = get<ClassType>(*cls->parent);
    else
      return nullptr;

    LUAU_ASSERT(cls);
  }

  return nullptr;
}

bool isSubclass(const ClassType *cls, const ClassType *parent) {
  while (cls) {
    if (cls == parent)
      return true;
    else if (!cls->parent)
      return false;

    cls = get<ClassType>(*cls->parent);
    LUAU_ASSERT(cls);
  }

  return false;
}

const std::vector<TypeId> &getTypes(const UnionType *utv) {
  return utv->options;
}

const std::vector<TypeId> &getTypes(const IntersectionType *itv) {
  return itv->parts;
}

UnionTypeIterator begin(const UnionType *utv) { return UnionTypeIterator{utv}; }

UnionTypeIterator end(const UnionType *utv) { return UnionTypeIterator{}; }

IntersectionTypeIterator begin(const IntersectionType *itv) {
  return IntersectionTypeIterator{itv};
}

IntersectionTypeIterator end(const IntersectionType *itv) {
  return IntersectionTypeIterator{};
}

TypeId freshType(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes,
                 Scope *scope) {
  return arena->addType(
      FreeType{scope, builtinTypes->neverType, builtinTypes->unknownType});
}

std::vector<TypeId> filterMap(TypeId type, TypeIdPredicate predicate) {
  type = follow(type);

  if (auto utv = get<UnionType>(type)) {
    std::set<TypeId> options;
    for (TypeId option : utv)
      if (auto out = predicate(follow(option)))
        options.insert(*out);

    return std::vector<TypeId>(options.begin(), options.end());
  } else if (auto out = predicate(type))
    return {*out};

  return {};
}

static Tags *getTags(TypeId ty) {
  ty = follow(ty);

  if (auto ftv = getMutable<FunctionType>(ty))
    return &ftv->tags;
  else if (auto ttv = getMutable<TableType>(ty))
    return &ttv->tags;
  else if (auto ctv = getMutable<ClassType>(ty))
    return &ctv->tags;

  return nullptr;
}

void attachTag(TypeId ty, const std::string &tagName) {
  if (auto tags = getTags(ty))
    tags->push_back(tagName);
  else
    LUAU_ASSERT(!"This TypeId does not support tags");
}

void attachTag(Property &prop, const std::string &tagName) {
  prop.tags.push_back(tagName);
}

// We would ideally not expose this because it could cause a footgun.
// If the Base class has a tag and you ask if Derived has that tag, it would
// return false. Unfortunately, there's already use cases that's hard to
// disentangle. For now, we expose it.
bool hasTag(const Tags &tags, const std::string &tagName) {
  return std::find(tags.begin(), tags.end(), tagName) != tags.end();
}

bool hasTag(TypeId ty, const std::string &tagName) {
  ty = follow(ty);

  // We special case classes because getTags only returns a pointer to one
  // vector of tags. But classes has multiple vector of tags, represented
  // throughout the hierarchy.
  if (auto ctv = get<ClassType>(ty)) {
    while (ctv) {
      if (hasTag(ctv->tags, tagName))
        return true;
      else if (!ctv->parent)
        return false;

      ctv = get<ClassType>(*ctv->parent);
      LUAU_ASSERT(ctv);
    }
  } else if (auto tags = getTags(ty))
    return hasTag(*tags, tagName);

  return false;
}

bool hasTag(const Property &prop, const std::string &tagName) {
  return hasTag(prop.tags, tagName);
}

bool TypeFun::operator==(const TypeFun &rhs) const {
  return type == rhs.type && typeParams == rhs.typeParams &&
         typePackParams == rhs.typePackParams;
}

bool GenericTypeDefinition::operator==(const GenericTypeDefinition &rhs) const {
  return ty == rhs.ty && defaultValue == rhs.defaultValue;
}

bool GenericTypePackDefinition::operator==(
    const GenericTypePackDefinition &rhs) const {
  return tp == rhs.tp && defaultValue == rhs.defaultValue;
}

template <>
LUAU_NOINLINE Unifiable::Bound<TypeId> *emplaceType<BoundType>(Type *ty,
                                                               TypeId &tyArg) {
  LUAU_ASSERT(ty != follow(tyArg));
  return &ty->ty.emplace<BoundType>(tyArg);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/BuiltinDefinitions.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Frontend.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Symbol.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintSolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ConstraintGenerator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

/** FIXME: Many of these type definitions are not quite completely accurate.
 *
 * Some of them require richer generics than we have.  For instance, we do not
 * yet have a way to talk about a function that takes any number of values, but
 * where each value must have some specific type.
 */

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution);

namespace Luau {

static std::optional<WithPredicate<TypePackId>>
magicFunctionSelect(TypeChecker &typechecker, const ScopePtr &scope,
                    const AstExprCall &expr,
                    WithPredicate<TypePackId> withPredicate);
static std::optional<WithPredicate<TypePackId>>
magicFunctionSetMetaTable(TypeChecker &typechecker, const ScopePtr &scope,
                          const AstExprCall &expr,
                          WithPredicate<TypePackId> withPredicate);
static std::optional<WithPredicate<TypePackId>>
magicFunctionAssert(TypeChecker &typechecker, const ScopePtr &scope,
                    const AstExprCall &expr,
                    WithPredicate<TypePackId> withPredicate);
static std::optional<WithPredicate<TypePackId>>
magicFunctionPack(TypeChecker &typechecker, const ScopePtr &scope,
                  const AstExprCall &expr,
                  WithPredicate<TypePackId> withPredicate);
static std::optional<WithPredicate<TypePackId>>
magicFunctionRequire(TypeChecker &typechecker, const ScopePtr &scope,
                     const AstExprCall &expr,
                     WithPredicate<TypePackId> withPredicate);

static bool dcrMagicFunctionSelect(MagicFunctionCallContext context);
static bool dcrMagicFunctionRequire(MagicFunctionCallContext context);
static bool dcrMagicFunctionPack(MagicFunctionCallContext context);

TypeId makeUnion(TypeArena &arena, std::vector<TypeId> &&types) {
  return arena.addType(UnionType{std::move(types)});
}

TypeId makeIntersection(TypeArena &arena, std::vector<TypeId> &&types) {
  return arena.addType(IntersectionType{std::move(types)});
}

TypeId makeOption(NotNull<BuiltinTypes> builtinTypes, TypeArena &arena,
                  TypeId t) {
  LUAU_ASSERT(t);
  return makeUnion(arena, {builtinTypes->nilType, t});
}

TypeId makeFunction(TypeArena &arena, std::optional<TypeId> selfType,
                    std::initializer_list<TypeId> paramTypes,
                    std::initializer_list<TypeId> retTypes, bool checked) {
  return makeFunction(arena, selfType, {}, {}, paramTypes, {}, retTypes,
                      checked);
}

TypeId makeFunction(TypeArena &arena, std::optional<TypeId> selfType,
                    std::initializer_list<TypeId> generics,
                    std::initializer_list<TypePackId> genericPacks,
                    std::initializer_list<TypeId> paramTypes,
                    std::initializer_list<TypeId> retTypes, bool checked) {
  return makeFunction(arena, selfType, generics, genericPacks, paramTypes, {},
                      retTypes, checked);
}

TypeId makeFunction(TypeArena &arena, std::optional<TypeId> selfType,
                    std::initializer_list<TypeId> paramTypes,
                    std::initializer_list<std::string> paramNames,
                    std::initializer_list<TypeId> retTypes, bool checked) {
  return makeFunction(arena, selfType, {}, {}, paramTypes, paramNames, retTypes,
                      checked);
}

TypeId makeFunction(TypeArena &arena, std::optional<TypeId> selfType,
                    std::initializer_list<TypeId> generics,
                    std::initializer_list<TypePackId> genericPacks,
                    std::initializer_list<TypeId> paramTypes,
                    std::initializer_list<std::string> paramNames,
                    std::initializer_list<TypeId> retTypes, bool checked) {
  std::vector<TypeId> params;
  if (selfType)
    params.push_back(*selfType);
  for (auto &&p : paramTypes)
    params.push_back(p);

  TypePackId paramPack = arena.addTypePack(std::move(params));
  TypePackId retPack = arena.addTypePack(std::vector<TypeId>(retTypes));
  FunctionType ftv{generics, genericPacks, paramPack,
                   retPack,  {},           selfType.has_value()};

  if (selfType)
    ftv.argNames.push_back(Luau::FunctionArgument{"self", {}});

  if (paramNames.size() != 0) {
    for (auto &&p : paramNames)
      ftv.argNames.push_back(Luau::FunctionArgument{std::move(p), {}});
  } else if (selfType) {
    // If argument names were not provided, but we have already added a name for
    // 'self' argument, we have to fill remaining slots as well
    for (size_t i = 0; i < paramTypes.size(); i++)
      ftv.argNames.push_back(std::nullopt);
  }

  ftv.isCheckedFunction = checked;

  return arena.addType(std::move(ftv));
}

void attachMagicFunction(TypeId ty, MagicFunction fn) {
  if (auto ftv = getMutable<FunctionType>(ty))
    ftv->magicFunction = fn;
  else
    LUAU_ASSERT(!"Got a non functional type");
}

void attachDcrMagicFunction(TypeId ty, DcrMagicFunction fn) {
  if (auto ftv = getMutable<FunctionType>(ty))
    ftv->dcrMagicFunction = fn;
  else
    LUAU_ASSERT(!"Got a non functional type");
}

void attachDcrMagicRefinement(TypeId ty, DcrMagicRefinement fn) {
  if (auto ftv = getMutable<FunctionType>(ty))
    ftv->dcrMagicRefinement = fn;
  else
    LUAU_ASSERT(!"Got a non functional type");
}

Property makeProperty(TypeId ty,
                      std::optional<std::string> documentationSymbol) {
  return {
      /* type */ ty,
      /* deprecated */ false,
      /* deprecatedSuggestion */ {},
      /* location */ std::nullopt,
      /* tags */ {},
      documentationSymbol,
  };
}

void addGlobalBinding(GlobalTypes &globals, const std::string &name, TypeId ty,
                      const std::string &packageName) {
  addGlobalBinding(globals, globals.globalScope, name, ty, packageName);
}

void addGlobalBinding(GlobalTypes &globals, const std::string &name,
                      Binding binding) {
  addGlobalBinding(globals, globals.globalScope, name, binding);
}

void addGlobalBinding(GlobalTypes &globals, const ScopePtr &scope,
                      const std::string &name, TypeId ty,
                      const std::string &packageName) {
  std::string documentationSymbol = packageName + "/global/" + name;
  addGlobalBinding(globals, scope, name,
                   Binding{ty, Location{}, {}, {}, documentationSymbol});
}

void addGlobalBinding(GlobalTypes &globals, const ScopePtr &scope,
                      const std::string &name, Binding binding) {
  scope->bindings[globals.globalNames.names->getOrAdd(name.c_str())] = binding;
}

std::optional<Binding> tryGetGlobalBinding(GlobalTypes &globals,
                                           const std::string &name) {
  AstName astName = globals.globalNames.names->getOrAdd(name.c_str());
  auto it = globals.globalScope->bindings.find(astName);
  if (it != globals.globalScope->bindings.end())
    return it->second;

  return std::nullopt;
}

TypeId getGlobalBinding(GlobalTypes &globals, const std::string &name) {
  auto t = tryGetGlobalBinding(globals, name);
  LUAU_ASSERT(t.has_value());
  return t->typeId;
}

Binding *tryGetGlobalBindingRef(GlobalTypes &globals, const std::string &name) {
  AstName astName = globals.globalNames.names->get(name.c_str());
  if (astName == AstName())
    return nullptr;

  auto it = globals.globalScope->bindings.find(astName);
  if (it != globals.globalScope->bindings.end())
    return &it->second;

  return nullptr;
}

void assignPropDocumentationSymbols(TableType::Props &props,
                                    const std::string &baseName) {
  for (auto &[name, prop] : props) {
    prop.documentationSymbol = baseName + "." + name;
  }
}

void registerBuiltinGlobals(Frontend &frontend, GlobalTypes &globals,
                            bool typeCheckForAutocomplete) {
  LUAU_ASSERT(!globals.globalTypes.types.isFrozen());
  LUAU_ASSERT(!globals.globalTypes.typePacks.isFrozen());

  TypeArena &arena = globals.globalTypes;
  NotNull<BuiltinTypes> builtinTypes = globals.builtinTypes;

  if (FFlag::DebugLuauDeferredConstraintResolution)
    builtinTypeFunctions().addToScope(NotNull{&arena},
                                      NotNull{globals.globalScope.get()});

  LoadDefinitionFileResult loadResult = frontend.loadDefinitionFile(
      globals, globals.globalScope, getBuiltinDefinitionSource(), "@luau",
      /* captureComments */ false, typeCheckForAutocomplete);
  LUAU_ASSERT(loadResult.success);

  TypeId genericK = arena.addType(GenericType{"K"});
  TypeId genericV = arena.addType(GenericType{"V"});
  TypeId mapOfKtoV = arena.addType(TableType{{},
                                             TableIndexer(genericK, genericV),
                                             globals.globalScope->level,
                                             TableState::Generic});

  std::optional<TypeId> stringMetatableTy =
      getMetatable(builtinTypes->stringType, builtinTypes);
  LUAU_ASSERT(stringMetatableTy);
  const TableType *stringMetatableTable =
      get<TableType>(follow(*stringMetatableTy));
  LUAU_ASSERT(stringMetatableTable);

  auto it = stringMetatableTable->props.find("__index");
  LUAU_ASSERT(it != stringMetatableTable->props.end());

  addGlobalBinding(globals, "string", it->second.type(), "@luau");

  // next<K, V>(t: Table<K, V>, i: K?) -> (K?, V)
  TypePackId nextArgsTypePack = arena.addTypePack(
      TypePack{{mapOfKtoV, makeOption(builtinTypes, arena, genericK)}});
  TypePackId nextRetsTypePack = arena.addTypePack(
      TypePack{{makeOption(builtinTypes, arena, genericK), genericV}});
  addGlobalBinding(
      globals, "next",
      arena.addType(FunctionType{
          {genericK, genericV}, {}, nextArgsTypePack, nextRetsTypePack}),
      "@luau");

  TypePackId pairsArgsTypePack = arena.addTypePack({mapOfKtoV});

  TypeId pairsNext =
      arena.addType(FunctionType{nextArgsTypePack, nextRetsTypePack});
  TypePackId pairsReturnTypePack = arena.addTypePack(
      TypePack{{pairsNext, mapOfKtoV, builtinTypes->nilType}});

  // pairs<K, V>(t: Table<K, V>) -> ((Table<K, V>, K?) -> (K, V), Table<K, V>,
  // nil)
  addGlobalBinding(
      globals, "pairs",
      arena.addType(FunctionType{
          {genericK, genericV}, {}, pairsArgsTypePack, pairsReturnTypePack}),
      "@luau");

  TypeId genericMT = arena.addType(GenericType{"MT"});

  TableType tab{TableState::Generic, globals.globalScope->level};
  TypeId tabTy = arena.addType(tab);

  TypeId tableMetaMT = arena.addType(MetatableType{tabTy, genericMT});

  // getmetatable : <MT>({ @metatable MT, {+ +} }) -> MT
  addGlobalBinding(globals, "getmetatable",
                   makeFunction(arena, std::nullopt, {genericMT}, {},
                                {tableMetaMT}, {genericMT}),
                   "@luau");

  if (FFlag::DebugLuauDeferredConstraintResolution) {
    TypeId genericT = arena.addType(GenericType{"T"});
    TypeId tMetaMT = arena.addType(MetatableType{genericT, genericMT});

    // clang-format off
        // setmetatable<T: {}, MT>(T, MT) -> { @metatable MT, T }
        addGlobalBinding(globals, "setmetatable",
            arena.addType(
                FunctionType{
                    {genericT, genericMT},
                    {},
                    arena.addTypePack(TypePack{{genericT, genericMT}}),
                    arena.addTypePack(TypePack{{tMetaMT}})
                }
            ), "@luau"
        );
    // clang-format on
  } else {
    // clang-format off
        // setmetatable<T: {}, MT>(T, MT) -> { @metatable MT, T }
        addGlobalBinding(globals, "setmetatable",
            arena.addType(
                FunctionType{
                    {genericMT},
                    {},
                    arena.addTypePack(TypePack{{tabTy, genericMT}}),
                    arena.addTypePack(TypePack{{tableMetaMT}})
                }
            ), "@luau"
        );
    // clang-format on
  }

  for (const auto &pair : globals.globalScope->bindings) {
    persist(pair.second.typeId);

    if (TableType *ttv = getMutable<TableType>(pair.second.typeId)) {
      if (!ttv->name)
        ttv->name = "typeof(" + toString(pair.first) + ")";
    }
  }

  attachMagicFunction(getGlobalBinding(globals, "assert"), magicFunctionAssert);

  if (FFlag::DebugLuauDeferredConstraintResolution) {
    // declare function assert<T>(value: T, errorMessage: string?): intersect<T,
    // ~(false?)>
    TypeId genericT = arena.addType(GenericType{"T"});
    TypeId refinedTy = arena.addType(TypeFunctionInstanceType{
        NotNull{&builtinTypeFunctions().intersectFunc},
        {genericT, arena.addType(NegationType{builtinTypes->falsyType})},
        {}});

    TypeId assertTy = arena.addType(
        FunctionType{{genericT},
                     {},
                     arena.addTypePack(TypePack{
                         {genericT, builtinTypes->optionalStringType}}),
                     arena.addTypePack(TypePack{{refinedTy}})});
    addGlobalBinding(globals, "assert", assertTy, "@luau");
  }

  attachMagicFunction(getGlobalBinding(globals, "setmetatable"),
                      magicFunctionSetMetaTable);
  attachMagicFunction(getGlobalBinding(globals, "select"), magicFunctionSelect);
  attachDcrMagicFunction(getGlobalBinding(globals, "select"),
                         dcrMagicFunctionSelect);

  if (TableType *ttv =
          getMutable<TableType>(getGlobalBinding(globals, "table"))) {
    // tabTy is a generic table type which we can't express via declaration
    // syntax yet
    ttv->props["freeze"] =
        makeProperty(makeFunction(arena, std::nullopt, {tabTy}, {tabTy}),
                     "@luau/global/table.freeze");
    ttv->props["clone"] =
        makeProperty(makeFunction(arena, std::nullopt, {tabTy}, {tabTy}),
                     "@luau/global/table.clone");

    ttv->props["getn"].deprecated = true;
    ttv->props["getn"].deprecatedSuggestion = "#";
    ttv->props["foreach"].deprecated = true;
    ttv->props["foreachi"].deprecated = true;

    attachMagicFunction(ttv->props["pack"].type(), magicFunctionPack);
    attachDcrMagicFunction(ttv->props["pack"].type(), dcrMagicFunctionPack);
  }

  attachMagicFunction(getGlobalBinding(globals, "require"),
                      magicFunctionRequire);
  attachDcrMagicFunction(getGlobalBinding(globals, "require"),
                         dcrMagicFunctionRequire);
}

static std::vector<TypeId> parseFormatString(NotNull<BuiltinTypes> builtinTypes,
                                             const char *data, size_t size) {
  const char *options = "cdiouxXeEfgGqs*";

  std::vector<TypeId> result;

  for (size_t i = 0; i < size; ++i) {
    if (data[i] == '%') {
      i++;

      if (i < size && data[i] == '%')
        continue;

      // we just ignore all characters (including flags/precision) up until
      // first alphabetic character
      while (i < size && !(data[i] > 0 && (isalpha(data[i]) || data[i] == '*')))
        i++;

      if (i == size)
        break;

      if (data[i] == 'q' || data[i] == 's')
        result.push_back(builtinTypes->stringType);
      else if (data[i] == '*')
        result.push_back(builtinTypes->unknownType);
      else if (strchr(options, data[i]))
        result.push_back(builtinTypes->numberType);
      else
        result.push_back(
            builtinTypes->errorRecoveryType(builtinTypes->anyType));
    }
  }

  return result;
}

std::optional<WithPredicate<TypePackId>>
magicFunctionFormat(TypeChecker &typechecker, const ScopePtr &scope,
                    const AstExprCall &expr,
                    WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  AstExprConstantString *fmt = nullptr;
  if (auto index = expr.func->as<AstExprIndexName>(); index && expr.self) {
    if (auto group = index->expr->as<AstExprGroup>())
      fmt = group->expr->as<AstExprConstantString>();
    else
      fmt = index->expr->as<AstExprConstantString>();
  }

  if (!expr.self && expr.args.size > 0)
    fmt = expr.args.data[0]->as<AstExprConstantString>();

  if (!fmt)
    return std::nullopt;

  std::vector<TypeId> expected = parseFormatString(
      typechecker.builtinTypes, fmt->value.data, fmt->value.size);
  const auto &[params, tail] = flatten(paramPack);

  size_t paramOffset = 1;
  size_t dataOffset = expr.self ? 0 : 1;

  // unify the prefix one argument at a time
  for (size_t i = 0; i < expected.size() && i + paramOffset < params.size();
       ++i) {
    Location location =
        expr.args.data[std::min(i + dataOffset, expr.args.size - 1)]->location;

    typechecker.unify(params[i + paramOffset], expected[i], scope, location);
  }

  // if we know the argument count or if we have too many arguments for sure, we
  // can issue an error
  size_t numActualParams = params.size();
  size_t numExpectedParams = expected.size() + 1; // + 1 for the format string

  if (numExpectedParams != numActualParams &&
      (!tail || numExpectedParams < numActualParams))
    typechecker.reportError(
        TypeError{expr.location, CountMismatch{numExpectedParams, std::nullopt,
                                               numActualParams}});

  return WithPredicate<TypePackId>{arena.addTypePack({typechecker.stringType})};
}

static bool dcrMagicFunctionFormat(MagicFunctionCallContext context) {
  TypeArena *arena = context.solver->arena;

  AstExprConstantString *fmt = nullptr;
  if (auto index = context.callSite->func->as<AstExprIndexName>();
      index && context.callSite->self) {
    if (auto group = index->expr->as<AstExprGroup>())
      fmt = group->expr->as<AstExprConstantString>();
    else
      fmt = index->expr->as<AstExprConstantString>();
  }

  if (!context.callSite->self && context.callSite->args.size > 0)
    fmt = context.callSite->args.data[0]->as<AstExprConstantString>();

  if (!fmt)
    return false;

  std::vector<TypeId> expected = parseFormatString(
      context.solver->builtinTypes, fmt->value.data, fmt->value.size);
  const auto &[params, tail] = flatten(context.arguments);

  size_t paramOffset = 1;

  // unify the prefix one argument at a time
  for (size_t i = 0; i < expected.size() && i + paramOffset < params.size();
       ++i) {
    context.solver->unify(context.constraint, params[i + paramOffset],
                          expected[i]);
  }

  // if we know the argument count or if we have too many arguments for sure, we
  // can issue an error
  size_t numActualParams = params.size();
  size_t numExpectedParams = expected.size() + 1; // + 1 for the format string

  if (numExpectedParams != numActualParams &&
      (!tail || numExpectedParams < numActualParams))
    context.solver->reportError(TypeError{
        context.callSite->location,
        CountMismatch{numExpectedParams, std::nullopt, numActualParams}});

  TypePackId resultPack =
      arena->addTypePack({context.solver->builtinTypes->stringType});
  asMutable(context.result)->ty.emplace<BoundTypePack>(resultPack);

  return true;
}

static std::vector<TypeId>
parsePatternString(NotNull<BuiltinTypes> builtinTypes, const char *data,
                   size_t size) {
  std::vector<TypeId> result;
  int depth = 0;
  bool parsingSet = false;

  for (size_t i = 0; i < size; ++i) {
    if (data[i] == '%') {
      ++i;
      if (!parsingSet && i < size && data[i] == 'b')
        i += 2;
    } else if (!parsingSet && data[i] == '[') {
      parsingSet = true;
      if (i + 1 < size && data[i + 1] == ']')
        i += 1;
    } else if (parsingSet && data[i] == ']') {
      parsingSet = false;
    } else if (data[i] == '(') {
      if (parsingSet)
        continue;

      if (i + 1 < size && data[i + 1] == ')') {
        i++;
        result.push_back(builtinTypes->optionalNumberType);
        continue;
      }

      ++depth;
      result.push_back(builtinTypes->optionalStringType);
    } else if (data[i] == ')') {
      if (parsingSet)
        continue;

      --depth;

      if (depth < 0)
        break;
    }
  }

  if (depth != 0 || parsingSet)
    return std::vector<TypeId>();

  if (result.empty())
    result.push_back(builtinTypes->optionalStringType);

  return result;
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionGmatch(TypeChecker &typechecker, const ScopePtr &scope,
                    const AstExprCall &expr,
                    WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;
  const auto &[params, tail] = flatten(paramPack);

  if (params.size() != 2)
    return std::nullopt;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  AstExprConstantString *pattern = nullptr;
  size_t index = expr.self ? 0 : 1;
  if (expr.args.size > index)
    pattern = expr.args.data[index]->as<AstExprConstantString>();

  if (!pattern)
    return std::nullopt;

  std::vector<TypeId> returnTypes = parsePatternString(
      typechecker.builtinTypes, pattern->value.data, pattern->value.size);

  if (returnTypes.empty())
    return std::nullopt;

  typechecker.unify(params[0], typechecker.stringType, scope,
                    expr.args.data[0]->location);

  const TypePackId emptyPack = arena.addTypePack({});
  const TypePackId returnList = arena.addTypePack(returnTypes);
  const TypeId iteratorType =
      arena.addType(FunctionType{emptyPack, returnList});
  return WithPredicate<TypePackId>{arena.addTypePack({iteratorType})};
}

static bool dcrMagicFunctionGmatch(MagicFunctionCallContext context) {
  const auto &[params, tail] = flatten(context.arguments);

  if (params.size() != 2)
    return false;

  TypeArena *arena = context.solver->arena;

  AstExprConstantString *pattern = nullptr;
  size_t index = context.callSite->self ? 0 : 1;
  if (context.callSite->args.size > index)
    pattern = context.callSite->args.data[index]->as<AstExprConstantString>();

  if (!pattern)
    return false;

  std::vector<TypeId> returnTypes = parsePatternString(
      context.solver->builtinTypes, pattern->value.data, pattern->value.size);

  if (returnTypes.empty())
    return false;

  context.solver->unify(context.constraint, params[0],
                        context.solver->builtinTypes->stringType);

  const TypePackId emptyPack = arena->addTypePack({});
  const TypePackId returnList = arena->addTypePack(returnTypes);
  const TypeId iteratorType =
      arena->addType(FunctionType{emptyPack, returnList});
  const TypePackId resTypePack = arena->addTypePack({iteratorType});
  asMutable(context.result)->ty.emplace<BoundTypePack>(resTypePack);

  return true;
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionMatch(TypeChecker &typechecker, const ScopePtr &scope,
                   const AstExprCall &expr,
                   WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;
  const auto &[params, tail] = flatten(paramPack);

  if (params.size() < 2 || params.size() > 3)
    return std::nullopt;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  AstExprConstantString *pattern = nullptr;
  size_t patternIndex = expr.self ? 0 : 1;
  if (expr.args.size > patternIndex)
    pattern = expr.args.data[patternIndex]->as<AstExprConstantString>();

  if (!pattern)
    return std::nullopt;

  std::vector<TypeId> returnTypes = parsePatternString(
      typechecker.builtinTypes, pattern->value.data, pattern->value.size);

  if (returnTypes.empty())
    return std::nullopt;

  typechecker.unify(params[0], typechecker.stringType, scope,
                    expr.args.data[0]->location);

  const TypeId optionalNumber =
      arena.addType(UnionType{{typechecker.nilType, typechecker.numberType}});

  size_t initIndex = expr.self ? 1 : 2;
  if (params.size() == 3 && expr.args.size > initIndex)
    typechecker.unify(params[2], optionalNumber, scope,
                      expr.args.data[initIndex]->location);

  const TypePackId returnList = arena.addTypePack(returnTypes);
  return WithPredicate<TypePackId>{returnList};
}

static bool dcrMagicFunctionMatch(MagicFunctionCallContext context) {
  const auto &[params, tail] = flatten(context.arguments);

  if (params.size() < 2 || params.size() > 3)
    return false;

  TypeArena *arena = context.solver->arena;

  AstExprConstantString *pattern = nullptr;
  size_t patternIndex = context.callSite->self ? 0 : 1;
  if (context.callSite->args.size > patternIndex)
    pattern =
        context.callSite->args.data[patternIndex]->as<AstExprConstantString>();

  if (!pattern)
    return false;

  std::vector<TypeId> returnTypes = parsePatternString(
      context.solver->builtinTypes, pattern->value.data, pattern->value.size);

  if (returnTypes.empty())
    return false;

  context.solver->unify(context.constraint, params[0],
                        context.solver->builtinTypes->stringType);

  const TypeId optionalNumber =
      arena->addType(UnionType{{context.solver->builtinTypes->nilType,
                                context.solver->builtinTypes->numberType}});

  size_t initIndex = context.callSite->self ? 1 : 2;
  if (params.size() == 3 && context.callSite->args.size > initIndex)
    context.solver->unify(context.constraint, params[2], optionalNumber);

  const TypePackId returnList = arena->addTypePack(returnTypes);
  asMutable(context.result)->ty.emplace<BoundTypePack>(returnList);

  return true;
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionFind(TypeChecker &typechecker, const ScopePtr &scope,
                  const AstExprCall &expr,
                  WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;
  const auto &[params, tail] = flatten(paramPack);

  if (params.size() < 2 || params.size() > 4)
    return std::nullopt;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  AstExprConstantString *pattern = nullptr;
  size_t patternIndex = expr.self ? 0 : 1;
  if (expr.args.size > patternIndex)
    pattern = expr.args.data[patternIndex]->as<AstExprConstantString>();

  if (!pattern)
    return std::nullopt;

  bool plain = false;
  size_t plainIndex = expr.self ? 2 : 3;
  if (expr.args.size > plainIndex) {
    AstExprConstantBool *p =
        expr.args.data[plainIndex]->as<AstExprConstantBool>();
    plain = p && p->value;
  }

  std::vector<TypeId> returnTypes;
  if (!plain) {
    returnTypes = parsePatternString(typechecker.builtinTypes,
                                     pattern->value.data, pattern->value.size);

    if (returnTypes.empty())
      return std::nullopt;
  }

  typechecker.unify(params[0], typechecker.stringType, scope,
                    expr.args.data[0]->location);

  const TypeId optionalNumber =
      arena.addType(UnionType{{typechecker.nilType, typechecker.numberType}});
  const TypeId optionalBoolean =
      arena.addType(UnionType{{typechecker.nilType, typechecker.booleanType}});

  size_t initIndex = expr.self ? 1 : 2;
  if (params.size() >= 3 && expr.args.size > initIndex)
    typechecker.unify(params[2], optionalNumber, scope,
                      expr.args.data[initIndex]->location);

  if (params.size() == 4 && expr.args.size > plainIndex)
    typechecker.unify(params[3], optionalBoolean, scope,
                      expr.args.data[plainIndex]->location);

  returnTypes.insert(returnTypes.begin(), {optionalNumber, optionalNumber});

  const TypePackId returnList = arena.addTypePack(returnTypes);
  return WithPredicate<TypePackId>{returnList};
}

static bool dcrMagicFunctionFind(MagicFunctionCallContext context) {
  const auto &[params, tail] = flatten(context.arguments);

  if (params.size() < 2 || params.size() > 4)
    return false;

  TypeArena *arena = context.solver->arena;
  NotNull<BuiltinTypes> builtinTypes = context.solver->builtinTypes;

  AstExprConstantString *pattern = nullptr;
  size_t patternIndex = context.callSite->self ? 0 : 1;
  if (context.callSite->args.size > patternIndex)
    pattern =
        context.callSite->args.data[patternIndex]->as<AstExprConstantString>();

  if (!pattern)
    return false;

  bool plain = false;
  size_t plainIndex = context.callSite->self ? 2 : 3;
  if (context.callSite->args.size > plainIndex) {
    AstExprConstantBool *p =
        context.callSite->args.data[plainIndex]->as<AstExprConstantBool>();
    plain = p && p->value;
  }

  std::vector<TypeId> returnTypes;
  if (!plain) {
    returnTypes = parsePatternString(builtinTypes, pattern->value.data,
                                     pattern->value.size);

    if (returnTypes.empty())
      return false;
  }

  context.solver->unify(context.constraint, params[0],
                        builtinTypes->stringType);

  const TypeId optionalNumber = arena->addType(
      UnionType{{builtinTypes->nilType, builtinTypes->numberType}});
  const TypeId optionalBoolean = arena->addType(
      UnionType{{builtinTypes->nilType, builtinTypes->booleanType}});

  size_t initIndex = context.callSite->self ? 1 : 2;
  if (params.size() >= 3 && context.callSite->args.size > initIndex)
    context.solver->unify(context.constraint, params[2], optionalNumber);

  if (params.size() == 4 && context.callSite->args.size > plainIndex)
    context.solver->unify(context.constraint, params[3], optionalBoolean);

  returnTypes.insert(returnTypes.begin(), {optionalNumber, optionalNumber});

  const TypePackId returnList = arena->addTypePack(returnTypes);
  asMutable(context.result)->ty.emplace<BoundTypePack>(returnList);
  return true;
}

TypeId makeStringMetatable(NotNull<BuiltinTypes> builtinTypes) {
  NotNull<TypeArena> arena{builtinTypes->arena.get()};

  const TypeId nilType = builtinTypes->nilType;
  const TypeId numberType = builtinTypes->numberType;
  const TypeId booleanType = builtinTypes->booleanType;
  const TypeId stringType = builtinTypes->stringType;

  const TypeId optionalNumber =
      arena->addType(UnionType{{nilType, numberType}});
  const TypeId optionalString =
      arena->addType(UnionType{{nilType, stringType}});
  const TypeId optionalBoolean =
      arena->addType(UnionType{{nilType, booleanType}});

  const TypePackId oneStringPack = arena->addTypePack({stringType});
  const TypePackId anyTypePack = builtinTypes->anyTypePack;

  const TypePackId variadicTailPack =
      FFlag::DebugLuauDeferredConstraintResolution
          ? builtinTypes->unknownTypePack
          : anyTypePack;
  const TypePackId emptyPack = arena->addTypePack({});
  const TypePackId stringVariadicList =
      arena->addTypePack(TypePackVar{VariadicTypePack{stringType}});
  const TypePackId numberVariadicList =
      arena->addTypePack(TypePackVar{VariadicTypePack{numberType}});

  FunctionType formatFTV{
      arena->addTypePack(TypePack{{stringType}, variadicTailPack}),
      oneStringPack};
  formatFTV.magicFunction = &magicFunctionFormat;
  formatFTV.isCheckedFunction = true;
  const TypeId formatFn = arena->addType(formatFTV);
  attachDcrMagicFunction(formatFn, dcrMagicFunctionFormat);

  const TypeId stringToStringType =
      makeFunction(*arena, std::nullopt, {}, {}, {stringType}, {}, {stringType},
                   /* checked */ true);

  const TypeId replArgType = arena->addType(UnionType{
      {stringType,
       arena->addType(TableType({}, TableIndexer(stringType, stringType),
                                TypeLevel{}, TableState::Generic)),
       makeFunction(*arena, std::nullopt, {}, {}, {stringType}, {},
                    {stringType}, /* checked */ false)}});
  const TypeId gsubFunc = makeFunction(
      *arena, stringType, {}, {}, {stringType, replArgType, optionalNumber}, {},
      {stringType, numberType}, /* checked */ false);
  const TypeId gmatchFunc = makeFunction(
      *arena, stringType, {}, {}, {stringType}, {},
      {arena->addType(FunctionType{emptyPack, stringVariadicList})},
      /* checked */ true);
  attachMagicFunction(gmatchFunc, magicFunctionGmatch);
  attachDcrMagicFunction(gmatchFunc, dcrMagicFunctionGmatch);

  FunctionType matchFuncTy{
      arena->addTypePack({stringType, stringType, optionalNumber}),
      arena->addTypePack(TypePackVar{VariadicTypePack{stringType}})};
  matchFuncTy.isCheckedFunction = true;
  const TypeId matchFunc = arena->addType(matchFuncTy);
  attachMagicFunction(matchFunc, magicFunctionMatch);
  attachDcrMagicFunction(matchFunc, dcrMagicFunctionMatch);

  FunctionType findFuncTy{
      arena->addTypePack(
          {stringType, stringType, optionalNumber, optionalBoolean}),
      arena->addTypePack(
          TypePack{{optionalNumber, optionalNumber}, stringVariadicList})};
  findFuncTy.isCheckedFunction = true;
  const TypeId findFunc = arena->addType(findFuncTy);
  attachMagicFunction(findFunc, magicFunctionFind);
  attachDcrMagicFunction(findFunc, dcrMagicFunctionFind);

  // string.byte : string -> number? -> number? -> ...number
  FunctionType stringDotByte{
      arena->addTypePack({stringType, optionalNumber, optionalNumber}),
      numberVariadicList};
  stringDotByte.isCheckedFunction = true;

  // string.char : .... number -> string
  FunctionType stringDotChar{numberVariadicList,
                             arena->addTypePack({stringType})};
  stringDotChar.isCheckedFunction = true;

  // string.unpack : string -> string -> number? -> ...any
  FunctionType stringDotUnpack{
      arena->addTypePack(TypePack{{stringType, stringType, optionalNumber}}),
      variadicTailPack,
  };
  stringDotUnpack.isCheckedFunction = true;

  TableType::Props stringLib = {
      {"byte", {arena->addType(stringDotByte)}},
      {"char", {arena->addType(stringDotChar)}},
      {"find", {findFunc}},
      {"format", {formatFn}}, // FIXME
      {"gmatch", {gmatchFunc}},
      {"gsub", {gsubFunc}},
      {"len",
       {makeFunction(*arena, stringType, {}, {}, {}, {}, {numberType},
                     /* checked */ true)}},
      {"lower", {stringToStringType}},
      {"match", {matchFunc}},
      {"rep",
       {makeFunction(*arena, stringType, {}, {}, {numberType}, {}, {stringType},
                     /* checked */ true)}},
      {"reverse", {stringToStringType}},
      {"sub",
       {makeFunction(*arena, stringType, {}, {}, {numberType, optionalNumber},
                     {}, {stringType}, /* checked */ true)}},
      {"upper", {stringToStringType}},
      {"split",
       {makeFunction(
           *arena, stringType, {}, {}, {optionalString}, {},
           {arena->addType(TableType{{},
                                     TableIndexer{numberType, stringType},
                                     TypeLevel{},
                                     TableState::Sealed})},
           /* checked */ true)}},
      {"pack",
       {arena->addType(FunctionType{
           arena->addTypePack(TypePack{{stringType}, variadicTailPack}),
           oneStringPack,
       })}},
      {"packsize",
       {makeFunction(*arena, stringType, {}, {}, {}, {}, {numberType},
                     /* checked */ true)}},
      {"unpack", {arena->addType(stringDotUnpack)}},
  };

  assignPropDocumentationSymbols(stringLib, "@luau/global/string");

  TypeId tableType = arena->addType(TableType{
      std::move(stringLib), std::nullopt, TypeLevel{}, TableState::Sealed});

  if (TableType *ttv = getMutable<TableType>(tableType))
    ttv->name = "typeof(string)";

  return arena->addType(TableType{{{{"__index", {tableType}}}},
                                  std::nullopt,
                                  TypeLevel{},
                                  TableState::Sealed});
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionSelect(TypeChecker &typechecker, const ScopePtr &scope,
                    const AstExprCall &expr,
                    WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;

  (void)scope;

  if (expr.args.size <= 0) {
    typechecker.reportError(TypeError{
        expr.location, GenericError{"select should take 1 or more arguments"}});
    return std::nullopt;
  }

  AstExpr *arg1 = expr.args.data[0];
  if (AstExprConstantNumber *num = arg1->as<AstExprConstantNumber>()) {
    const auto &[v, tail] = flatten(paramPack);

    int offset = int(num->value);
    if (offset > 0) {
      if (size_t(offset) < v.size()) {
        std::vector<TypeId> result(v.begin() + offset, v.end());
        return WithPredicate<TypePackId>{
            typechecker.currentModule->internalTypes.addTypePack(
                TypePack{std::move(result), tail})};
      } else if (tail)
        return WithPredicate<TypePackId>{*tail};
    }

    typechecker.reportError(TypeError{
        arg1->location,
        GenericError{"bad argument #1 to select (index out of range)"}});
  } else if (AstExprConstantString *str = arg1->as<AstExprConstantString>()) {
    if (str->value.size == 1 && str->value.data[0] == '#')
      return WithPredicate<TypePackId>{
          typechecker.currentModule->internalTypes.addTypePack(
              {typechecker.numberType})};
  }

  return std::nullopt;
}

static bool dcrMagicFunctionSelect(MagicFunctionCallContext context) {
  if (context.callSite->args.size <= 0) {
    context.solver->reportError(
        TypeError{context.callSite->location,
                  GenericError{"select should take 1 or more arguments"}});
    return false;
  }

  AstExpr *arg1 = context.callSite->args.data[0];

  if (AstExprConstantNumber *num = arg1->as<AstExprConstantNumber>()) {
    const auto &[v, tail] = flatten(context.arguments);

    int offset = int(num->value);
    if (offset > 0) {
      if (size_t(offset) < v.size()) {
        std::vector<TypeId> res(v.begin() + offset, v.end());
        TypePackId resTypePack =
            context.solver->arena->addTypePack({std::move(res), tail});
        asMutable(context.result)->ty.emplace<BoundTypePack>(resTypePack);
      } else if (tail)
        asMutable(context.result)->ty.emplace<BoundTypePack>(*tail);

      return true;
    }

    return false;
  }

  if (AstExprConstantString *str = arg1->as<AstExprConstantString>()) {
    if (str->value.size == 1 && str->value.data[0] == '#') {
      TypePackId numberTypePack = context.solver->arena->addTypePack(
          {context.solver->builtinTypes->numberType});
      asMutable(context.result)->ty.emplace<BoundTypePack>(numberTypePack);
      return true;
    }
  }

  return false;
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionSetMetaTable(TypeChecker &typechecker, const ScopePtr &scope,
                          const AstExprCall &expr,
                          WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;

  if (size(paramPack) < 2 && finite(paramPack))
    return std::nullopt;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  std::vector<TypeId> expectedArgs =
      typechecker.unTypePack(scope, paramPack, 2, expr.location);

  TypeId target = follow(expectedArgs[0]);
  TypeId mt = follow(expectedArgs[1]);

  typechecker.tablify(target);
  typechecker.tablify(mt);

  if (const auto &tab = get<TableType>(target)) {
    if (target->persistent) {
      typechecker.reportError(
          TypeError{expr.location,
                    CannotExtendTable{target, CannotExtendTable::Metatable}});
    } else {
      const TableType *mtTtv = get<TableType>(mt);
      MetatableType mtv{target, mt};
      if ((tab->name || tab->syntheticName) &&
          (mtTtv && (mtTtv->name || mtTtv->syntheticName))) {
        std::string tableName = tab->name ? *tab->name : *tab->syntheticName;
        std::string metatableName =
            mtTtv->name ? *mtTtv->name : *mtTtv->syntheticName;

        if (tableName == metatableName)
          mtv.syntheticName = tableName;
      }

      TypeId mtTy = arena.addType(mtv);

      if (expr.args.size < 1)
        return std::nullopt;

      if (!expr.self) {
        AstExpr *targetExpr = expr.args.data[0];
        if (AstExprLocal *targetLocal = targetExpr->as<AstExprLocal>()) {
          const Name targetName(targetLocal->local->name.value);
          scope->bindings[targetLocal->local] = Binding{mtTy, expr.location};
        }
      }

      return WithPredicate<TypePackId>{arena.addTypePack({mtTy})};
    }
  } else if (get<AnyType>(target) || get<ErrorType>(target) ||
             isTableIntersection(target)) {
  } else if (isTableUnion(target)) {
    const UnionType *ut = get<UnionType>(target);
    LUAU_ASSERT(ut);

    std::vector<TypeId> resultParts;

    for (TypeId ty : ut)
      resultParts.push_back(arena.addType(MetatableType{ty, mt}));

    return WithPredicate<TypePackId>{
        arena.addTypePack({arena.addType(UnionType{std::move(resultParts)})})};
  } else {
    typechecker.reportError(TypeError{
        expr.location, GenericError{"setmetatable should take a table"}});
  }

  return WithPredicate<TypePackId>{arena.addTypePack({target})};
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionAssert(TypeChecker &typechecker, const ScopePtr &scope,
                    const AstExprCall &expr,
                    WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, predicates] = withPredicate;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  auto [head, tail] = flatten(paramPack);
  if (head.empty() && tail) {
    std::optional<TypeId> fst = first(*tail);
    if (!fst)
      return WithPredicate<TypePackId>{paramPack};
    head.push_back(*fst);
  }

  typechecker.resolve(predicates, scope, true);

  if (head.size() > 0) {
    auto [ty, ok] = typechecker.pickTypesFromSense(
        head[0], true, typechecker.builtinTypes->nilType);
    if (get<NeverType>(*ty))
      head = {*ty};
    else
      head[0] = *ty;
  }

  return WithPredicate<TypePackId>{
      arena.addTypePack(TypePack{std::move(head), tail})};
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionPack(TypeChecker &typechecker, const ScopePtr &scope,
                  const AstExprCall &expr,
                  WithPredicate<TypePackId> withPredicate) {
  auto [paramPack, _predicates] = withPredicate;

  TypeArena &arena = typechecker.currentModule->internalTypes;

  const auto &[paramTypes, paramTail] = flatten(paramPack);

  std::vector<TypeId> options;
  options.reserve(paramTypes.size());
  for (auto type : paramTypes)
    options.push_back(type);

  if (paramTail) {
    if (const VariadicTypePack *vtp = get<VariadicTypePack>(*paramTail))
      options.push_back(vtp->ty);
  }

  options = reduceUnion(options);

  // table.pack()         -> {| n: number, [number]: nil |}
  // table.pack(1)        -> {| n: number, [number]: number |}
  // table.pack(1, "foo") -> {| n: number, [number]: number | string |}
  TypeId result = nullptr;
  if (options.empty())
    result = typechecker.nilType;
  else if (options.size() == 1)
    result = options[0];
  else
    result = arena.addType(UnionType{std::move(options)});

  TypeId packedTable =
      arena.addType(TableType{{{"n", {typechecker.numberType}}},
                              TableIndexer(typechecker.numberType, result),
                              scope->level,
                              TableState::Sealed});

  return WithPredicate<TypePackId>{arena.addTypePack({packedTable})};
}

static bool dcrMagicFunctionPack(MagicFunctionCallContext context) {

  TypeArena *arena = context.solver->arena;

  const auto &[paramTypes, paramTail] = flatten(context.arguments);

  std::vector<TypeId> options;
  options.reserve(paramTypes.size());
  for (auto type : paramTypes)
    options.push_back(type);

  if (paramTail) {
    if (const VariadicTypePack *vtp = get<VariadicTypePack>(*paramTail))
      options.push_back(vtp->ty);
  }

  options = reduceUnion(options);

  // table.pack()         -> {| n: number, [number]: nil |}
  // table.pack(1)        -> {| n: number, [number]: number |}
  // table.pack(1, "foo") -> {| n: number, [number]: number | string |}
  TypeId result = nullptr;
  if (options.empty())
    result = context.solver->builtinTypes->nilType;
  else if (options.size() == 1)
    result = options[0];
  else
    result = arena->addType(UnionType{std::move(options)});

  TypeId numberType = context.solver->builtinTypes->numberType;
  TypeId packedTable =
      arena->addType(TableType{{{"n", {numberType}}},
                               TableIndexer(numberType, result),
                               {},
                               TableState::Sealed});

  TypePackId tableTypePack = arena->addTypePack({packedTable});
  asMutable(context.result)->ty.emplace<BoundTypePack>(tableTypePack);

  return true;
}

static bool checkRequirePath(TypeChecker &typechecker, AstExpr *expr) {
  // require(foo.parent.bar) will technically work, but it depends on legacy
  // goop that Luau does not and could not support without a bunch of work. It's
  // deprecated anyway, so we'll warn here if we see it.
  bool good = true;
  AstExprIndexName *indexExpr = expr->as<AstExprIndexName>();

  while (indexExpr) {
    if (indexExpr->index == "parent") {
      typechecker.reportError(indexExpr->indexLocation,
                              DeprecatedApiUsed{"parent", "Parent"});
      good = false;
    }

    indexExpr = indexExpr->expr->as<AstExprIndexName>();
  }

  return good;
}

static std::optional<WithPredicate<TypePackId>>
magicFunctionRequire(TypeChecker &typechecker, const ScopePtr &scope,
                     const AstExprCall &expr,
                     WithPredicate<TypePackId> withPredicate) {
  TypeArena &arena = typechecker.currentModule->internalTypes;

  if (expr.args.size != 1) {
    typechecker.reportError(
        TypeError{expr.location, GenericError{"require takes 1 argument"}});
    return std::nullopt;
  }

  if (!checkRequirePath(typechecker, expr.args.data[0]))
    return std::nullopt;

  if (auto moduleInfo = typechecker.resolver->resolveModuleInfo(
          typechecker.currentModule->name, expr))
    return WithPredicate<TypePackId>{arena.addTypePack(
        {typechecker.checkRequire(scope, *moduleInfo, expr.location)})};

  return std::nullopt;
}

static bool checkRequirePathDcr(NotNull<ConstraintSolver> solver,
                                AstExpr *expr) {
  // require(foo.parent.bar) will technically work, but it depends on legacy
  // goop that Luau does not and could not support without a bunch of work. It's
  // deprecated anyway, so we'll warn here if we see it.
  bool good = true;
  AstExprIndexName *indexExpr = expr->as<AstExprIndexName>();

  while (indexExpr) {
    if (indexExpr->index == "parent") {
      solver->reportError(DeprecatedApiUsed{"parent", "Parent"},
                          indexExpr->indexLocation);
      good = false;
    }

    indexExpr = indexExpr->expr->as<AstExprIndexName>();
  }

  return good;
}

static bool dcrMagicFunctionRequire(MagicFunctionCallContext context) {
  if (context.callSite->args.size != 1) {
    context.solver->reportError(GenericError{"require takes 1 argument"},
                                context.callSite->location);
    return false;
  }

  if (!checkRequirePathDcr(context.solver, context.callSite->args.data[0]))
    return false;

  if (auto moduleInfo = context.solver->moduleResolver->resolveModuleInfo(
          context.solver->currentModuleName, *context.callSite)) {
    TypeId moduleType =
        context.solver->resolveModule(*moduleInfo, context.callSite->location);
    TypePackId moduleResult = context.solver->arena->addTypePack({moduleType});
    asMutable(context.result)->ty.emplace<BoundTypePack>(moduleResult);

    return true;
  }

  return false;
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Def.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

namespace Luau {

bool containsSubscriptedDefinition(DefId def) {
  if (auto cell = get<Cell>(def))
    return cell->subscripted;
  else if (auto phi = get<Phi>(def))
    return std::any_of(phi->operands.begin(), phi->operands.end(),
                       containsSubscriptedDefinition);
  else
    return false;
}

void collectOperands(DefId def, std::vector<DefId> *operands) {
  LUAU_ASSERT(operands);
  if (std::find(operands->begin(), operands->end(), def) != operands->end())
    return;
  else if (get<Cell>(def))
    operands->push_back(def);
  else if (auto phi = get<Phi>(def)) {
    // A trivial phi node has no operands to populate, so we push this
    // definition in directly.
    if (phi->operands.empty())
      return operands->push_back(def);

    for (const Def *operand : phi->operands)
      collectOperands(NotNull{operand}, operands);
  }
}

DefId DefArena::freshCell(bool subscripted) {
  return NotNull{allocator.allocate(Def{Cell{subscripted}})};
}

DefId DefArena::phi(DefId a, DefId b) { return phi({a, b}); }

DefId DefArena::phi(const std::vector<DefId> &defs) {
  std::vector<DefId> operands;
  for (DefId operand : defs)
    collectOperands(operand, &operands);

  // There's no need to allocate a Phi node for a singleton set.
  if (operands.size() == 1)
    return operands[0];
  else
    return NotNull{allocator.allocate(Def{Phi{std::move(operands)}})};
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NonStrictTypeChecker.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Simplify.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Def.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <iostream>

// @@@@@ PACK.LUA : was already included! <iterator>

namespace Luau {

/* Push a scope onto the end of a stack for the lifetime of the StackPusher
 * instance. NonStrictTypeChecker uses this to maintain knowledge about which
 * scope encloses every given AstNode.
 */
struct StackPusher {
  std::vector<NotNull<Scope>> *stack;
  NotNull<Scope> scope;

  explicit StackPusher(std::vector<NotNull<Scope>> &stack, Scope *scope)
      : stack(&stack), scope(scope) {
    stack.push_back(NotNull{scope});
  }

  ~StackPusher() {
    if (stack) {
      LUAU_ASSERT(stack->back() == scope);
      stack->pop_back();
    }
  }

  StackPusher(const StackPusher &) = delete;
  StackPusher &&operator=(const StackPusher &) = delete;

  StackPusher(StackPusher &&other)
      : stack(std::exchange(other.stack, nullptr)), scope(other.scope) {}
};

struct NonStrictContext {
  NonStrictContext() = default;

  NonStrictContext(const NonStrictContext &) = delete;
  NonStrictContext &operator=(const NonStrictContext &) = delete;

  NonStrictContext(NonStrictContext &&) = default;
  NonStrictContext &operator=(NonStrictContext &&) = default;

  static NonStrictContext disjunction(NotNull<BuiltinTypes> builtinTypes,
                                      NotNull<TypeArena> arena,
                                      const NonStrictContext &left,
                                      const NonStrictContext &right) {
    // disjunction implements union over the domain of keys
    // if the default value for a defId not in the map is `never`
    // then never | T is T
    NonStrictContext disj{};

    for (auto [def, leftTy] : left.context) {
      if (std::optional<TypeId> rightTy = right.find(def))
        disj.context[def] =
            simplifyUnion(builtinTypes, arena, leftTy, *rightTy).result;
      else
        disj.context[def] = leftTy;
    }

    for (auto [def, rightTy] : right.context) {
      if (!left.find(def).has_value())
        disj.context[def] = rightTy;
    }

    return disj;
  }

  static NonStrictContext conjunction(NotNull<BuiltinTypes> builtins,
                                      NotNull<TypeArena> arena,
                                      const NonStrictContext &left,
                                      const NonStrictContext &right) {
    NonStrictContext conj{};

    for (auto [def, leftTy] : left.context) {
      if (std::optional<TypeId> rightTy = right.find(def))
        conj.context[def] =
            simplifyIntersection(builtins, arena, leftTy, *rightTy).result;
    }

    return conj;
  }

  // Returns true if the removal was successful
  bool remove(const DefId &def) {
    std::vector<DefId> defs;
    collectOperands(def, &defs);
    bool result = true;
    for (DefId def : defs)
      result = result && context.erase(def.get()) == 1;
    return result;
  }

  std::optional<TypeId> find(const DefId &def) const {
    const Def *d = def.get();
    return find(d);
  }

  void addContext(const DefId &def, TypeId ty) {
    std::vector<DefId> defs;
    collectOperands(def, &defs);
    for (DefId def : defs)
      context[def.get()] = ty;
  }

private:
  std::optional<TypeId> find(const Def *d) const {
    auto it = context.find(d);
    if (it != context.end())
      return {it->second};
    return {};
  }

  std::unordered_map<const Def *, TypeId> context;
};

struct NonStrictTypeChecker {

  NotNull<BuiltinTypes> builtinTypes;
  const NotNull<InternalErrorReporter> ice;
  NotNull<TypeArena> arena;
  Module *module;
  Normalizer normalizer;
  Subtyping subtyping;
  NotNull<const DataFlowGraph> dfg;
  DenseHashSet<TypeId> noTypeFunctionErrors{nullptr};
  std::vector<NotNull<Scope>> stack;
  DenseHashMap<TypeId, TypeId> cachedNegations{nullptr};

  const NotNull<TypeCheckLimits> limits;

  NonStrictTypeChecker(NotNull<TypeArena> arena,
                       NotNull<BuiltinTypes> builtinTypes,
                       const NotNull<InternalErrorReporter> ice,
                       NotNull<UnifierSharedState> unifierState,
                       NotNull<const DataFlowGraph> dfg,
                       NotNull<TypeCheckLimits> limits, Module *module)
      : builtinTypes(builtinTypes), ice(ice), arena(arena), module(module),
        normalizer{arena, builtinTypes, unifierState,
                   /* cache inhabitance */ true},
        subtyping{builtinTypes, arena, NotNull(&normalizer), ice,
                  NotNull{module->getModuleScope().get()}},
        dfg(dfg), limits(limits) {}

  std::optional<StackPusher> pushStack(AstNode *node) {
    if (Scope **scope = module->astScopes.find(node))
      return StackPusher{stack, *scope};
    else
      return std::nullopt;
  }

  TypeId flattenPack(TypePackId pack) {
    pack = follow(pack);

    if (auto fst = first(pack, /*ignoreHiddenVariadics*/ false))
      return *fst;
    else if (auto ftp = get<FreeTypePack>(pack)) {
      TypeId result = arena->addType(FreeType{ftp->scope});
      TypePackId freeTail = arena->addTypePack(FreeTypePack{ftp->scope});

      TypePack *resultPack = emplaceTypePack<TypePack>(asMutable(pack));
      resultPack->head.assign(1, result);
      resultPack->tail = freeTail;

      return result;
    } else if (get<Unifiable::Error>(pack))
      return builtinTypes->errorRecoveryType();
    else if (finite(pack) && size(pack) == 0)
      return builtinTypes->nilType; // `(f())` where `f()` returns no values is
                                    // coerced into `nil`
    else
      ice->ice("flattenPack got a weird pack!");
  }

  TypeId checkForFamilyInhabitance(TypeId instance, Location location) {
    if (noTypeFunctionErrors.find(instance))
      return instance;

    ErrorVec errors =
        reduceTypeFunctions(
            instance, location,
            TypeFunctionContext{arena, builtinTypes, stack.back(),
                                NotNull{&normalizer}, ice, limits},
            true)
            .errors;

    if (errors.empty())
      noTypeFunctionErrors.insert(instance);
    // TODO??
    // if (!isErrorSuppressing(location, instance))
    //     reportErrors(std::move(errors));
    return instance;
  }

  TypeId lookupType(AstExpr *expr) {
    TypeId *ty = module->astTypes.find(expr);
    if (ty)
      return checkForFamilyInhabitance(follow(*ty), expr->location);

    TypePackId *tp = module->astTypePacks.find(expr);
    if (tp)
      return checkForFamilyInhabitance(flattenPack(*tp), expr->location);
    return builtinTypes->anyType;
  }

  NonStrictContext visit(AstStat *stat) {
    auto pusher = pushStack(stat);
    if (auto s = stat->as<AstStatBlock>())
      return visit(s);
    else if (auto s = stat->as<AstStatIf>())
      return visit(s);
    else if (auto s = stat->as<AstStatWhile>())
      return visit(s);
    else if (auto s = stat->as<AstStatRepeat>())
      return visit(s);
    else if (auto s = stat->as<AstStatBreak>())
      return visit(s);
    else if (auto s = stat->as<AstStatContinue>())
      return visit(s);
    else if (auto s = stat->as<AstStatReturn>())
      return visit(s);
    else if (auto s = stat->as<AstStatExpr>())
      return visit(s);
    else if (auto s = stat->as<AstStatLocal>())
      return visit(s);
    else if (auto s = stat->as<AstStatFor>())
      return visit(s);
    else if (auto s = stat->as<AstStatForIn>())
      return visit(s);
    else if (auto s = stat->as<AstStatAssign>())
      return visit(s);
    else if (auto s = stat->as<AstStatCompoundAssign>())
      return visit(s);
    else if (auto s = stat->as<AstStatFunction>())
      return visit(s);
    else if (auto s = stat->as<AstStatLocalFunction>())
      return visit(s);
    else if (auto s = stat->as<AstStatTypeAlias>())
      return visit(s);
    else if (auto s = stat->as<AstStatDeclareFunction>())
      return visit(s);
    else if (auto s = stat->as<AstStatDeclareGlobal>())
      return visit(s);
    else if (auto s = stat->as<AstStatDeclareClass>())
      return visit(s);
    else if (auto s = stat->as<AstStatError>())
      return visit(s);
    else {
      LUAU_ASSERT(
          !"NonStrictTypeChecker encountered an unknown statement type");
      ice->ice("NonStrictTypeChecker encountered an unknown statement type");
    }
  }

  NonStrictContext visit(AstStatBlock *block) {
    auto StackPusher = pushStack(block);
    NonStrictContext ctx;

    for (auto it = block->body.rbegin(); it != block->body.rend(); it++) {
      AstStat *stat = *it;
      if (AstStatLocal *local = stat->as<AstStatLocal>()) {
        // Iterating in reverse order
        // local x ; B generates the context of B without x
        visit(local);
        for (auto local : local->vars)
          ctx.remove(dfg->getDef(local));
      } else
        ctx = NonStrictContext::disjunction(builtinTypes, arena, visit(stat),
                                            ctx);
    }
    return ctx;
  }

  NonStrictContext visit(AstStatIf *ifStatement) {
    NonStrictContext condB = visit(ifStatement->condition);
    NonStrictContext branchContext;
    // If there is no else branch, don't bother generating warnings for the then
    // branch - we can't prove there is an error
    if (ifStatement->elsebody) {
      NonStrictContext thenBody = visit(ifStatement->thenbody);
      NonStrictContext elseBody = visit(ifStatement->elsebody);
      branchContext = NonStrictContext::conjunction(builtinTypes, arena,
                                                    thenBody, elseBody);
    }
    return NonStrictContext::disjunction(builtinTypes, arena, condB,
                                         branchContext);
  }

  NonStrictContext visit(AstStatWhile *whileStatement) { return {}; }

  NonStrictContext visit(AstStatRepeat *repeatStatement) { return {}; }

  NonStrictContext visit(AstStatBreak *breakStatement) { return {}; }

  NonStrictContext visit(AstStatContinue *continueStatement) { return {}; }

  NonStrictContext visit(AstStatReturn *returnStatement) { return {}; }

  NonStrictContext visit(AstStatExpr *expr) { return visit(expr->expr); }

  NonStrictContext visit(AstStatLocal *local) {
    for (AstExpr *rhs : local->values)
      visit(rhs);
    return {};
  }

  NonStrictContext visit(AstStatFor *forStatement) { return {}; }

  NonStrictContext visit(AstStatForIn *forInStatement) { return {}; }

  NonStrictContext visit(AstStatAssign *assign) { return {}; }

  NonStrictContext visit(AstStatCompoundAssign *compoundAssign) { return {}; }

  NonStrictContext visit(AstStatFunction *statFn) {
    return visit(statFn->func);
  }

  NonStrictContext visit(AstStatLocalFunction *localFn) {
    return visit(localFn->func);
  }

  NonStrictContext visit(AstStatTypeAlias *typeAlias) { return {}; }

  NonStrictContext visit(AstStatDeclareFunction *declFn) { return {}; }

  NonStrictContext visit(AstStatDeclareGlobal *declGlobal) { return {}; }

  NonStrictContext visit(AstStatDeclareClass *declClass) { return {}; }

  NonStrictContext visit(AstStatError *error) { return {}; }

  NonStrictContext visit(AstExpr *expr) {
    auto pusher = pushStack(expr);
    if (auto e = expr->as<AstExprGroup>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantNil>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantBool>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantNumber>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantString>())
      return visit(e);
    else if (auto e = expr->as<AstExprLocal>())
      return visit(e);
    else if (auto e = expr->as<AstExprGlobal>())
      return visit(e);
    else if (auto e = expr->as<AstExprVarargs>())
      return visit(e);
    else if (auto e = expr->as<AstExprCall>())
      return visit(e);
    else if (auto e = expr->as<AstExprIndexName>())
      return visit(e);
    else if (auto e = expr->as<AstExprIndexExpr>())
      return visit(e);
    else if (auto e = expr->as<AstExprFunction>())
      return visit(e);
    else if (auto e = expr->as<AstExprTable>())
      return visit(e);
    else if (auto e = expr->as<AstExprUnary>())
      return visit(e);
    else if (auto e = expr->as<AstExprBinary>())
      return visit(e);
    else if (auto e = expr->as<AstExprTypeAssertion>())
      return visit(e);
    else if (auto e = expr->as<AstExprIfElse>())
      return visit(e);
    else if (auto e = expr->as<AstExprInterpString>())
      return visit(e);
    else if (auto e = expr->as<AstExprError>())
      return visit(e);
    else {
      LUAU_ASSERT(
          !"NonStrictTypeChecker encountered an unknown expression type");
      ice->ice("NonStrictTypeChecker encountered an unknown expression type");
    }
  }

  NonStrictContext visit(AstExprGroup *group) { return {}; }

  NonStrictContext visit(AstExprConstantNil *expr) { return {}; }

  NonStrictContext visit(AstExprConstantBool *expr) { return {}; }

  NonStrictContext visit(AstExprConstantNumber *expr) { return {}; }

  NonStrictContext visit(AstExprConstantString *expr) { return {}; }

  NonStrictContext visit(AstExprLocal *local) { return {}; }

  NonStrictContext visit(AstExprGlobal *global) { return {}; }

  NonStrictContext visit(AstExprVarargs *global) { return {}; }

  NonStrictContext visit(AstExprCall *call) {
    NonStrictContext fresh{};
    TypeId *originalCallTy = module->astOriginalCallTypes.find(call);
    if (!originalCallTy)
      return fresh;

    TypeId fnTy = *originalCallTy;
    if (auto fn = get<FunctionType>(follow(fnTy))) {
      if (fn->isCheckedFunction) {
        // We know fn is a checked function, which means it looks like:
        // (S1, ... SN) -> T &
        // (~S1, unknown^N-1) -> error &
        // (unknown, ~S2, unknown^N-2) -> error
        // ...
        // ...
        // (unknown^N-1, ~S_N) -> error
        std::vector<TypeId> argTypes;
        argTypes.reserve(call->args.size);
        // Pad out the arg types array with the types you would expect to see
        TypePackIterator curr = begin(fn->argTypes);
        TypePackIterator fin = end(fn->argTypes);
        while (curr != fin) {
          argTypes.push_back(*curr);
          ++curr;
        }
        if (auto argTail = curr.tail()) {
          if (const VariadicTypePack *vtp =
                  get<VariadicTypePack>(follow(*argTail))) {
            while (argTypes.size() < call->args.size) {
              argTypes.push_back(vtp->ty);
            }
          }
        }

        std::string functionName =
            getFunctionNameAsString(*call->func).value_or("");
        if (call->args.size > argTypes.size()) {
          // We are passing more arguments than we expect, so we should error
          reportError(CheckedFunctionIncorrectArgs{functionName,
                                                   argTypes.size(),
                                                   call->args.size},
                      call->location);
          return fresh;
        }

        for (size_t i = 0; i < call->args.size; i++) {
          // For example, if the arg is "hi"
          // The actual arg type is string
          // The expected arg type is number
          // The type of the argument in the overload is ~number
          // We will compare arg and ~number
          AstExpr *arg = call->args.data[i];
          TypeId expectedArgType = argTypes[i];
          std::shared_ptr<const NormalizedType> norm =
              normalizer.normalize(expectedArgType);
          DefId def = dfg->getDef(arg);
          TypeId runTimeErrorTy;
          // If we're dealing with any, negating any will cause all subtype
          // tests to fail, since ~any is any However, when someone calls this
          // function, they're going to want to be able to pass it anything, for
          // that reason, we manually inject never into the context so that the
          // runtime test will always pass.
          if (!norm)
            reportError(NormalizationTooComplex{}, arg->location);

          if (norm && get<AnyType>(norm->tops))
            runTimeErrorTy = builtinTypes->neverType;
          else
            runTimeErrorTy = getOrCreateNegation(expectedArgType);
          fresh.addContext(def, runTimeErrorTy);
        }

        // Populate the context and now iterate through each of the arguments to
        // the call to find out if we satisfy the types
        for (size_t i = 0; i < call->args.size; i++) {
          AstExpr *arg = call->args.data[i];
          if (auto runTimeFailureType = willRunTimeError(arg, fresh))
            reportError(CheckedFunctionCallError{argTypes[i],
                                                 *runTimeFailureType,
                                                 functionName, i},
                        arg->location);
        }

        if (call->args.size < argTypes.size()) {
          // We are passing fewer arguments than we expect
          // so we need to ensure that the rest of the args are optional.
          bool remainingArgsOptional = true;
          for (size_t i = call->args.size; i < argTypes.size(); i++)
            remainingArgsOptional =
                remainingArgsOptional && isOptional(argTypes[i]);
          if (!remainingArgsOptional) {
            reportError(CheckedFunctionIncorrectArgs{functionName,
                                                     argTypes.size(),
                                                     call->args.size},
                        call->location);
            return fresh;
          }
        }
      }
    }

    return fresh;
  }

  NonStrictContext visit(AstExprIndexName *indexName) { return {}; }

  NonStrictContext visit(AstExprIndexExpr *indexExpr) { return {}; }

  NonStrictContext visit(AstExprFunction *exprFn) {
    // TODO: should a function being used as an expression generate a context
    // without the arguments?
    auto pusher = pushStack(exprFn);
    NonStrictContext remainder = visit(exprFn->body);
    for (AstLocal *local : exprFn->args) {
      if (std::optional<TypeId> ty =
              willRunTimeErrorFunctionDefinition(local, remainder))
        reportError(NonStrictFunctionDefinitionError{exprFn->debugname.value,
                                                     local->name.value, *ty},
                    local->location);
      remainder.remove(dfg->getDef(local));
    }
    return remainder;
  }

  NonStrictContext visit(AstExprTable *table) { return {}; }

  NonStrictContext visit(AstExprUnary *unary) { return {}; }

  NonStrictContext visit(AstExprBinary *binary) { return {}; }

  NonStrictContext visit(AstExprTypeAssertion *typeAssertion) { return {}; }

  NonStrictContext visit(AstExprIfElse *ifElse) {
    NonStrictContext condB = visit(ifElse->condition);
    NonStrictContext thenB = visit(ifElse->trueExpr);
    NonStrictContext elseB = visit(ifElse->falseExpr);
    return NonStrictContext::disjunction(
        builtinTypes, arena, condB,
        NonStrictContext::conjunction(builtinTypes, arena, thenB, elseB));
  }

  NonStrictContext visit(AstExprInterpString *interpString) { return {}; }

  NonStrictContext visit(AstExprError *error) { return {}; }

  void reportError(TypeErrorData data, const Location &location) {
    module->errors.emplace_back(location, module->name, std::move(data));
    // TODO: weave in logger here?
  }

  // If this fragment of the ast will run time error, return the type that
  // causes this
  std::optional<TypeId> willRunTimeError(AstExpr *fragment,
                                         const NonStrictContext &context) {
    DefId def = dfg->getDef(fragment);
    std::vector<DefId> defs;
    collectOperands(def, &defs);
    for (DefId def : defs) {
      if (std::optional<TypeId> contextTy = context.find(def)) {

        TypeId actualType = lookupType(fragment);
        SubtypingResult r = subtyping.isSubtype(actualType, *contextTy);
        if (r.normalizationTooComplex)
          reportError(NormalizationTooComplex{}, fragment->location);
        if (r.isSubtype)
          return {actualType};
      }
    }

    return {};
  }

  std::optional<TypeId>
  willRunTimeErrorFunctionDefinition(AstLocal *fragment,
                                     const NonStrictContext &context) {
    DefId def = dfg->getDef(fragment);
    std::vector<DefId> defs;
    collectOperands(def, &defs);
    for (DefId def : defs) {
      if (std::optional<TypeId> contextTy = context.find(def)) {
        SubtypingResult r1 =
            subtyping.isSubtype(builtinTypes->unknownType, *contextTy);
        SubtypingResult r2 =
            subtyping.isSubtype(*contextTy, builtinTypes->unknownType);
        if (r1.normalizationTooComplex || r2.normalizationTooComplex)
          reportError(NormalizationTooComplex{}, fragment->location);
        bool isUnknown = r1.isSubtype && r2.isSubtype;
        if (isUnknown)
          return {builtinTypes->unknownType};
      }
    }
    return {};
  }

private:
  TypeId getOrCreateNegation(TypeId baseType) {
    TypeId &cachedResult = cachedNegations[baseType];
    if (!cachedResult)
      cachedResult = arena->addType(NegationType{baseType});
    return cachedResult;
  };
};

void checkNonStrict(NotNull<BuiltinTypes> builtinTypes,
                    NotNull<InternalErrorReporter> ice,
                    NotNull<UnifierSharedState> unifierState,
                    NotNull<const DataFlowGraph> dfg,
                    NotNull<TypeCheckLimits> limits,
                    const SourceModule &sourceModule, Module *module) {
  NonStrictTypeChecker typeChecker{NotNull{&module->internalTypes},
                                   builtinTypes,
                                   ice,
                                   unifierState,
                                   dfg,
                                   limits,
                                   module};
  typeChecker.visit(sourceModule.root);
  unfreeze(module->interfaceTypes);
  copyErrors(module->errors, module->interfaceTypes, builtinTypes);
  freeze(module->interfaceTypes);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeChecker2.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/AstQuery.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DcrLogger.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// DONE : was aleready inlined <Luau/InsertionOrderedMap.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Instantiation.h>

// DONE : was aleready inlined <Luau/Metamethods.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/OverloadResolution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Subtyping.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included!
// <Luau/TypeFunctionReductionGuesser.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePath.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeOrPack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <iostream>

// @@@@@ PACK.LUA : was already included! <ostream>

LUAU_FASTFLAG(DebugLuauMagicTypes)

namespace Luau {

// TypeInfer.h
// TODO move these
using PrintLineProc = void (*)(const std::string &);
extern PrintLineProc luauPrintLine;

/* Push a scope onto the end of a stack for the lifetime of the StackPusher
 * instance. TypeChecker2 uses this to maintain knowledge about which scope
 * encloses every given AstNode.
 */
struct StackPusher {
  std::vector<NotNull<Scope>> *stack;
  NotNull<Scope> scope;

  explicit StackPusher(std::vector<NotNull<Scope>> &stack, Scope *scope)
      : stack(&stack), scope(scope) {
    stack.push_back(NotNull{scope});
  }

  ~StackPusher() {
    if (stack) {
      LUAU_ASSERT(stack->back() == scope);
      stack->pop_back();
    }
  }

  StackPusher(const StackPusher &) = delete;
  StackPusher &&operator=(const StackPusher &) = delete;

  StackPusher(StackPusher &&other)
      : stack(std::exchange(other.stack, nullptr)), scope(other.scope) {}
};

static std::optional<std::string> getIdentifierOfBaseVar(AstExpr *node) {
  if (AstExprGlobal *expr = node->as<AstExprGlobal>())
    return expr->name.value;

  if (AstExprLocal *expr = node->as<AstExprLocal>())
    return expr->local->name.value;

  if (AstExprIndexExpr *expr = node->as<AstExprIndexExpr>())
    return getIdentifierOfBaseVar(expr->expr);

  if (AstExprIndexName *expr = node->as<AstExprIndexName>())
    return getIdentifierOfBaseVar(expr->expr);

  return std::nullopt;
}

template <typename T> bool areEquivalent(const T &a, const T &b) {
  if (a.family != b.family)
    return false;

  if (a.typeArguments.size() != b.typeArguments.size() ||
      a.packArguments.size() != b.packArguments.size())
    return false;

  for (size_t i = 0; i < a.typeArguments.size(); ++i) {
    if (follow(a.typeArguments[i]) != follow(b.typeArguments[i]))
      return false;
  }

  for (size_t i = 0; i < a.packArguments.size(); ++i) {
    if (follow(a.packArguments[i]) != follow(b.packArguments[i]))
      return false;
  }

  return true;
}

struct FamilyFinder : TypeOnceVisitor {
  DenseHashSet<TypeId> mentionedFamilies{nullptr};
  DenseHashSet<TypePackId> mentionedFamilyPacks{nullptr};

  bool visit(TypeId ty, const TypeFunctionInstanceType &) override {
    mentionedFamilies.insert(ty);
    return true;
  }

  bool visit(TypePackId tp, const TypeFunctionInstanceTypePack &) override {
    mentionedFamilyPacks.insert(tp);
    return true;
  }
};

struct InternalFamilyFinder : TypeOnceVisitor {
  DenseHashSet<TypeId> internalFamilies{nullptr};
  DenseHashSet<TypePackId> internalPackFamilies{nullptr};
  DenseHashSet<TypeId> mentionedFamilies{nullptr};
  DenseHashSet<TypePackId> mentionedFamilyPacks{nullptr};

  InternalFamilyFinder(std::vector<TypeId> &declStack) {
    FamilyFinder f;
    for (TypeId fn : declStack)
      f.traverse(fn);

    mentionedFamilies = std::move(f.mentionedFamilies);
    mentionedFamilyPacks = std::move(f.mentionedFamilyPacks);
  }

  bool visit(TypeId ty, const TypeFunctionInstanceType &tfit) override {
    bool hasGeneric = false;

    for (TypeId p : tfit.typeArguments) {
      if (get<GenericType>(follow(p))) {
        hasGeneric = true;
        break;
      }
    }

    for (TypePackId p : tfit.packArguments) {
      if (get<GenericTypePack>(follow(p))) {
        hasGeneric = true;
        break;
      }
    }

    if (hasGeneric) {
      for (TypeId mentioned : mentionedFamilies) {
        const TypeFunctionInstanceType *mentionedTfit =
            get<TypeFunctionInstanceType>(mentioned);
        LUAU_ASSERT(mentionedTfit);
        if (areEquivalent(tfit, *mentionedTfit)) {
          return true;
        }
      }

      internalFamilies.insert(ty);
    }

    return true;
  }

  bool visit(TypePackId tp,
             const TypeFunctionInstanceTypePack &tfitp) override {
    bool hasGeneric = false;

    for (TypeId p : tfitp.typeArguments) {
      if (get<GenericType>(follow(p))) {
        hasGeneric = true;
        break;
      }
    }

    for (TypePackId p : tfitp.packArguments) {
      if (get<GenericTypePack>(follow(p))) {
        hasGeneric = true;
        break;
      }
    }

    if (hasGeneric) {
      for (TypePackId mentioned : mentionedFamilyPacks) {
        const TypeFunctionInstanceTypePack *mentionedTfitp =
            get<TypeFunctionInstanceTypePack>(mentioned);
        LUAU_ASSERT(mentionedTfitp);
        if (areEquivalent(tfitp, *mentionedTfitp)) {
          return true;
        }
      }

      internalPackFamilies.insert(tp);
    }

    return true;
  }
};

struct TypeChecker2 {
  NotNull<BuiltinTypes> builtinTypes;
  DcrLogger *logger;
  const NotNull<TypeCheckLimits> limits;
  const NotNull<InternalErrorReporter> ice;
  const SourceModule *sourceModule;
  Module *module;

  TypeContext typeContext = TypeContext::Default;
  std::vector<NotNull<Scope>> stack;
  std::vector<TypeId> functionDeclStack;

  DenseHashSet<TypeId> seenTypeFunctionInstances{nullptr};

  Normalizer normalizer;
  Subtyping _subtyping;
  NotNull<Subtyping> subtyping;

  TypeChecker2(NotNull<BuiltinTypes> builtinTypes,
               NotNull<UnifierSharedState> unifierState,
               NotNull<TypeCheckLimits> limits, DcrLogger *logger,
               const SourceModule *sourceModule, Module *module)
      : builtinTypes(builtinTypes), logger(logger), limits(limits),
        ice(unifierState->iceHandler), sourceModule(sourceModule),
        module(module), normalizer{&module->internalTypes, builtinTypes,
                                   unifierState, /* cacheInhabitance */ true},
        _subtyping{builtinTypes, NotNull{&module->internalTypes},
                   NotNull{&normalizer}, NotNull{unifierState->iceHandler},
                   NotNull{module->getModuleScope().get()}},
        subtyping(&_subtyping) {}

  static bool allowsNoReturnValues(const TypePackId tp) {
    for (TypeId ty : tp) {
      if (!get<ErrorType>(follow(ty)))
        return false;
    }

    return true;
  }

  static Location getEndLocation(const AstExprFunction *function) {
    Location loc = function->location;
    if (loc.begin.line != loc.end.line) {
      Position begin = loc.end;
      begin.column = std::max(0u, begin.column - 3);
      loc = Location(begin, 3);
    }

    return loc;
  }

  bool isErrorCall(const AstExprCall *call) {
    const AstExprGlobal *global = call->func->as<AstExprGlobal>();
    if (!global)
      return false;

    if (global->name == "error")
      return true;
    else if (global->name == "assert") {
      // assert() will error because it is missing the first argument
      if (call->args.size == 0)
        return true;

      if (AstExprConstantBool *expr =
              call->args.data[0]->as<AstExprConstantBool>())
        if (!expr->value)
          return true;
    }

    return false;
  }

  bool hasBreak(AstStat *node) {
    if (AstStatBlock *stat = node->as<AstStatBlock>()) {
      for (size_t i = 0; i < stat->body.size; ++i) {
        if (hasBreak(stat->body.data[i]))
          return true;
      }

      return false;
    }

    if (node->is<AstStatBreak>())
      return true;

    if (AstStatIf *stat = node->as<AstStatIf>()) {
      if (hasBreak(stat->thenbody))
        return true;

      if (stat->elsebody && hasBreak(stat->elsebody))
        return true;

      return false;
    }

    return false;
  }

  // returns the last statement before the block implicitly exits, or nullptr if
  // the block does not implicitly exit i.e. returns nullptr if the block
  // returns properly or never returns
  const AstStat *getFallthrough(const AstStat *node) {
    if (const AstStatBlock *stat = node->as<AstStatBlock>()) {
      if (stat->body.size == 0)
        return stat;

      for (size_t i = 0; i < stat->body.size - 1; ++i) {
        if (getFallthrough(stat->body.data[i]) == nullptr)
          return nullptr;
      }

      return getFallthrough(stat->body.data[stat->body.size - 1]);
    }

    if (const AstStatIf *stat = node->as<AstStatIf>()) {
      if (const AstStat *thenf = getFallthrough(stat->thenbody))
        return thenf;

      if (stat->elsebody) {
        if (const AstStat *elsef = getFallthrough(stat->elsebody))
          return elsef;

        return nullptr;
      } else
        return stat;
    }

    if (node->is<AstStatReturn>())
      return nullptr;

    if (const AstStatExpr *stat = node->as<AstStatExpr>()) {
      if (AstExprCall *call = stat->expr->as<AstExprCall>();
          call && isErrorCall(call))
        return nullptr;

      return stat;
    }

    if (const AstStatWhile *stat = node->as<AstStatWhile>()) {
      if (AstExprConstantBool *expr =
              stat->condition->as<AstExprConstantBool>()) {
        if (expr->value && !hasBreak(stat->body))
          return nullptr;
      }

      return node;
    }

    if (const AstStatRepeat *stat = node->as<AstStatRepeat>()) {
      if (AstExprConstantBool *expr =
              stat->condition->as<AstExprConstantBool>()) {
        if (!expr->value && !hasBreak(stat->body))
          return nullptr;
      }

      if (getFallthrough(stat->body) == nullptr)
        return nullptr;

      return node;
    }

    return node;
  }

  std::optional<StackPusher> pushStack(AstNode *node) {
    if (Scope **scope = module->astScopes.find(node))
      return StackPusher{stack, *scope};
    else
      return std::nullopt;
  }

  void checkForInternalFamily(TypeId ty, Location location) {
    InternalFamilyFinder finder(functionDeclStack);
    finder.traverse(ty);

    for (TypeId internal : finder.internalFamilies)
      reportError(WhereClauseNeeded{internal}, location);

    for (TypePackId internal : finder.internalPackFamilies)
      reportError(PackWhereClauseNeeded{internal}, location);
  }

  TypeId checkForFamilyInhabitance(TypeId instance, Location location) {
    if (seenTypeFunctionInstances.find(instance))
      return instance;
    seenTypeFunctionInstances.insert(instance);

    ErrorVec errors =
        reduceTypeFunctions(instance, location,
                            TypeFunctionContext{NotNull{&module->internalTypes},
                                                builtinTypes, stack.back(),
                                                NotNull{&normalizer}, ice,
                                                limits},
                            true)
            .errors;
    if (!isErrorSuppressing(location, instance))
      reportErrors(std::move(errors));
    return instance;
  }

  TypePackId lookupPack(AstExpr *expr) {
    // If a type isn't in the type graph, it probably means that a recursion
    // limit was exceeded. We'll just return anyType in these cases.
    // Typechecking against any is very fast and this allows us not to think
    // about this very much in the actual typechecking logic.
    TypePackId *tp = module->astTypePacks.find(expr);
    if (tp)
      return follow(*tp);
    else
      return builtinTypes->anyTypePack;
  }

  TypeId lookupType(AstExpr *expr) {
    // If a type isn't in the type graph, it probably means that a recursion
    // limit was exceeded. We'll just return anyType in these cases.
    // Typechecking against any is very fast and this allows us not to think
    // about this very much in the actual typechecking logic.
    TypeId *ty = module->astTypes.find(expr);
    if (ty)
      return checkForFamilyInhabitance(follow(*ty), expr->location);

    TypePackId *tp = module->astTypePacks.find(expr);
    if (tp)
      return checkForFamilyInhabitance(flattenPack(*tp), expr->location);

    return builtinTypes->anyType;
  }

  TypeId lookupAnnotation(AstType *annotation) {
    if (FFlag::DebugLuauMagicTypes) {
      if (auto ref = annotation->as<AstTypeReference>();
          ref && ref->name == "_luau_print" && ref->parameters.size > 0) {
        if (auto ann = ref->parameters.data[0].type) {
          TypeId argTy = lookupAnnotation(ref->parameters.data[0].type);
          luauPrintLine(format(
              "_luau_print (%d, %d): %s\n", annotation->location.begin.line,
              annotation->location.begin.column, toString(argTy).c_str()));
          return follow(argTy);
        }
      }
    }

    TypeId *ty = module->astResolvedTypes.find(annotation);
    LUAU_ASSERT(ty);
    return checkForFamilyInhabitance(follow(*ty), annotation->location);
  }

  std::optional<TypePackId> lookupPackAnnotation(AstTypePack *annotation) {
    TypePackId *tp = module->astResolvedTypePacks.find(annotation);
    if (tp != nullptr)
      return {follow(*tp)};
    return {};
  }

  TypeId lookupExpectedType(AstExpr *expr) {
    if (TypeId *ty = module->astExpectedTypes.find(expr))
      return follow(*ty);

    return builtinTypes->anyType;
  }

  TypePackId lookupExpectedPack(AstExpr *expr, TypeArena &arena) {
    if (TypeId *ty = module->astExpectedTypes.find(expr))
      return arena.addTypePack(TypePack{{follow(*ty)}, std::nullopt});

    return builtinTypes->anyTypePack;
  }

  TypePackId reconstructPack(AstArray<AstExpr *> exprs, TypeArena &arena) {
    if (exprs.size == 0)
      return arena.addTypePack(TypePack{{}, std::nullopt});

    std::vector<TypeId> head;

    for (size_t i = 0; i < exprs.size - 1; ++i) {
      head.push_back(lookupType(exprs.data[i]));
    }

    TypePackId tail = lookupPack(exprs.data[exprs.size - 1]);
    return arena.addTypePack(TypePack{head, tail});
  }

  Scope *findInnermostScope(Location location) {
    Scope *bestScope = module->getModuleScope().get();

    bool didNarrow;
    do {
      didNarrow = false;
      for (auto scope : bestScope->children) {
        if (scope->location.encloses(location)) {
          bestScope = scope.get();
          didNarrow = true;
          break;
        }
      }
    } while (didNarrow && bestScope->children.size() > 0);

    return bestScope;
  }

  void visit(AstStat *stat) {
    auto pusher = pushStack(stat);

    if (auto s = stat->as<AstStatBlock>())
      return visit(s);
    else if (auto s = stat->as<AstStatIf>())
      return visit(s);
    else if (auto s = stat->as<AstStatWhile>())
      return visit(s);
    else if (auto s = stat->as<AstStatRepeat>())
      return visit(s);
    else if (auto s = stat->as<AstStatBreak>())
      return visit(s);
    else if (auto s = stat->as<AstStatContinue>())
      return visit(s);
    else if (auto s = stat->as<AstStatReturn>())
      return visit(s);
    else if (auto s = stat->as<AstStatExpr>())
      return visit(s);
    else if (auto s = stat->as<AstStatLocal>())
      return visit(s);
    else if (auto s = stat->as<AstStatFor>())
      return visit(s);
    else if (auto s = stat->as<AstStatForIn>())
      return visit(s);
    else if (auto s = stat->as<AstStatAssign>())
      return visit(s);
    else if (auto s = stat->as<AstStatCompoundAssign>())
      return visit(s);
    else if (auto s = stat->as<AstStatFunction>())
      return visit(s);
    else if (auto s = stat->as<AstStatLocalFunction>())
      return visit(s);
    else if (auto s = stat->as<AstStatTypeAlias>())
      return visit(s);
    else if (auto s = stat->as<AstStatDeclareFunction>())
      return visit(s);
    else if (auto s = stat->as<AstStatDeclareGlobal>())
      return visit(s);
    else if (auto s = stat->as<AstStatDeclareClass>())
      return visit(s);
    else if (auto s = stat->as<AstStatError>())
      return visit(s);
    else
      LUAU_ASSERT(!"TypeChecker2 encountered an unknown node type");
  }

  void visit(AstStatBlock *block) {
    auto StackPusher = pushStack(block);

    for (AstStat *statement : block->body)
      visit(statement);
  }

  void visit(AstStatIf *ifStatement) {
    {
      InConditionalContext flipper{&typeContext};
      visit(ifStatement->condition, ValueContext::RValue);
    }

    visit(ifStatement->thenbody);
    if (ifStatement->elsebody)
      visit(ifStatement->elsebody);
  }

  void visit(AstStatWhile *whileStatement) {
    visit(whileStatement->condition, ValueContext::RValue);
    visit(whileStatement->body);
  }

  void visit(AstStatRepeat *repeatStatement) {
    visit(repeatStatement->body);
    visit(repeatStatement->condition, ValueContext::RValue);
  }

  void visit(AstStatBreak *) {}

  void visit(AstStatContinue *) {}

  void visit(AstStatReturn *ret) {
    Scope *scope = findInnermostScope(ret->location);
    TypePackId expectedRetType = scope->returnType;

    TypeArena *arena = &module->internalTypes;
    TypePackId actualRetType = reconstructPack(ret->list, *arena);

    testIsSubtype(actualRetType, expectedRetType, ret->location);

    for (AstExpr *expr : ret->list)
      visit(expr, ValueContext::RValue);
  }

  void visit(AstStatExpr *expr) { visit(expr->expr, ValueContext::RValue); }

  void visit(AstStatLocal *local) {
    size_t count = std::max(local->values.size, local->vars.size);
    for (size_t i = 0; i < count; ++i) {
      AstExpr *value = i < local->values.size ? local->values.data[i] : nullptr;
      const bool isPack =
          value && (value->is<AstExprCall>() || value->is<AstExprVarargs>());

      if (value)
        visit(value, ValueContext::RValue);

      if (i != local->values.size - 1 || !isPack) {
        AstLocal *var = i < local->vars.size ? local->vars.data[i] : nullptr;

        if (var && var->annotation) {
          TypeId annotationType = lookupAnnotation(var->annotation);
          TypeId valueType = value ? lookupType(value) : nullptr;
          if (valueType)
            testIsSubtype(valueType, annotationType, value->location);

          visit(var->annotation);
        }
      } else if (value) {
        TypePackId valuePack = lookupPack(value);
        TypePack valueTypes;
        if (i < local->vars.size)
          valueTypes = extendTypePack(module->internalTypes, builtinTypes,
                                      valuePack, local->vars.size - i);

        Location errorLocation;
        for (size_t j = i; j < local->vars.size; ++j) {
          if (j - i >= valueTypes.head.size()) {
            errorLocation = local->vars.data[j]->location;
            break;
          }

          AstLocal *var = local->vars.data[j];
          if (var->annotation) {
            TypeId varType = lookupAnnotation(var->annotation);
            testIsSubtype(valueTypes.head[j - i], varType, value->location);

            visit(var->annotation);
          }
        }

        if (valueTypes.head.size() < local->vars.size - i) {
          reportError(
              CountMismatch{
                  // We subtract 1 here because the final AST
                  // expression is not worth one value.  It is worth 0
                  // or more depending on valueTypes.head
                  local->values.size - 1 + valueTypes.head.size(),
                  std::nullopt,
                  local->vars.size,
                  local->values.data[local->values.size - 1]->is<AstExprCall>()
                      ? CountMismatch::FunctionResult
                      : CountMismatch::ExprListResult,
              },
              errorLocation);
        }
      }
    }
  }

  void visit(AstStatFor *forStatement) {
    if (forStatement->var->annotation) {
      visit(forStatement->var->annotation);

      TypeId annotatedType = lookupAnnotation(forStatement->var->annotation);
      testIsSubtype(builtinTypes->numberType, annotatedType,
                    forStatement->var->location);
    }

    auto checkNumber = [this](AstExpr *expr) {
      if (!expr)
        return;

      visit(expr, ValueContext::RValue);
      testIsSubtype(lookupType(expr), builtinTypes->numberType, expr->location);
    };

    checkNumber(forStatement->from);
    checkNumber(forStatement->to);
    checkNumber(forStatement->step);

    visit(forStatement->body);
  }

  void visit(AstStatForIn *forInStatement) {
    for (AstLocal *local : forInStatement->vars) {
      if (local->annotation)
        visit(local->annotation);
    }

    for (AstExpr *expr : forInStatement->values)
      visit(expr, ValueContext::RValue);

    visit(forInStatement->body);

    // Rule out crazy stuff.  Maybe possible if the file is not syntactically
    // valid.
    if (!forInStatement->vars.size || !forInStatement->values.size)
      return;

    NotNull<Scope> scope = stack.back();
    TypeArena &arena = module->internalTypes;

    std::vector<TypeId> variableTypes;
    for (AstLocal *var : forInStatement->vars) {
      std::optional<TypeId> ty = scope->lookup(var);
      LUAU_ASSERT(ty);
      variableTypes.emplace_back(*ty);
    }

    AstExpr *firstValue = forInStatement->values.data[0];

    // we need to build up a typepack for the iterators/values portion of the
    // for-in statement.
    std::vector<TypeId> valueTypes;
    std::optional<TypePackId> iteratorTail;

    // since the first value may be the only iterator (e.g. if it is a call), we
    // want to look to see if it has a resulting typepack as our iterators.
    TypePackId *retPack = module->astTypePacks.find(firstValue);
    if (retPack) {
      auto [head, tail] = flatten(*retPack);
      valueTypes = head;
      iteratorTail = tail;
    } else {
      valueTypes.emplace_back(lookupType(firstValue));
    }

    // if the initial and expected types from the iterator unified during
    // constraint solving, we'll have a resolved type to use here, but we'll
    // only use it if either the iterator is directly present in the for-in
    // statement or if we have an iterator state constraining us
    TypeId *resolvedTy = module->astForInNextTypes.find(firstValue);
    if (resolvedTy && (!retPack || valueTypes.size() > 1))
      valueTypes[0] = *resolvedTy;

    for (size_t i = 1; i < forInStatement->values.size - 1; ++i) {
      valueTypes.emplace_back(lookupType(forInStatement->values.data[i]));
    }

    // if we had more than one value, the tail from the first value is no longer
    // appropriate to use.
    if (forInStatement->values.size > 1) {
      auto [head, tail] = flatten(lookupPack(
          forInStatement->values.data[forInStatement->values.size - 1]));
      valueTypes.insert(valueTypes.end(), head.begin(), head.end());
      iteratorTail = tail;
    }

    // and now we can put everything together to get the actual typepack of the
    // iterators.
    TypePackId iteratorPack = arena.addTypePack(valueTypes, iteratorTail);

    // ... and then expand it out to 3 values (if possible)
    TypePack iteratorTypes =
        extendTypePack(arena, builtinTypes, iteratorPack, 3);
    if (iteratorTypes.head.empty()) {
      reportError(GenericError{"for..in loops require at least one value to "
                               "iterate over.  Got zero"},
                  getLocation(forInStatement->values));
      return;
    }
    TypeId iteratorTy = follow(iteratorTypes.head[0]);

    auto checkFunction = [this, &arena, &forInStatement, &variableTypes](
                             const FunctionType *iterFtv,
                             std::vector<TypeId> iterTys, bool isMm) {
      if (iterTys.size() < 1 || iterTys.size() > 3) {
        if (isMm)
          reportError(
              GenericError{
                  "__iter metamethod must return (next[, table[, state]])"},
              getLocation(forInStatement->values));
        else
          reportError(
              GenericError{
                  "for..in loops must be passed (next[, table[, state]])"},
              getLocation(forInStatement->values));

        return;
      }

      // It is okay if there aren't enough iterators, but the iteratee must
      // provide enough.
      TypePack expectedVariableTypes = extendTypePack(
          arena, builtinTypes, iterFtv->retTypes, variableTypes.size());
      if (expectedVariableTypes.head.size() < variableTypes.size()) {
        if (isMm)
          reportError(GenericError{"__iter metamethod's next() function does "
                                   "not return enough values"},
                      getLocation(forInStatement->values));
        else
          reportError(GenericError{"next() does not return enough values"},
                      forInStatement->values.data[0]->location);
      }

      for (size_t i = 0; i < std::min(expectedVariableTypes.head.size(),
                                      variableTypes.size());
           ++i)
        testIsSubtype(variableTypes[i], expectedVariableTypes.head[i],
                      forInStatement->vars.data[i]->location);

      // nextFn is going to be invoked with (arrayTy, startIndexTy)

      // It will be passed two arguments on every iteration save the
      // first.

      // It may be invoked with 0 or 1 argument on the first iteration.
      // This depends on the types in iterateePack and therefore
      // iteratorTypes.

      // If the iteratee is an error type, then we can't really say anything
      // else about iteration over it. After all, it _could've_ been a table.
      if (get<ErrorType>(follow(flattenPack(iterFtv->argTypes))))
        return;

      // If iteratorTypes is too short to be a valid call to nextFn, we have to
      // report a count mismatch error. If 2 is too short to be a valid call to
      // nextFn, we have to report a count mismatch error. If 2 is too long to
      // be a valid call to nextFn, we have to report a count mismatch error.
      auto [minCount, maxCount] = getParameterExtents(
          TxnLog::empty(), iterFtv->argTypes, /*includeHiddenVariadics*/ true);

      TypePack flattenedArgTypes =
          extendTypePack(arena, builtinTypes, iterFtv->argTypes, 2);
      size_t firstIterationArgCount = iterTys.empty() ? 0 : iterTys.size() - 1;
      size_t actualArgCount = expectedVariableTypes.head.size();
      if (firstIterationArgCount < minCount) {
        if (isMm)
          reportError(
              GenericError{
                  "__iter metamethod must return (next[, table[, state]])"},
              getLocation(forInStatement->values));
        else
          reportError(CountMismatch{2, std::nullopt, firstIterationArgCount,
                                    CountMismatch::Arg},
                      forInStatement->values.data[0]->location);
      }

      else if (actualArgCount < minCount) {
        if (isMm)
          reportError(
              GenericError{
                  "__iter metamethod must return (next[, table[, state]])"},
              getLocation(forInStatement->values));
        else
          reportError(CountMismatch{2, std::nullopt, firstIterationArgCount,
                                    CountMismatch::Arg},
                      forInStatement->values.data[0]->location);
      }

      if (iterTys.size() >= 2 && flattenedArgTypes.head.size() > 0) {
        size_t valueIndex = forInStatement->values.size > 1 ? 1 : 0;
        testIsSubtype(iterTys[1], flattenedArgTypes.head[0],
                      forInStatement->values.data[valueIndex]->location);
      }

      if (iterTys.size() == 3 && flattenedArgTypes.head.size() > 1) {
        size_t valueIndex = forInStatement->values.size > 2 ? 2 : 0;
        testIsSubtype(iterTys[2], flattenedArgTypes.head[1],
                      forInStatement->values.data[valueIndex]->location);
      }
    };

    std::shared_ptr<const NormalizedType> iteratorNorm =
        normalizer.normalize(iteratorTy);

    if (!iteratorNorm)
      reportError(NormalizationTooComplex{}, firstValue->location);

    /*
     * If the first iterator argument is a function
     *  * There must be 1 to 3 iterator arguments.  Name them (nextTy,
     *    arrayTy, startIndexTy)
     *  * The return type of nextTy() must correspond to the variables'
     *    types and counts.  HOWEVER the first iterator will never be nil.
     *  * The first return value of nextTy must be compatible with
     *    startIndexTy.
     *  * The first argument to nextTy() must be compatible with arrayTy if
     *    present.  nil if not.
     *  * The second argument to nextTy() must be compatible with
     *    startIndexTy if it is present.  Else, it must be compatible with
     *    nil.
     *  * nextTy() must be callable with only 2 arguments.
     */
    if (const FunctionType *nextFn = get<FunctionType>(iteratorTy)) {
      checkFunction(nextFn, iteratorTypes.head, false);
    } else if (const TableType *ttv = get<TableType>(iteratorTy)) {
      if ((forInStatement->vars.size == 1 || forInStatement->vars.size == 2) &&
          ttv->indexer) {
        testIsSubtype(variableTypes[0], ttv->indexer->indexType,
                      forInStatement->vars.data[0]->location);
        if (variableTypes.size() == 2)
          testIsSubtype(variableTypes[1], ttv->indexer->indexResultType,
                        forInStatement->vars.data[1]->location);
      } else
        reportError(GenericError{"Cannot iterate over a table without indexer"},
                    forInStatement->values.data[0]->location);
    } else if (get<AnyType>(iteratorTy) || get<ErrorType>(iteratorTy) ||
               get<NeverType>(iteratorTy)) {
      // nothing
    } else if (isOptional(iteratorTy) &&
               !(iteratorNorm && iteratorNorm->shouldSuppressErrors())) {
      reportError(OptionalValueAccess{iteratorTy},
                  forInStatement->values.data[0]->location);
    } else if (std::optional<TypeId> iterMmTy = findMetatableEntry(
                   builtinTypes, module->errors, iteratorTy, "__iter",
                   forInStatement->values.data[0]->location)) {
      Instantiation instantiation{TxnLog::empty(), &arena, builtinTypes,
                                  TypeLevel{}, scope};

      if (std::optional<TypeId> instantiatedIterMmTy = instantiate(
              builtinTypes, NotNull{&arena}, limits, scope, *iterMmTy)) {
        if (const FunctionType *iterMmFtv =
                get<FunctionType>(*instantiatedIterMmTy)) {
          TypePackId argPack = arena.addTypePack({iteratorTy});
          testIsSubtype(argPack, iterMmFtv->argTypes,
                        forInStatement->values.data[0]->location);

          TypePack mmIteratorTypes =
              extendTypePack(arena, builtinTypes, iterMmFtv->retTypes, 3);

          if (mmIteratorTypes.head.size() == 0) {
            reportError(GenericError{"__iter must return at least one value"},
                        forInStatement->values.data[0]->location);
            return;
          }

          TypeId nextFn = follow(mmIteratorTypes.head[0]);

          if (std::optional<TypeId> instantiatedNextFn =
                  instantiation.substitute(nextFn)) {
            std::vector<TypeId> instantiatedIteratorTypes =
                mmIteratorTypes.head;
            instantiatedIteratorTypes[0] = *instantiatedNextFn;

            if (const FunctionType *nextFtv =
                    get<FunctionType>(*instantiatedNextFn)) {
              checkFunction(nextFtv, instantiatedIteratorTypes, true);
            } else if (!isErrorSuppressing(
                           forInStatement->values.data[0]->location,
                           *instantiatedNextFn)) {
              reportError(CannotCallNonFunction{*instantiatedNextFn},
                          forInStatement->values.data[0]->location);
            }
          } else {
            reportError(UnificationTooComplex{},
                        forInStatement->values.data[0]->location);
          }
        } else if (!isErrorSuppressing(forInStatement->values.data[0]->location,
                                       *iterMmTy)) {
          // TODO: This will not tell the user that this is because the
          // metamethod isn't callable. This is not ideal, and we should
          // improve this error message.

          // TODO: This will also not handle intersections of functions or
          // callable tables (which are supported by the runtime).
          reportError(CannotCallNonFunction{*iterMmTy},
                      forInStatement->values.data[0]->location);
        }
      } else {
        reportError(UnificationTooComplex{},
                    forInStatement->values.data[0]->location);
      }
    } else if (iteratorNorm && iteratorNorm->hasTables()) {
      // Ok. All tables can be iterated.
    } else if (!iteratorNorm || !iteratorNorm->shouldSuppressErrors()) {
      reportError(CannotCallNonFunction{iteratorTy},
                  forInStatement->values.data[0]->location);
    }
  }

  std::optional<TypeId> getBindingType(AstExpr *expr) {
    if (auto localExpr = expr->as<AstExprLocal>()) {
      Scope *s = stack.back();
      return s->lookup(localExpr->local);
    } else if (auto globalExpr = expr->as<AstExprGlobal>()) {
      Scope *s = stack.back();
      return s->lookup(globalExpr->name);
    } else
      return std::nullopt;
  }

  // this should only be called if the type of `lhs` is `never`.
  void reportErrorsFromAssigningToNever(AstExpr *lhs, TypeId rhsType) {

    if (auto indexName = lhs->as<AstExprIndexName>()) {
      TypeId indexedType = lookupType(indexName->expr);

      // if it's already never, I don't think we have anything to do here.
      if (get<NeverType>(indexedType))
        return;

      std::string prop = indexName->index.value;

      std::shared_ptr<const NormalizedType> norm =
          normalizer.normalize(indexedType);
      if (!norm) {
        reportError(NormalizationTooComplex{}, lhs->location);
        return;
      }

      // if the type is error suppressing, we don't actually have any work left
      // to do.
      if (norm->shouldSuppressErrors())
        return;

      const auto propTypes =
          lookupProp(norm.get(), prop, ValueContext::LValue, lhs->location,
                     builtinTypes->stringType, module->errors);

      reportError(
          CannotAssignToNever{rhsType, propTypes.typesOfProp,
                              CannotAssignToNever::Reason::PropertyNarrowed},
          lhs->location);
    }
  }

  void visit(AstStatAssign *assign) {
    size_t count = std::min(assign->vars.size, assign->values.size);

    for (size_t i = 0; i < count; ++i) {
      AstExpr *lhs = assign->vars.data[i];
      visit(lhs, ValueContext::LValue);
      TypeId lhsType = lookupType(lhs);

      AstExpr *rhs = assign->values.data[i];
      visit(rhs, ValueContext::RValue);
      TypeId rhsType = lookupType(rhs);

      if (get<NeverType>(lhsType)) {
        reportErrorsFromAssigningToNever(lhs, rhsType);
        continue;
      }

      bool ok = testIsSubtype(rhsType, lhsType, rhs->location);

      // If rhsType </: lhsType, then it's not useful to also report that
      // rhsType </: bindingType
      if (ok) {
        std::optional<TypeId> bindingType = getBindingType(lhs);
        if (bindingType)
          testIsSubtype(rhsType, *bindingType, rhs->location);
      }
    }
  }

  void visit(AstStatCompoundAssign *stat) {
    AstExprBinary fake{stat->location, stat->op, stat->var, stat->value};
    visit(&fake, stat);

    TypeId *resultTy = module->astCompoundAssignResultTypes.find(stat);
    LUAU_ASSERT(resultTy);
    TypeId varTy = lookupType(stat->var);

    testIsSubtype(*resultTy, varTy, stat->location);
  }

  void visit(AstStatFunction *stat) {
    visit(stat->name, ValueContext::LValue);
    visit(stat->func);
  }

  void visit(AstStatLocalFunction *stat) { visit(stat->func); }

  void visit(const AstTypeList *typeList) {
    for (AstType *ty : typeList->types)
      visit(ty);

    if (typeList->tailType)
      visit(typeList->tailType);
  }

  void visit(AstStatTypeAlias *stat) {
    visitGenerics(stat->generics, stat->genericPacks);
    visit(stat->type);
  }

  void visit(AstTypeList types) {
    for (AstType *type : types.types)
      visit(type);
    if (types.tailType)
      visit(types.tailType);
  }

  void visit(AstStatDeclareFunction *stat) {
    visitGenerics(stat->generics, stat->genericPacks);
    visit(stat->params);
    visit(stat->retTypes);
  }

  void visit(AstStatDeclareGlobal *stat) { visit(stat->type); }

  void visit(AstStatDeclareClass *stat) {
    for (const AstDeclaredClassProp &prop : stat->props)
      visit(prop.ty);
  }

  void visit(AstStatError *stat) {
    for (AstExpr *expr : stat->expressions)
      visit(expr, ValueContext::RValue);

    for (AstStat *s : stat->statements)
      visit(s);
  }

  void visit(AstExpr *expr, ValueContext context) {
    auto StackPusher = pushStack(expr);

    if (auto e = expr->as<AstExprGroup>())
      return visit(e, context);
    else if (auto e = expr->as<AstExprConstantNil>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantBool>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantNumber>())
      return visit(e);
    else if (auto e = expr->as<AstExprConstantString>())
      return visit(e);
    else if (auto e = expr->as<AstExprLocal>())
      return visit(e);
    else if (auto e = expr->as<AstExprGlobal>())
      return visit(e);
    else if (auto e = expr->as<AstExprVarargs>())
      return visit(e);
    else if (auto e = expr->as<AstExprCall>())
      return visit(e);
    else if (auto e = expr->as<AstExprIndexName>())
      return visit(e, context);
    else if (auto e = expr->as<AstExprIndexExpr>())
      return visit(e, context);
    else if (auto e = expr->as<AstExprFunction>())
      return visit(e);
    else if (auto e = expr->as<AstExprTable>())
      return visit(e);
    else if (auto e = expr->as<AstExprUnary>())
      return visit(e);
    else if (auto e = expr->as<AstExprBinary>()) {
      visit(e);
      return;
    } else if (auto e = expr->as<AstExprTypeAssertion>())
      return visit(e);
    else if (auto e = expr->as<AstExprIfElse>())
      return visit(e);
    else if (auto e = expr->as<AstExprInterpString>())
      return visit(e);
    else if (auto e = expr->as<AstExprError>())
      return visit(e);
    else
      LUAU_ASSERT(!"TypeChecker2 encountered an unknown expression type");
  }

  void visit(AstExprGroup *expr, ValueContext context) {
    visit(expr->expr, context);
  }

  void visit(AstExprConstantNil *expr) {
#if defined(LUAU_ENABLE_ASSERT)
    TypeId actualType = lookupType(expr);
    TypeId expectedType = builtinTypes->nilType;

    SubtypingResult r = subtyping->isSubtype(actualType, expectedType);
    LUAU_ASSERT(r.isSubtype || isErrorSuppressing(expr->location, actualType));
#endif
  }

  void visit(AstExprConstantBool *expr) {
    // booleans use specialized inference logic for singleton types, which can
    // lead to real type errors here.

    const TypeId bestType =
        expr->value ? builtinTypes->trueType : builtinTypes->falseType;
    const TypeId inferredType = lookupType(expr);

    const SubtypingResult r = subtyping->isSubtype(bestType, inferredType);
    if (!r.isSubtype && !isErrorSuppressing(expr->location, inferredType))
      reportError(TypeMismatch{inferredType, bestType}, expr->location);
  }

  void visit(AstExprConstantNumber *expr) {
#if defined(LUAU_ENABLE_ASSERT)
    const TypeId bestType = builtinTypes->numberType;
    const TypeId inferredType = lookupType(expr);

    const SubtypingResult r = subtyping->isSubtype(bestType, inferredType);
    LUAU_ASSERT(r.isSubtype ||
                isErrorSuppressing(expr->location, inferredType));
#endif
  }

  void visit(AstExprConstantString *expr) {
    // strings use specialized inference logic for singleton types, which can
    // lead to real type errors here.

    const TypeId bestType = module->internalTypes.addType(SingletonType{
        StringSingleton{std::string{expr->value.data, expr->value.size}}});
    const TypeId inferredType = lookupType(expr);

    const SubtypingResult r = subtyping->isSubtype(bestType, inferredType);
    if (!r.isSubtype && !isErrorSuppressing(expr->location, inferredType))
      reportError(TypeMismatch{inferredType, bestType}, expr->location);
  }

  void visit(AstExprLocal *expr) {
    // TODO!
  }

  void visit(AstExprGlobal *expr) {
    NotNull<Scope> scope = stack.back();
    if (!scope->lookup(expr->name))
      reportError(UnknownSymbol{expr->name.value, UnknownSymbol::Binding},
                  expr->location);
  }

  void visit(AstExprVarargs *expr) {
    // TODO!
  }

  // Note: this is intentionally separated from `visit(AstExprCall*)` for stack
  // allocation purposes.
  void visitCall(AstExprCall *call) {
    TypePack args;
    std::vector<AstExpr *> argExprs;
    argExprs.reserve(call->args.size + 1);

    TypeId *originalCallTy = module->astOriginalCallTypes.find(call);
    TypeId *selectedOverloadTy = module->astOverloadResolvedTypes.find(call);
    if (!originalCallTy)
      return;

    TypeId fnTy = follow(*originalCallTy);

    if (get<AnyType>(fnTy) || get<ErrorType>(fnTy) || get<NeverType>(fnTy))
      return;
    else if (isOptional(fnTy)) {
      switch (shouldSuppressErrors(NotNull{&normalizer}, fnTy)) {
      case ErrorSuppression::Suppress:
        break;
      case ErrorSuppression::NormalizationFailed:
        reportError(NormalizationTooComplex{}, call->func->location);
        // fallthrough intentional
      case ErrorSuppression::DoNotSuppress:
        reportError(OptionalValueAccess{fnTy}, call->func->location);
      }
      return;
    }

    if (selectedOverloadTy) {
      SubtypingResult result =
          subtyping->isSubtype(*originalCallTy, *selectedOverloadTy);
      if (result.isSubtype)
        fnTy = follow(*selectedOverloadTy);

      if (result.normalizationTooComplex) {
        reportError(NormalizationTooComplex{}, call->func->location);
        return;
      }
    }

    if (call->self) {
      AstExprIndexName *indexExpr = call->func->as<AstExprIndexName>();
      if (!indexExpr)
        ice->ice("method call expression has no 'self'");

      args.head.push_back(lookupType(indexExpr->expr));
      argExprs.push_back(indexExpr->expr);
    } else if (findMetatableEntry(builtinTypes, module->errors, *originalCallTy,
                                  "__call", call->func->location)) {
      args.head.insert(args.head.begin(), lookupType(call->func));
      argExprs.push_back(call->func);
    }

    for (size_t i = 0; i < call->args.size; ++i) {
      AstExpr *arg = call->args.data[i];
      argExprs.push_back(arg);
      TypeId *argTy = module->astTypes.find(arg);
      if (argTy)
        args.head.push_back(*argTy);
      else if (i == call->args.size - 1) {
        if (auto argTail = module->astTypePacks.find(arg)) {
          auto [head, tail] = flatten(*argTail);
          args.head.insert(args.head.end(), head.begin(), head.end());
          args.tail = tail;
        } else
          args.tail = builtinTypes->anyTypePack;
      } else
        args.head.push_back(builtinTypes->anyType);
    }

    OverloadResolver resolver{
        builtinTypes,
        NotNull{&module->internalTypes},
        NotNull{&normalizer},
        NotNull{stack.back()},
        ice,
        limits,
        call->location,
    };
    resolver.resolve(fnTy, &args, call->func, &argExprs);

    auto norm = normalizer.normalize(fnTy);
    if (!norm)
      reportError(NormalizationTooComplex{}, call->func->location);
    auto isInhabited = normalizer.isInhabited(norm.get());
    if (isInhabited == NormalizationResult::HitLimits)
      reportError(NormalizationTooComplex{}, call->func->location);

    if (norm && norm->shouldSuppressErrors())
      return; // error suppressing function type!
    else if (!resolver.ok.empty())
      return; // We found a call that works, so this is ok.
    else if (!norm || isInhabited == NormalizationResult::False)
      return; // Ok. Calling an uninhabited type is no-op.
    else if (!resolver.nonviableOverloads.empty()) {
      if (resolver.nonviableOverloads.size() == 1 &&
          !isErrorSuppressing(call->func->location,
                              resolver.nonviableOverloads.front().first))
        reportErrors(resolver.nonviableOverloads.front().second);
      else {
        std::string s = "None of the overloads for function that accept ";
        s += std::to_string(args.head.size());
        s += " arguments are compatible.";
        reportError(GenericError{std::move(s)}, call->location);
      }
    } else if (!resolver.arityMismatches.empty()) {
      if (resolver.arityMismatches.size() == 1)
        reportErrors(resolver.arityMismatches.front().second);
      else {
        std::string s = "No overload for function accepts ";
        s += std::to_string(args.head.size());
        s += " arguments.";
        reportError(GenericError{std::move(s)}, call->location);
      }
    } else if (!resolver.nonFunctions.empty())
      reportError(CannotCallNonFunction{fnTy}, call->func->location);
    else
      LUAU_ASSERT(!"Generating the best possible error from this function call "
                   "resolution was inexhaustive?");

    if (resolver.arityMismatches.size() > 1 ||
        resolver.nonviableOverloads.size() > 1) {
      std::string s = "Available overloads: ";

      std::vector<TypeId> overloads;
      if (resolver.nonviableOverloads.empty()) {
        for (const auto &[ty, p] : resolver.resolution) {
          if (p.first == OverloadResolver::TypeIsNotAFunction)
            continue;

          overloads.push_back(ty);
        }
      } else {
        for (const auto &[ty, _] : resolver.nonviableOverloads)
          overloads.push_back(ty);
      }

      for (size_t i = 0; i < overloads.size(); ++i) {
        if (i > 0)
          s += (i == overloads.size() - 1) ? "; and " : "; ";

        s += toString(overloads[i]);
      }

      reportError(ExtraInformation{std::move(s)}, call->func->location);
    }
  }

  void visit(AstExprCall *call) {
    visit(call->func, ValueContext::RValue);

    for (AstExpr *arg : call->args)
      visit(arg, ValueContext::RValue);

    visitCall(call);
  }

  std::optional<TypeId> tryStripUnionFromNil(TypeId ty) {
    if (const UnionType *utv = get<UnionType>(ty)) {
      if (!std::any_of(begin(utv), end(utv), isNil))
        return ty;

      std::vector<TypeId> result;

      for (TypeId option : utv) {
        if (!isNil(option))
          result.push_back(option);
      }

      if (result.empty())
        return std::nullopt;

      return result.size() == 1
                 ? result[0]
                 : module->internalTypes.addType(UnionType{std::move(result)});
    }

    return std::nullopt;
  }

  TypeId stripFromNilAndReport(TypeId ty, const Location &location) {
    ty = follow(ty);

    if (auto utv = get<UnionType>(ty)) {
      if (!std::any_of(begin(utv), end(utv), isNil))
        return ty;
    }

    if (std::optional<TypeId> strippedUnion = tryStripUnionFromNil(ty)) {
      switch (shouldSuppressErrors(NotNull{&normalizer}, ty)) {
      case ErrorSuppression::Suppress:
        break;
      case ErrorSuppression::NormalizationFailed:
        reportError(NormalizationTooComplex{}, location);
        // fallthrough intentional
      case ErrorSuppression::DoNotSuppress:
        reportError(OptionalValueAccess{ty}, location);
      }

      return follow(*strippedUnion);
    }

    return ty;
  }

  void visitExprName(AstExpr *expr, Location location,
                     const std::string &propName, ValueContext context,
                     TypeId astIndexExprTy) {
    visit(expr, ValueContext::RValue);
    TypeId leftType = stripFromNilAndReport(lookupType(expr), location);
    checkIndexTypeFromType(leftType, propName, context, location,
                           astIndexExprTy);
  }

  void visit(AstExprIndexName *indexName, ValueContext context) {
    // If we're indexing like _.foo - foo could either be a prop or a string.
    visitExprName(indexName->expr, indexName->location, indexName->index.value,
                  context, builtinTypes->stringType);
  }

  void indexExprMetatableHelper(AstExprIndexExpr *indexExpr,
                                const MetatableType *metaTable, TypeId exprType,
                                TypeId indexType) {
    if (auto tt = get<TableType>(follow(metaTable->table)); tt && tt->indexer)
      testIsSubtype(indexType, tt->indexer->indexType,
                    indexExpr->index->location);
    else if (auto mt = get<MetatableType>(follow(metaTable->table)))
      indexExprMetatableHelper(indexExpr, mt, exprType, indexType);
    else if (auto tmt = get<TableType>(follow(metaTable->metatable));
             tmt && tmt->indexer)
      testIsSubtype(indexType, tmt->indexer->indexType,
                    indexExpr->index->location);
    else if (auto mtmt = get<MetatableType>(follow(metaTable->metatable)))
      indexExprMetatableHelper(indexExpr, mtmt, exprType, indexType);
    else {
      LUAU_ASSERT(tt || get<PrimitiveType>(follow(metaTable->table)));

      reportError(
          CannotExtendTable{exprType, CannotExtendTable::Indexer, "indexer??"},
          indexExpr->location);
    }
  }

  void visit(AstExprIndexExpr *indexExpr, ValueContext context) {
    if (auto str = indexExpr->index->as<AstExprConstantString>()) {
      TypeId astIndexExprType = lookupType(indexExpr->index);
      const std::string stringValue(str->value.data, str->value.size);
      visitExprName(indexExpr->expr, indexExpr->location, stringValue, context,
                    astIndexExprType);
      return;
    }

    visit(indexExpr->expr, ValueContext::RValue);
    visit(indexExpr->index, ValueContext::RValue);

    TypeId exprType = follow(lookupType(indexExpr->expr));
    TypeId indexType = follow(lookupType(indexExpr->index));

    if (auto tt = get<TableType>(exprType)) {
      if (tt->indexer)
        testIsSubtype(indexType, tt->indexer->indexType,
                      indexExpr->index->location);
      else
        reportError(CannotExtendTable{exprType, CannotExtendTable::Indexer,
                                      "indexer??"},
                    indexExpr->location);
    } else if (auto mt = get<MetatableType>(exprType)) {
      return indexExprMetatableHelper(indexExpr, mt, exprType, indexType);
    } else if (auto cls = get<ClassType>(exprType)) {
      if (cls->indexer)
        testIsSubtype(indexType, cls->indexer->indexType,
                      indexExpr->index->location);
      else
        reportError(DynamicPropertyLookupOnClassesUnsafe{exprType},
                    indexExpr->location);
    } else if (get<UnionType>(exprType) && isOptional(exprType)) {
      switch (shouldSuppressErrors(NotNull{&normalizer}, exprType)) {
      case ErrorSuppression::Suppress:
        break;
      case ErrorSuppression::NormalizationFailed:
        reportError(NormalizationTooComplex{}, indexExpr->location);
        // fallthrough intentional
      case ErrorSuppression::DoNotSuppress:
        reportError(OptionalValueAccess{exprType}, indexExpr->location);
      }
    } else if (auto exprIntersection = get<IntersectionType>(exprType)) {
      for (TypeId part : exprIntersection) {
        (void)part;
      }
    } else if (get<NeverType>(exprType) ||
               isErrorSuppressing(indexExpr->location, exprType)) {
      // Nothing
    } else
      reportError(NotATable{exprType}, indexExpr->location);
  }

  void visit(AstExprFunction *fn) {
    auto StackPusher = pushStack(fn);

    visitGenerics(fn->generics, fn->genericPacks);

    TypeId inferredFnTy = lookupType(fn);
    functionDeclStack.push_back(inferredFnTy);

    std::shared_ptr<const NormalizedType> normalizedFnTy =
        normalizer.normalize(inferredFnTy);
    if (!normalizedFnTy) {
      reportError(CodeTooComplex{}, fn->location);
    } else if (get<ErrorType>(normalizedFnTy->errors)) {
      // Nothing
    } else if (!normalizedFnTy->hasFunctions()) {
      ice->ice("Internal error: Lambda has non-function type " +
                   toString(inferredFnTy),
               fn->location);
    } else {
      if (1 != normalizedFnTy->functions.parts.size())
        ice->ice("Unexpected: Lambda has unexpected type " +
                     toString(inferredFnTy),
                 fn->location);

      const FunctionType *inferredFtv =
          get<FunctionType>(normalizedFnTy->functions.parts.front());
      LUAU_ASSERT(inferredFtv);

      // There is no way to write an annotation for the self argument, so we
      // cannot do anything to check it.
      auto argIt = begin(inferredFtv->argTypes);
      if (fn->self)
        ++argIt;

      for (const auto &arg : fn->args) {
        if (argIt == end(inferredFtv->argTypes))
          break;

        TypeId inferredArgTy = *argIt;

        if (arg->annotation) {
          // we need to typecheck any argument annotations themselves.
          visit(arg->annotation);

          TypeId annotatedArgTy = lookupAnnotation(arg->annotation);

          testIsSubtype(inferredArgTy, annotatedArgTy, arg->location);
        }

        // Some Luau constructs can result in an argument type being
        // reduced to never by inference. In this case, we want to
        // report an error at the function, instead of reporting an
        // error at every callsite.
        if (is<NeverType>(follow(inferredArgTy))) {
          // If the annotation simplified to never, we don't want to
          // even look at contributors.
          bool explicitlyNever = false;
          if (arg->annotation) {
            TypeId annotatedArgTy = lookupAnnotation(arg->annotation);
            explicitlyNever = is<NeverType>(annotatedArgTy);
          }

          // Not following here is deliberate: the contribution map is
          // keyed by type pointer, but that type pointer has, at some
          // point, been transmuted to a bound type pointing to never.
          if (const auto contributors =
                  module->upperBoundContributors.find(inferredArgTy);
              contributors && !explicitlyNever) {
            // It's unfortunate that we can't link error messages
            // together. For now, this will work.
            reportError(GenericError{format(
                            "Parameter '%s' has been reduced to never. This "
                            "function is not callable with any possible value.",
                            arg->name.value)},
                        arg->location);
            for (const auto &[site, component] : *contributors)
              reportError(ExtraInformation{format(
                              "Parameter '%s' is required to be a subtype of "
                              "'%s' here.",
                              arg->name.value, toString(component).c_str())},
                          site);
          }
        }

        ++argIt;
      }

      // we need to typecheck the vararg annotation, if it exists.
      if (fn->vararg && fn->varargAnnotation)
        visit(fn->varargAnnotation);

      bool reachesImplicitReturn = getFallthrough(fn->body) != nullptr;
      if (reachesImplicitReturn &&
          !allowsNoReturnValues(follow(inferredFtv->retTypes)))
        reportError(FunctionExitsWithoutReturning{inferredFtv->retTypes},
                    getEndLocation(fn));
    }

    visit(fn->body);

    // we need to typecheck the return annotation itself, if it exists.
    if (fn->returnAnnotation)
      visit(*fn->returnAnnotation);

    // If the function type has a family annotation, we need to see if we can
    // suggest an annotation
    if (normalizedFnTy) {
      const FunctionType *inferredFtv =
          get<FunctionType>(normalizedFnTy->functions.parts.front());
      LUAU_ASSERT(inferredFtv);

      TypeFunctionReductionGuesser guesser{NotNull{&module->internalTypes},
                                           builtinTypes, NotNull{&normalizer}};
      for (TypeId retTy : inferredFtv->retTypes) {
        if (get<TypeFunctionInstanceType>(follow(retTy))) {
          TypeFunctionReductionGuessResult result =
              guesser.guessTypeFunctionReductionForFunctionExpr(
                  *fn, inferredFtv, retTy);
          if (result.shouldRecommendAnnotation)
            reportError(
                ExplicitFunctionAnnotationRecommended{
                    std::move(result.guessedFunctionAnnotations),
                    result.guessedReturnType},
                fn->location);
        }
      }
    }

    functionDeclStack.pop_back();
  }

  void visit(AstExprTable *expr) {
    // TODO!
    for (const AstExprTable::Item &item : expr->items) {
      if (item.key)
        visit(item.key, ValueContext::LValue);
      visit(item.value, ValueContext::RValue);
    }
  }

  void visit(AstExprUnary *expr) {
    visit(expr->expr, ValueContext::RValue);

    TypeId operandType = lookupType(expr->expr);
    TypeId resultType = lookupType(expr);

    if (isErrorSuppressing(expr->expr->location, operandType))
      return;

    if (auto it = kUnaryOpMetamethods.find(expr->op);
        it != kUnaryOpMetamethods.end()) {
      std::optional<TypeId> mm =
          findMetatableEntry(builtinTypes, module->errors, operandType,
                             it->second, expr->location);
      if (mm) {
        if (const FunctionType *ftv = get<FunctionType>(follow(*mm))) {
          if (std::optional<TypeId> ret = first(ftv->retTypes)) {
            if (expr->op == AstExprUnary::Op::Len) {
              testIsSubtype(follow(*ret), builtinTypes->numberType,
                            expr->location);
            }
          } else {
            reportError(GenericError{format(
                            "Metamethod '%s' must return a value", it->second)},
                        expr->location);
          }

          std::optional<TypeId> firstArg = first(ftv->argTypes);
          if (!firstArg) {
            reportError(
                GenericError{"__unm metamethod must accept one argument"},
                expr->location);
            return;
          }

          TypePackId expectedArgs =
              module->internalTypes.addTypePack({operandType});
          TypePackId expectedRet =
              module->internalTypes.addTypePack({resultType});

          TypeId expectedFunction = module->internalTypes.addType(
              FunctionType{expectedArgs, expectedRet});

          bool success = testIsSubtype(*mm, expectedFunction, expr->location);
          if (!success)
            return;
        }

        return;
      }
    }

    if (expr->op == AstExprUnary::Op::Len) {
      DenseHashSet<TypeId> seen{nullptr};
      int recursionCount = 0;
      std::shared_ptr<const NormalizedType> nty =
          normalizer.normalize(operandType);

      if (nty && nty->shouldSuppressErrors())
        return;

      if (!hasLength(operandType, seen, &recursionCount)) {
        if (isOptional(operandType))
          reportError(OptionalValueAccess{operandType}, expr->location);
        else
          reportError(NotATable{operandType}, expr->location);
      }
    } else if (expr->op == AstExprUnary::Op::Minus) {
      testIsSubtype(operandType, builtinTypes->numberType, expr->location);
    } else if (expr->op == AstExprUnary::Op::Not) {
    } else {
      LUAU_ASSERT(!"Unhandled unary operator");
    }
  }

  TypeId visit(AstExprBinary *expr, AstNode *overrideKey = nullptr) {
    visit(expr->left, ValueContext::RValue);
    visit(expr->right, ValueContext::RValue);

    NotNull<Scope> scope = stack.back();

    bool isEquality = expr->op == AstExprBinary::Op::CompareEq ||
                      expr->op == AstExprBinary::Op::CompareNe;
    bool isComparison = expr->op >= AstExprBinary::Op::CompareEq &&
                        expr->op <= AstExprBinary::Op::CompareGe;
    bool isLogical =
        expr->op == AstExprBinary::Op::And || expr->op == AstExprBinary::Op::Or;

    TypeId leftType = follow(lookupType(expr->left));
    TypeId rightType = follow(lookupType(expr->right));
    TypeId expectedResult = follow(lookupType(expr));

    if (get<TypeFunctionInstanceType>(expectedResult)) {
      checkForInternalFamily(expectedResult, expr->location);
      return expectedResult;
    }

    if (expr->op == AstExprBinary::Op::Or) {
      leftType = stripNil(builtinTypes, module->internalTypes, leftType);
    }

    std::shared_ptr<const NormalizedType> normLeft =
        normalizer.normalize(leftType);
    std::shared_ptr<const NormalizedType> normRight =
        normalizer.normalize(rightType);

    bool isStringOperation =
        (normLeft ? normLeft->isSubtypeOfString() : isString(leftType)) &&
        (normRight ? normRight->isSubtypeOfString() : isString(rightType));
    leftType = follow(leftType);
    if (get<AnyType>(leftType) || get<ErrorType>(leftType) ||
        get<NeverType>(leftType))
      return leftType;
    else if (get<AnyType>(rightType) || get<ErrorType>(rightType) ||
             get<NeverType>(rightType))
      return rightType;
    else if ((normLeft && normLeft->shouldSuppressErrors()) ||
             (normRight && normRight->shouldSuppressErrors()))
      return builtinTypes
          ->anyType; // we can't say anything better if it's error suppressing
                     // but not any or error alone.

    if ((get<BlockedType>(leftType) || get<FreeType>(leftType) ||
         get<GenericType>(leftType)) &&
        !isEquality && !isLogical) {
      auto name = getIdentifierOfBaseVar(expr->left);
      reportError(
          CannotInferBinaryOperation{
              expr->op, name,
              isComparison ? CannotInferBinaryOperation::OpKind::Comparison
                           : CannotInferBinaryOperation::OpKind::Operation},
          expr->location);
      return leftType;
    }

    NormalizationResult typesHaveIntersection =
        normalizer.isIntersectionInhabited(leftType, rightType);
    if (auto it = kBinaryOpMetamethods.find(expr->op);
        it != kBinaryOpMetamethods.end()) {
      std::optional<TypeId> leftMt = getMetatable(leftType, builtinTypes);
      std::optional<TypeId> rightMt = getMetatable(rightType, builtinTypes);
      bool matches = leftMt == rightMt;

      if (isEquality && !matches) {
        auto testUnion = [&matches, builtinTypes = this->builtinTypes](
                             const UnionType *utv,
                             std::optional<TypeId> otherMt) {
          for (TypeId option : utv) {
            if (getMetatable(follow(option), builtinTypes) == otherMt) {
              matches = true;
              break;
            }
          }
        };

        if (const UnionType *utv = get<UnionType>(leftType); utv && rightMt) {
          testUnion(utv, rightMt);
        }

        if (const UnionType *utv = get<UnionType>(rightType);
            utv && leftMt && !matches) {
          testUnion(utv, leftMt);
        }
      }

      // If we're working with things that are not tables, the metatable
      // comparisons above are a little excessive It's ok for one type to have a
      // meta table and the other to not. In that case, we should fall back on
      // checking if the intersection of the types is inhabited. If
      // `typesHaveIntersection` failed due to limits,
      // TODO: Maybe add more checks here (e.g. for functions, classes, etc)
      if (!(get<TableType>(leftType) || get<TableType>(rightType)))
        if (!leftMt.has_value() || !rightMt.has_value())
          matches =
              matches || typesHaveIntersection != NormalizationResult::False;

      if (!matches && isComparison) {
        reportError(GenericError{format(
                        "Types %s and %s cannot be compared with %s because "
                        "they do not have the same metatable",
                        toString(leftType).c_str(), toString(rightType).c_str(),
                        toString(expr->op).c_str())},
                    expr->location);

        return builtinTypes->errorRecoveryType();
      }

      std::optional<TypeId> mm;
      if (std::optional<TypeId> leftMm =
              findMetatableEntry(builtinTypes, module->errors, leftType,
                                 it->second, expr->left->location))
        mm = leftMm;
      else if (std::optional<TypeId> rightMm =
                   findMetatableEntry(builtinTypes, module->errors, rightType,
                                      it->second, expr->right->location)) {
        mm = rightMm;
        std::swap(leftType, rightType);
      }

      if (mm) {
        AstNode *key = expr;
        if (overrideKey != nullptr)
          key = overrideKey;

        TypeId *selectedOverloadTy = module->astOverloadResolvedTypes.find(key);
        if (!selectedOverloadTy) {
          // reportError(CodeTooComplex{}, expr->location);
          // was handled by a type function
          return expectedResult;
        }

        else if (const FunctionType *ftv =
                     get<FunctionType>(follow(*selectedOverloadTy))) {
          TypePackId expectedArgs;
          // For >= and > we invoke __lt and __le respectively with
          // swapped argument ordering.
          if (expr->op == AstExprBinary::Op::CompareGe ||
              expr->op == AstExprBinary::Op::CompareGt) {
            expectedArgs =
                module->internalTypes.addTypePack({rightType, leftType});
          } else {
            expectedArgs =
                module->internalTypes.addTypePack({leftType, rightType});
          }

          TypePackId expectedRets;
          if (expr->op == AstExprBinary::CompareEq ||
              expr->op == AstExprBinary::CompareNe ||
              expr->op == AstExprBinary::CompareGe ||
              expr->op == AstExprBinary::CompareGt ||
              expr->op == AstExprBinary::Op::CompareLe ||
              expr->op == AstExprBinary::Op::CompareLt) {
            expectedRets =
                module->internalTypes.addTypePack({builtinTypes->booleanType});
          } else {
            expectedRets = module->internalTypes.addTypePack(
                {module->internalTypes.freshType(scope, TypeLevel{})});
          }

          TypeId expectedTy = module->internalTypes.addType(
              FunctionType(expectedArgs, expectedRets));

          testIsSubtype(follow(*mm), expectedTy, expr->location);

          std::optional<TypeId> ret = first(ftv->retTypes);
          if (ret) {
            if (isComparison) {
              if (!isBoolean(follow(*ret))) {
                reportError(
                    GenericError{format("Metamethod '%s' must return a boolean",
                                        it->second)},
                    expr->location);
              }

              return builtinTypes->booleanType;
            } else {
              return follow(*ret);
            }
          } else {
            if (isComparison) {
              reportError(
                  GenericError{format("Metamethod '%s' must return a boolean",
                                      it->second)},
                  expr->location);
            } else {
              reportError(
                  GenericError{format("Metamethod '%s' must return a value",
                                      it->second)},
                  expr->location);
            }

            return builtinTypes->errorRecoveryType();
          }
        } else {
          reportError(CannotCallNonFunction{*mm}, expr->location);
        }

        return builtinTypes->errorRecoveryType();
      }
      // If this is a string comparison, or a concatenation of strings, we
      // want to fall through to primitive behavior.
      else if (!isEquality &&
               !(isStringOperation &&
                 (expr->op == AstExprBinary::Op::Concat || isComparison))) {
        if ((leftMt && !isString(leftType)) ||
            (rightMt && !isString(rightType))) {
          if (isComparison) {
            reportError(
                GenericError{format(
                    "Types '%s' and '%s' cannot be compared with %s because "
                    "neither type's metatable has a '%s' metamethod",
                    toString(leftType).c_str(), toString(rightType).c_str(),
                    toString(expr->op).c_str(), it->second)},
                expr->location);
          } else {
            reportError(
                GenericError{format(
                    "Operator %s is not applicable for '%s' and '%s' because "
                    "neither type's metatable has a '%s' metamethod",
                    toString(expr->op).c_str(), toString(leftType).c_str(),
                    toString(rightType).c_str(), it->second)},
                expr->location);
          }

          return builtinTypes->errorRecoveryType();
        } else if (!leftMt && !rightMt &&
                   (get<TableType>(leftType) || get<TableType>(rightType))) {
          if (isComparison) {
            reportError(
                GenericError{format(
                    "Types '%s' and '%s' cannot be compared with %s because "
                    "neither type has a metatable",
                    toString(leftType).c_str(), toString(rightType).c_str(),
                    toString(expr->op).c_str())},
                expr->location);
          } else {
            reportError(
                GenericError{format(
                    "Operator %s is not applicable for '%s' and '%s' because "
                    "neither type has a metatable",
                    toString(expr->op).c_str(), toString(leftType).c_str(),
                    toString(rightType).c_str())},
                expr->location);
          }

          return builtinTypes->errorRecoveryType();
        }
      }
    }

    switch (expr->op) {
    case AstExprBinary::Op::Add:
    case AstExprBinary::Op::Sub:
    case AstExprBinary::Op::Mul:
    case AstExprBinary::Op::Div:
    case AstExprBinary::Op::FloorDiv:
    case AstExprBinary::Op::Pow:
    case AstExprBinary::Op::Mod:
      testIsSubtype(leftType, builtinTypes->numberType, expr->left->location);
      testIsSubtype(rightType, builtinTypes->numberType, expr->right->location);

      return builtinTypes->numberType;
    case AstExprBinary::Op::Concat:
      testIsSubtype(leftType, builtinTypes->stringType, expr->left->location);
      testIsSubtype(rightType, builtinTypes->stringType, expr->right->location);

      return builtinTypes->stringType;
    case AstExprBinary::Op::CompareGe:
    case AstExprBinary::Op::CompareGt:
    case AstExprBinary::Op::CompareLe:
    case AstExprBinary::Op::CompareLt: {
      if (normLeft && normLeft->shouldSuppressErrors())
        return builtinTypes->booleanType;

      // if we're comparing against an uninhabited type, it's unobservable that
      // the comparison did not run
      if (normLeft &&
          normalizer.isInhabited(normLeft.get()) == NormalizationResult::False)
        return builtinTypes->booleanType;

      if (normLeft && normLeft->isExactlyNumber()) {
        testIsSubtype(rightType, builtinTypes->numberType,
                      expr->right->location);
        return builtinTypes->booleanType;
      }

      if (normLeft && normLeft->isSubtypeOfString()) {
        testIsSubtype(rightType, builtinTypes->stringType,
                      expr->right->location);
        return builtinTypes->booleanType;
      }

      reportError(GenericError{format("Types '%s' and '%s' cannot be compared "
                                      "with relational operator %s",
                                      toString(leftType).c_str(),
                                      toString(rightType).c_str(),
                                      toString(expr->op).c_str())},
                  expr->location);
      return builtinTypes->errorRecoveryType();
    }

    case AstExprBinary::Op::And:
    case AstExprBinary::Op::Or:
    case AstExprBinary::Op::CompareEq:
    case AstExprBinary::Op::CompareNe:
      // Ugly case: we don't care about this possibility, because a
      // compound assignment will never exist with one of these operators.
      return builtinTypes->anyType;
    default:
      // Unhandled AstExprBinary::Op possibility.
      LUAU_ASSERT(false);
      return builtinTypes->errorRecoveryType();
    }
  }

  void visit(AstExprTypeAssertion *expr) {
    visit(expr->expr, ValueContext::RValue);
    visit(expr->annotation);

    TypeId annotationType = lookupAnnotation(expr->annotation);
    TypeId computedType = lookupType(expr->expr);

    switch (shouldSuppressErrors(NotNull{&normalizer}, computedType)
                .orElse(shouldSuppressErrors(NotNull{&normalizer},
                                             annotationType))) {
    case ErrorSuppression::Suppress:
      return;
    case ErrorSuppression::NormalizationFailed:
      reportError(NormalizationTooComplex{}, expr->location);
      return;
    case ErrorSuppression::DoNotSuppress:
      break;
    }

    switch (normalizer.isInhabited(computedType)) {
    case NormalizationResult::True:
      break;
    case NormalizationResult::False:
      return;
    case NormalizationResult::HitLimits:
      reportError(NormalizationTooComplex{}, expr->location);
      return;
    }

    switch (normalizer.isIntersectionInhabited(computedType, annotationType)) {
    case NormalizationResult::True:
      return;
    case NormalizationResult::False:
      reportError(TypesAreUnrelated{computedType, annotationType},
                  expr->location);
      break;
    case NormalizationResult::HitLimits:
      reportError(NormalizationTooComplex{}, expr->location);
      break;
    }
  }

  void visit(AstExprIfElse *expr) {
    // TODO!
    visit(expr->condition, ValueContext::RValue);
    visit(expr->trueExpr, ValueContext::RValue);
    visit(expr->falseExpr, ValueContext::RValue);
  }

  void visit(AstExprInterpString *interpString) {
    for (AstExpr *expr : interpString->expressions)
      visit(expr, ValueContext::RValue);
  }

  void visit(AstExprError *expr) {
    // TODO!
    for (AstExpr *e : expr->expressions)
      visit(e, ValueContext::RValue);
  }

  /** Extract a TypeId for the first type of the provided pack.
   *
   * Note that this may require modifying some types.  I hope this doesn't cause
   * problems!
   */
  TypeId flattenPack(TypePackId pack) {
    pack = follow(pack);

    if (auto fst = first(pack, /*ignoreHiddenVariadics*/ false))
      return *fst;
    else if (auto ftp = get<FreeTypePack>(pack)) {
      TypeId result = module->internalTypes.addType(FreeType{ftp->scope});
      TypePackId freeTail =
          module->internalTypes.addTypePack(FreeTypePack{ftp->scope});

      TypePack *resultPack = emplaceTypePack<TypePack>(asMutable(pack));
      resultPack->head.assign(1, result);
      resultPack->tail = freeTail;

      return result;
    } else if (get<Unifiable::Error>(pack))
      return builtinTypes->errorRecoveryType();
    else if (finite(pack) && size(pack) == 0)
      return builtinTypes->nilType; // `(f())` where `f()` returns no values is
                                    // coerced into `nil`
    else
      ice->ice("flattenPack got a weird pack!");
  }

  void visitGenerics(AstArray<AstGenericType> generics,
                     AstArray<AstGenericTypePack> genericPacks) {
    DenseHashSet<AstName> seen{AstName{}};

    for (const auto &g : generics) {
      if (seen.contains(g.name))
        reportError(DuplicateGenericParameter{g.name.value}, g.location);
      else
        seen.insert(g.name);

      if (g.defaultValue)
        visit(g.defaultValue);
    }

    for (const auto &g : genericPacks) {
      if (seen.contains(g.name))
        reportError(DuplicateGenericParameter{g.name.value}, g.location);
      else
        seen.insert(g.name);

      if (g.defaultValue)
        visit(g.defaultValue);
    }
  }

  void visit(AstType *ty) {
    TypeId *resolvedTy = module->astResolvedTypes.find(ty);
    if (resolvedTy)
      checkForFamilyInhabitance(follow(*resolvedTy), ty->location);

    if (auto t = ty->as<AstTypeReference>())
      return visit(t);
    else if (auto t = ty->as<AstTypeTable>())
      return visit(t);
    else if (auto t = ty->as<AstTypeFunction>())
      return visit(t);
    else if (auto t = ty->as<AstTypeTypeof>())
      return visit(t);
    else if (auto t = ty->as<AstTypeUnion>())
      return visit(t);
    else if (auto t = ty->as<AstTypeIntersection>())
      return visit(t);
  }

  void visit(AstTypeReference *ty) {
    // No further validation is necessary in this case. The main logic for
    // _luau_print is contained in lookupAnnotation.
    if (FFlag::DebugLuauMagicTypes && ty->name == "_luau_print")
      return;

    for (const AstTypeOrPack &param : ty->parameters) {
      if (param.type)
        visit(param.type);
      else
        visit(param.typePack);
    }

    Scope *scope = findInnermostScope(ty->location);
    LUAU_ASSERT(scope);

    std::optional<TypeFun> alias =
        (ty->prefix)
            ? scope->lookupImportedType(ty->prefix->value, ty->name.value)
            : scope->lookupType(ty->name.value);

    if (alias.has_value()) {
      size_t typesRequired = alias->typeParams.size();
      size_t packsRequired = alias->typePackParams.size();

      bool hasDefaultTypes =
          std::any_of(alias->typeParams.begin(), alias->typeParams.end(),
                      [](auto &&el) { return el.defaultValue.has_value(); });

      bool hasDefaultPacks = std::any_of(
          alias->typePackParams.begin(), alias->typePackParams.end(),
          [](auto &&el) { return el.defaultValue.has_value(); });

      if (!ty->hasParameterList) {
        if ((!alias->typeParams.empty() && !hasDefaultTypes) ||
            (!alias->typePackParams.empty() && !hasDefaultPacks)) {
          reportError(GenericError{"Type parameter list is required"},
                      ty->location);
        }
      }

      size_t typesProvided = 0;
      size_t extraTypes = 0;
      size_t packsProvided = 0;

      for (const AstTypeOrPack &p : ty->parameters) {
        if (p.type) {
          if (packsProvided != 0) {
            reportError(
                GenericError{
                    "Type parameters must come before type pack parameters"},
                ty->location);
            continue;
          }

          if (typesProvided < typesRequired) {
            typesProvided += 1;
          } else {
            extraTypes += 1;
          }
        } else if (p.typePack) {
          std::optional<TypePackId> tp = lookupPackAnnotation(p.typePack);
          if (!tp.has_value())
            continue;

          if (typesProvided < typesRequired && size(*tp) == 1 && finite(*tp) &&
              first(*tp)) {
            typesProvided += 1;
          } else {
            packsProvided += 1;
          }
        }
      }

      if (extraTypes != 0 && packsProvided == 0) {
        // Extra types are only collected into a pack if a pack is expected
        if (packsRequired != 0)
          packsProvided += 1;
        else
          typesProvided += extraTypes;
      }

      for (size_t i = typesProvided; i < typesRequired; ++i) {
        if (alias->typeParams[i].defaultValue) {
          typesProvided += 1;
        }
      }

      for (size_t i = packsProvided; i < packsRequired; ++i) {
        if (alias->typePackParams[i].defaultValue) {
          packsProvided += 1;
        }
      }

      if (extraTypes == 0 && packsProvided + 1 == packsRequired) {
        packsProvided += 1;
      }

      if (typesProvided != typesRequired || packsProvided != packsRequired) {
        reportError(IncorrectGenericParameterCount{
                        /* name */ ty->name.value,
                        /* typeFun */ *alias,
                        /* actualParameters */ typesProvided,
                        /* actualPackParameters */ packsProvided,
                    },
                    ty->location);
      }
    } else {
      if (scope->lookupPack(ty->name.value)) {
        reportError(
            SwappedGenericTypeParameter{
                ty->name.value,
                SwappedGenericTypeParameter::Kind::Type,
            },
            ty->location);
      } else {
        std::string symbol = "";
        if (ty->prefix) {
          symbol += (*(ty->prefix)).value;
          symbol += ".";
        }
        symbol += ty->name.value;

        reportError(UnknownSymbol{symbol, UnknownSymbol::Context::Type},
                    ty->location);
      }
    }
  }

  void visit(AstTypeTable *table) {
    // TODO!

    for (const AstTableProp &prop : table->props)
      visit(prop.type);

    if (table->indexer) {
      visit(table->indexer->indexType);
      visit(table->indexer->resultType);
    }
  }

  void visit(AstTypeFunction *ty) {
    visitGenerics(ty->generics, ty->genericPacks);
    visit(ty->argTypes);
    visit(ty->returnTypes);
  }

  void visit(AstTypeTypeof *ty) { visit(ty->expr, ValueContext::RValue); }

  void visit(AstTypeUnion *ty) {
    // TODO!
    for (AstType *type : ty->types)
      visit(type);
  }

  void visit(AstTypeIntersection *ty) {
    // TODO!
    for (AstType *type : ty->types)
      visit(type);
  }

  void visit(AstTypePack *pack) {
    if (auto p = pack->as<AstTypePackExplicit>())
      return visit(p);
    else if (auto p = pack->as<AstTypePackVariadic>())
      return visit(p);
    else if (auto p = pack->as<AstTypePackGeneric>())
      return visit(p);
  }

  void visit(AstTypePackExplicit *tp) {
    // TODO!
    for (AstType *type : tp->typeList.types)
      visit(type);

    if (tp->typeList.tailType)
      visit(tp->typeList.tailType);
  }

  void visit(AstTypePackVariadic *tp) {
    // TODO!
    visit(tp->variadicType);
  }

  void visit(AstTypePackGeneric *tp) {
    Scope *scope = findInnermostScope(tp->location);
    LUAU_ASSERT(scope);

    std::optional<TypePackId> alias = scope->lookupPack(tp->genericName.value);
    if (!alias.has_value()) {
      if (scope->lookupType(tp->genericName.value)) {
        reportError(
            SwappedGenericTypeParameter{
                tp->genericName.value,
                SwappedGenericTypeParameter::Kind::Pack,
            },
            tp->location);
      } else {
        reportError(
            UnknownSymbol{tp->genericName.value, UnknownSymbol::Context::Type},
            tp->location);
      }
    }
  }

  struct Reasonings {
    // the list of reasons
    std::vector<std::string> reasons;

    // this should be true if _all_ of the reasons have an error suppressing
    // type, and false otherwise.
    bool suppressed;

    std::string toString() {
      // DenseHashSet ordering is entirely undefined, so we want to
      // sort the reasons here to achieve a stable error
      // stringification.
      std::sort(reasons.begin(), reasons.end());
      std::string allReasons;
      bool first = true;
      for (const std::string &reason : reasons) {
        if (first)
          first = false;
        else
          allReasons += "\n\t";

        allReasons += reason;
      }

      return allReasons;
    }
  };

  template <typename TID>
  Reasonings explainReasonings(TID subTy, TID superTy, Location location,
                               const SubtypingResult &r) {
    if (r.reasoning.empty())
      return {};

    std::vector<std::string> reasons;
    bool suppressed = true;
    for (const SubtypingReasoning &reasoning : r.reasoning) {
      if (reasoning.subPath.empty() && reasoning.superPath.empty())
        continue;

      std::optional<TypeOrPack> optSubLeaf =
          traverse(subTy, reasoning.subPath, builtinTypes);
      std::optional<TypeOrPack> optSuperLeaf =
          traverse(superTy, reasoning.superPath, builtinTypes);

      if (!optSubLeaf || !optSuperLeaf)
        ice->ice("Subtyping test returned a reasoning with an invalid path",
                 location);

      const TypeOrPack &subLeaf = *optSubLeaf;
      const TypeOrPack &superLeaf = *optSuperLeaf;

      auto subLeafTy = get<TypeId>(subLeaf);
      auto superLeafTy = get<TypeId>(superLeaf);

      auto subLeafTp = get<TypePackId>(subLeaf);
      auto superLeafTp = get<TypePackId>(superLeaf);

      if (!subLeafTy && !superLeafTy && !subLeafTp && !superLeafTp)
        ice->ice("Subtyping test returned a reasoning where one path ends at a "
                 "type and the other ends at a pack.",
                 location);

      std::string relation = "a subtype of";
      if (reasoning.variance == SubtypingVariance::Invariant)
        relation = "exactly";
      else if (reasoning.variance == SubtypingVariance::Contravariant)
        relation = "a supertype of";

      std::string reason;
      if (reasoning.subPath == reasoning.superPath)
        reason = "at " + toString(reasoning.subPath) + ", " +
                 toString(subLeaf) + " is not " + relation + " " +
                 toString(superLeaf);
      else
        reason = "type " + toString(subTy) +
                 toString(reasoning.subPath, /* prefixDot */ true) + " (" +
                 toString(subLeaf) + ") is not " + relation + " " +
                 toString(superTy) +
                 toString(reasoning.superPath, /* prefixDot */ true) + " (" +
                 toString(superLeaf) + ")";

      reasons.push_back(reason);

      // if we haven't already proved this isn't suppressing, we have to keep
      // checking.
      if (suppressed) {
        if (subLeafTy && superLeafTy)
          suppressed &= isErrorSuppressing(location, *subLeafTy) ||
                        isErrorSuppressing(location, *superLeafTy);
        else
          suppressed &= isErrorSuppressing(location, *subLeafTp) ||
                        isErrorSuppressing(location, *superLeafTp);
      }
    }

    return {std::move(reasons), suppressed};
  }

  void explainError(TypeId subTy, TypeId superTy, Location location,
                    const SubtypingResult &result) {
    switch (shouldSuppressErrors(NotNull{&normalizer}, subTy)
                .orElse(shouldSuppressErrors(NotNull{&normalizer}, superTy))) {
    case ErrorSuppression::Suppress:
      return;
    case ErrorSuppression::NormalizationFailed:
      reportError(NormalizationTooComplex{}, location);
    case ErrorSuppression::DoNotSuppress:
      break;
    }

    Reasonings reasonings = explainReasonings(subTy, superTy, location, result);

    if (!reasonings.suppressed)
      reportError(TypeMismatch{superTy, subTy, reasonings.toString()},
                  location);
  }

  void explainError(TypePackId subTy, TypePackId superTy, Location location,
                    const SubtypingResult &result) {
    switch (shouldSuppressErrors(NotNull{&normalizer}, subTy)
                .orElse(shouldSuppressErrors(NotNull{&normalizer}, superTy))) {
    case ErrorSuppression::Suppress:
      return;
    case ErrorSuppression::NormalizationFailed:
      reportError(NormalizationTooComplex{}, location);
    case ErrorSuppression::DoNotSuppress:
      break;
    }

    Reasonings reasonings = explainReasonings(subTy, superTy, location, result);

    if (!reasonings.suppressed)
      reportError(TypePackMismatch{superTy, subTy, reasonings.toString()},
                  location);
  }

  bool testIsSubtype(TypeId subTy, TypeId superTy, Location location) {
    SubtypingResult r = subtyping->isSubtype(subTy, superTy);

    if (r.normalizationTooComplex)
      reportError(NormalizationTooComplex{}, location);

    if (!r.isSubtype)
      explainError(subTy, superTy, location, r);

    return r.isSubtype;
  }

  bool testIsSubtype(TypePackId subTy, TypePackId superTy, Location location) {
    SubtypingResult r = subtyping->isSubtype(subTy, superTy);

    if (r.normalizationTooComplex)
      reportError(NormalizationTooComplex{}, location);

    if (!r.isSubtype)
      explainError(subTy, superTy, location, r);

    return r.isSubtype;
  }

  void reportError(TypeErrorData data, const Location &location) {
    if (auto utk = get_if<UnknownProperty>(&data))
      diagnoseMissingTableKey(utk, data);

    module->errors.emplace_back(location, module->name, std::move(data));

    if (logger)
      logger->captureTypeCheckError(module->errors.back());
  }

  void reportError(TypeError e) { reportError(std::move(e.data), e.location); }

  void reportErrors(ErrorVec errors) {
    for (TypeError e : errors)
      reportError(std::move(e));
  }

  struct PropertyTypes {
    // a vector of all the types assigned to the given property.
    std::vector<TypeId> typesOfProp;

    // a vector of all the types that are missing the given property.
    std::vector<TypeId> missingProp;

    bool foundOneProp() const { return !typesOfProp.empty(); }

    bool noneMissingProp() const { return missingProp.empty(); }

    bool foundMissingProp() const { return !missingProp.empty(); }
  };

  /* A helper for checkIndexTypeFromType.
   *
   * Returns a pair:
   * * A boolean indicating that at least one of the constituent types
   *     contains the prop, and
   * * A vector of types that do not contain the prop.
   */
  PropertyTypes lookupProp(const NormalizedType *norm, const std::string &prop,
                           ValueContext context, const Location &location,
                           TypeId astIndexExprType,
                           std::vector<TypeError> &errors) {
    std::vector<TypeId> typesOfProp;
    std::vector<TypeId> typesMissingTheProp;

    // this is `false` if we ever hit the resource limits during any of our uses
    // of `fetch`.
    bool normValid = true;

    auto fetch = [&](TypeId ty) {
      NormalizationResult result = normalizer.isInhabited(ty);
      if (result == NormalizationResult::HitLimits)
        normValid = false;
      if (result != NormalizationResult::True)
        return;

      DenseHashSet<TypeId> seen{nullptr};
      PropertyType res = hasIndexTypeFromType(ty, prop, context, location, seen,
                                              astIndexExprType, errors);

      if (res.present == NormalizationResult::HitLimits) {
        normValid = false;
        return;
      }

      if (res.present == NormalizationResult::True && res.result)
        typesOfProp.emplace_back(*res.result);

      if (res.present == NormalizationResult::False)
        typesMissingTheProp.push_back(ty);
    };

    if (normValid)
      fetch(norm->tops);
    if (normValid)
      fetch(norm->booleans);

    if (normValid) {
      for (const auto &[ty, _negations] : norm->classes.classes) {
        fetch(ty);

        if (!normValid)
          break;
      }
    }

    if (normValid)
      fetch(norm->errors);
    if (normValid)
      fetch(norm->nils);
    if (normValid)
      fetch(norm->numbers);
    if (normValid && !norm->strings.isNever())
      fetch(builtinTypes->stringType);
    if (normValid)
      fetch(norm->threads);
    if (normValid)
      fetch(norm->buffers);

    if (normValid) {
      for (TypeId ty : norm->tables) {
        fetch(ty);

        if (!normValid)
          break;
      }
    }

    if (normValid && norm->functions.isTop)
      fetch(builtinTypes->functionType);
    else if (normValid && !norm->functions.isNever()) {
      if (norm->functions.parts.size() == 1)
        fetch(norm->functions.parts.front());
      else {
        std::vector<TypeId> parts;
        parts.insert(parts.end(), norm->functions.parts.begin(),
                     norm->functions.parts.end());
        fetch(
            module->internalTypes.addType(IntersectionType{std::move(parts)}));
      }
    }

    if (normValid) {
      for (const auto &[tyvar, intersect] : norm->tyvars) {
        if (get<NeverType>(intersect->tops)) {
          TypeId ty = normalizer.typeFromNormal(*intersect);
          fetch(module->internalTypes.addType(IntersectionType{{tyvar, ty}}));
        } else
          fetch(follow(tyvar));

        if (!normValid)
          break;
      }
    }

    return {typesOfProp, typesMissingTheProp};
  }

  // If the provided type does not have the named property, report an error.
  void checkIndexTypeFromType(TypeId tableTy, const std::string &prop,
                              ValueContext context, const Location &location,
                              TypeId astIndexExprType) {
    std::shared_ptr<const NormalizedType> norm = normalizer.normalize(tableTy);
    if (!norm) {
      reportError(NormalizationTooComplex{}, location);
      return;
    }

    // if the type is error suppressing, we don't actually have any work left to
    // do.
    if (norm->shouldSuppressErrors())
      return;

    std::vector<TypeError> dummy;
    const auto propTypes = lookupProp(norm.get(), prop, context, location,
                                      astIndexExprType, module->errors);

    if (propTypes.foundMissingProp()) {
      if (propTypes.foundOneProp())
        reportError(MissingUnionProperty{tableTy, propTypes.missingProp, prop},
                    location);
      // For class LValues, we don't want to report an extension error,
      // because classes come into being with full knowledge of their
      // shape. We instead want to report the unknown property error of
      // the `else` branch.
      else if (context == ValueContext::LValue && !get<ClassType>(tableTy)) {
        const auto lvPropTypes =
            lookupProp(norm.get(), prop, ValueContext::RValue, location,
                       astIndexExprType, dummy);
        if (lvPropTypes.foundOneProp() && lvPropTypes.noneMissingProp())
          reportError(
              PropertyAccessViolation{tableTy, prop,
                                      PropertyAccessViolation::CannotWrite},
              location);
        else if (get<PrimitiveType>(tableTy) || get<FunctionType>(tableTy))
          reportError(NotATable{tableTy}, location);
        else
          reportError(
              CannotExtendTable{tableTy, CannotExtendTable::Property, prop},
              location);
      } else if (context == ValueContext::RValue && !get<ClassType>(tableTy)) {
        const auto rvPropTypes =
            lookupProp(norm.get(), prop, ValueContext::LValue, location,
                       astIndexExprType, dummy);
        if (rvPropTypes.foundOneProp() && rvPropTypes.noneMissingProp())
          reportError(
              PropertyAccessViolation{tableTy, prop,
                                      PropertyAccessViolation::CannotRead},
              location);
        else
          reportError(UnknownProperty{tableTy, prop}, location);
      } else
        reportError(UnknownProperty{tableTy, prop}, location);
    }
  }

  struct PropertyType {
    NormalizationResult present;
    std::optional<TypeId> result;
  };

  PropertyType hasIndexTypeFromType(TypeId ty, const std::string &prop,
                                    ValueContext context,
                                    const Location &location,
                                    DenseHashSet<TypeId> &seen,
                                    TypeId astIndexExprType,
                                    std::vector<TypeError> &errors) {
    // If we have already encountered this type, we must assume that some
    // other codepath will do the right thing and signal false if the
    // property is not present.
    if (seen.contains(ty))
      return {NormalizationResult::True, {}};
    seen.insert(ty);

    if (get<ErrorType>(ty) || get<AnyType>(ty) || get<NeverType>(ty))
      return {NormalizationResult::True, {ty}};

    if (isString(ty)) {
      std::optional<TypeId> mtIndex = Luau::findMetatableEntry(
          builtinTypes, errors, builtinTypes->stringType, "__index", location);
      LUAU_ASSERT(mtIndex);
      ty = *mtIndex;
    }

    if (auto tt = getTableType(ty)) {
      if (auto resTy = findTablePropertyRespectingMeta(builtinTypes, errors, ty,
                                                       prop, context, location))
        return {NormalizationResult::True, resTy};

      if (tt->indexer) {
        TypeId indexType = follow(tt->indexer->indexType);
        if (isPrim(indexType, PrimitiveType::String))
          return {NormalizationResult::True, {tt->indexer->indexResultType}};
        // If the indexer looks like { [any] : _} - the prop lookup should be
        // allowed!
        else if (get<AnyType>(indexType) || get<UnknownType>(indexType))
          return {NormalizationResult::True, {tt->indexer->indexResultType}};
      }

      // if we are in a conditional context, we treat the property as present
      // and `unknown` because we may be _refining_ `tableTy` to include that
      // property. we will want to revisit this a bit in the future once luau
      // has support for exact tables since this only applies when inexact.
      return {inConditional(typeContext) ? NormalizationResult::True
                                         : NormalizationResult::False,
              {builtinTypes->unknownType}};
    } else if (const ClassType *cls = get<ClassType>(ty)) {
      // If the property doesn't exist on the class, we consult the indexer
      // We need to check if the type of the index expression foo (x[foo])
      // is compatible with the indexer's indexType
      // Construct the intersection and test inhabitedness!
      if (auto property = lookupClassProp(cls, prop))
        return {NormalizationResult::True, context == ValueContext::LValue
                                               ? property->writeTy
                                               : property->readTy};
      if (cls->indexer) {
        TypeId inhabitatedTestType = module->internalTypes.addType(
            IntersectionType{{cls->indexer->indexType, astIndexExprType}});
        return {normalizer.isInhabited(inhabitatedTestType),
                {cls->indexer->indexResultType}};
      }
      return {NormalizationResult::False, {}};
    } else if (const UnionType *utv = get<UnionType>(ty)) {
      std::vector<TypeId> parts;
      parts.reserve(utv->options.size());

      for (TypeId part : utv) {
        PropertyType result = hasIndexTypeFromType(
            part, prop, context, location, seen, astIndexExprType, errors);

        if (result.present != NormalizationResult::True)
          return {result.present, {}};
        if (result.result)
          parts.emplace_back(*result.result);
      }

      if (parts.size() == 0)
        return {NormalizationResult::False, {}};

      if (parts.size() == 1)
        return {NormalizationResult::True, {parts[0]}};

      TypeId propTy;
      if (context == ValueContext::LValue)
        propTy = module->internalTypes.addType(IntersectionType{parts});
      else
        propTy = module->internalTypes.addType(UnionType{parts});

      return {NormalizationResult::True, propTy};
    } else if (const IntersectionType *itv = get<IntersectionType>(ty)) {
      for (TypeId part : itv) {
        PropertyType result = hasIndexTypeFromType(
            part, prop, context, location, seen, astIndexExprType, errors);
        if (result.present != NormalizationResult::False)
          return result;
      }

      return {NormalizationResult::False, {}};
    } else if (const PrimitiveType *pt = get<PrimitiveType>(ty))
      return {(inConditional(typeContext) && pt->type == PrimitiveType::Table)
                  ? NormalizationResult::True
                  : NormalizationResult::False,
              {ty}};
    else
      return {NormalizationResult::False, {}};
  }

  void diagnoseMissingTableKey(UnknownProperty *utk,
                               TypeErrorData &data) const {
    std::string_view sv(utk->key);
    std::set<Name> candidates;

    auto accumulate = [&](const TableType::Props &props) {
      for (const auto &[name, ty] : props) {
        if (sv != name && equalsLower(sv, name))
          candidates.insert(name);
      }
    };

    if (auto ttv = getTableType(utk->table))
      accumulate(ttv->props);
    else if (auto ctv = get<ClassType>(follow(utk->table))) {
      while (ctv) {
        accumulate(ctv->props);

        if (!ctv->parent)
          break;

        ctv = get<ClassType>(*ctv->parent);
        LUAU_ASSERT(ctv);
      }
    }

    if (!candidates.empty())
      data = TypeErrorData(
          UnknownPropButFoundLikeProp{utk->table, utk->key, candidates});
  }

  bool isErrorSuppressing(Location loc, TypeId ty) {
    switch (shouldSuppressErrors(NotNull{&normalizer}, ty)) {
    case ErrorSuppression::DoNotSuppress:
      return false;
    case ErrorSuppression::Suppress:
      return true;
    case ErrorSuppression::NormalizationFailed:
      reportError(NormalizationTooComplex{}, loc);
      return false;
    };

    LUAU_ASSERT(false);
    return false; // UNREACHABLE
  }

  bool isErrorSuppressing(Location loc1, TypeId ty1, Location loc2,
                          TypeId ty2) {
    return isErrorSuppressing(loc1, ty1) || isErrorSuppressing(loc2, ty2);
  }

  bool isErrorSuppressing(Location loc, TypePackId tp) {
    switch (shouldSuppressErrors(NotNull{&normalizer}, tp)) {
    case ErrorSuppression::DoNotSuppress:
      return false;
    case ErrorSuppression::Suppress:
      return true;
    case ErrorSuppression::NormalizationFailed:
      reportError(NormalizationTooComplex{}, loc);
      return false;
    };

    LUAU_ASSERT(false);
    return false; // UNREACHABLE
  }

  bool isErrorSuppressing(Location loc1, TypePackId tp1, Location loc2,
                          TypePackId tp2) {
    return isErrorSuppressing(loc1, tp1) || isErrorSuppressing(loc2, tp2);
  }
};

void check(NotNull<BuiltinTypes> builtinTypes,
           NotNull<UnifierSharedState> unifierState,
           NotNull<TypeCheckLimits> limits, DcrLogger *logger,
           const SourceModule &sourceModule, Module *module) {
  TypeChecker2 typeChecker{builtinTypes, unifierState,  limits,
                           logger,       &sourceModule, module};

  typeChecker.visit(sourceModule.root);

  unfreeze(module->interfaceTypes);
  copyErrors(module->errors, module->interfaceTypes, builtinTypes);
  freeze(module->interfaceTypes);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/Linter.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/AstQuery.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeInfer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@@@ PACK.LUA : was already included! <math.h>

// @@@ PACK.lua : not found, likely and std header
#include <limits.h>

LUAU_FASTINTVARIABLE(LuauSuggestionDistance, 4)

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

LUAU_FASTFLAG(LuauAttributeSyntax)
LUAU_FASTFLAG(LuauAttribute)
LUAU_FASTFLAG(LuauNativeAttribute)
LUAU_FASTFLAGVARIABLE(LintRedundantNativeAttribute, false)

namespace Luau {

struct LintContext {
  struct Global {
    TypeId type = nullptr;
    std::optional<const char *> deprecated;
  };

  std::vector<LintWarning> result;
  LintOptions options;

  AstStat *root;

  AstName placeholder;
  DenseHashMap<AstName, Global> builtinGlobals;
  ScopePtr scope;
  const Module *module;

  LintContext() : root(nullptr), builtinGlobals(AstName()), module(nullptr) {}

  bool warningEnabled(LintWarning::Code code) {
    return (options.warningMask & (1ull << code)) != 0;
  }

  std::optional<TypeId> getType(AstExpr *expr) {
    if (!module)
      return std::nullopt;

    auto it = module->astTypes.find(expr);
    if (!it)
      return std::nullopt;

    return *it;
  }
};

struct WarningComparator {
  int compare(const Position &lhs, const Position &rhs) const {
    if (lhs.line != rhs.line)
      return lhs.line < rhs.line ? -1 : 1;
    if (lhs.column != rhs.column)
      return lhs.column < rhs.column ? -1 : 1;
    return 0;
  }

  int compare(const Location &lhs, const Location &rhs) const {
    if (int c = compare(lhs.begin, rhs.begin))
      return c;
    if (int c = compare(lhs.end, rhs.end))
      return c;
    return 0;
  }

  bool operator()(const LintWarning &lhs, const LintWarning &rhs) const {
    if (int c = compare(lhs.location, rhs.location))
      return c < 0;

    return lhs.code < rhs.code;
  }
};

LUAU_PRINTF_ATTR(4, 5)
static void emitWarning(LintContext &context, LintWarning::Code code,
                        const Location &location, const char *format, ...) {
  if (!context.warningEnabled(code))
    return;

  va_list args;
  va_start(args, format);
  std::string message = vformat(format, args);
  va_end(args);

  LintWarning warning = {code, location, message};
  context.result.push_back(warning);
}

static bool similar(AstExpr *lhs, AstExpr *rhs) {
  if (lhs->classIndex != rhs->classIndex)
    return false;

#define CASE(T) else if (T *le = lhs->as<T>(), *re = rhs->as<T>(); le && re)

  if (false)
    return false;
  CASE(AstExprGroup) return similar(le->expr, re->expr);
  CASE(AstExprConstantNil) return true;
  CASE(AstExprConstantBool) return le->value == re->value;
  CASE(AstExprConstantNumber) return le->value == re->value;
  CASE(AstExprConstantString)
          return le->value.size == re->value.size &&
      memcmp(le->value.data, re->value.data, le->value.size) == 0;
  CASE(AstExprLocal) return le->local == re->local;
  CASE(AstExprGlobal) return le->name == re->name;
  CASE(AstExprVarargs) return true;
  CASE(AstExprIndexName)
          return le->index == re->index &&
      similar(le->expr, re->expr);
  CASE(AstExprIndexExpr)
      return similar(le->expr, re->expr) && similar(le->index, re->index);
  CASE(AstExprFunction)
  return false; // rarely meaningful in context of this pass, avoids having to
                // process statement nodes
  CASE(AstExprUnary) return le->op == re->op && similar(le->expr, re->expr);
  CASE(AstExprBinary)
          return le->op == re->op &&
      similar(le->left, re->left) && similar(le->right, re->right);
  CASE(AstExprTypeAssertion)
      return le->expr ==
      re->expr; // the type doesn't affect execution semantics, avoids having to
                // process type nodes
  CASE(AstExprError) return false;
  CASE(AstExprCall) {
    if (le->args.size != re->args.size || le->self != re->self)
      return false;

    if (!similar(le->func, re->func))
      return false;

    for (size_t i = 0; i < le->args.size; ++i)
      if (!similar(le->args.data[i], re->args.data[i]))
        return false;

    return true;
  }
  CASE(AstExprTable) {
    if (le->items.size != re->items.size)
      return false;

    for (size_t i = 0; i < le->items.size; ++i) {
      const AstExprTable::Item &li = le->items.data[i];
      const AstExprTable::Item &ri = re->items.data[i];

      if (li.kind != ri.kind)
        return false;

      if (bool(li.key) != bool(ri.key))
        return false;
      else if (li.key && !similar(li.key, ri.key))
        return false;

      if (!similar(li.value, ri.value))
        return false;
    }

    return true;
  }
  CASE(AstExprIfElse)
      return similar(le->condition, re->condition) &&
      similar(le->trueExpr, re->trueExpr) &&
      similar(le->falseExpr, re->falseExpr);
  CASE(AstExprInterpString) {
    if (le->strings.size != re->strings.size)
      return false;

    if (le->expressions.size != re->expressions.size)
      return false;

    for (size_t i = 0; i < le->strings.size; ++i)
      if (le->strings.data[i].size != re->strings.data[i].size ||
          memcmp(le->strings.data[i].data, re->strings.data[i].data,
                 le->strings.data[i].size) != 0)
        return false;

    for (size_t i = 0; i < le->expressions.size; ++i)
      if (!similar(le->expressions.data[i], re->expressions.data[i]))
        return false;

    return true;
  }
  else {
    LUAU_ASSERT(!"Unknown expression type");
    return false;
  }

#undef CASE
}

class LintGlobalLocal : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintGlobalLocal pass;
    pass.context = &context;

    for (auto &global : context.builtinGlobals) {
      Global &g = pass.globals[global.first];

      g.builtin = true;
      g.deprecated = global.second.deprecated;
    }

    context.root->visit(&pass);

    pass.report();
  }

private:
  struct FunctionInfo {
    explicit FunctionInfo(AstExprFunction *ast)
        : ast(ast), dominatedGlobals({}), conditionalExecution(false) {}

    AstExprFunction *ast;
    DenseHashSet<AstName> dominatedGlobals;
    bool conditionalExecution;
  };

  struct Global {
    AstExprGlobal *firstRef = nullptr;

    std::vector<AstExprFunction *> functionRef;

    bool assigned = false;
    bool builtin = false;
    bool definedInModuleScope = false;
    bool definedAsFunction = false;
    bool readBeforeWritten = false;
    std::optional<const char *> deprecated;
  };

  LintContext *context;

  DenseHashMap<AstName, Global> globals;
  std::vector<AstExprGlobal *> globalRefs;
  std::vector<FunctionInfo> functionStack;

  LintGlobalLocal() : globals(AstName()) {}

  void report() {
    for (size_t i = 0; i < globalRefs.size(); ++i) {
      AstExprGlobal *gv = globalRefs[i];
      Global *g = globals.find(gv->name);

      if (!g || (!g->assigned && !g->builtin))
        emitWarning(*context, LintWarning::Code_UnknownGlobal, gv->location,
                    "Unknown global '%s'", gv->name.value);
      else if (g->deprecated) {
        if (const char *replacement = *g->deprecated;
            replacement && strlen(replacement))
          emitWarning(*context, LintWarning::Code_DeprecatedGlobal,
                      gv->location,
                      "Global '%s' is deprecated, use '%s' instead",
                      gv->name.value, replacement);
        else
          emitWarning(*context, LintWarning::Code_DeprecatedGlobal,
                      gv->location, "Global '%s' is deprecated",
                      gv->name.value);
      }
    }

    for (auto &global : globals) {
      const Global &g = global.second;

      if (g.functionRef.size() && g.assigned &&
          g.firstRef->name != context->placeholder) {
        AstExprFunction *top = g.functionRef.back();

        if (top->debugname.value)
          emitWarning(*context, LintWarning::Code_GlobalUsedAsLocal,
                      g.firstRef->location,
                      "Global '%s' is only used in the enclosing function "
                      "'%s'; consider changing it to local",
                      g.firstRef->name.value, top->debugname.value);
        else
          emitWarning(*context, LintWarning::Code_GlobalUsedAsLocal,
                      g.firstRef->location,
                      "Global '%s' is only used in the enclosing function "
                      "defined at line %d; consider changing it to local",
                      g.firstRef->name.value, top->location.begin.line + 1);
      } else if (g.assigned && !g.readBeforeWritten &&
                 !g.definedInModuleScope &&
                 g.firstRef->name != context->placeholder) {
        emitWarning(*context, LintWarning::Code_GlobalUsedAsLocal,
                    g.firstRef->location,
                    "Global '%s' is never read before being written. Consider "
                    "changing it to local",
                    g.firstRef->name.value);
      }
    }
  }

  bool visit(AstExprFunction *node) override {
    functionStack.emplace_back(node);

    node->body->visit(this);

    functionStack.pop_back();

    return false;
  }

  bool visit(AstExprGlobal *node) override {
    if (!functionStack.empty() &&
        !functionStack.back().dominatedGlobals.contains(node->name)) {
      Global &g = globals[node->name];
      g.readBeforeWritten = true;
    }
    trackGlobalRef(node);

    if (node->name == context->placeholder)
      emitWarning(*context, LintWarning::Code_PlaceholderRead, node->location,
                  "Placeholder value '_' is read here; consider using a named "
                  "variable");

    return true;
  }

  bool visit(AstExprLocal *node) override {
    if (node->local->name == context->placeholder)
      emitWarning(*context, LintWarning::Code_PlaceholderRead, node->location,
                  "Placeholder value '_' is read here; consider using a named "
                  "variable");

    return true;
  }

  bool visit(AstStatAssign *node) override {
    for (size_t i = 0; i < node->vars.size; ++i) {
      AstExpr *var = node->vars.data[i];

      if (AstExprGlobal *gv = var->as<AstExprGlobal>()) {
        Global &g = globals[gv->name];

        if (functionStack.empty()) {
          g.definedInModuleScope = true;
        } else {
          if (!functionStack.back().conditionalExecution) {
            functionStack.back().dominatedGlobals.insert(gv->name);
          }
        }

        if (g.builtin)
          emitWarning(*context, LintWarning::Code_BuiltinGlobalWrite,
                      gv->location,
                      "Built-in global '%s' is overwritten here; consider "
                      "using a local or changing the name",
                      gv->name.value);
        else
          g.assigned = true;

        trackGlobalRef(gv);
      } else if (var->is<AstExprLocal>()) {
        // We don't visit locals here because it's a local *write*, and
        // visit(AstExprLocal*) assumes it's a local *read*
      } else {
        var->visit(this);
      }
    }

    for (size_t i = 0; i < node->values.size; ++i)
      node->values.data[i]->visit(this);

    return false;
  }

  bool visit(AstStatFunction *node) override {
    if (AstExprGlobal *gv = node->name->as<AstExprGlobal>()) {
      Global &g = globals[gv->name];

      if (g.builtin)
        emitWarning(*context, LintWarning::Code_BuiltinGlobalWrite,
                    gv->location,
                    "Built-in global '%s' is overwritten here; consider using "
                    "a local or changing the name",
                    gv->name.value);
      else {
        g.assigned = true;
        g.definedAsFunction = true;
        g.definedInModuleScope = functionStack.empty();
      }

      trackGlobalRef(gv);
    }

    return true;
  }

  class HoldConditionalExecution {
  public:
    HoldConditionalExecution(LintGlobalLocal &p) : p(p) {
      if (!p.functionStack.empty() &&
          !p.functionStack.back().conditionalExecution) {
        resetToFalse = true;
        p.functionStack.back().conditionalExecution = true;
      }
    }
    ~HoldConditionalExecution() {
      if (resetToFalse)
        p.functionStack.back().conditionalExecution = false;
    }

  private:
    bool resetToFalse = false;
    LintGlobalLocal &p;
  };

  bool visit(AstStatIf *node) override {
    HoldConditionalExecution ce(*this);
    node->condition->visit(this);
    node->thenbody->visit(this);
    if (node->elsebody)
      node->elsebody->visit(this);

    return false;
  }

  bool visit(AstStatWhile *node) override {
    HoldConditionalExecution ce(*this);
    node->condition->visit(this);
    node->body->visit(this);

    return false;
  }

  bool visit(AstStatRepeat *node) override {
    HoldConditionalExecution ce(*this);
    node->condition->visit(this);
    node->body->visit(this);

    return false;
  }

  bool visit(AstStatFor *node) override {
    HoldConditionalExecution ce(*this);
    node->from->visit(this);
    node->to->visit(this);

    if (node->step)
      node->step->visit(this);

    node->body->visit(this);

    return false;
  }

  bool visit(AstStatForIn *node) override {
    HoldConditionalExecution ce(*this);
    for (AstExpr *expr : node->values)
      expr->visit(this);

    node->body->visit(this);

    return false;
  }

  void trackGlobalRef(AstExprGlobal *node) {
    Global &g = globals[node->name];

    globalRefs.push_back(node);

    if (!g.firstRef) {
      g.firstRef = node;

      // to reduce the cost of tracking we only track this for user globals
      if (!g.builtin) {
        g.functionRef.clear();
        g.functionRef.reserve(functionStack.size());
        for (const FunctionInfo &entry : functionStack) {
          g.functionRef.push_back(entry.ast);
        }
      }
    } else {
      // to reduce the cost of tracking we only track this for user globals
      if (!g.builtin) {
        // we need to find a common prefix between all uses of a global
        size_t prefix = 0;

        while (prefix < g.functionRef.size() && prefix < functionStack.size() &&
               g.functionRef[prefix] == functionStack[prefix].ast)
          prefix++;

        g.functionRef.resize(prefix);
      }
    }
  }
};

class LintSameLineStatement : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintSameLineStatement pass;

    pass.context = &context;
    pass.lastLine = ~0u;

    context.root->visit(&pass);
  }

private:
  LintContext *context;
  unsigned int lastLine;

  bool visit(AstStatBlock *node) override {
    for (size_t i = 1; i < node->body.size; ++i) {
      const Location &last = node->body.data[i - 1]->location;
      const Location &location = node->body.data[i]->location;

      if (location.begin.line != last.end.line)
        continue;

      // We warn once per line with multiple statements
      if (location.begin.line == lastLine)
        continue;

      // There's a common pattern where local variables are computed inside a do
      // block that starts on the same line; we white-list this pattern
      if (node->body.data[i - 1]->is<AstStatLocal>() &&
          node->body.data[i]->is<AstStatBlock>())
        continue;

      // Another common pattern is using multiple statements on the same line
      // with semi-colons on each of them. White-list this pattern too.
      if (node->body.data[i - 1]->hasSemicolon)
        continue;

      emitWarning(*context, LintWarning::Code_SameLineStatement, location,
                  "A new statement is on the same line; add semi-colon on "
                  "previous statement to silence");

      lastLine = location.begin.line;
    }

    return true;
  }
};

class LintMultiLineStatement : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintMultiLineStatement pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  struct Statement {
    Location start;
    unsigned int lastLine;
    bool flagged;
  };

  std::vector<Statement> stack;

  bool visit(AstExpr *node) override {
    Statement &top = stack.back();

    if (!top.flagged) {
      Location location = node->location;

      if (location.begin.line > top.lastLine) {
        top.lastLine = location.begin.line;

        if (location.begin.column <= top.start.begin.column) {
          emitWarning(
              *context, LintWarning::Code_MultiLineStatement, location,
              "Statement spans multiple lines; use indentation to silence");

          top.flagged = true;
        }
      }
    }

    return true;
  }

  bool visit(AstExprTable *node) override {
    (void)node;

    return false;
  }

  bool visit(AstStatRepeat *node) override {
    node->body->visit(this);

    return false;
  }

  bool visit(AstStatBlock *node) override {
    for (size_t i = 0; i < node->body.size; ++i) {
      AstStat *stmt = node->body.data[i];

      Statement s = {stmt->location, stmt->location.begin.line, false};
      stack.push_back(s);

      stmt->visit(this);

      stack.pop_back();
    }

    return false;
  }
};

class LintLocalHygiene : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintLocalHygiene pass;
    pass.context = &context;

    for (auto &global : context.builtinGlobals)
      pass.globals[global.first].builtin = true;

    context.root->visit(&pass);

    pass.report();
  }

private:
  LintContext *context;

  struct Local {
    AstNode *defined = nullptr;
    bool function;
    bool import;
    bool used;
    bool arg;
  };

  struct Global {
    bool used;
    bool builtin;
    AstExprGlobal *firstRef;
  };

  DenseHashMap<AstLocal *, Local> locals;
  DenseHashMap<AstName, AstLocal *> imports;
  DenseHashMap<AstName, Global> globals;

  LintLocalHygiene() : locals(NULL), imports(AstName()), globals(AstName()) {}

  void report() {
    for (auto &l : locals) {
      if (l.second.used)
        reportUsedLocal(l.first, l.second);
      else if (l.second.defined)
        reportUnusedLocal(l.first, l.second);
    }
  }

  void reportUsedLocal(AstLocal *local, const Local &info) {
    if (AstLocal *shadow = local->shadow) {
      // LintDuplicateFunctions will catch this.
      Local *shadowLocal = locals.find(shadow);
      if (context->options.isEnabled(LintWarning::Code_DuplicateFunction) &&
          info.function && shadowLocal && shadowLocal->function)
        return;

      // LintDuplicateLocal will catch this.
      if (context->options.isEnabled(LintWarning::Code_DuplicateLocal) &&
          shadowLocal && shadowLocal->defined == info.defined)
        return;

      // don't warn on inter-function shadowing since it is much more fragile
      // wrt refactoring
      if (shadow->functionDepth == local->functionDepth)
        emitWarning(*context, LintWarning::Code_LocalShadow, local->location,
                    "Variable '%s' shadows previous declaration at line %d",
                    local->name.value, shadow->location.begin.line + 1);
    } else if (Global *global = globals.find(local->name)) {
      if (global->builtin)
        ; // there are many builtins with common names like 'table'; some of
          // them are deprecated as well
      else if (global->firstRef) {
        emitWarning(*context, LintWarning::Code_LocalShadow, local->location,
                    "Variable '%s' shadows a global variable used at line %d",
                    local->name.value,
                    global->firstRef->location.begin.line + 1);
      } else {
        emitWarning(*context, LintWarning::Code_LocalShadow, local->location,
                    "Variable '%s' shadows a global variable",
                    local->name.value);
      }
    }
  }

  void reportUnusedLocal(AstLocal *local, const Local &info) {
    if (local->name.value[0] == '_')
      return;

    if (info.function)
      emitWarning(*context, LintWarning::Code_FunctionUnused, local->location,
                  "Function '%s' is never used; prefix with '_' to silence",
                  local->name.value);
    else if (info.import)
      emitWarning(*context, LintWarning::Code_ImportUnused, local->location,
                  "Import '%s' is never used; prefix with '_' to silence",
                  local->name.value);
    else
      emitWarning(*context, LintWarning::Code_LocalUnused, local->location,
                  "Variable '%s' is never used; prefix with '_' to silence",
                  local->name.value);
  }

  bool isRequireCall(AstExpr *expr) {
    AstExprCall *call = expr->as<AstExprCall>();
    if (!call)
      return false;

    AstExprGlobal *glob = call->func->as<AstExprGlobal>();
    if (!glob)
      return false;

    return glob->name == "require";
  }

  bool visit(AstStatAssign *node) override {
    for (AstExpr *var : node->vars) {
      // We don't visit locals here because it's a local *write*, and
      // visit(AstExprLocal*) assumes it's a local *read*
      if (!var->is<AstExprLocal>())
        var->visit(this);
    }

    for (AstExpr *value : node->values)
      value->visit(this);

    return false;
  }

  bool visit(AstStatLocal *node) override {
    if (node->vars.size == 1 && node->values.size == 1) {
      Local &l = locals[node->vars.data[0]];

      l.defined = node;
      l.import = isRequireCall(node->values.data[0]);

      if (l.import)
        imports[node->vars.data[0]->name] = node->vars.data[0];
    } else {
      for (size_t i = 0; i < node->vars.size; ++i) {
        Local &l = locals[node->vars.data[i]];

        l.defined = node;
      }
    }

    return true;
  }

  bool visit(AstStatLocalFunction *node) override {
    Local &l = locals[node->name];

    l.defined = node;
    l.function = true;

    return true;
  }

  bool visit(AstExprLocal *node) override {
    Local &l = locals[node->local];

    l.used = true;

    return true;
  }

  bool visit(AstExprGlobal *node) override {
    Global &global = globals[node->name];

    global.used = true;
    if (!global.firstRef)
      global.firstRef = node;

    return true;
  }

  bool visit(AstType *node) override { return true; }

  bool visit(AstTypeReference *node) override {
    if (!node->prefix)
      return true;

    if (!imports.contains(*node->prefix))
      return true;

    AstLocal *astLocal = imports[*node->prefix];
    Local &local = locals[astLocal];
    LUAU_ASSERT(local.import);
    local.used = true;

    return true;
  }

  bool visit(AstExprFunction *node) override {
    if (node->self)
      locals[node->self].arg = true;

    for (size_t i = 0; i < node->args.size; ++i)
      locals[node->args.data[i]].arg = true;

    return true;
  }
};

class LintUnusedFunction : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintUnusedFunction pass;
    pass.context = &context;

    context.root->visit(&pass);

    pass.report();
  }

private:
  LintContext *context;

  struct Global {
    Location location;
    bool function;
    bool used;
  };

  DenseHashMap<AstName, Global> globals;

  LintUnusedFunction() : globals(AstName()) {}

  void report() {
    for (auto &g : globals) {
      if (g.second.function && !g.second.used && g.first.value[0] != '_')
        emitWarning(*context, LintWarning::Code_FunctionUnused,
                    g.second.location,
                    "Function '%s' is never used; prefix with '_' to silence",
                    g.first.value);
    }
  }

  bool visit(AstStatFunction *node) override {
    if (AstExprGlobal *expr = node->name->as<AstExprGlobal>()) {
      Global &g = globals[expr->name];

      g.function = true;
      g.location = expr->location;

      node->func->visit(this);

      return false;
    }

    return true;
  }

  bool visit(AstExprGlobal *node) override {
    Global &g = globals[node->name];

    g.used = true;

    return true;
  }
};

class LintUnreachableCode : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintUnreachableCode pass;
    pass.context = &context;

    pass.analyze(context.root);
    context.root->visit(&pass);
  }

private:
  LintContext *context;

  // Note: this enum is order-sensitive!
  // The order is in the "severity" of the termination and affects merging of
  // status codes from different branches For example, if one branch breaks and
  // one returns, the merged result is "break"
  enum Status {
    Unknown,
    Continue,
    Break,
    Return,
    Error,
  };

  const char *getReason(Status status) {
    switch (status) {
    case Continue:
      return "continue";

    case Break:
      return "break";

    case Return:
      return "return";

    case Error:
      return "error";

    default:
      return "unknown";
    }
  }

  Status analyze(AstStat *node) {
    if (AstStatBlock *stat = node->as<AstStatBlock>()) {
      for (size_t i = 0; i < stat->body.size; ++i) {
        AstStat *si = stat->body.data[i];
        Status step = analyze(si);

        if (step != Unknown) {
          if (i + 1 == stat->body.size)
            return step;

          AstStat *next = stat->body.data[i + 1];

          // silence the warning for common pattern of Error (coming from
          // error()) + Return
          if (step == Error && si->is<AstStatExpr>() &&
              next->is<AstStatReturn>() && i + 2 == stat->body.size)
            return Error;

          emitWarning(*context, LintWarning::Code_UnreachableCode,
                      next->location,
                      "Unreachable code (previous statement always %ss)",
                      getReason(step));
          return step;
        }
      }

      return Unknown;
    } else if (AstStatIf *stat = node->as<AstStatIf>()) {
      Status ifs = analyze(stat->thenbody);
      Status elses = stat->elsebody ? analyze(stat->elsebody) : Unknown;

      return std::min(ifs, elses);
    } else if (AstStatWhile *stat = node->as<AstStatWhile>()) {
      analyze(stat->body);

      return Unknown;
    } else if (AstStatRepeat *stat = node->as<AstStatRepeat>()) {
      analyze(stat->body);

      return Unknown;
    } else if (node->is<AstStatBreak>()) {
      return Break;
    } else if (node->is<AstStatContinue>()) {
      return Continue;
    } else if (node->is<AstStatReturn>()) {
      return Return;
    } else if (AstStatExpr *stat = node->as<AstStatExpr>()) {
      if (AstExprCall *call = stat->expr->as<AstExprCall>())
        if (doesCallError(call))
          return Error;

      return Unknown;
    } else if (AstStatFor *stat = node->as<AstStatFor>()) {
      analyze(stat->body);

      return Unknown;
    } else if (AstStatForIn *stat = node->as<AstStatForIn>()) {
      analyze(stat->body);

      return Unknown;
    } else {
      return Unknown;
    }
  }

  bool visit(AstExprFunction *node) override {
    analyze(node->body);

    return true;
  }
};

class LintUnknownType : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintUnknownType pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  enum TypeKind {
    Kind_Unknown,
    Kind_Primitive, // primitive type supported by VM - boolean/userdata/etc. No
                    // differentiation between types of userdata.
    Kind_Vector,    // 'vector' but only used when type is used
    Kind_Userdata,  // custom userdata type
  };

  TypeKind getTypeKind(const std::string &name) {
    if (name == "nil" || name == "boolean" || name == "userdata" ||
        name == "number" || name == "string" || name == "table" ||
        name == "function" || name == "thread" || name == "buffer")
      return Kind_Primitive;

    if (name == "vector")
      return Kind_Vector;

    if (std::optional<TypeFun> maybeTy = context->scope->lookupType(name))
      return Kind_Userdata;

    return Kind_Unknown;
  }

  void validateType(AstExprConstantString *expr,
                    std::initializer_list<TypeKind> expected,
                    const char *expectedString) {
    std::string name(expr->value.data, expr->value.size);
    TypeKind kind = getTypeKind(name);

    if (kind == Kind_Unknown) {
      emitWarning(*context, LintWarning::Code_UnknownType, expr->location,
                  "Unknown type '%s'", name.c_str());
      return;
    }

    for (TypeKind ek : expected) {
      if (kind == ek)
        return;
    }

    emitWarning(*context, LintWarning::Code_UnknownType, expr->location,
                "Unknown type '%s' (expected %s)", name.c_str(),
                expectedString);
  }

  bool visit(AstExprBinary *node) override {
    if (node->op == AstExprBinary::CompareNe ||
        node->op == AstExprBinary::CompareEq) {
      AstExpr *lhs = node->left;
      AstExpr *rhs = node->right;

      if (!rhs->is<AstExprConstantString>())
        std::swap(lhs, rhs);

      AstExprCall *call = lhs->as<AstExprCall>();
      AstExprConstantString *arg = rhs->as<AstExprConstantString>();

      if (call && arg) {
        AstExprGlobal *g = call->func->as<AstExprGlobal>();

        if (g && g->name == "type") {
          validateType(arg, {Kind_Primitive, Kind_Vector}, "primitive type");
        } else if (g && g->name == "typeof") {
          validateType(arg, {Kind_Primitive, Kind_Userdata},
                       "primitive or userdata type");
        }
      }
    }

    return true;
  }
};

class LintForRange : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintForRange pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  double getLoopEnd(double from, double to) { return from + floor(to - from); }

  bool visit(AstStatFor *node) override {
    // note: we silence all warnings below if *any* step is specified, assuming
    // that the user knows best
    if (!node->step) {
      AstExprConstantNumber *fc = node->from->as<AstExprConstantNumber>();
      AstExprUnary *fu = node->from->as<AstExprUnary>();
      AstExprConstantNumber *tc = node->to->as<AstExprConstantNumber>();
      AstExprUnary *tu = node->to->as<AstExprUnary>();

      Location rangeLocation(node->from->location, node->to->location);

      // for i=#t,1 do
      if (fu && fu->op == AstExprUnary::Len && tc && tc->value == 1.0)
        emitWarning(*context, LintWarning::Code_ForRange, rangeLocation,
                    "For loop should iterate backwards; did you forget to "
                    "specify -1 as step?");
      // for i=8,1 do
      else if (fc && tc && fc->value > tc->value)
        emitWarning(*context, LintWarning::Code_ForRange, rangeLocation,
                    "For loop should iterate backwards; did you forget to "
                    "specify -1 as step?");
      // for i=1,8.75 do
      else if (fc && tc && getLoopEnd(fc->value, tc->value) != tc->value)
        emitWarning(*context, LintWarning::Code_ForRange, rangeLocation,
                    "For loop ends at %g instead of %g; did you forget to "
                    "specify step?",
                    getLoopEnd(fc->value, tc->value), tc->value);
      // for i=0,#t do
      else if (fc && tu && fc->value == 0.0 && tu->op == AstExprUnary::Len)
        emitWarning(*context, LintWarning::Code_ForRange, rangeLocation,
                    "For loop starts at 0, but arrays start at 1");
      // for i=#t,0 do
      else if (fu && fu->op == AstExprUnary::Len && tc && tc->value == 0.0)
        emitWarning(
            *context, LintWarning::Code_ForRange, rangeLocation,
            "For loop should iterate backwards; did you forget to specify -1 "
            "as step? Also consider changing 0 to 1 since arrays start at 1");
    }

    return true;
  }
};

class LintUnbalancedAssignment : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintUnbalancedAssignment pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  void assign(size_t vars, const AstArray<AstExpr *> &values,
              const Location &location) {
    if (vars != values.size && values.size > 0) {
      AstExpr *last = values.data[values.size - 1];

      if (vars < values.size)
        emitWarning(
            *context, LintWarning::Code_UnbalancedAssignment, location,
            "Assigning %d values to %d variables leaves some values unused",
            int(values.size), int(vars));
      else if (last->is<AstExprCall>() || last->is<AstExprVarargs>())
        ; // we don't know how many values the last expression returns
      else if (last->is<AstExprConstantNil>())
        ; // last expression is nil which explicitly silences the nil-init
          // warning
      else
        emitWarning(*context, LintWarning::Code_UnbalancedAssignment, location,
                    "Assigning %d values to %d variables initializes extra "
                    "variables with nil; add 'nil' to value list to silence",
                    int(values.size), int(vars));
    }
  }

  bool visit(AstStatLocal *node) override {
    assign(node->vars.size, node->values, node->location);

    return true;
  }

  bool visit(AstStatAssign *node) override {
    assign(node->vars.size, node->values, node->location);

    return true;
  }
};

class LintImplicitReturn : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintImplicitReturn pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  Location getEndLocation(const AstStat *node) {
    Location loc = node->location;

    if (node->is<AstStatExpr>() || node->is<AstStatAssign>() ||
        node->is<AstStatLocal>())
      return loc;

    if (loc.begin.line == loc.end.line)
      return loc;

    // assume that we're in context of a statement that has an "end" block
    return Location(
        Position(loc.end.line, std::max(0, int(loc.end.column) - 3)), loc.end);
  }

  AstStatReturn *getValueReturn(AstStat *node) {
    struct Visitor : AstVisitor {
      AstStatReturn *result = nullptr;

      bool visit(AstExpr *node) override {
        (void)node;
        return false;
      }

      bool visit(AstStatReturn *node) override {
        if (!result && node->list.size > 0)
          result = node;

        return false;
      }
    };

    Visitor visitor;
    node->visit(&visitor);
    return visitor.result;
  }

  bool visit(AstExprFunction *node) override {
    const AstStat *bodyf = getFallthrough(node->body);
    AstStat *vret = getValueReturn(node->body);

    if (bodyf && vret) {
      Location location = getEndLocation(bodyf);

      if (node->debugname.value)
        emitWarning(
            *context, LintWarning::Code_ImplicitReturn, location,
            "Function '%s' can implicitly return no values even though there's "
            "an explicit return at line %d; add explicit return to silence",
            node->debugname.value, vret->location.begin.line + 1);
      else
        emitWarning(
            *context, LintWarning::Code_ImplicitReturn, location,
            "Function can implicitly return no values even though there's an "
            "explicit return at line %d; add explicit return to silence",
            vret->location.begin.line + 1);
    }

    return true;
  }
};

class LintFormatString : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintFormatString pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

  static void fuzz(const char *data, size_t size) {
    LintContext context;

    LintFormatString pass;
    pass.context = &context;

    pass.checkStringFormat(data, size);
    pass.checkStringPack(data, size, false);
    pass.checkStringMatch(data, size);
    pass.checkStringReplace(data, size, -1);
    pass.checkDateFormat(data, size);
  }

private:
  LintContext *context;

  static inline bool isAlpha(char ch) {
    // use or trick to convert to lower case and unsigned comparison to do range
    // check
    return unsigned((ch | ' ') - 'a') < 26;
  }

  static inline bool isDigit(char ch) {
    // use unsigned comparison to do range check for performance
    return unsigned(ch - '0') < 10;
  }

  const char *checkStringFormat(const char *data, size_t size) {
    const char *flags = "-+ #0";
    const char *options = "cdiouxXeEfgGqs*";

    for (size_t i = 0; i < size; ++i) {
      if (data[i] == '%') {
        i++;

        // escaped % doesn't allow for flags/etc.
        if (i < size && data[i] == '%')
          continue;

        // skip flags
        while (i < size && strchr(flags, data[i]))
          i++;

        // skip width (up to two digits)
        if (i < size && isDigit(data[i]))
          i++;
        if (i < size && isDigit(data[i]))
          i++;

        // skip precision
        if (i < size && data[i] == '.') {
          i++;

          // up to two digits
          if (i < size && isDigit(data[i]))
            i++;
          if (i < size && isDigit(data[i]))
            i++;
        }

        if (i == size)
          return "unfinished format specifier";

        if (!strchr(options, data[i]))
          return "invalid format specifier: must be a string format specifier "
                 "or %";
      }
    }

    return nullptr;
  }

  const char *checkStringPack(const char *data, size_t size, bool fixed) {
    const char *options = "<>=!bBhHlLjJTiIfdnczsxX ";
    const char *unsized = "<>=!zX ";

    for (size_t i = 0; i < size; ++i) {
      if (!strchr(options, data[i]))
        return "unexpected character; must be a pack specifier or space";

      if (data[i] == 'c' && (i + 1 == size || !isDigit(data[i + 1])))
        return "fixed-sized string format must specify the size";

      if (data[i] == 'X' && (i + 1 == size || strchr(unsized, data[i + 1])))
        return "X must be followed by a size specifier";

      if (fixed && (data[i] == 'z' || data[i] == 's'))
        return "pack specifier must be fixed-size";

      if ((data[i] == '!' || data[i] == 'i' || data[i] == 'I' ||
           data[i] == 'c' || data[i] == 's') &&
          i + 1 < size && isDigit(data[i + 1])) {
        bool isc = data[i] == 'c';

        unsigned int v = 0;
        while (i + 1 < size && isDigit(data[i + 1]) &&
               v <= (INT_MAX - 9) / 10) {
          v = v * 10 + (data[i + 1] - '0');
          i++;
        }

        if (i + 1 < size && isDigit(data[i + 1]))
          return "size specifier is too large";

        if (!isc && (v == 0 || v > 16))
          return "integer size must be in range [1,16]";
      }
    }

    return nullptr;
  }

  const char *checkStringMatchSet(const char *data, size_t size,
                                  const char *magic, const char *classes) {
    for (size_t i = 0; i < size; ++i) {
      if (data[i] == '%') {
        i++;

        if (i == size)
          return "unfinished character class";

        if (isDigit(data[i])) {
          return "sets can not contain capture references";
        } else if (isAlpha(data[i])) {
          // lower case lookup - upper case for every character class is defined
          // as its inverse
          if (!strchr(classes, data[i] | ' '))
            return "invalid character class, must refer to a defined class or "
                   "its inverse";
        } else {
          // technically % can escape any non-alphanumeric character but this is
          // error-prone
          if (!strchr(magic, data[i]))
            return "expected a magic character after %";
        }

        if (i + 1 < size && data[i + 1] == '-')
          return "character range can't include character sets";
      } else if (data[i] == '-') {
        if (i + 1 < size && data[i + 1] == '%')
          return "character range can't include character sets";
      }
    }

    return nullptr;
  }

  const char *checkStringMatch(const char *data, size_t size,
                               int *outCaptures = nullptr) {
    const char *magic = "^$()%.[]*+-?)";
    const char *classes = "acdglpsuwxz";

    std::vector<int> openCaptures;
    int totalCaptures = 0;

    for (size_t i = 0; i < size; ++i) {
      if (data[i] == '%') {
        i++;

        if (i == size)
          return "unfinished character class";

        if (isDigit(data[i])) {
          if (data[i] == '0')
            return "invalid capture reference, must be 1-9";

          int captureIndex = data[i] - '0';

          if (captureIndex > totalCaptures)
            return "invalid capture reference, must refer to a valid capture";

          for (int open : openCaptures)
            if (open == captureIndex)
              return "invalid capture reference, must refer to a closed "
                     "capture";
        } else if (isAlpha(data[i])) {
          if (data[i] == 'b') {
            if (i + 2 >= size)
              return "missing brace characters for balanced match";

            i += 2;
          } else if (data[i] == 'f') {
            if (i + 1 >= size || data[i + 1] != '[')
              return "missing set after a frontier pattern";

            // we can parse the set with the regular logic
          } else {
            // lower case lookup - upper case for every character class is
            // defined as its inverse
            if (!strchr(classes, data[i] | ' '))
              return "invalid character class, must refer to a defined class "
                     "or its inverse";
          }
        } else {
          // technically % can escape any non-alphanumeric character but this is
          // error-prone
          if (!strchr(magic, data[i]))
            return "expected a magic character after %";
        }
      } else if (data[i] == '[') {
        size_t j = i + 1;

        // empty patterns don't exist as per grammar rules, so we skip leading ^
        // and ]
        if (j < size && data[j] == '^')
          j++;

        if (j < size && data[j] == ']')
          j++;

        // scan for the end of the pattern
        while (j < size && data[j] != ']') {
          // % escapes the next character
          if (j + 1 < size && data[j] == '%')
            j++;

          j++;
        }

        if (j == size)
          return "expected ] at the end of the string to close a set";

        if (const char *error =
                checkStringMatchSet(data + i + 1, j - i - 1, magic, classes))
          return error;

        LUAU_ASSERT(data[j] == ']');
        i = j;
      } else if (data[i] == '(') {
        totalCaptures++;
        openCaptures.push_back(totalCaptures);
      } else if (data[i] == ')') {
        if (openCaptures.empty())
          return "unexpected ) without a matching (";
        openCaptures.pop_back();
      }
    }

    if (!openCaptures.empty())
      return "expected ) at the end of the string to close a capture";

    if (outCaptures)
      *outCaptures = totalCaptures;

    return nullptr;
  }

  const char *checkStringReplace(const char *data, size_t size, int captures) {
    for (size_t i = 0; i < size; ++i) {
      if (data[i] == '%') {
        i++;

        if (i == size)
          return "unfinished replacement";

        if (data[i] != '%' && !isDigit(data[i]))
          return "unexpected replacement character; must be a digit or %";

        if (isDigit(data[i]) && captures >= 0 && data[i] - '0' > captures)
          return "invalid capture index, must refer to pattern capture";
      }
    }

    return nullptr;
  }

  const char *checkDateFormat(const char *data, size_t size) {
    const char *options = "aAbBcdHIjmMpSUwWxXyYzZ";

    for (size_t i = 0; i < size; ++i) {
      if (data[i] == '%') {
        i++;

        if (i == size)
          return "unfinished replacement";

        if (data[i] != '%' && !strchr(options, data[i]))
          return "unexpected replacement character; must be a date format "
                 "specifier or %";
      }

      if (data[i] == 0)
        return "date format can not contain null characters";
    }

    return nullptr;
  }

  void matchStringCall(AstName name, AstExpr *self, AstArray<AstExpr *> args) {
    if (name == "format") {
      if (AstExprConstantString *fmt = self->as<AstExprConstantString>())
        if (const char *error =
                checkStringFormat(fmt->value.data, fmt->value.size))
          emitWarning(*context, LintWarning::Code_FormatString, fmt->location,
                      "Invalid format string: %s", error);
    } else if (name == "pack" || name == "packsize" || name == "unpack") {
      if (AstExprConstantString *fmt = self->as<AstExprConstantString>())
        if (const char *error = checkStringPack(
                fmt->value.data, fmt->value.size, name == "packsize"))
          emitWarning(*context, LintWarning::Code_FormatString, fmt->location,
                      "Invalid pack format: %s", error);
    } else if ((name == "match" || name == "gmatch") && args.size > 0) {
      if (AstExprConstantString *pat =
              args.data[0]->as<AstExprConstantString>())
        if (const char *error =
                checkStringMatch(pat->value.data, pat->value.size))
          emitWarning(*context, LintWarning::Code_FormatString, pat->location,
                      "Invalid match pattern: %s", error);
    } else if (name == "find" && args.size > 0 && args.size <= 2) {
      if (AstExprConstantString *pat =
              args.data[0]->as<AstExprConstantString>())
        if (const char *error =
                checkStringMatch(pat->value.data, pat->value.size))
          emitWarning(*context, LintWarning::Code_FormatString, pat->location,
                      "Invalid match pattern: %s", error);
    } else if (name == "find" && args.size >= 3) {
      AstExprConstantBool *mode = args.data[2]->as<AstExprConstantBool>();

      // find(_, _, _, true) is a raw string find, not a pattern match
      if (mode && !mode->value)
        if (AstExprConstantString *pat =
                args.data[0]->as<AstExprConstantString>())
          if (const char *error =
                  checkStringMatch(pat->value.data, pat->value.size))
            emitWarning(*context, LintWarning::Code_FormatString, pat->location,
                        "Invalid match pattern: %s", error);
    } else if (name == "gsub" && args.size > 1) {
      int captures = -1;

      if (AstExprConstantString *pat =
              args.data[0]->as<AstExprConstantString>())
        if (const char *error =
                checkStringMatch(pat->value.data, pat->value.size, &captures))
          emitWarning(*context, LintWarning::Code_FormatString, pat->location,
                      "Invalid match pattern: %s", error);

      if (AstExprConstantString *rep =
              args.data[1]->as<AstExprConstantString>())
        if (const char *error =
                checkStringReplace(rep->value.data, rep->value.size, captures))
          emitWarning(*context, LintWarning::Code_FormatString, rep->location,
                      "Invalid match replacement: %s", error);
    }
  }

  void matchCall(AstExprCall *node) {
    AstExprIndexName *func = node->func->as<AstExprIndexName>();
    if (!func)
      return;

    if (node->self) {
      AstExprGroup *group = func->expr->as<AstExprGroup>();
      AstExpr *self = group ? group->expr : func->expr;

      if (self->is<AstExprConstantString>())
        matchStringCall(func->index, self, node->args);
      else if (std::optional<TypeId> type = context->getType(self))
        if (isString(*type))
          matchStringCall(func->index, self, node->args);
      return;
    }

    AstExprGlobal *lib = func->expr->as<AstExprGlobal>();
    if (!lib)
      return;

    if (lib->name == "string") {
      if (node->args.size > 0) {
        AstArray<AstExpr *> rest = {node->args.data + 1, node->args.size - 1};

        matchStringCall(func->index, node->args.data[0], rest);
      }
    } else if (lib->name == "os") {
      if (func->index == "date" && node->args.size > 0) {
        if (AstExprConstantString *fmt =
                node->args.data[0]->as<AstExprConstantString>())
          if (const char *error =
                  checkDateFormat(fmt->value.data, fmt->value.size))
            emitWarning(*context, LintWarning::Code_FormatString, fmt->location,
                        "Invalid date format: %s", error);
      }
    }
  }

  bool visit(AstExprCall *node) override {
    matchCall(node);
    return true;
  }
};

class LintTableLiteral : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintTableLiteral pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  bool visit(AstExprTable *node) override {
    int count = 0;

    for (const AstExprTable::Item &item : node->items)
      if (item.kind == AstExprTable::Item::List)
        count++;

    DenseHashMap<AstArray<char> *, int, AstArrayPredicate, AstArrayPredicate>
        names(nullptr);
    DenseHashMap<int, int> indices(-1);

    for (const AstExprTable::Item &item : node->items) {
      if (!item.key)
        continue;

      if (AstExprConstantString *expr = item.key->as<AstExprConstantString>()) {
        int &line = names[&expr->value];

        if (line)
          emitWarning(*context, LintWarning::Code_TableLiteral, expr->location,
                      "Table field '%.*s' is a duplicate; previously defined "
                      "at line %d",
                      int(expr->value.size), expr->value.data, line);
        else
          line = expr->location.begin.line + 1;
      } else if (AstExprConstantNumber *expr =
                     item.key->as<AstExprConstantNumber>()) {
        if (expr->value >= 1 && expr->value <= double(count) &&
            double(int(expr->value)) == expr->value)
          emitWarning(*context, LintWarning::Code_TableLiteral, expr->location,
                      "Table index %d is a duplicate; previously defined as a "
                      "list entry",
                      int(expr->value));
        else if (expr->value >= 0 && expr->value <= double(INT_MAX) &&
                 double(int(expr->value)) == expr->value) {
          int &line = indices[int(expr->value)];

          if (line)
            emitWarning(
                *context, LintWarning::Code_TableLiteral, expr->location,
                "Table index %d is a duplicate; previously defined at line %d",
                int(expr->value), line);
          else
            line = expr->location.begin.line + 1;
        }
      }
    }

    return true;
  }

  bool visit(AstType *node) override { return true; }

  bool visit(AstTypeTable *node) override {
    if (FFlag::DebugLuauDeferredConstraintResolution) {
      struct Rec {
        AstTableAccess access;
        Location location;
      };
      DenseHashMap<AstName, Rec> names(AstName{});

      for (const AstTableProp &item : node->props) {
        Rec *rec = names.find(item.name);
        if (!rec) {
          names[item.name] = Rec{item.access, item.location};
          continue;
        }

        if (int(rec->access) & int(item.access)) {
          if (rec->access == item.access)
            emitWarning(*context, LintWarning::Code_TableLiteral, item.location,
                        "Table type field '%s' is a duplicate; previously "
                        "defined at line %d",
                        item.name.value, rec->location.begin.line + 1);
          else if (rec->access == AstTableAccess::ReadWrite)
            emitWarning(*context, LintWarning::Code_TableLiteral, item.location,
                        "Table type field '%s' is already read-write; "
                        "previously defined at line %d",
                        item.name.value, rec->location.begin.line + 1);
          else if (rec->access == AstTableAccess::Read)
            emitWarning(*context, LintWarning::Code_TableLiteral, rec->location,
                        "Table type field '%s' already has a read type defined "
                        "at line %d",
                        item.name.value, rec->location.begin.line + 1);
          else if (rec->access == AstTableAccess::Write)
            emitWarning(*context, LintWarning::Code_TableLiteral, rec->location,
                        "Table type field '%s' already has a write type "
                        "defined at line %d",
                        item.name.value, rec->location.begin.line + 1);
          else
            LUAU_ASSERT(!"Unreachable");
        } else
          rec->access = AstTableAccess(int(rec->access) | int(item.access));
      }

      return true;
    }

    DenseHashMap<AstName, int> names(AstName{});

    for (const AstTableProp &item : node->props) {
      int &line = names[item.name];

      if (line)
        emitWarning(*context, LintWarning::Code_TableLiteral, item.location,
                    "Table type field '%s' is a duplicate; previously defined "
                    "at line %d",
                    item.name.value, line);
      else
        line = item.location.begin.line + 1;
    }

    return true;
  }

  struct AstArrayPredicate {
    size_t operator()(const AstArray<char> *value) const {
      return hashRange(value->data, value->size);
    }

    bool operator()(const AstArray<char> *lhs,
                    const AstArray<char> *rhs) const {
      return (lhs && rhs) ? lhs->size == rhs->size &&
                                memcmp(lhs->data, rhs->data, lhs->size) == 0
                          : lhs == rhs;
    }
  };
};

class LintUninitializedLocal : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintUninitializedLocal pass;
    pass.context = &context;

    context.root->visit(&pass);

    pass.report();
  }

private:
  struct Local {
    bool defined;
    bool initialized;
    bool assigned;
    AstExprLocal *firstUse;
  };

  LintContext *context;
  DenseHashMap<AstLocal *, Local> locals;

  LintUninitializedLocal() : locals(NULL) {}

  void report() {
    for (auto &lp : locals) {
      AstLocal *local = lp.first;
      const Local &l = lp.second;

      if (l.defined && !l.initialized && !l.assigned && l.firstUse) {
        emitWarning(*context, LintWarning::Code_UninitializedLocal,
                    l.firstUse->location,
                    "Variable '%s' defined at line %d is never initialized or "
                    "assigned; initialize with 'nil' to silence",
                    local->name.value, local->location.begin.line + 1);
      }
    }
  }

  bool visit(AstStatLocal *node) override {
    AstExpr *last =
        node->values.size ? node->values.data[node->values.size - 1] : nullptr;
    bool vararg =
        last && (last->is<AstExprVarargs>() || last->is<AstExprCall>());

    for (size_t i = 0; i < node->vars.size; ++i) {
      Local &l = locals[node->vars.data[i]];

      l.defined = true;
      l.initialized = vararg || i < node->values.size;
    }

    return true;
  }

  bool visit(AstStatAssign *node) override {
    for (size_t i = 0; i < node->vars.size; ++i)
      visitAssign(node->vars.data[i]);

    for (size_t i = 0; i < node->values.size; ++i)
      node->values.data[i]->visit(this);

    return false;
  }

  bool visit(AstStatFunction *node) override {
    visitAssign(node->name);
    node->func->visit(this);

    return false;
  }

  bool visit(AstExprLocal *node) override {
    Local &l = locals[node->local];

    if (!l.firstUse)
      l.firstUse = node;

    return false;
  }

  void visitAssign(AstExpr *var) {
    if (AstExprLocal *lv = var->as<AstExprLocal>()) {
      Local &l = locals[lv->local];

      l.assigned = true;
    } else {
      var->visit(this);
    }
  }
};

class LintDuplicateFunction : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintDuplicateFunction pass{&context};
    context.root->visit(&pass);
  }

private:
  LintContext *context;
  DenseHashMap<std::string, Location> defns;

  LintDuplicateFunction(LintContext *context) : context(context), defns("") {}

  bool visit(AstStatBlock *block) override {
    defns.clear();

    for (AstStat *stat : block->body) {
      if (AstStatFunction *func = stat->as<AstStatFunction>())
        trackFunction(func->name->location, buildName(func->name));
      else if (AstStatLocalFunction *func = stat->as<AstStatLocalFunction>())
        trackFunction(func->name->location, func->name->name.value);
    }

    return true;
  }

  void trackFunction(Location location, const std::string &name) {
    if (name.empty())
      return;

    Location &defn = defns[name];

    if (defn.end.line == 0 && defn.end.column == 0)
      defn = location;
    else
      report(name, location, defn);
  }

  std::string buildName(AstExpr *expr) {
    if (AstExprLocal *local = expr->as<AstExprLocal>())
      return local->local->name.value;
    else if (AstExprGlobal *global = expr->as<AstExprGlobal>())
      return global->name.value;
    else if (AstExprIndexName *indexName = expr->as<AstExprIndexName>()) {
      std::string lhs = buildName(indexName->expr);
      if (lhs.empty())
        return lhs;

      lhs += '.';
      lhs += indexName->index.value;
      return lhs;
    } else
      return std::string();
  }

  void report(const std::string &name, Location location,
              Location otherLocation) {
    emitWarning(*context, LintWarning::Code_DuplicateFunction, location,
                "Duplicate function definition: '%s' also defined on line %d",
                name.c_str(), otherLocation.begin.line + 1);
  }
};

class LintDeprecatedApi : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintDeprecatedApi pass{&context};
    context.root->visit(&pass);
  }

private:
  LintContext *context;

  LintDeprecatedApi(LintContext *context) : context(context) {}

  bool visit(AstExprIndexName *node) override {
    if (std::optional<TypeId> ty = context->getType(node->expr))
      check(node, follow(*ty));
    else if (AstExprGlobal *global = node->expr->as<AstExprGlobal>())
      check(node->location, global->name, node->index);

    return true;
  }

  bool visit(AstExprCall *node) override {
    // getfenv/setfenv are deprecated, however they are still used in some test
    // frameworks and don't have a great general replacement for now we warn
    // about the deprecation only when they are used with a numeric first
    // argument; this produces fewer warnings and makes use of getfenv/setfenv a
    // little more localized
    if (!node->self && node->args.size >= 1) {
      if (AstExprGlobal *fenv = node->func->as<AstExprGlobal>();
          fenv && (fenv->name == "getfenv" || fenv->name == "setfenv")) {
        AstExpr *level = node->args.data[0];
        std::optional<TypeId> ty = context->getType(level);

        if ((ty && isNumber(*ty)) || level->is<AstExprConstantNumber>()) {
          // some common uses of getfenv(n) can be replaced by debug.info if the
          // goal is to get the caller's identity
          const char *suggestion = (fenv->name == "getfenv")
                                       ? "; consider using 'debug.info' instead"
                                       : "";

          emitWarning(*context, LintWarning::Code_DeprecatedApi, node->location,
                      "Function '%s' is deprecated%s", fenv->name.value,
                      suggestion);
        }
      }
    }

    return true;
  }

  void check(AstExprIndexName *node, TypeId ty) {
    if (const ClassType *cty = get<ClassType>(ty)) {
      const Property *prop = lookupClassProp(cty, node->index.value);

      if (prop && prop->deprecated)
        report(node->location, *prop, cty->name.c_str(), node->index.value);
    } else if (const TableType *tty = get<TableType>(ty)) {
      auto prop = tty->props.find(node->index.value);

      if (prop != tty->props.end() && prop->second.deprecated) {
        // strip synthetic typeof() for builtin tables
        if (tty->name && tty->name->compare(0, 7, "typeof(") == 0 &&
            tty->name->back() == ')')
          report(node->location, prop->second,
                 tty->name->substr(7, tty->name->length() - 8).c_str(),
                 node->index.value);
        else
          report(node->location, prop->second,
                 tty->name ? tty->name->c_str() : nullptr, node->index.value);
      }
    }
  }

  void check(const Location &location, AstName global, AstName index) {
    if (const LintContext::Global *gv = context->builtinGlobals.find(global)) {
      if (const TableType *tty = get<TableType>(gv->type)) {
        auto prop = tty->props.find(index.value);

        if (prop != tty->props.end() && prop->second.deprecated)
          report(location, prop->second, global.value, index.value);
      }
    }
  }

  void report(const Location &location, const Property &prop,
              const char *container, const char *field) {
    std::string suggestion =
        prop.deprecatedSuggestion.empty()
            ? ""
            : format(", use '%s' instead", prop.deprecatedSuggestion.c_str());

    if (container)
      emitWarning(*context, LintWarning::Code_DeprecatedApi, location,
                  "Member '%s.%s' is deprecated%s", container, field,
                  suggestion.c_str());
    else
      emitWarning(*context, LintWarning::Code_DeprecatedApi, location,
                  "Member '%s' is deprecated%s", field, suggestion.c_str());
  }
};

class LintTableOperations : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    if (!context.module)
      return;

    LintTableOperations pass{&context};
    context.root->visit(&pass);
  }

private:
  LintContext *context;

  LintTableOperations(LintContext *context) : context(context) {}

  bool visit(AstExprUnary *node) override {
    if (node->op == AstExprUnary::Len)
      checkIndexer(node, node->expr, "#");

    return true;
  }

  bool visit(AstExprCall *node) override {
    if (AstExprGlobal *func = node->func->as<AstExprGlobal>()) {
      if (func->name == "ipairs" && node->args.size == 1)
        checkIndexer(node, node->args.data[0], "ipairs");
    } else if (AstExprIndexName *func = node->func->as<AstExprIndexName>()) {
      if (AstExprGlobal *tablib = func->expr->as<AstExprGlobal>();
          tablib && tablib->name == "table")
        checkTableCall(node, func);
    }

    return true;
  }

  void checkIndexer(AstExpr *node, AstExpr *expr, const char *op) {
    std::optional<Luau::TypeId> ty = context->getType(expr);
    if (!ty)
      return;

    const TableType *tty = get<TableType>(follow(*ty));
    if (!tty)
      return;

    if (!tty->indexer && !tty->props.empty() &&
        tty->state != TableState::Generic)
      emitWarning(*context, LintWarning::Code_TableOperations, node->location,
                  "Using '%s' on a table without an array part is likely a bug",
                  op);
    else if (tty->indexer &&
             isString(tty->indexer->indexType)) // note: to avoid complexity of
                                                // subtype tests we just check
                                                // if the key is a string
      emitWarning(*context, LintWarning::Code_TableOperations, node->location,
                  "Using '%s' on a table with string keys is likely a bug", op);
  }

  void checkTableCall(AstExprCall *node, AstExprIndexName *func) {
    AstExpr **args = node->args.data;

    if (func->index == "insert" && node->args.size == 2) {
      if (AstExprCall *tail = args[1]->as<AstExprCall>()) {
        if (std::optional<TypeId> funty = context->getType(tail->func)) {
          size_t ret = getReturnCount(follow(*funty));

          if (ret > 1)
            emitWarning(
                *context, LintWarning::Code_TableOperations, tail->location,
                "table.insert may change behavior if the call returns more "
                "than one result; consider adding parentheses around second "
                "argument");
        }
      }
    }

    if (func->index == "insert" && node->args.size >= 3) {
      // table.insert(t, 0, ?)
      if (isConstant(args[1], 0.0))
        emitWarning(*context, LintWarning::Code_TableOperations,
                    args[1]->location,
                    "table.insert uses index 0 but arrays are 1-based; did you "
                    "mean 1 instead?");

      // table.insert(t, #t, ?)
      if (isLength(args[1], args[0]))
        emitWarning(
            *context, LintWarning::Code_TableOperations, args[1]->location,
            "table.insert will insert the value before the last element, which "
            "is likely a bug; consider removing the second argument or "
            "wrap it in parentheses to silence");

      // table.insert(t, #t+1, ?)
      if (AstExprBinary *add = args[1]->as<AstExprBinary>();
          add && add->op == AstExprBinary::Add &&
          isLength(add->left, args[0]) && isConstant(add->right, 1.0))
        emitWarning(*context, LintWarning::Code_TableOperations,
                    args[1]->location,
                    "table.insert will append the value to the table; consider "
                    "removing the second argument for efficiency");
    }

    if (func->index == "remove" && node->args.size >= 2) {
      // table.remove(t, 0)
      if (isConstant(args[1], 0.0))
        emitWarning(*context, LintWarning::Code_TableOperations,
                    args[1]->location,
                    "table.remove uses index 0 but arrays are 1-based; did you "
                    "mean 1 instead?");

      // note: it's tempting to check for table.remove(t, #t), which is
      // equivalent to table.remove(t), but it's correct, occurs frequently, and
      // also reads better.

      // table.remove(t, #t-1)
      if (AstExprBinary *sub = args[1]->as<AstExprBinary>();
          sub && sub->op == AstExprBinary::Sub &&
          isLength(sub->left, args[0]) && isConstant(sub->right, 1.0))
        emitWarning(
            *context, LintWarning::Code_TableOperations, args[1]->location,
            "table.remove will remove the value before the last element, which "
            "is likely a bug; consider removing the second argument or "
            "wrap it in parentheses to silence");
    }

    if (func->index == "move" && node->args.size >= 4) {
      // table.move(t, 0, _, _)
      if (isConstant(args[1], 0.0))
        emitWarning(*context, LintWarning::Code_TableOperations,
                    args[1]->location,
                    "table.move uses index 0 but arrays are 1-based; did you "
                    "mean 1 instead?");

      // table.move(t, _, _, 0)
      else if (isConstant(args[3], 0.0))
        emitWarning(*context, LintWarning::Code_TableOperations,
                    args[3]->location,
                    "table.move uses index 0 but arrays are 1-based; did you "
                    "mean 1 instead?");
    }

    if (func->index == "create" && node->args.size == 2) {
      // table.create(n, {...})
      if (args[1]->is<AstExprTable>())
        emitWarning(
            *context, LintWarning::Code_TableOperations, args[1]->location,
            "table.create with a table literal will reuse the same object for "
            "all elements; consider using a for loop instead");

      // table.create(n, {...} :: ?)
      if (AstExprTypeAssertion *as = args[1]->as<AstExprTypeAssertion>();
          as && as->expr->is<AstExprTable>())
        emitWarning(
            *context, LintWarning::Code_TableOperations, as->expr->location,
            "table.create with a table literal will reuse the same object for "
            "all elements; consider using a for loop instead");
    }
  }

  bool isConstant(AstExpr *expr, double value) {
    AstExprConstantNumber *n = expr->as<AstExprConstantNumber>();
    return n && n->value == value;
  }

  bool isLength(AstExpr *expr, AstExpr *table) {
    AstExprUnary *n = expr->as<AstExprUnary>();
    return n && n->op == AstExprUnary::Len && similar(n->expr, table);
  }

  size_t getReturnCount(TypeId ty) {
    if (auto ftv = get<FunctionType>(ty))
      return size(ftv->retTypes);

    if (auto itv = get<IntersectionType>(ty)) {
      // We don't process the type recursively to avoid having to deal with
      // self-recursive intersection types
      size_t result = 0;

      for (TypeId part : itv->parts)
        if (auto ftv = get<FunctionType>(follow(part)))
          result = std::max(result, size(ftv->retTypes));

      return result;
    }

    return 0;
  }
};

class LintDuplicateCondition : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintDuplicateCondition pass{&context};
    context.root->visit(&pass);
  }

private:
  LintContext *context;

  LintDuplicateCondition(LintContext *context) : context(context) {}

  bool visit(AstStatIf *stat) override {
    if (!stat->elsebody)
      return true;

    if (!stat->elsebody->is<AstStatIf>())
      return true;

    // if..elseif chain detected, we need to unroll it
    std::vector<AstExpr *> conditions;
    conditions.reserve(2);

    AstStatIf *head = stat;
    while (head) {
      head->condition->visit(this);
      head->thenbody->visit(this);

      conditions.push_back(head->condition);

      if (head->elsebody && head->elsebody->is<AstStatIf>()) {
        head = head->elsebody->as<AstStatIf>();
        continue;
      }

      if (head->elsebody)
        head->elsebody->visit(this);

      break;
    }

    detectDuplicates(conditions);

    // block recursive visits so that we only analyze each chain once
    return false;
  }

  bool visit(AstExprIfElse *expr) override {
    if (!expr->falseExpr->is<AstExprIfElse>())
      return true;

    // if..elseif chain detected, we need to unroll it
    std::vector<AstExpr *> conditions;
    conditions.reserve(2);

    AstExprIfElse *head = expr;
    while (head) {
      head->condition->visit(this);
      head->trueExpr->visit(this);

      conditions.push_back(head->condition);

      if (head->falseExpr->is<AstExprIfElse>()) {
        head = head->falseExpr->as<AstExprIfElse>();
        continue;
      }

      head->falseExpr->visit(this);
      break;
    }

    detectDuplicates(conditions);

    // block recursive visits so that we only analyze each chain once
    return false;
  }

  bool visit(AstExprBinary *expr) override {
    if (expr->op != AstExprBinary::And && expr->op != AstExprBinary::Or)
      return true;

    // for And expressions, it's idiomatic to use "a and a or b" as a ternary
    // replacement, so we detect this pattern
    if (expr->op == AstExprBinary::Or) {
      AstExprBinary *la = expr->left->as<AstExprBinary>();

      if (la && la->op == AstExprBinary::And) {
        AstExprBinary *lb = la->left->as<AstExprBinary>();
        AstExprBinary *rb = la->right->as<AstExprBinary>();

        // check that the length of and-chain is exactly 2
        if (!(lb && lb->op == AstExprBinary::And) &&
            !(rb && rb->op == AstExprBinary::And)) {
          la->left->visit(this);
          la->right->visit(this);
          expr->right->visit(this);
          return false;
        }
      }
    }

    // unroll condition chain
    std::vector<AstExpr *> conditions;
    conditions.reserve(2);

    extractOpChain(conditions, expr, expr->op);

    detectDuplicates(conditions);

    // block recursive visits so that we only analyze each chain once
    return false;
  }

  void extractOpChain(std::vector<AstExpr *> &conditions, AstExpr *expr,
                      AstExprBinary::Op op) {
    if (AstExprBinary *bin = expr->as<AstExprBinary>(); bin && bin->op == op) {
      extractOpChain(conditions, bin->left, op);
      extractOpChain(conditions, bin->right, op);
    } else if (AstExprGroup *group = expr->as<AstExprGroup>()) {
      extractOpChain(conditions, group->expr, op);
    } else {
      conditions.push_back(expr);
    }
  }

  void detectDuplicates(const std::vector<AstExpr *> &conditions) {
    // Limit the distance at which we consider duplicates to reduce N^2
    // complexity to KN
    const size_t kMaxDistance = 5;

    for (size_t i = 0; i < conditions.size(); ++i) {
      for (size_t j = std::max(i, kMaxDistance) - kMaxDistance; j < i; ++j) {
        if (similar(conditions[j], conditions[i])) {
          if (conditions[i]->location.begin.line ==
              conditions[j]->location.begin.line)
            emitWarning(*context, LintWarning::Code_DuplicateCondition,
                        conditions[i]->location,
                        "Condition has already been checked on column %d",
                        conditions[j]->location.begin.column + 1);
          else
            emitWarning(*context, LintWarning::Code_DuplicateCondition,
                        conditions[i]->location,
                        "Condition has already been checked on line %d",
                        conditions[j]->location.begin.line + 1);
          break;
        }
      }
    }
  }
};

class LintDuplicateLocal : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintDuplicateLocal pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  DenseHashMap<AstLocal *, AstNode *> locals;

  LintDuplicateLocal() : locals(nullptr) {}

  bool visit(AstStatLocal *node) override {
    // early out for performance
    if (node->vars.size == 1)
      return true;

    for (size_t i = 0; i < node->vars.size; ++i)
      locals[node->vars.data[i]] = node;

    for (size_t i = 0; i < node->vars.size; ++i) {
      AstLocal *local = node->vars.data[i];

      if (local->shadow && locals[local->shadow] == node &&
          !ignoreDuplicate(local)) {
        if (local->shadow->location.begin.line == local->location.begin.line)
          emitWarning(
              *context, LintWarning::Code_DuplicateLocal, local->location,
              "Variable '%s' already defined on column %d", local->name.value,
              local->shadow->location.begin.column + 1);
        else
          emitWarning(
              *context, LintWarning::Code_DuplicateLocal, local->location,
              "Variable '%s' already defined on line %d", local->name.value,
              local->shadow->location.begin.line + 1);
      }
    }

    return true;
  }

  bool visit(AstExprFunction *node) override {
    if (node->self)
      locals[node->self] = node;

    for (size_t i = 0; i < node->args.size; ++i)
      locals[node->args.data[i]] = node;

    for (size_t i = 0; i < node->args.size; ++i) {
      AstLocal *local = node->args.data[i];

      if (local->shadow && locals[local->shadow] == node &&
          !ignoreDuplicate(local)) {
        if (local->shadow == node->self)
          emitWarning(*context, LintWarning::Code_DuplicateLocal,
                      local->location,
                      "Function parameter 'self' already defined implicitly");
        else if (local->shadow->location.begin.line ==
                 local->location.begin.line)
          emitWarning(
              *context, LintWarning::Code_DuplicateLocal, local->location,
              "Function parameter '%s' already defined on column %d",
              local->name.value, local->shadow->location.begin.column + 1);
        else
          emitWarning(
              *context, LintWarning::Code_DuplicateLocal, local->location,
              "Function parameter '%s' already defined on line %d",
              local->name.value, local->shadow->location.begin.line + 1);
      }
    }

    return true;
  }

  bool ignoreDuplicate(AstLocal *local) { return local->name == "_"; }
};

class LintMisleadingAndOr : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintMisleadingAndOr pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  bool visit(AstExprBinary *node) override {
    if (node->op != AstExprBinary::Or)
      return true;

    AstExprBinary *and_ = node->left->as<AstExprBinary>();
    if (!and_ || and_->op != AstExprBinary::And)
      return true;

    const char *alt = nullptr;

    if (and_->right->is<AstExprConstantNil>())
      alt = "nil";
    else if (AstExprConstantBool *c = and_->right->as<AstExprConstantBool>();
             c && c->value == false)
      alt = "false";

    if (alt)
      emitWarning(
          *context, LintWarning::Code_MisleadingAndOr, node->location,
          "The and-or expression always evaluates to the second alternative "
          "because the first alternative is %s; consider using if-then-else "
          "expression instead",
          alt);

    return true;
  }
};

class LintIntegerParsing : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintIntegerParsing pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  bool visit(AstExprConstantNumber *node) override {
    switch (node->parseResult) {
    case ConstantNumberParseResult::Ok:
    case ConstantNumberParseResult::Malformed:
      break;
    case ConstantNumberParseResult::Imprecise:
      emitWarning(*context, LintWarning::Code_IntegerParsing, node->location,
                  "Number literal exceeded available precision and was "
                  "truncated to closest representable number");
      break;
    case ConstantNumberParseResult::BinOverflow:
      emitWarning(*context, LintWarning::Code_IntegerParsing, node->location,
                  "Binary number literal exceeded available precision and was "
                  "truncated to 2^64");
      break;
    case ConstantNumberParseResult::HexOverflow:
      emitWarning(*context, LintWarning::Code_IntegerParsing, node->location,
                  "Hexadecimal number literal exceeded available precision and "
                  "was truncated to 2^64");
      break;
    }

    return true;
  }
};

class LintComparisonPrecedence : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LintComparisonPrecedence pass;
    pass.context = &context;

    context.root->visit(&pass);
  }

private:
  LintContext *context;

  static bool isEquality(AstExprBinary::Op op) {
    return op == AstExprBinary::CompareNe || op == AstExprBinary::CompareEq;
  }

  static bool isComparison(AstExprBinary::Op op) {
    return op == AstExprBinary::CompareNe || op == AstExprBinary::CompareEq ||
           op == AstExprBinary::CompareLt || op == AstExprBinary::CompareLe ||
           op == AstExprBinary::CompareGt || op == AstExprBinary::CompareGe;
  }

  static bool isNot(AstExpr *node) {
    AstExprUnary *expr = node->as<AstExprUnary>();

    return expr && expr->op == AstExprUnary::Not;
  }

  bool visit(AstExprBinary *node) override {
    if (!isComparison(node->op))
      return true;

    // not X == Y; we silence this for not X == not Y as it's likely an
    // intentional boolean comparison
    if (isNot(node->left) && !isNot(node->right)) {
      std::string op = toString(node->op);

      if (isEquality(node->op))
        emitWarning(*context, LintWarning::Code_ComparisonPrecedence,
                    node->location,
                    "not X %s Y is equivalent to (not X) %s Y; consider using "
                    "X %s Y, or add parentheses to silence",
                    op.c_str(), op.c_str(),
                    node->op == AstExprBinary::CompareEq ? "~=" : "==");
      else
        emitWarning(*context, LintWarning::Code_ComparisonPrecedence,
                    node->location,
                    "not X %s Y is equivalent to (not X) %s Y; add parentheses "
                    "to silence",
                    op.c_str(), op.c_str());
    } else if (AstExprBinary *left = node->left->as<AstExprBinary>();
               left && isComparison(left->op)) {
      std::string lop = toString(left->op);
      std::string rop = toString(node->op);

      if (isEquality(left->op) || isEquality(node->op))
        emitWarning(*context, LintWarning::Code_ComparisonPrecedence,
                    node->location,
                    "X %s Y %s Z is equivalent to (X %s Y) %s Z; add "
                    "parentheses to silence",
                    lop.c_str(), rop.c_str(), lop.c_str(), rop.c_str());
      else
        emitWarning(*context, LintWarning::Code_ComparisonPrecedence,
                    node->location,
                    "X %s Y %s Z is equivalent to (X %s Y) %s Z; did you mean "
                    "X %s Y and Y %s Z?",
                    lop.c_str(), rop.c_str(), lop.c_str(), rop.c_str(),
                    lop.c_str(), rop.c_str());
    }

    return true;
  }
};

static void fillBuiltinGlobals(LintContext &context, const AstNameTable &names,
                               const ScopePtr &env) {
  ScopePtr current = env;
  while (true) {
    for (auto &[global, binding] : current->bindings) {
      AstName name = names.get(global.c_str());

      if (name.value) {
        auto &g = context.builtinGlobals[name];
        g.type = binding.typeId;
        if (binding.deprecated)
          g.deprecated = binding.deprecatedSuggestion.c_str();
      }
    }

    if (current->parent)
      current = current->parent;
    else
      break;
  }
}

static const char *fuzzyMatch(std::string_view str, const char **array,
                              size_t size) {
  if (FInt::LuauSuggestionDistance == 0)
    return nullptr;

  size_t bestDistance = FInt::LuauSuggestionDistance;
  size_t bestMatch = size;

  for (size_t i = 0; i < size; ++i) {
    size_t ed = editDistance(str, array[i]);

    if (ed <= bestDistance) {
      bestDistance = ed;
      bestMatch = i;
    }
  }

  return bestMatch < size ? array[bestMatch] : nullptr;
}

static void lintComments(LintContext &context,
                         const std::vector<HotComment> &hotcomments) {
  bool seenMode = false;

  for (const HotComment &hc : hotcomments) {
    // We reserve --!<space> for various informational (non-directive) comments
    if (hc.content.empty() || hc.content[0] == ' ' || hc.content[0] == '\t')
      continue;

    if (!hc.header) {
      emitWarning(context, LintWarning::Code_CommentDirective, hc.location,
                  "Comment directive is ignored because it is placed after the "
                  "first non-comment token");
    } else {
      size_t space = hc.content.find_first_of(" \t");
      std::string_view first = std::string_view(hc.content).substr(0, space);

      if (first == "nolint") {
        size_t notspace = hc.content.find_first_not_of(" \t", space);

        if (space == std::string::npos || notspace == std::string::npos) {
          // disables all lints
        } else if (LintWarning::parseName(hc.content.c_str() + notspace) ==
                   LintWarning::Code_Unknown) {
          const char *rule = hc.content.c_str() + notspace;

          // skip Unknown
          if (const char *suggestion = fuzzyMatch(rule, kWarningNames + 1,
                                                  LintWarning::Code__Count - 1))
            emitWarning(context, LintWarning::Code_CommentDirective,
                        hc.location,
                        "nolint directive refers to unknown lint rule '%s'; "
                        "did you mean '%s'?",
                        rule, suggestion);
          else
            emitWarning(
                context, LintWarning::Code_CommentDirective, hc.location,
                "nolint directive refers to unknown lint rule '%s'", rule);
        }
      } else if (first == "nocheck" || first == "nonstrict" ||
                 first == "strict") {
        if (space != std::string::npos)
          emitWarning(context, LintWarning::Code_CommentDirective, hc.location,
                      "Comment directive with the type checking mode has extra "
                      "symbols at the end of the line");
        else if (seenMode)
          emitWarning(context, LintWarning::Code_CommentDirective, hc.location,
                      "Comment directive with the type checking mode has "
                      "already been used");
        else
          seenMode = true;
      } else if (first == "optimize") {
        size_t notspace = hc.content.find_first_not_of(" \t", space);

        if (space == std::string::npos || notspace == std::string::npos)
          emitWarning(context, LintWarning::Code_CommentDirective, hc.location,
                      "optimize directive requires an optimization level");
        else {
          const char *level = hc.content.c_str() + notspace;

          if (strcmp(level, "0") && strcmp(level, "1") && strcmp(level, "2"))
            emitWarning(context, LintWarning::Code_CommentDirective,
                        hc.location,
                        "optimize directive uses unknown optimization level "
                        "'%s', 0..2 expected",
                        level);
        }
      } else if (first == "native") {
        if (space != std::string::npos)
          emitWarning(
              context, LintWarning::Code_CommentDirective, hc.location,
              "native directive has extra symbols at the end of the line");
      } else {
        static const char *kHotComments[] = {
            "nolint", "nocheck", "nonstrict", "strict", "optimize", "native",
        };

        if (const char *suggestion =
                fuzzyMatch(first, kHotComments, std::size(kHotComments)))
          emitWarning(context, LintWarning::Code_CommentDirective, hc.location,
                      "Unknown comment directive '%.*s'; did you mean '%s'?",
                      int(first.size()), first.data(), suggestion);
        else
          emitWarning(context, LintWarning::Code_CommentDirective, hc.location,
                      "Unknown comment directive '%.*s'", int(first.size()),
                      first.data());
      }
    }
  }
}

static bool
hasNativeCommentDirective(const std::vector<HotComment> &hotcomments) {
  LUAU_ASSERT(FFlag::LuauAttributeSyntax);
  LUAU_ASSERT(FFlag::LuauNativeAttribute);
  LUAU_ASSERT(FFlag::LintRedundantNativeAttribute);

  for (const HotComment &hc : hotcomments) {
    if (hc.content.empty() || hc.content[0] == ' ' || hc.content[0] == '\t')
      continue;

    if (hc.header) {
      size_t space = hc.content.find_first_of(" \t");
      std::string_view first = std::string_view(hc.content).substr(0, space);

      if (first == "native")
        return true;
    }
  }

  return false;
}

struct LintRedundantNativeAttribute : AstVisitor {
public:
  LUAU_NOINLINE static void process(LintContext &context) {
    LUAU_ASSERT(FFlag::LuauAttributeSyntax);
    LUAU_ASSERT(FFlag::LuauNativeAttribute);
    LUAU_ASSERT(FFlag::LintRedundantNativeAttribute);

    LintRedundantNativeAttribute pass;
    pass.context = &context;
    context.root->visit(&pass);
  }

private:
  LintContext *context;

  bool visit(AstExprFunction *node) override {
    node->body->visit(this);

    for (const auto attribute : node->attributes) {
      if (attribute->type == AstAttr::Type::Native) {
        emitWarning(*context, LintWarning::Code_RedundantNativeAttribute,
                    attribute->location,
                    "native attribute on a function is redundant in a native "
                    "module; consider removing it");
      }
    }

    return false;
  }
};

std::vector<LintWarning> lint(AstStat *root, const AstNameTable &names,
                              const ScopePtr &env, const Module *module,
                              const std::vector<HotComment> &hotcomments,
                              const LintOptions &options) {
  LintContext context;

  context.options = options;
  context.root = root;
  context.placeholder = names.get("_");
  context.scope = env;
  context.module = module;

  fillBuiltinGlobals(context, names, env);

  if (context.warningEnabled(LintWarning::Code_UnknownGlobal) ||
      context.warningEnabled(LintWarning::Code_DeprecatedGlobal) ||
      context.warningEnabled(LintWarning::Code_GlobalUsedAsLocal) ||
      context.warningEnabled(LintWarning::Code_PlaceholderRead) ||
      context.warningEnabled(LintWarning::Code_BuiltinGlobalWrite)) {
    LintGlobalLocal::process(context);
  }

  if (context.warningEnabled(LintWarning::Code_MultiLineStatement))
    LintMultiLineStatement::process(context);

  if (context.warningEnabled(LintWarning::Code_SameLineStatement))
    LintSameLineStatement::process(context);

  if (context.warningEnabled(LintWarning::Code_LocalShadow) ||
      context.warningEnabled(LintWarning::Code_FunctionUnused) ||
      context.warningEnabled(LintWarning::Code_ImportUnused) ||
      context.warningEnabled(LintWarning::Code_LocalUnused)) {
    LintLocalHygiene::process(context);
  }

  if (context.warningEnabled(LintWarning::Code_FunctionUnused))
    LintUnusedFunction::process(context);

  if (context.warningEnabled(LintWarning::Code_UnreachableCode))
    LintUnreachableCode::process(context);

  if (context.warningEnabled(LintWarning::Code_UnknownType))
    LintUnknownType::process(context);

  if (context.warningEnabled(LintWarning::Code_ForRange))
    LintForRange::process(context);

  if (context.warningEnabled(LintWarning::Code_UnbalancedAssignment))
    LintUnbalancedAssignment::process(context);

  if (context.warningEnabled(LintWarning::Code_ImplicitReturn))
    LintImplicitReturn::process(context);

  if (context.warningEnabled(LintWarning::Code_FormatString))
    LintFormatString::process(context);

  if (context.warningEnabled(LintWarning::Code_TableLiteral))
    LintTableLiteral::process(context);

  if (context.warningEnabled(LintWarning::Code_UninitializedLocal))
    LintUninitializedLocal::process(context);

  if (context.warningEnabled(LintWarning::Code_DuplicateFunction))
    LintDuplicateFunction::process(context);

  if (context.warningEnabled(LintWarning::Code_DeprecatedApi))
    LintDeprecatedApi::process(context);

  if (context.warningEnabled(LintWarning::Code_TableOperations))
    LintTableOperations::process(context);

  if (context.warningEnabled(LintWarning::Code_DuplicateCondition))
    LintDuplicateCondition::process(context);

  if (context.warningEnabled(LintWarning::Code_DuplicateLocal))
    LintDuplicateLocal::process(context);

  if (context.warningEnabled(LintWarning::Code_MisleadingAndOr))
    LintMisleadingAndOr::process(context);

  if (context.warningEnabled(LintWarning::Code_CommentDirective))
    lintComments(context, hotcomments);

  if (context.warningEnabled(LintWarning::Code_IntegerParsing))
    LintIntegerParsing::process(context);

  if (context.warningEnabled(LintWarning::Code_ComparisonPrecedence))
    LintComparisonPrecedence::process(context);

  if (FFlag::LuauAttributeSyntax && FFlag::LuauNativeAttribute &&
      FFlag::LintRedundantNativeAttribute &&
      context.warningEnabled(LintWarning::Code_RedundantNativeAttribute)) {
    if (hasNativeCommentDirective(hotcomments))
      LintRedundantNativeAttribute::process(context);
  }

  std::sort(context.result.begin(), context.result.end(), WarningComparator());

  return context.result;
}

std::vector<AstName> getDeprecatedGlobals(const AstNameTable &names) {
  LintContext context;

  std::vector<AstName> result;
  result.reserve(context.builtinGlobals.size());

  for (auto &p : context.builtinGlobals)
    if (p.second.deprecated)
      result.push_back(p.first);

  return result;
}

void fuzzFormatString(const char *data, size_t size) {
  LintFormatString::fuzz(data, size);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TopoSortStatements.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

/* Decide the order in which we typecheck Lua statements in a block.
 *
 * Algorithm:
 *
 *     1. Build up a dependency graph.
 *          i.   An AstStat is said to depend on another AstStat if it refers to
 * it in any child node. A dependency is the relationship between the
 * declaration of a symbol and its uses. ii.  Additionally, statements that do
 * not define functions have a dependency on the previous non-function
 * statement.  We do this to prevent the algorithm from checking imperative
 * statements out-of-order.
 *     2. Walk each node in the graph in lexical order.  For each node:
 *          i.   Select the next thing `t`
 *          ii.  If `t` has no dependencies at all and is not a function
 * definition, check it now iii. If `t` is a function definition or an
 * expression that does not include a function call, add it to a queue `Q`. iv.
 * Else, toposort `Q` and check things until it is possible to check `t`
 *              * If this fails, we expect the Lua runtime to also fail, as the
 * code is trying to use a symbol before it has been defined.
 *     3. Toposort whatever remains in `Q` and check it all.
 *
 * The end result that we want satisfies a few qualities:
 *
 *     1. Things are generally checked in lexical order.
 *     2. If a function F calls another function G that is declared
 * out-of-order, but in a way that will work when the code is actually run, we
 * want to check G before F.
 *     3. Cyclic dependencies can be resolved by picking an arbitrary statement
 * to check first.
 */
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/StringUtils.h>

// @@@@@ PACK.LUA : was already included! <algorithm>

// @@@ PACK.lua : not found, likely and std header
#include <deque>

// @@@ PACK.lua : not found, likely and std header
#include <list>

// @@@ PACK.lua : not found, likely and std header
#include <map>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@ PACK.lua : not found, likely and std header
#include <set>

// @@@@@ PACK.LUA : was already included! <stdexcept>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau {

// For some reason, natvis interacts really poorly with anonymous data types
namespace detail {

struct Identifier {
  std::string name;    // A nice textual name
  const AstLocal *ctx; // Only used to disambiguate potentially shadowed names
};

bool operator==(const Identifier &lhs, const Identifier &rhs) {
  return lhs.name == rhs.name && lhs.ctx == rhs.ctx;
}

struct IdentifierHash {
  size_t operator()(const Identifier &ident) const {
    return std::hash<std::string>()(ident.name) ^
           std::hash<const void *>()(ident.ctx);
  }
};

struct Node;

struct Arcs {
  std::set<Node *> provides;
  std::set<Node *> depends;
};

struct Node : Arcs {
  std::optional<Identifier> name;
  AstStat *element;

  Node(const std::optional<Identifier> &name, AstStat *el)
      : name(name), element(el) {}
};

using NodeQueue = std::deque<std::unique_ptr<Node>>;
using NodeList = std::list<std::unique_ptr<Node>>;

std::optional<Identifier> mkName(const AstExpr &expr);

Identifier mkName(const AstLocal &local) { return {local.name.value, &local}; }

Identifier mkName(const AstExprLocal &local) { return mkName(*local.local); }

Identifier mkName(const AstExprGlobal &global) {
  return {global.name.value, nullptr};
}

Identifier mkName(const AstName &name) { return {name.value, nullptr}; }

std::optional<Identifier> mkName(const AstExprIndexName &expr) {
  auto lhs = mkName(*expr.expr);
  if (lhs) {
    std::string s = std::move(lhs->name);
    s += ".";
    s += expr.index.value;
    return Identifier{std::move(s), lhs->ctx};
  } else
    return std::nullopt;
}

Identifier mkName(const AstExprError &expr) {
  return {format("error#%d", expr.messageIndex), nullptr};
}

std::optional<Identifier> mkName(const AstExpr &expr) {
  if (auto l = expr.as<AstExprLocal>())
    return mkName(*l);
  else if (auto g = expr.as<AstExprGlobal>())
    return mkName(*g);
  else if (auto i = expr.as<AstExprIndexName>())
    return mkName(*i);
  else if (auto e = expr.as<AstExprError>())
    return mkName(*e);

  return std::nullopt;
}

Identifier mkName(const AstStatFunction &function) {
  auto name = mkName(*function.name);
  LUAU_ASSERT(bool(name));
  if (!name)
    throw InternalCompilerError(
        "Internal error: Function declaration has a bad name");

  return *name;
}

Identifier mkName(const AstStatLocalFunction &function) {
  return mkName(*function.name);
}

std::optional<Identifier> mkName(const AstStatAssign &assign) {
  if (assign.vars.size != 1)
    return std::nullopt;

  return mkName(*assign.vars.data[0]);
}

std::optional<Identifier> mkName(const AstStatLocal &local) {
  if (local.vars.size != 1)
    return std::nullopt;

  return mkName(*local.vars.data[0]);
}

Identifier mkName(const AstStatTypeAlias &typealias) {
  return mkName(typealias.name);
}

std::optional<Identifier> mkName(AstStat *const el) {
  if (auto function = el->as<AstStatFunction>())
    return mkName(*function);
  else if (auto function = el->as<AstStatLocalFunction>())
    return mkName(*function);
  else if (auto assign = el->as<AstStatAssign>())
    return mkName(*assign);
  else if (auto local = el->as<AstStatLocal>())
    return mkName(*local);
  else if (auto typealias = el->as<AstStatTypeAlias>())
    return mkName(*typealias);

  return std::nullopt;
}

struct ArcCollector : public AstVisitor {
  NodeQueue &queue;
  DenseHashMap<Identifier, Node *, IdentifierHash> map;

  Node *currentArc;

  ArcCollector(NodeQueue &queue)
      : queue(queue), map(Identifier{std::string{}, 0}), currentArc(nullptr) {
    for (const auto &node : queue) {
      if (node->name && !map.contains(*node->name))
        map[*node->name] = node.get();
    }
  }

  // Adds a dependency from the current node to the named node.
  void add(const Identifier &name) {
    Node **it = map.find(name);
    if (it == nullptr)
      return;

    Node *n = *it;

    if (n == currentArc)
      return;

    n->provides.insert(currentArc);
    currentArc->depends.insert(n);
  }

  bool visit(AstExprGlobal *node) override {
    add(mkName(*node));
    return true;
  }

  bool visit(AstExprLocal *node) override {
    add(mkName(*node));
    return true;
  }

  bool visit(AstExprIndexName *node) override {
    auto name = mkName(*node);
    if (name)
      add(*name);
    return true;
  }

  bool visit(AstStatFunction *node) override {
    auto name = mkName(*node->name);
    if (!name)
      throw InternalCompilerError(
          "Internal error: AstStatFunction has a bad name");

    add(*name);
    return true;
  }

  bool visit(AstStatLocalFunction *node) override {
    add(mkName(*node->name));
    return true;
  }

  bool visit(AstStatAssign *node) override { return true; }

  bool visit(AstStatTypeAlias *node) override {
    add(mkName(*node));
    return true;
  }

  bool visit(AstType *node) override { return true; }

  bool visit(AstTypeReference *node) override {
    add(mkName(node->name));
    return true;
  }

  bool visit(AstTypeTypeof *node) override {
    std::optional<Identifier> name = mkName(*node->expr);
    if (name)
      add(*name);
    return true;
  }
};

struct ContainsFunctionCall : public AstVisitor {
  bool alsoReturn = false;
  bool result = false;

  ContainsFunctionCall() = default;
  explicit ContainsFunctionCall(bool alsoReturn) : alsoReturn(alsoReturn) {}

  bool visit(AstExpr *) override {
    return !result; // short circuit if result is true
  }

  bool visit(AstExprCall *) override {
    result = true;
    return false;
  }

  bool visit(AstStatForIn *) override {
    // for in loops perform an implicit function call as part of the iterator
    // protocol
    result = true;
    return false;
  }

  bool visit(AstStatReturn *stat) override {
    if (alsoReturn) {
      result = true;
      return false;
    } else
      return AstVisitor::visit(stat);
  }

  bool visit(AstExprFunction *) override { return false; }
  bool visit(AstStatFunction *) override { return false; }
  bool visit(AstStatLocalFunction *) override { return false; }

  bool visit(AstType *ta) override { return true; }
};

bool isToposortableNode(const AstStat &stat) {
  return isFunction(stat) || stat.is<AstStatTypeAlias>();
}

bool containsToposortableNode(const std::vector<AstStat *> &block) {
  for (AstStat *stat : block)
    if (isToposortableNode(*stat))
      return true;

  return false;
}

bool isBlockTerminator(const AstStat &stat) {
  return stat.is<AstStatReturn>() || stat.is<AstStatBreak>() ||
         stat.is<AstStatContinue>();
}

// Clip arcs to and from the node
void prune(Node *next) {
  for (const auto &node : next->provides) {
    auto it = node->depends.find(next);
    LUAU_ASSERT(it != node->depends.end());
    node->depends.erase(it);
  }

  for (const auto &node : next->depends) {
    auto it = node->provides.find(next);
    LUAU_ASSERT(it != node->provides.end());
    node->provides.erase(it);
  }
}

// Drain Q until the target's depends arcs are satisfied.  target is always
// added to the result.
void drain(NodeList &Q, std::vector<AstStat *> &result, Node *target) {
  // Trying to toposort a subgraph is a pretty big hassle. :(
  // Some of the nodes in .depends and .provides aren't present in our subgraph

  std::map<Node *, Arcs> allArcs;

  for (auto &node : Q) {
    // Copy the connectivity information but filter out any provides or depends
    // arcs that are not in Q
    Arcs &arcs = allArcs[node.get()];

    DenseHashSet<Node *> elements{nullptr};
    for (const auto &q : Q)
      elements.insert(q.get());

    for (Node *node : node->depends) {
      if (elements.contains(node))
        arcs.depends.insert(node);
    }
    for (Node *node : node->provides) {
      if (elements.contains(node))
        arcs.provides.insert(node);
    }
  }

  while (!Q.empty()) {
    if (target && target->depends.empty()) {
      prune(target);
      result.push_back(target->element);
      return;
    }

    std::unique_ptr<Node> nextNode;

    for (auto iter = Q.begin(); iter != Q.end(); ++iter) {
      if (isBlockTerminator(*iter->get()->element))
        continue;

      LUAU_ASSERT(allArcs.end() != allArcs.find(iter->get()));
      const Arcs &arcs = allArcs[iter->get()];

      if (arcs.depends.empty()) {
        nextNode = std::move(*iter);
        Q.erase(iter);
        break;
      }
    }

    if (!nextNode) {
      // We've hit a cycle or a terminator. Pick an arbitrary node.
      nextNode = std::move(Q.front());
      Q.pop_front();
    }

    for (const auto &node : nextNode->provides) {
      auto it = allArcs.find(node);
      if (allArcs.end() != it) {
        auto i2 = it->second.depends.find(nextNode.get());
        LUAU_ASSERT(i2 != it->second.depends.end());
        it->second.depends.erase(i2);
      }
    }

    for (const auto &node : nextNode->depends) {
      auto it = allArcs.find(node);
      if (allArcs.end() != it) {
        auto i2 = it->second.provides.find(nextNode.get());
        LUAU_ASSERT(i2 != it->second.provides.end());
        it->second.provides.erase(i2);
      }
    }

    prune(nextNode.get());
    result.push_back(nextNode->element);
  }

  if (target) {
    prune(target);
    result.push_back(target->element);
  }
}

} // namespace detail

bool containsFunctionCall(const AstStat &stat) {
  detail::ContainsFunctionCall cfc;
  const_cast<AstStat &>(stat).visit(&cfc);
  return cfc.result;
}

bool containsFunctionCallOrReturn(const AstStat &stat) {
  detail::ContainsFunctionCall cfc{true};
  const_cast<AstStat &>(stat).visit(&cfc);
  return cfc.result;
}

bool isFunction(const AstStat &stat) {
  return stat.is<AstStatFunction>() || stat.is<AstStatLocalFunction>();
}

void toposort(std::vector<AstStat *> &stats) {
  using namespace detail;

  if (stats.empty())
    return;

  if (!containsToposortableNode(stats))
    return;

  std::vector<AstStat *> result;
  result.reserve(stats.size());

  NodeQueue nodes;
  NodeList Q;

  for (AstStat *stat : stats)
    nodes.push_back(std::unique_ptr<Node>(new Node(mkName(stat), stat)));

  ArcCollector collector{nodes};

  for (const auto &node : nodes) {
    collector.currentArc = node.get();
    node->element->visit(&collector);
  }

  {
    auto it = nodes.begin();
    auto prev = it;

    while (it != nodes.end()) {
      if (it != prev && !isToposortableNode(*(*it)->element)) {
        (*it)->depends.insert(prev->get());
        (*prev)->provides.insert(it->get());
        prev = it;
      }
      ++it;
    }
  }

  while (!nodes.empty()) {
    Node *next = nodes.front().get();

    if (next->depends.empty() && !isBlockTerminator(*next->element)) {
      prune(next);
      result.push_back(next->element);
    } else if (!containsFunctionCall(*next->element))
      Q.push_back(std::move(nodes.front()));
    else
      drain(Q, result, next);

    nodes.pop_front();
  }

  drain(Q, result, nullptr);

  std::swap(stats, result);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details DONE : was aleready inlined
// <Luau/GlobalTypes.h>

namespace Luau {

GlobalTypes::GlobalTypes(NotNull<BuiltinTypes> builtinTypes)
    : builtinTypes(builtinTypes) {
  globalScope = std::make_shared<Scope>(
      globalTypes.addTypePack(TypePackVar{FreeTypePack{TypeLevel{}}}));

  globalScope->addBuiltinTypeBinding("any", TypeFun{{}, builtinTypes->anyType});
  globalScope->addBuiltinTypeBinding("nil", TypeFun{{}, builtinTypes->nilType});
  globalScope->addBuiltinTypeBinding("number",
                                     TypeFun{{}, builtinTypes->numberType});
  globalScope->addBuiltinTypeBinding("string",
                                     TypeFun{{}, builtinTypes->stringType});
  globalScope->addBuiltinTypeBinding("boolean",
                                     TypeFun{{}, builtinTypes->booleanType});
  globalScope->addBuiltinTypeBinding("thread",
                                     TypeFun{{}, builtinTypes->threadType});
  globalScope->addBuiltinTypeBinding("buffer",
                                     TypeFun{{}, builtinTypes->bufferType});
  globalScope->addBuiltinTypeBinding("unknown",
                                     TypeFun{{}, builtinTypes->unknownType});
  globalScope->addBuiltinTypeBinding("never",
                                     TypeFun{{}, builtinTypes->neverType});

  unfreeze(*builtinTypes->arena);
  TypeId stringMetatableTy = makeStringMetatable(builtinTypes);
  asMutable(builtinTypes->stringType)
      ->ty.emplace<PrimitiveType>(PrimitiveType::String, stringMetatableTy);
  persist(stringMetatableTy);
  freeze(*builtinTypes->arena);
}

} // namespace Luau

// This file is part of the Luau programming language and is licensed under MIT
// License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/BuiltinDefinitions.h>

LUAU_FASTFLAGVARIABLE(LuauCheckedEmbeddedDefinitions2, false);
LUAU_FASTFLAG(LuauAttributeSyntax);

namespace Luau {

static const std::string kBuiltinDefinitionLuaSrc = R"BUILTIN_SRC(

declare buffer: {
    create: (size: number) -> buffer,
    fromstring: (str: string) -> buffer,
    tostring: (b: buffer) -> string,
    len: (b: buffer) -> number,
    copy: (target: buffer, targetOffset: number, source: buffer, sourceOffset: number?, count: number?) -> (),
    fill: (b: buffer, offset: number, value: number, count: number?) -> (),
    readi8: (b: buffer, offset: number) -> number,
    readu8: (b: buffer, offset: number) -> number,
    readi16: (b: buffer, offset: number) -> number,
    readu16: (b: buffer, offset: number) -> number,
    readi32: (b: buffer, offset: number) -> number,
    readu32: (b: buffer, offset: number) -> number,
    readf32: (b: buffer, offset: number) -> number,
    readf64: (b: buffer, offset: number) -> number,
    writei8: (b: buffer, offset: number, value: number) -> (),
    writeu8: (b: buffer, offset: number, value: number) -> (),
    writei16: (b: buffer, offset: number, value: number) -> (),
    writeu16: (b: buffer, offset: number, value: number) -> (),
    writei32: (b: buffer, offset: number, value: number) -> (),
    writeu32: (b: buffer, offset: number, value: number) -> (),
    writef32: (b: buffer, offset: number, value: number) -> (),
    writef64: (b: buffer, offset: number, value: number) -> (),
    readstring: (b: buffer, offset: number, count: number) -> string,
    writestring: (b: buffer, offset: number, value: string, count: number?) -> (),
}

declare bit32: {
    band: (...number) -> number,
    bor: (...number) -> number,
    bxor: (...number) -> number,
    btest: (number, ...number) -> boolean,
    rrotate: (x: number, disp: number) -> number,
    lrotate: (x: number, disp: number) -> number,
    lshift: (x: number, disp: number) -> number,
    arshift: (x: number, disp: number) -> number,
    rshift: (x: number, disp: number) -> number,
    bnot: (x: number) -> number,
    extract: (n: number, field: number, width: number?) -> number,
    replace: (n: number, v: number, field: number, width: number?) -> number,
    countlz: (n: number) -> number,
    countrz: (n: number) -> number,
    byteswap: (n: number) -> number,
}

declare math: {
    frexp: (n: number) -> (number, number),
    ldexp: (s: number, e: number) -> number,
    fmod: (x: number, y: number) -> number,
    modf: (n: number) -> (number, number),
    pow: (x: number, y: number) -> number,
    exp: (n: number) -> number,

    ceil: (n: number) -> number,
    floor: (n: number) -> number,
    abs: (n: number) -> number,
    sqrt: (n: number) -> number,

    log: (n: number, base: number?) -> number,
    log10: (n: number) -> number,

    rad: (n: number) -> number,
    deg: (n: number) -> number,

    sin: (n: number) -> number,
    cos: (n: number) -> number,
    tan: (n: number) -> number,
    sinh: (n: number) -> number,
    cosh: (n: number) -> number,
    tanh: (n: number) -> number,
    atan: (n: number) -> number,
    acos: (n: number) -> number,
    asin: (n: number) -> number,
    atan2: (y: number, x: number) -> number,

    min: (number, ...number) -> number,
    max: (number, ...number) -> number,

    pi: number,
    huge: number,

    randomseed: (seed: number) -> (),
    random: (number?, number?) -> number,

    sign: (n: number) -> number,
    clamp: (n: number, min: number, max: number) -> number,
    noise: (x: number, y: number?, z: number?) -> number,
    round: (n: number) -> number,
}

type DateTypeArg = {
    year: number,
    month: number,
    day: number,
    hour: number?,
    min: number?,
    sec: number?,
    isdst: boolean?,
}

type DateTypeResult = {
    year: number,
    month: number,
    wday: number,
    yday: number,
    day: number,
    hour: number,
    min: number,
    sec: number,
    isdst: boolean,
}

declare os: {
    time: (time: DateTypeArg?) -> number,
    date: ((formatString: "*t" | "!*t", time: number?) -> DateTypeResult) & ((formatString: string?, time: number?) -> string),
    difftime: (t2: DateTypeResult | number, t1: DateTypeResult | number) -> number,
    clock: () -> number,
}

declare function require(target: any): any

declare function getfenv(target: any): { [string]: any }

declare _G: any
declare _VERSION: string

declare function gcinfo(): number

declare function print<T...>(...: T...)

declare function type<T>(value: T): string
declare function typeof<T>(value: T): string

-- `assert` has a magic function attached that will give more detailed type information
declare function assert<T>(value: T, errorMessage: string?): T
declare function error<T>(message: T, level: number?): never

declare function tostring<T>(value: T): string
declare function tonumber<T>(value: T, radix: number?): number?

declare function rawequal<T1, T2>(a: T1, b: T2): boolean
declare function rawget<K, V>(tab: {[K]: V}, k: K): V
declare function rawset<K, V>(tab: {[K]: V}, k: K, v: V): {[K]: V}
declare function rawlen<K, V>(obj: {[K]: V} | string): number

declare function setfenv<T..., R...>(target: number | (T...) -> R..., env: {[string]: any}): ((T...) -> R...)?

declare function ipairs<V>(tab: {V}): (({V}, number) -> (number?, V), {V}, number)

declare function pcall<A..., R...>(f: (A...) -> R..., ...: A...): (boolean, R...)

-- FIXME: The actual type of `xpcall` is:
-- <E, A..., R1..., R2...>(f: (A...) -> R1..., err: (E) -> R2..., A...) -> (true, R1...) | (false, R2...)
-- Since we can't represent the return value, we use (boolean, R1...).
declare function xpcall<E, A..., R1..., R2...>(f: (A...) -> R1..., err: (E) -> R2..., ...: A...): (boolean, R1...)

-- `select` has a magic function attached to provide more detailed type information
declare function select<A...>(i: string | number, ...: A...): ...any

-- FIXME: This type is not entirely correct - `loadstring` returns a function or
-- (nil, string).
declare function loadstring<A...>(src: string, chunkname: string?): (((A...) -> any)?, string?)

declare function newproxy(mt: boolean?): any

declare coroutine: {
    create: <A..., R...>(f: (A...) -> R...) -> thread,
    resume: <A..., R...>(co: thread, A...) -> (boolean, R...),
    running: () -> thread,
    status: (co: thread) -> "dead" | "running" | "normal" | "suspended",
    wrap: <A..., R...>(f: (A...) -> R...) -> ((A...) -> R...),
    yield: <A..., R...>(A...) -> R...,
    isyieldable: () -> boolean,
    close: (co: thread) -> (boolean, any)
}

declare table: {
    concat: <V>(t: {V}, sep: string?, i: number?, j: number?) -> string,
    insert: (<V>(t: {V}, value: V) -> ()) & (<V>(t: {V}, pos: number, value: V) -> ()),
    maxn: <V>(t: {V}) -> number,
    remove: <V>(t: {V}, number?) -> V?,
    sort: <V>(t: {V}, comp: ((V, V) -> boolean)?) -> (),
    create: <V>(count: number, value: V?) -> {V},
    find: <V>(haystack: {V}, needle: V, init: number?) -> number?,

    unpack: <V>(list: {V}, i: number?, j: number?) -> ...V,
    pack: <V>(...V) -> { n: number, [number]: V },

    getn: <V>(t: {V}) -> number,
    foreach: <K, V>(t: {[K]: V}, f: (K, V) -> ()) -> (),
    foreachi: <V>({V}, (number, V) -> ()) -> (),

    move: <V>(src: {V}, a: number, b: number, t: number, dst: {V}?) -> {V},
    clear: <K, V>(table: {[K]: V}) -> (),

    isfrozen: <K, V>(t: {[K]: V}) -> boolean,
}

declare debug: {
    info: (<R...>(thread: thread, level: number, options: string) -> R...) & (<R...>(level: number, options: string) -> R...) & (<A..., R1..., R2...>(func: (A...) -> R1..., options: string) -> R2...),
    traceback: ((message: string?, level: number?) -> string) & ((thread: thread, message: string?, level: number?) -> string),
}

declare utf8: {
    char: (...number) -> string,
    charpattern: string,
    codes: (str: string) -> ((string, number) -> (number, number), string, number),
    codepoint: (str: string, i: number?, j: number?) -> ...number,
    len: (s: string, i: number?, j: number?) -> (number?, number?),
    offset: (s: string, n: number?, i: number?) -> number,
}

-- Cannot use `typeof` here because it will produce a polytype when we expect a monotype.
declare function unpack<V>(tab: {V}, i: number?, j: number?): ...V

)BUILTIN_SRC";

static const std::string kBuiltinDefinitionLuaSrcChecked = R"BUILTIN_SRC(

declare bit32: {
    band: @checked (...number) -> number,
    bor: @checked (...number) -> number,
    bxor: @checked (...number) -> number,
    btest: @checked (number, ...number) -> boolean,
    rrotate: @checked (x: number, disp: number) -> number,
    lrotate: @checked (x: number, disp: number) -> number,
    lshift: @checked (x: number, disp: number) -> number,
    arshift: @checked (x: number, disp: number) -> number,
    rshift: @checked (x: number, disp: number) -> number,
    bnot: @checked (x: number) -> number,
    extract: @checked (n: number, field: number, width: number?) -> number,
    replace: @checked (n: number, v: number, field: number, width: number?) -> number,
    countlz: @checked (n: number) -> number,
    countrz: @checked (n: number) -> number,
    byteswap: @checked (n: number) -> number,
}

declare math: {
    frexp: @checked (n: number) -> (number, number),
    ldexp: @checked (s: number, e: number) -> number,
    fmod: @checked (x: number, y: number) -> number,
    modf: @checked (n: number) -> (number, number),
    pow: @checked (x: number, y: number) -> number,
    exp: @checked (n: number) -> number,

    ceil: @checked (n: number) -> number,
    floor: @checked (n: number) -> number,
    abs: @checked (n: number) -> number,
    sqrt: @checked (n: number) -> number,

    log: @checked (n: number, base: number?) -> number,
    log10: @checked (n: number) -> number,

    rad: @checked (n: number) -> number,
    deg: @checked (n: number) -> number,

    sin: @checked (n: number) -> number,
    cos: @checked (n: number) -> number,
    tan: @checked (n: number) -> number,
    sinh: @checked (n: number) -> number,
    cosh: @checked (n: number) -> number,
    tanh: @checked (n: number) -> number,
    atan: @checked (n: number) -> number,
    acos: @checked (n: number) -> number,
    asin: @checked (n: number) -> number,
    atan2: @checked (y: number, x: number) -> number,

    min: @checked (number, ...number) -> number,
    max: @checked (number, ...number) -> number,

    pi: number,
    huge: number,

    randomseed: @checked (seed: number) -> (),
    random: @checked (number?, number?) -> number,

    sign: @checked (n: number) -> number,
    clamp: @checked (n: number, min: number, max: number) -> number,
    noise: @checked (x: number, y: number?, z: number?) -> number,
    round: @checked (n: number) -> number,
}

type DateTypeArg = {
    year: number,
    month: number,
    day: number,
    hour: number?,
    min: number?,
    sec: number?,
    isdst: boolean?,
}

type DateTypeResult = {
    year: number,
    month: number,
    wday: number,
    yday: number,
    day: number,
    hour: number,
    min: number,
    sec: number,
    isdst: boolean,
}

declare os: {
    time: (time: DateTypeArg?) -> number,
    date: ((formatString: "*t" | "!*t", time: number?) -> DateTypeResult) & ((formatString: string?, time: number?) -> string),
    difftime: (t2: DateTypeResult | number, t1: DateTypeResult | number) -> number,
    clock: () -> number,
}

@checked declare function require(target: any): any

@checked declare function getfenv(target: any): { [string]: any }

declare _G: any
declare _VERSION: string

declare function gcinfo(): number

declare function print<T...>(...: T...)

declare function type<T>(value: T): string
declare function typeof<T>(value: T): string

-- `assert` has a magic function attached that will give more detailed type information
declare function assert<T>(value: T, errorMessage: string?): T
declare function error<T>(message: T, level: number?): never

declare function tostring<T>(value: T): string
declare function tonumber<T>(value: T, radix: number?): number?

declare function rawequal<T1, T2>(a: T1, b: T2): boolean
declare function rawget<K, V>(tab: {[K]: V}, k: K): V
declare function rawset<K, V>(tab: {[K]: V}, k: K, v: V): {[K]: V}
declare function rawlen<K, V>(obj: {[K]: V} | string): number

declare function setfenv<T..., R...>(target: number | (T...) -> R..., env: {[string]: any}): ((T...) -> R...)?

declare function ipairs<V>(tab: {V}): (({V}, number) -> (number?, V), {V}, number)

declare function pcall<A..., R...>(f: (A...) -> R..., ...: A...): (boolean, R...)

-- FIXME: The actual type of `xpcall` is:
-- <E, A..., R1..., R2...>(f: (A...) -> R1..., err: (E) -> R2..., A...) -> (true, R1...) | (false, R2...)
-- Since we can't represent the return value, we use (boolean, R1...).
declare function xpcall<E, A..., R1..., R2...>(f: (A...) -> R1..., err: (E) -> R2..., ...: A...): (boolean, R1...)

-- `select` has a magic function attached to provide more detailed type information
declare function select<A...>(i: string | number, ...: A...): ...any

-- FIXME: This type is not entirely correct - `loadstring` returns a function or
-- (nil, string).
declare function loadstring<A...>(src: string, chunkname: string?): (((A...) -> any)?, string?)

@checked declare function newproxy(mt: boolean?): any

declare coroutine: {
    create: <A..., R...>(f: (A...) -> R...) -> thread,
    resume: <A..., R...>(co: thread, A...) -> (boolean, R...),
    running: () -> thread,
    status: @checked (co: thread) -> "dead" | "running" | "normal" | "suspended",
    wrap: <A..., R...>(f: (A...) -> R...) -> ((A...) -> R...),
    yield: <A..., R...>(A...) -> R...,
    isyieldable: () -> boolean,
    close: @checked (co: thread) -> (boolean, any)
}

declare table: {
    concat: <V>(t: {V}, sep: string?, i: number?, j: number?) -> string,
    insert: (<V>(t: {V}, value: V) -> ()) & (<V>(t: {V}, pos: number, value: V) -> ()),
    maxn: <V>(t: {V}) -> number,
    remove: <V>(t: {V}, number?) -> V?,
    sort: <V>(t: {V}, comp: ((V, V) -> boolean)?) -> (),
    create: <V>(count: number, value: V?) -> {V},
    find: <V>(haystack: {V}, needle: V, init: number?) -> number?,

    unpack: <V>(list: {V}, i: number?, j: number?) -> ...V,
    pack: <V>(...V) -> { n: number, [number]: V },

    getn: <V>(t: {V}) -> number,
    foreach: <K, V>(t: {[K]: V}, f: (K, V) -> ()) -> (),
    foreachi: <V>({V}, (number, V) -> ()) -> (),

    move: <V>(src: {V}, a: number, b: number, t: number, dst: {V}?) -> {V},
    clear: <K, V>(table: {[K]: V}) -> (),

    isfrozen: <K, V>(t: {[K]: V}) -> boolean,
}

declare debug: {
    info: (<R...>(thread: thread, level: number, options: string) -> R...) & (<R...>(level: number, options: string) -> R...) & (<A..., R1..., R2...>(func: (A...) -> R1..., options: string) -> R2...),
    traceback: ((message: string?, level: number?) -> string) & ((thread: thread, message: string?, level: number?) -> string),
}

declare utf8: {
    char: @checked (...number) -> string,
    charpattern: string,
    codes: @checked (str: string) -> ((string, number) -> (number, number), string, number),
    codepoint: @checked (str: string, i: number?, j: number?) -> ...number,
    len: @checked (s: string, i: number?, j: number?) -> (number?, number?),
    offset: @checked (s: string, n: number?, i: number?) -> number,
}

-- Cannot use `typeof` here because it will produce a polytype when we expect a monotype.
declare function unpack<V>(tab: {V}, i: number?, j: number?): ...V


--- Buffer API
declare buffer: {
    create: @checked (size: number) -> buffer,
    fromstring: @checked (str: string) -> buffer,
    tostring: @checked (b: buffer) -> string,
    len: @checked (b: buffer) -> number,
    copy: @checked (target: buffer, targetOffset: number, source: buffer, sourceOffset: number?, count: number?) -> (),
    fill: @checked (b: buffer, offset: number, value: number, count: number?) -> (),
    readi8: @checked (b: buffer, offset: number) -> number,
    readu8: @checked (b: buffer, offset: number) -> number,
    readi16: @checked (b: buffer, offset: number) -> number,
    readu16: @checked (b: buffer, offset: number) -> number,
    readi32: @checked (b: buffer, offset: number) -> number,
    readu32: @checked (b: buffer, offset: number) -> number,
    readf32: @checked (b: buffer, offset: number) -> number,
    readf64: @checked (b: buffer, offset: number) -> number,
    writei8: @checked (b: buffer, offset: number, value: number) -> (),
    writeu8: @checked (b: buffer, offset: number, value: number) -> (),
    writei16: @checked (b: buffer, offset: number, value: number) -> (),
    writeu16: @checked (b: buffer, offset: number, value: number) -> (),
    writei32: @checked (b: buffer, offset: number, value: number) -> (),
    writeu32: @checked (b: buffer, offset: number, value: number) -> (),
    writef32: @checked (b: buffer, offset: number, value: number) -> (),
    writef64: @checked (b: buffer, offset: number, value: number) -> (),
    readstring: @checked (b: buffer, offset: number, count: number) -> string,
    writestring: @checked (b: buffer, offset: number, value: string, count: number?) -> (),
}

)BUILTIN_SRC";

std::string getBuiltinDefinitionSource() {
  std::string result = kBuiltinDefinitionLuaSrc;

  // Annotates each non generic function as checked
  if (FFlag::LuauCheckedEmbeddedDefinitions2 && FFlag::LuauAttributeSyntax)
    result = kBuiltinDefinitionLuaSrcChecked;

  return result;
}

} // namespace Luau
