/* @@@@@ PACK.LUA : THIS FILE WAS AUTOGENERATED USING PACK.lua v.2.0!
 * @@@@@ SEE https://github.com/UtoECat/miniLuau/blob/main/PACK.lua FOR DETAILS
 */
/*
 * Luau programming language.
 * MIT License
 *
 * Copyright (c) 2019-2024 Roblox Corporation
 * Copyright (c) 1994â€“2019 Lua.org, PUC-Rio.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//only once
#pragma once
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ApplyTypeFunction.h>

#line __LINE__ "Analysis/include/Luau/ApplyTypeFunction.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Substitution.h>

#line __LINE__ "Luau/Substitution.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeArena.h>

#line __LINE__ "Luau/TypeArena.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypedAllocator.h>

#line __LINE__ "Luau/TypedAllocator.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
#include "luau_common_int.hpp"

// @@@@@ PACK.lua : not found, likely and std header
#include <vector>

// @@@@@ PACK.lua : not found, likely and std header
#include <memory>

namespace Luau
{

void* pagedAllocate(size_t size);
void pagedDeallocate(void* ptr, size_t size);
void pagedFreeze(void* ptr, size_t size);
void pagedUnfreeze(void* ptr, size_t size);

template<typename T>
class TypedAllocator
{
public:
    TypedAllocator()
    {
        currentBlockSize = kBlockSize;
    }

    TypedAllocator(const TypedAllocator&) = delete;
    TypedAllocator& operator=(const TypedAllocator&) = delete;

    TypedAllocator(TypedAllocator&&) = default;
    TypedAllocator& operator=(TypedAllocator&&) = default;

    ~TypedAllocator()
    {
        if (frozen)
            unfreeze();
        free();
    }

    template<typename... Args>
    T* allocate(Args&&... args)
    {
        LUAU_ASSERT(!frozen);

        if (currentBlockSize >= kBlockSize)
        {
            LUAU_ASSERT(currentBlockSize == kBlockSize);
            appendBlock();
        }

        T* block = stuff.back();
        T* res = block + currentBlockSize;
        new (res) T(std::forward<Args&&...>(args...));
        ++currentBlockSize;
        return res;
    }

    bool contains(const T* ptr) const
    {
        for (T* block : stuff)
            if (ptr >= block && ptr < block + kBlockSize)
                return true;

        return false;
    }

    bool empty() const
    {
        return stuff.empty();
    }

    size_t size() const
    {
        return stuff.empty() ? 0 : kBlockSize * (stuff.size() - 1) + currentBlockSize;
    }

    void clear()
    {
        if (frozen)
            unfreeze();
        free();

        currentBlockSize = kBlockSize;
    }

    void freeze()
    {
        for (T* block : stuff)
            pagedFreeze(block, kBlockSizeBytes);
        frozen = true;
    }

    void unfreeze()
    {
        for (T* block : stuff)
            pagedUnfreeze(block, kBlockSizeBytes);
        frozen = false;
    }

    bool isFrozen()
    {
        return frozen;
    }

private:
    void free()
    {
        LUAU_ASSERT(!frozen);

        for (T* block : stuff)
        {
            size_t blockSize = (block == stuff.back()) ? currentBlockSize : kBlockSize;

            for (size_t i = 0; i < blockSize; ++i)
                block[i].~T();

            pagedDeallocate(block, kBlockSizeBytes);
        }

        stuff.clear();
        currentBlockSize = 0;
    }

    void appendBlock()
    {
        void* block = pagedAllocate(kBlockSizeBytes);
        if (!block)
            throw std::bad_alloc();

        stuff.emplace_back(static_cast<T*>(block));
        currentBlockSize = 0;
    }

    bool frozen = false;
    std::vector<T*> stuff;
    size_t currentBlockSize = 0;

    static constexpr size_t kBlockSizeBytes = 32768;
    static constexpr size_t kBlockSize = kBlockSizeBytes / sizeof(T);
};

} // namespace Luau

#line __LINE__ "Luau/TypeArena.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Type.h>

#line __LINE__ "Luau/Type.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeFwd.h>

#line __LINE__ "Luau/TypeFwd.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Variant.h>

#line __LINE__ "Luau/Variant.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.lua : not found, likely and std header
#include <initializer_list>

// @@@@@ PACK.lua : not found, likely and std header
#include <new>

// @@@@@ PACK.lua : not found, likely and std header
#include <type_traits>

// @@@@@ PACK.lua : not found, likely and std header
#include <utility>

// @@@@@ PACK.lua : not found, likely and std header
#include <stddef.h>

namespace Luau
{

template<typename... Ts>
class Variant
{
    static_assert(sizeof...(Ts) > 0, "variant must have at least 1 type (empty variants are ill-formed)");
    static_assert(std::disjunction_v<std::is_void<Ts>...> == false, "variant does not allow void as an alternative type");
    static_assert(std::disjunction_v<std::is_reference<Ts>...> == false, "variant does not allow references as an alternative type");
    static_assert(std::disjunction_v<std::is_array<Ts>...> == false, "variant does not allow arrays as an alternative type");

private:
    template<typename T>
    static constexpr int getTypeId()
    {
        using TT = std::decay_t<T>;

        constexpr int N = sizeof...(Ts);
        constexpr bool is[N] = {std::is_same_v<TT, Ts>...};

        for (int i = 0; i < N; ++i)
            if (is[i])
                return i;

        return -1;
    }

    template<typename T, typename... Tail>
    struct First
    {
        using type = T;
    };

public:
    using first_alternative = typename First<Ts...>::type;

    template<typename T>
    static constexpr bool is_part_of_v = std::disjunction_v<typename std::is_same<std::decay_t<Ts>, T>...>;

    Variant()
    {
        static_assert(std::is_default_constructible_v<first_alternative>, "first alternative type must be default constructible");
        typeId = 0;
        new (&storage) first_alternative();
    }

    template<typename T>
    Variant(T&& value, std::enable_if_t<getTypeId<T>() >= 0>* = 0)
    {
        using TT = std::decay_t<T>;

        constexpr int tid = getTypeId<T>();
        typeId = tid;
        new (&storage) TT(std::forward<T>(value));
    }

    Variant(const Variant& other)
    {
        static constexpr FnCopy table[sizeof...(Ts)] = {&fnCopy<Ts>...};

        typeId = other.typeId;
        table[typeId](&storage, &other.storage);
    }

    Variant(Variant&& other)
    {
        typeId = other.typeId;
        tableMove[typeId](&storage, &other.storage);
    }

    ~Variant()
    {
        tableDtor[typeId](&storage);
    }

    Variant& operator=(const Variant& other)
    {
        Variant copy(other);
        // static_cast<T&&> is equivalent to std::move() but faster in Debug
        return *this = static_cast<Variant&&>(copy);
    }

    Variant& operator=(Variant&& other)
    {
        if (this != &other)
        {
            tableDtor[typeId](&storage);
            typeId = other.typeId;
            tableMove[typeId](&storage, &other.storage); // nothrow
        }
        return *this;
    }

    template<typename T, typename... Args>
    T& emplace(Args&&... args)
    {
        using TT = std::decay_t<T>;
        constexpr int tid = getTypeId<T>();
        static_assert(tid >= 0, "unsupported T");

        tableDtor[typeId](&storage);
        typeId = tid;
        new (&storage) TT{std::forward<Args>(args)...};

        return *reinterpret_cast<T*>(&storage);
    }

    template<typename T>
    const T* get_if() const
    {
        constexpr int tid = getTypeId<T>();
        static_assert(tid >= 0, "unsupported T");

        return tid == typeId ? reinterpret_cast<const T*>(&storage) : nullptr;
    }

    template<typename T>
    T* get_if()
    {
        constexpr int tid = getTypeId<T>();
        static_assert(tid >= 0, "unsupported T");

        return tid == typeId ? reinterpret_cast<T*>(&storage) : nullptr;
    }

    bool valueless_by_exception() const
    {
        return false;
    }

    int index() const
    {
        return typeId;
    }

    bool operator==(const Variant& other) const
    {
        static constexpr FnPred table[sizeof...(Ts)] = {&fnPredEq<Ts>...};

        return typeId == other.typeId && table[typeId](&storage, &other.storage);
    }

    bool operator!=(const Variant& other) const
    {
        return !(*this == other);
    }

private:
    static constexpr size_t cmax(std::initializer_list<size_t> l)
    {
        size_t res = 0;
        for (size_t i : l)
            res = (res < i) ? i : res;
        return res;
    }

    static constexpr size_t storageSize = cmax({sizeof(Ts)...});
    static constexpr size_t storageAlign = cmax({alignof(Ts)...});

    using FnCopy = void (*)(void*, const void*);
    using FnMove = void (*)(void*, void*);
    using FnDtor = void (*)(void*);
    using FnPred = bool (*)(const void*, const void*);

    template<typename T>
    static void fnCopy(void* dst, const void* src)
    {
        new (dst) T(*static_cast<const T*>(src));
    }

    template<typename T>
    static void fnMove(void* dst, void* src)
    {
        // static_cast<T&&> is equivalent to std::move() but faster in Debug
        new (dst) T(static_cast<T&&>(*static_cast<T*>(src)));
    }

    template<typename T>
    static void fnDtor(void* dst)
    {
        static_cast<T*>(dst)->~T();
    }

    template<typename T>
    static bool fnPredEq(const void* lhs, const void* rhs)
    {
        return *static_cast<const T*>(lhs) == *static_cast<const T*>(rhs);
    }

    static constexpr FnMove tableMove[sizeof...(Ts)] = {&fnMove<Ts>...};
    static constexpr FnDtor tableDtor[sizeof...(Ts)] = {&fnDtor<Ts>...};

    int typeId;
    alignas(storageAlign) char storage[storageSize];

    template<class Visitor, typename... _Ts>
    friend auto visit(Visitor&& vis, const Variant<_Ts...>& var);
    template<class Visitor, typename... _Ts>
    friend auto visit(Visitor&& vis, Variant<_Ts...>& var);
};

template<typename T, typename... Ts>
const T* get_if(const Variant<Ts...>* var)
{
    return var ? var->template get_if<T>() : nullptr;
}

template<typename T, typename... Ts>
T* get_if(Variant<Ts...>* var)
{
    return var ? var->template get_if<T>() : nullptr;
}

template<typename Visitor, typename Result, typename T>
static void fnVisitR(Visitor& vis, Result& dst, std::conditional_t<std::is_const_v<T>, const void, void>* src)
{
    dst = vis(*static_cast<T*>(src));
}

template<typename Visitor, typename T>
static void fnVisitV(Visitor& vis, std::conditional_t<std::is_const_v<T>, const void, void>* src)
{
    vis(*static_cast<T*>(src));
}

template<class Visitor, typename... Ts>
auto visit(Visitor&& vis, const Variant<Ts...>& var)
{
    static_assert(std::conjunction_v<std::is_invocable<Visitor, Ts>...>, "visitor must accept every alternative as an argument");

    using Result = std::invoke_result_t<Visitor, typename Variant<Ts...>::first_alternative>;
    static_assert(std::conjunction_v<std::is_same<Result, std::invoke_result_t<Visitor, Ts>>...>,
        "visitor result type must be consistent between alternatives");

    if constexpr (std::is_same_v<Result, void>)
    {
        using FnVisitV = void (*)(Visitor&, const void*);
        static const FnVisitV tableVisit[sizeof...(Ts)] = {&fnVisitV<Visitor, const Ts>...};

        tableVisit[var.typeId](vis, &var.storage);
    }
    else
    {
        using FnVisitR = void (*)(Visitor&, Result&, const void*);
        static const FnVisitR tableVisit[sizeof...(Ts)] = {&fnVisitR<Visitor, Result, const Ts>...};

        Result res;
        tableVisit[var.typeId](vis, res, &var.storage);
        return res;
    }
}

template<class Visitor, typename... Ts>
auto visit(Visitor&& vis, Variant<Ts...>& var)
{
    static_assert(std::conjunction_v<std::is_invocable<Visitor, Ts&>...>, "visitor must accept every alternative as an argument");

    using Result = std::invoke_result_t<Visitor, typename Variant<Ts...>::first_alternative&>;
    static_assert(std::conjunction_v<std::is_same<Result, std::invoke_result_t<Visitor, Ts&>>...>,
        "visitor result type must be consistent between alternatives");

    if constexpr (std::is_same_v<Result, void>)
    {
        using FnVisitV = void (*)(Visitor&, void*);
        static const FnVisitV tableVisit[sizeof...(Ts)] = {&fnVisitV<Visitor, Ts>...};

        tableVisit[var.typeId](vis, &var.storage);
    }
    else
    {
        using FnVisitR = void (*)(Visitor&, Result&, void*);
        static const FnVisitR tableVisit[sizeof...(Ts)] = {&fnVisitR<Visitor, Result, Ts>...};

        Result res;
        tableVisit[var.typeId](vis, res, &var.storage);
        return res;
    }
}

template<class>
inline constexpr bool always_false_v = false;

} // namespace Luau

#line __LINE__ "Luau/TypeFwd.h"

// @@@@@ PACK.lua : not found, likely and std header
#include <string>

namespace Luau
{

// So... why `const T*` here rather than `T*`?
// It's because we've had problems caused by the type graph being mutated
// in ways it shouldn't be, for example mutating types from other modules.
// To try to control this, we make the use of types immutable by default,
// then provide explicit mutable access via getMutable and asMutable.
// This means we can grep for all the places we're mutating the type graph,
// and it makes it possible to provide other APIs (e.g. the txn log)
// which control mutable access to the type graph.

struct Type;
using TypeId = const Type*;

struct FreeType;
struct GenericType;
struct PrimitiveType;
struct BlockedType;
struct PendingExpansionType;
struct SingletonType;
struct FunctionType;
struct TableType;
struct MetatableType;
struct ClassType;
struct AnyType;
struct UnionType;
struct IntersectionType;
struct LazyType;
struct UnknownType;
struct NeverType;
struct NegationType;
struct TypeFunctionInstanceType;

struct TypePackVar;
using TypePackId = const TypePackVar*;

struct FreeTypePack;
struct GenericTypePack;
struct TypePack;
struct VariadicTypePack;
struct BlockedTypePack;
struct TypeFunctionInstanceTypePack;

using Name = std::string;
using ModuleName = std::string;

struct BuiltinTypes;

using TypeOrPack = Variant<TypeId, TypePackId>;

} // namespace Luau

#line __LINE__ "Luau/Type.h"

#include "luau_ast_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Refinement.h>

#line __LINE__ "Luau/Refinement.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/NotNull.h>

#line __LINE__ "Luau/NotNull.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.lua : not found, likely and std header
#include <functional>

namespace Luau
{

/** A non-owning, non-null pointer to a T.
 *
 * A NotNull<T> is notionally identical to a T* with the added restriction that
 * it can never store nullptr.
 *
 * The sole conversion rule from T* to NotNull<T> is the single-argument
 * constructor, which is intentionally marked explicit. This constructor
 * performs a runtime test to verify that the passed pointer is never nullptr.
 *
 * Pointer arithmetic, increment, decrement, and array indexing are all
 * forbidden.
 *
 * An implicit coersion from NotNull<T> to T* is afforded, as are the pointer
 * indirection and member access operators. (*p and p->prop)
 *
 * The explicit delete statement is permitted (but not recommended) on a
 * NotNull<T> through this implicit conversion.
 */
template<typename T>
struct NotNull
{
    explicit NotNull(T* t)
        : ptr(t)
    {
        LUAU_ASSERT(t);
    }

    explicit NotNull(std::nullptr_t) = delete;
    void operator=(std::nullptr_t) = delete;

    template<typename U>
    NotNull(NotNull<U> other)
        : ptr(other.get())
    {
    }

    operator T*() const noexcept
    {
        return ptr;
    }

    T& operator*() const noexcept
    {
        return *ptr;
    }

    T* operator->() const noexcept
    {
        return ptr;
    }

    template<typename U>
    bool operator==(NotNull<U> other) const noexcept
    {
        return get() == other.get();
    }

    template<typename U>
    bool operator!=(NotNull<U> other) const noexcept
    {
        return get() != other.get();
    }

    operator bool() const noexcept = delete;

    T& operator[](int) = delete;

    T& operator+(int) = delete;
    T& operator-(int) = delete;

    T* get() const noexcept
    {
        return ptr;
    }

private:
    T* ptr;
};

} // namespace Luau

namespace std
{

template<typename T>
struct hash<Luau::NotNull<T>>
{
    size_t operator()(const Luau::NotNull<T>& p) const
    {
        return std::hash<T*>()(p.get());
    }
};

} // namespace std

#line __LINE__ "Luau/Refinement.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypedAllocator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

namespace Luau
{

struct RefinementKey;
using DefId = NotNull<const struct Def>;

struct Variadic;
struct Negation;
struct Conjunction;
struct Disjunction;
struct Equivalence;
struct Proposition;
using Refinement = Variant<Variadic, Negation, Conjunction, Disjunction, Equivalence, Proposition>;
using RefinementId = Refinement*; // Can and most likely is nullptr.

struct Variadic
{
    std::vector<RefinementId> refinements;
};

struct Negation
{
    RefinementId refinement;
};

struct Conjunction
{
    RefinementId lhs;
    RefinementId rhs;
};

struct Disjunction
{
    RefinementId lhs;
    RefinementId rhs;
};

struct Equivalence
{
    RefinementId lhs;
    RefinementId rhs;
};

struct Proposition
{
    const RefinementKey* key;
    TypeId discriminantTy;
};

template<typename T>
const T* get(RefinementId refinement)
{
    return get_if<T>(refinement);
}

struct RefinementArena
{
    RefinementId variadic(const std::vector<RefinementId>& refis);
    RefinementId negation(RefinementId refinement);
    RefinementId conjunction(RefinementId lhs, RefinementId rhs);
    RefinementId disjunction(RefinementId lhs, RefinementId rhs);
    RefinementId equivalence(RefinementId lhs, RefinementId rhs);
    RefinementId proposition(const RefinementKey* key, TypeId discriminantTy);

private:
    TypedAllocator<Refinement> allocator;
};

} // namespace Luau

#line __LINE__ "Luau/Type.h"

// @@@@@ DONE : was aleready included <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Predicate.h>

#line __LINE__ "Luau/Predicate.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ DONE : was aleready included <Luau/Location.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/LValue.h>

#line __LINE__ "Luau/LValue.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Symbol.h>

#line __LINE__ "Luau/Symbol.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <string>

namespace Luau
{

struct Symbol
{
    Symbol()
        : local(nullptr)
        , global()
    {
    }

    Symbol(AstLocal* local)
        : local(local)
        , global()
    {
    }

    Symbol(const AstName& global)
        : local(nullptr)
        , global(global)
    {
    }

    template<typename T>
    Symbol(const T&) = delete;

    AstLocal* local;
    AstName global;

    explicit operator bool() const
    {
        return local != nullptr || global.value != nullptr;
    }

    bool operator==(const Symbol& rhs) const;

    bool operator!=(const Symbol& rhs) const
    {
        return !(*this == rhs);
    }

    bool operator<(const Symbol& rhs) const
    {
        if (local && rhs.local)
            return local < rhs.local;
        else if (global.value && rhs.global.value)
            return global < rhs.global;
        else if (local)
            return true;

        return false;
    }

    AstName astName() const
    {
        if (local)
            return local->name;

        LUAU_ASSERT(global.value);
        return global;
    }

    const char* c_str() const
    {
        if (local)
            return local->name.value;

        LUAU_ASSERT(global.value);
        return global.value;
    }
};

std::string toString(const Symbol& name);

} // namespace Luau

namespace std
{
template<>
struct hash<Luau::Symbol>
{
    std::size_t operator()(const Luau::Symbol& s) const noexcept
    {
        return std::hash<const Luau::AstLocal*>()(s.local) ^ (s.global.value ? std::hash<std::string_view>()(s.global.value) : 0);
    }
};
} // namespace std

#line __LINE__ "Luau/LValue.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.lua : not found, likely and std header
#include <unordered_map>

namespace Luau
{

struct Field;

// Deprecated. Do not use in new work.
using LValue = Variant<Symbol, Field>;

struct Field
{
    std::shared_ptr<LValue> parent;
    std::string key;

    bool operator==(const Field& rhs) const;
    bool operator!=(const Field& rhs) const;
};

struct LValueHasher
{
    size_t operator()(const LValue& lvalue) const;
};

const LValue* baseof(const LValue& lvalue);

std::optional<LValue> tryGetLValue(const class AstExpr& expr);

// Utility function: breaks down an LValue to get at the Symbol
Symbol getBaseSymbol(const LValue& lvalue);

template<typename T>
const T* get(const LValue& lvalue)
{
    return get_if<T>(&lvalue);
}

using RefinementMap = std::unordered_map<LValue, TypeId, LValueHasher>;

void merge(RefinementMap& l, const RefinementMap& r, std::function<TypeId(TypeId, TypeId)> f);
void addRefinement(RefinementMap& refis, const LValue& lvalue, TypeId ty);

} // namespace Luau

#line __LINE__ "Luau/Predicate.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

struct TruthyPredicate;
struct IsAPredicate;
struct TypeGuardPredicate;
struct EqPredicate;
struct AndPredicate;
struct OrPredicate;
struct NotPredicate;

using Predicate = Variant<TruthyPredicate, IsAPredicate, TypeGuardPredicate, EqPredicate, AndPredicate, OrPredicate, NotPredicate>;
using PredicateVec = std::vector<Predicate>;

struct TruthyPredicate
{
    LValue lvalue;
    Location location;
};

struct IsAPredicate
{
    LValue lvalue;
    Location location;
    TypeId ty;
};

struct TypeGuardPredicate
{
    LValue lvalue;
    Location location;
    std::string kind; // TODO: When singleton types arrive, replace this with `TypeId ty;`
    bool isTypeof;
};

struct EqPredicate
{
    LValue lvalue;
    TypeId type;
    Location location;
};

struct AndPredicate
{
    PredicateVec lhs;
    PredicateVec rhs;

    AndPredicate(PredicateVec&& lhs, PredicateVec&& rhs);
};

struct OrPredicate
{
    PredicateVec lhs;
    PredicateVec rhs;

    OrPredicate(PredicateVec&& lhs, PredicateVec&& rhs);
};

struct NotPredicate
{
    PredicateVec predicates;
};

// Outside definition works around clang 15 issue where vector instantiation is triggered while Predicate is still incomplete
inline AndPredicate::AndPredicate(PredicateVec&& lhs, PredicateVec&& rhs)
    : lhs(std::move(lhs))
    , rhs(std::move(rhs))
{
}

inline OrPredicate::OrPredicate(PredicateVec&& lhs, PredicateVec&& rhs)
    : lhs(std::move(lhs))
    , rhs(std::move(rhs))
{
}

template<typename T>
const T* get(const Predicate& predicate)
{
    return get_if<T>(&predicate);
}

} // namespace Luau

#line __LINE__ "Luau/Type.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Unifiable.h>

#line __LINE__ "Luau/Unifiable.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <string>

namespace Luau
{

struct Scope;

/**
 * The 'level' of a Type is an indirect way to talk about the scope that it 'belongs' too.
 * To start, read http://okmij.org/ftp/ML/generalization.html
 *
 * We extend the idea by adding a "sub-level" which helps us to differentiate sibling scopes
 * within a single larger scope.
 *
 * We need this because we try to prototype functions and add them to the type environment before
 * we check the function bodies.  This allows us to properly typecheck many scenarios where there
 * is no single good order in which to typecheck a program.
 */
struct TypeLevel
{
    int level = 0;
    int subLevel = 0;

    // Returns true if the level of "this" belongs to an equal or larger scope than that of rhs
    bool subsumes(const TypeLevel& rhs) const
    {
        if (level < rhs.level)
            return true;
        if (level > rhs.level)
            return false;
        if (subLevel == rhs.subLevel)
            return true; // if level == rhs.level and subLevel == rhs.subLevel, then they are the exact same TypeLevel

        // Sibling TypeLevels (that is, TypeLevels that share a level but have a different subLevel) are not considered to subsume one another
        return false;
    }

    // Returns true if the level of "this" belongs to a larger (not equal) scope than that of rhs
    bool subsumesStrict(const TypeLevel& rhs) const
    {
        if (level == rhs.level && subLevel == rhs.subLevel)
            return false;
        else
            return subsumes(rhs);
    }

    TypeLevel incr() const
    {
        TypeLevel result;
        result.level = level + 1;
        result.subLevel = 0;
        return result;
    }
};

inline TypeLevel max(const TypeLevel& a, const TypeLevel& b)
{
    if (a.subsumes(b))
        return b;
    else
        return a;
}

inline TypeLevel min(const TypeLevel& a, const TypeLevel& b)
{
    if (a.subsumes(b))
        return a;
    else
        return b;
}

} // namespace Luau

namespace Luau::Unifiable
{

using Name = std::string;

int freshIndex();

template<typename Id>
struct Bound
{
    explicit Bound(Id boundTo)
        : boundTo(boundTo)
    {
    }

    Id boundTo;
};

struct Error
{
    // This constructor has to be public, since it's used in Type and TypePack,
    // but shouldn't be called directly. Please use errorRecoveryType() instead.
    Error();

    int index;

private:
    static int nextIndex;
};

template<typename Id, typename... Value>
using Variant = Luau::Variant<Bound<Id>, Error, Value...>;

} // namespace Luau::Unifiable

#line __LINE__ "Luau/Type.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ DONE : was aleready included <Luau/VecDeque.h>

// @@@@@ PACK.lua : not found, likely and std header
#include <atomic>

// @@@@@ PACK.lua : not found, likely and std header
#include <map>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.lua : not found, likely and std header
#include <optional>

// @@@@@ PACK.lua : not found, likely and std header
#include <set>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <vector>

LUAU_FASTINT(LuauTableTypeMaximumStringifierLength)
LUAU_FASTINT(LuauTypeMaximumStringifierLength)

namespace Luau
{

struct TypeArena;
struct Scope;
using ScopePtr = std::shared_ptr<Scope>;

struct TypeFunction;
struct Constraint;

/**
 * There are three kinds of type variables:
 * - `Free` variables are metavariables, which stand for unconstrained types.
 * - `Bound` variables are metavariables that have an equality constraint.
 * - `Generic` variables are type variables that are bound by generic functions.
 *
 * For example, consider the program:
 * ```
 * function(x, y) x.f = y end
 * ```
 * To typecheck this, we first introduce free metavariables for the types of `x` and `y`:
 * ```
 * function(x: X, y: Y) x.f = y end
 * ```
 * Type inference for the function body then produces the constraint:
 * ```
 * X = { f: Y }
 * ```
 * so `X` is now a bound metavariable. We can then quantify the metavariables,
 * which replaces any bound metavariables by their binding, and free metavariables
 * by bound generic variables:
 * ```
 * function<a>(x: { f: a }, y: a) x.f = y end
 * ```
 */

using Name = std::string;

// A free type is one whose exact shape has yet to be fully determined.
struct FreeType
{
    explicit FreeType(TypeLevel level);
    explicit FreeType(Scope* scope);
    FreeType(Scope* scope, TypeLevel level);

    FreeType(Scope* scope, TypeId lowerBound, TypeId upperBound);

    int index;
    TypeLevel level;
    Scope* scope = nullptr;

    // True if this free type variable is part of a mutually
    // recursive type alias whose definitions haven't been
    // resolved yet.
    bool forwardedTypeAlias = false;

    // Only used under local type inference
    TypeId lowerBound = nullptr;
    TypeId upperBound = nullptr;
};

struct GenericType
{
    // By default, generics are global, with a synthetic name
    GenericType();

    explicit GenericType(TypeLevel level);
    explicit GenericType(const Name& name);
    explicit GenericType(Scope* scope);

    GenericType(TypeLevel level, const Name& name);
    GenericType(Scope* scope, const Name& name);

    int index;
    TypeLevel level;
    Scope* scope = nullptr;
    Name name;
    bool explicitName = false;
};

// When an equality constraint is found, it is then "bound" to that type,
// indicating that the two types are actually the same type.
using BoundType = Unifiable::Bound<TypeId>;

using Tags = std::vector<std::string>;

using ModuleName = std::string;

/** A Type that cannot be computed.
 *
 * BlockedTypes essentially serve as a way to encode partial ordering on the
 * constraint graph. Until a BlockedType is unblocked by its owning
 * constraint, nothing at all can be said about it. Constraints that need to
 * process a BlockedType cannot be dispatched.
 *
 * Whenever a BlockedType is added to the graph, we also record a constraint
 * that will eventually unblock it.
 */
struct BlockedType
{
    BlockedType();
    int index;

    Constraint* getOwner() const;
    void setOwner(Constraint* newOwner);
    void replaceOwner(Constraint* newOwner);

private:
    // The constraint that is intended to unblock this type. Other constraints
    // should block on this constraint if present.
    Constraint* owner = nullptr;
};

struct PrimitiveType
{
    enum Type
    {
        NilType, // ObjC #defines Nil :(
        Boolean,
        Number,
        String,
        Thread,
        Function,
        Table,
        Buffer,
    };

    Type type;
    std::optional<TypeId> metatable; // string has a metatable

    explicit PrimitiveType(Type type)
        : type(type)
    {
    }

    explicit PrimitiveType(Type type, TypeId metatable)
        : type(type)
        , metatable(metatable)
    {
    }
};

// Singleton types https://github.com/luau-lang/rfcs/blob/master/docs/syntax-singleton-types.md
// Types for true and false
struct BooleanSingleton
{
    bool value;

    bool operator==(const BooleanSingleton& rhs) const
    {
        return value == rhs.value;
    }

    bool operator!=(const BooleanSingleton& rhs) const
    {
        return !(*this == rhs);
    }
};

// Types for "foo", "bar" etc.
struct StringSingleton
{
    std::string value;

    bool operator==(const StringSingleton& rhs) const
    {
        return value == rhs.value;
    }

    bool operator!=(const StringSingleton& rhs) const
    {
        return !(*this == rhs);
    }
};

// No type for float singletons, partly because === isn't any equalivalence on floats
// (NaN != NaN).

using SingletonVariant = Luau::Variant<BooleanSingleton, StringSingleton>;

struct SingletonType
{
    explicit SingletonType(const SingletonVariant& variant)
        : variant(variant)
    {
    }

    explicit SingletonType(SingletonVariant&& variant)
        : variant(std::move(variant))
    {
    }

    // Default operator== is C++20.
    bool operator==(const SingletonType& rhs) const
    {
        return variant == rhs.variant;
    }

    bool operator!=(const SingletonType& rhs) const
    {
        return !(*this == rhs);
    }

    SingletonVariant variant;
};

template<typename T>
const T* get(const SingletonType* stv)
{
    if (stv)
        return get_if<T>(&stv->variant);
    else
        return nullptr;
}

struct FunctionArgument
{
    Name name;
    Location location;
};

struct FunctionDefinition
{
    std::optional<ModuleName> definitionModuleName;
    Location definitionLocation;
    std::optional<Location> varargLocation;
    Location originalNameLocation;
};

// TODO: Come up with a better name.
// TODO: Do we actually need this? We'll find out later if we can delete this.
// Does not exactly belong in Type.h, but this is the only way to appease the compiler.
template<typename T>
struct WithPredicate
{
    T type;
    PredicateVec predicates;

    WithPredicate() = default;
    explicit WithPredicate(T type)
        : type(type)
    {
    }

    WithPredicate(T type, PredicateVec predicates)
        : type(type)
        , predicates(std::move(predicates))
    {
    }
};

using MagicFunction = std::function<std::optional<WithPredicate<TypePackId>>(
    struct TypeChecker&, const std::shared_ptr<struct Scope>&, const class AstExprCall&, WithPredicate<TypePackId>)>;

struct MagicFunctionCallContext
{
    NotNull<struct ConstraintSolver> solver;
    NotNull<const Constraint> constraint;
    const class AstExprCall* callSite;
    TypePackId arguments;
    TypePackId result;
};

using DcrMagicFunction = std::function<bool(MagicFunctionCallContext)>;

struct MagicRefinementContext
{
    NotNull<Scope> scope;
    const class AstExprCall* callSite;
    std::vector<std::optional<TypeId>> discriminantTypes;
};

using DcrMagicRefinement = void (*)(const MagicRefinementContext&);

struct FunctionType
{
    // Global monomorphic function
    FunctionType(TypePackId argTypes, TypePackId retTypes, std::optional<FunctionDefinition> defn = {}, bool hasSelf = false);

    // Global polymorphic function
    FunctionType(std::vector<TypeId> generics, std::vector<TypePackId> genericPacks, TypePackId argTypes, TypePackId retTypes,
        std::optional<FunctionDefinition> defn = {}, bool hasSelf = false);

    // Local monomorphic function
    FunctionType(TypeLevel level, TypePackId argTypes, TypePackId retTypes, std::optional<FunctionDefinition> defn = {}, bool hasSelf = false);
    FunctionType(
        TypeLevel level, Scope* scope, TypePackId argTypes, TypePackId retTypes, std::optional<FunctionDefinition> defn = {}, bool hasSelf = false);

    // Local polymorphic function
    FunctionType(TypeLevel level, std::vector<TypeId> generics, std::vector<TypePackId> genericPacks, TypePackId argTypes, TypePackId retTypes,
        std::optional<FunctionDefinition> defn = {}, bool hasSelf = false);
    FunctionType(TypeLevel level, Scope* scope, std::vector<TypeId> generics, std::vector<TypePackId> genericPacks, TypePackId argTypes,
        TypePackId retTypes, std::optional<FunctionDefinition> defn = {}, bool hasSelf = false);

    std::optional<FunctionDefinition> definition;
    /// These should all be generic
    std::vector<TypeId> generics;
    std::vector<TypePackId> genericPacks;
    std::vector<std::optional<FunctionArgument>> argNames;
    Tags tags;
    TypeLevel level;
    Scope* scope = nullptr;
    TypePackId argTypes;
    TypePackId retTypes;
    MagicFunction magicFunction = nullptr;
    DcrMagicFunction dcrMagicFunction = nullptr;
    DcrMagicRefinement dcrMagicRefinement = nullptr;
    bool hasSelf;
    // `hasNoFreeOrGenericTypes` should be true if and only if the type does not have any free or generic types present inside it.
    // this flag is used as an optimization to exit early from procedures that manipulate free or generic types.
    bool hasNoFreeOrGenericTypes = false;
    bool isCheckedFunction = false;
};

enum class TableState
{
    // Sealed tables have an exact, known shape
    Sealed,

    // An unsealed table can have extra properties added to it
    Unsealed,

    // Tables which are not yet fully understood.  We are still in the process of learning its shape.
    Free,

    // A table which is a generic parameter to a function.  We know that certain properties are required,
    // but we don't care about the full shape.
    Generic,
};

struct TableIndexer
{
    TableIndexer(TypeId indexType, TypeId indexResultType)
        : indexType(indexType)
        , indexResultType(indexResultType)
    {
    }

    TypeId indexType;
    TypeId indexResultType;
};

struct Property
{
    static Property readonly(TypeId ty);
    static Property writeonly(TypeId ty);
    static Property rw(TypeId ty);                 // Shared read-write type.
    static Property rw(TypeId read, TypeId write); // Separate read-write type.

    // Invariant: at least one of the two optionals are not nullopt!
    // If the read type is not nullopt, but the write type is, then the property is readonly.
    // If the read type is nullopt, but the write type is not, then the property is writeonly.
    // If the read and write types are not nullopt, then the property is read and write.
    // Otherwise, an assertion where read and write types are both nullopt will be tripped.
    static Property create(std::optional<TypeId> read, std::optional<TypeId> write);

    bool deprecated = false;
    std::string deprecatedSuggestion;

    // If this property was inferred from an expression, this field will be
    // populated with the source location of the corresponding table property.
    std::optional<Location> location = std::nullopt;

    // If this property was built from an explicit type annotation, this field
    // will be populated with the source location of that table property.
    std::optional<Location> typeLocation = std::nullopt;

    Tags tags;
    std::optional<std::string> documentationSymbol;

    // DEPRECATED
    // TODO: Kill all constructors in favor of `Property::rw(TypeId read, TypeId write)` and friends.
    Property();
    Property(TypeId readTy, bool deprecated = false, const std::string& deprecatedSuggestion = "", std::optional<Location> location = std::nullopt,
        const Tags& tags = {}, const std::optional<std::string>& documentationSymbol = std::nullopt,
        std::optional<Location> typeLocation = std::nullopt);

    // DEPRECATED: Should only be called in non-RWP! We assert that the `readTy` is not nullopt.
    // TODO: Kill once we don't have non-RWP.
    TypeId type() const;
    void setType(TypeId ty);

    // Sets the write type of this property to the read type.
    void makeShared();

    bool isShared() const;
    bool isReadOnly() const;
    bool isWriteOnly() const;
    bool isReadWrite() const;

    std::optional<TypeId> readTy;
    std::optional<TypeId> writeTy;
};

struct TableType
{
    // We choose std::map over unordered_map here just because we have unit tests that compare
    // textual outputs.  I don't want to spend the effort making them resilient in the case where
    // random events cause the iteration order of the map elements to change.
    // If this shows up in a profile, we can revisit it.
    using Props = std::map<Name, Property>;

    TableType() = default;
    explicit TableType(TableState state, TypeLevel level, Scope* scope = nullptr);
    TableType(const Props& props, const std::optional<TableIndexer>& indexer, TypeLevel level, TableState state);
    TableType(const Props& props, const std::optional<TableIndexer>& indexer, TypeLevel level, Scope* scope, TableState state);

    Props props;
    std::optional<TableIndexer> indexer;

    TableState state = TableState::Unsealed;
    TypeLevel level;
    Scope* scope = nullptr;
    std::optional<std::string> name;

    // Sometimes we throw a type on a name to make for nicer error messages, but without creating any entry in the type namespace
    // We need to know which is which when we stringify types.
    std::optional<std::string> syntheticName;

    std::vector<TypeId> instantiatedTypeParams;
    std::vector<TypePackId> instantiatedTypePackParams;
    ModuleName definitionModuleName;
    Location definitionLocation;

    std::optional<TypeId> boundTo;
    Tags tags;

    // Methods of this table that have an untyped self will use the same shared self type.
    std::optional<TypeId> selfTy;

    // We track the number of as-yet-unadded properties to unsealed tables.
    // Some constraints will use this information to decide whether or not they
    // are able to dispatch.
    size_t remainingProps = 0;
};

// Represents a metatable attached to a table type. Somewhat analogous to a bound type.
struct MetatableType
{
    // Should always be a TableType.
    TypeId table;
    // Should almost always either be a TableType or another MetatableType,
    // though it is possible for other types (like AnyType and ErrorType) to
    // find their way here sometimes.
    TypeId metatable;

    std::optional<std::string> syntheticName;
};

// Custom userdata of a class type
struct ClassUserData
{
    virtual ~ClassUserData() {}
};

/** The type of a class.
 *
 * Classes behave like tables in many ways, but there are some important differences:
 *
 * The properties of a class are always exactly known.
 * Classes optionally have a parent class.
 * Two different classes that share the same properties are nevertheless distinct and mutually incompatible.
 */
struct ClassType
{
    using Props = TableType::Props;

    Name name;
    Props props;
    std::optional<TypeId> parent;
    std::optional<TypeId> metatable; // metaclass?
    Tags tags;
    std::shared_ptr<ClassUserData> userData;
    ModuleName definitionModuleName;
    std::optional<TableIndexer> indexer;

    ClassType(Name name, Props props, std::optional<TypeId> parent, std::optional<TypeId> metatable, Tags tags,
        std::shared_ptr<ClassUserData> userData, ModuleName definitionModuleName)
        : name(name)
        , props(props)
        , parent(parent)
        , metatable(metatable)
        , tags(tags)
        , userData(userData)
        , definitionModuleName(definitionModuleName)
    {
    }

    ClassType(Name name, Props props, std::optional<TypeId> parent, std::optional<TypeId> metatable, Tags tags,
        std::shared_ptr<ClassUserData> userData, ModuleName definitionModuleName, std::optional<TableIndexer> indexer)
        : name(name)
        , props(props)
        , parent(parent)
        , metatable(metatable)
        , tags(tags)
        , userData(userData)
        , definitionModuleName(definitionModuleName)
        , indexer(indexer)
    {
    }
};

/**
 * An instance of a type function that has not yet been reduced to a more concrete
 * type. The constraint solver receives a constraint to reduce each
 * TypeFunctionInstanceType to a concrete type. A design detail is important to
 * note here: the parameters for this instantiation of the type function are
 * contained within this type, so that they can be substituted.
 */
struct TypeFunctionInstanceType
{
    NotNull<const TypeFunction> family;

    std::vector<TypeId> typeArguments;
    std::vector<TypePackId> packArguments;

    TypeFunctionInstanceType(NotNull<const TypeFunction> family, std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments)
        : family(family)
        , typeArguments(typeArguments)
        , packArguments(packArguments)
    {
    }

    TypeFunctionInstanceType(const TypeFunction& family, std::vector<TypeId> typeArguments)
        : family{&family}
        , typeArguments(typeArguments)
        , packArguments{}
    {
    }

    TypeFunctionInstanceType(const TypeFunction& family, std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments)
        : family{&family}
        , typeArguments(typeArguments)
        , packArguments(packArguments)
    {
    }
};

/** Represents a pending type alias instantiation.
 *
 * In order to afford (co)recursive type aliases, we need to reason about a
 * partially-complete instantiation. This requires encoding more information in
 * a type variable than a BlockedType affords, hence this. Each
 * PendingExpansionType has a corresponding TypeAliasExpansionConstraint
 * enqueued in the solver to convert it to an actual instantiated type
 */
struct PendingExpansionType
{
    PendingExpansionType(std::optional<AstName> prefix, AstName name, std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments);
    std::optional<AstName> prefix;
    AstName name;
    std::vector<TypeId> typeArguments;
    std::vector<TypePackId> packArguments;
    size_t index;

    static size_t nextIndex;
};

// Anything!  All static checking is off.
struct AnyType
{
};

// `T | U`
struct UnionType
{
    std::vector<TypeId> options;
};

// `T & U`
struct IntersectionType
{
    std::vector<TypeId> parts;
};

struct LazyType
{
    LazyType() = default;
    LazyType(std::function<void(LazyType&)> unwrap)
        : unwrap(unwrap)
    {
    }

    // std::atomic is sad and requires a manual copy
    LazyType(const LazyType& rhs)
        : unwrap(rhs.unwrap)
        , unwrapped(rhs.unwrapped.load())
    {
    }

    LazyType(LazyType&& rhs) noexcept
        : unwrap(std::move(rhs.unwrap))
        , unwrapped(rhs.unwrapped.load())
    {
    }

    LazyType& operator=(const LazyType& rhs)
    {
        unwrap = rhs.unwrap;
        unwrapped = rhs.unwrapped.load();

        return *this;
    }

    LazyType& operator=(LazyType&& rhs) noexcept
    {
        unwrap = std::move(rhs.unwrap);
        unwrapped = rhs.unwrapped.load();

        return *this;
    }

    std::function<void(LazyType&)> unwrap;
    std::atomic<TypeId> unwrapped = nullptr;
};

struct UnknownType
{
};

struct NeverType
{
};

// `~T`
struct NegationType
{
    TypeId ty;
};

using ErrorType = Unifiable::Error;

using TypeVariant =
    Unifiable::Variant<TypeId, FreeType, GenericType, PrimitiveType, SingletonType, BlockedType, PendingExpansionType, FunctionType, TableType,
        MetatableType, ClassType, AnyType, UnionType, IntersectionType, LazyType, UnknownType, NeverType, NegationType, TypeFunctionInstanceType>;

struct Type final
{
    explicit Type(const TypeVariant& ty)
        : ty(ty)
    {
    }

    explicit Type(TypeVariant&& ty)
        : ty(std::move(ty))
    {
    }

    Type(const TypeVariant& ty, bool persistent)
        : ty(ty)
        , persistent(persistent)
    {
    }

    // Re-assignes the content of the type, but doesn't change the owning arena and can't make type persistent.
    void reassign(const Type& rhs)
    {
        ty = rhs.ty;
        documentationSymbol = rhs.documentationSymbol;
    }

    TypeVariant ty;

    // Kludge: A persistent Type is one that belongs to the global scope.
    // Global type bindings are immutable but are reused many times.
    // Persistent Types do not get cloned.
    bool persistent = false;

    std::optional<std::string> documentationSymbol;

    // Pointer to the type arena that allocated this type.
    TypeArena* owningArena = nullptr;

    bool operator==(const Type& rhs) const;
    bool operator!=(const Type& rhs) const;

    Type& operator=(const TypeVariant& rhs);
    Type& operator=(TypeVariant&& rhs);

    Type& operator=(const Type& rhs);
};

struct GenericTypeDefinition
{
    TypeId ty;
    std::optional<TypeId> defaultValue;

    bool operator==(const GenericTypeDefinition& rhs) const;
};

struct GenericTypePackDefinition
{
    TypePackId tp;
    std::optional<TypePackId> defaultValue;

    bool operator==(const GenericTypePackDefinition& rhs) const;
};

struct TypeFun
{
    // These should all be generic
    std::vector<GenericTypeDefinition> typeParams;
    std::vector<GenericTypePackDefinition> typePackParams;

    /** The underlying type.
     *
     * WARNING!  This is not safe to use as a type if typeParams is not empty!!
     * You must first use TypeChecker::instantiateTypeFun to turn it into a real type.
     */
    TypeId type;

    TypeFun() = default;

    explicit TypeFun(TypeId ty)
        : type(ty)
    {
    }

    TypeFun(std::vector<GenericTypeDefinition> typeParams, TypeId type)
        : typeParams(std::move(typeParams))
        , type(type)
    {
    }

    TypeFun(std::vector<GenericTypeDefinition> typeParams, std::vector<GenericTypePackDefinition> typePackParams, TypeId type)
        : typeParams(std::move(typeParams))
        , typePackParams(std::move(typePackParams))
        , type(type)
    {
    }

    bool operator==(const TypeFun& rhs) const;
};

using SeenSet = std::set<std::pair<const void*, const void*>>;
bool areEqual(SeenSet& seen, const Type& lhs, const Type& rhs);

enum class FollowOption
{
    Normal,
    DisableLazyTypeThunks,
};

// Follow BoundTypes until we get to something real
TypeId follow(TypeId t);
TypeId follow(TypeId t, FollowOption followOption);
TypeId follow(TypeId t, const void* context, TypeId (*mapper)(const void*, TypeId));
TypeId follow(TypeId t, FollowOption followOption, const void* context, TypeId (*mapper)(const void*, TypeId));

std::vector<TypeId> flattenIntersection(TypeId ty);

bool isPrim(TypeId ty, PrimitiveType::Type primType);
bool isNil(TypeId ty);
bool isBoolean(TypeId ty);
bool isNumber(TypeId ty);
bool isString(TypeId ty);
bool isThread(TypeId ty);
bool isBuffer(TypeId ty);
bool isOptional(TypeId ty);
bool isTableIntersection(TypeId ty);
bool isTableUnion(TypeId ty);
bool isOverloadedFunction(TypeId ty);

// True when string is a subtype of ty
bool maybeString(TypeId ty);

std::optional<TypeId> getMetatable(TypeId type, NotNull<struct BuiltinTypes> builtinTypes);
TableType* getMutableTableType(TypeId type);
const TableType* getTableType(TypeId type);

// If the type has a name, return that.  Else if it has a synthetic name, return that.
// Returns nullptr if the type has no name.
const std::string* getName(TypeId type);

// Returns name of the module where type was defined if type has that information
std::optional<ModuleName> getDefinitionModuleName(TypeId type);

// Checks whether a union contains all types of another union.
bool isSubset(const UnionType& super, const UnionType& sub);

// Checks if a type contains generic type binders
bool isGeneric(const TypeId ty);

// Checks if a type may be instantiated to one containing generic type binders
bool maybeGeneric(const TypeId ty);

// Checks if a type is of the form T1|...|Tn where one of the Ti is a singleton
bool maybeSingleton(TypeId ty);

// Checks if the length operator can be applied on the value of type
bool hasLength(TypeId ty, DenseHashSet<TypeId>& seen, int* recursionCount);

struct BuiltinTypes
{
    BuiltinTypes();
    ~BuiltinTypes();
    BuiltinTypes(const BuiltinTypes&) = delete;
    void operator=(const BuiltinTypes&) = delete;

    TypeId errorRecoveryType(TypeId guess) const;
    TypePackId errorRecoveryTypePack(TypePackId guess) const;
    TypeId errorRecoveryType() const;
    TypePackId errorRecoveryTypePack() const;

    friend TypeId makeStringMetatable(NotNull<BuiltinTypes> builtinTypes);
    friend struct GlobalTypes;

private:
    std::unique_ptr<struct TypeArena> arena;
    bool debugFreezeArena = false;

public:
    const TypeId nilType;
    const TypeId numberType;
    const TypeId stringType;
    const TypeId booleanType;
    const TypeId threadType;
    const TypeId bufferType;
    const TypeId functionType;
    const TypeId classType;
    const TypeId tableType;
    const TypeId emptyTableType;
    const TypeId trueType;
    const TypeId falseType;
    const TypeId anyType;
    const TypeId unknownType;
    const TypeId neverType;
    const TypeId errorType;
    const TypeId falsyType;
    const TypeId truthyType;

    const TypeId optionalNumberType;
    const TypeId optionalStringType;

    const TypePackId emptyTypePack;
    const TypePackId anyTypePack;
    const TypePackId unknownTypePack;
    const TypePackId neverTypePack;
    const TypePackId uninhabitableTypePack;
    const TypePackId errorTypePack;
};

void persist(TypeId ty);
void persist(TypePackId tp);

const TypeLevel* getLevel(TypeId ty);
TypeLevel* getMutableLevel(TypeId ty);

std::optional<TypeLevel> getLevel(TypePackId tp);

const Property* lookupClassProp(const ClassType* cls, const Name& name);

// Whether `cls` is a subclass of `parent`
bool isSubclass(const ClassType* cls, const ClassType* parent);

Type* asMutable(TypeId ty);

template<typename... Ts, typename T>
bool is(T&& tv)
{
    if (!tv)
        return false;

    if constexpr (std::is_same_v<TypeId, T> && !(std::is_same_v<BoundType, Ts> || ...))
        LUAU_ASSERT(get_if<BoundType>(&tv->ty) == nullptr);

    return (get<Ts>(tv) || ...);
}

template<typename T>
const T* get(TypeId tv)
{
    LUAU_ASSERT(tv);

    if constexpr (!std::is_same_v<T, BoundType>)
        LUAU_ASSERT(get_if<BoundType>(&tv->ty) == nullptr);

    return get_if<T>(&tv->ty);
}

template<typename T>
T* getMutable(TypeId tv)
{
    LUAU_ASSERT(tv);

    if constexpr (!std::is_same_v<T, BoundType>)
        LUAU_ASSERT(get_if<BoundType>(&tv->ty) == nullptr);

    return get_if<T>(&asMutable(tv)->ty);
}

const std::vector<TypeId>& getTypes(const UnionType* utv);
const std::vector<TypeId>& getTypes(const IntersectionType* itv);

template<typename T>
struct TypeIterator;

using UnionTypeIterator = TypeIterator<UnionType>;
UnionTypeIterator begin(const UnionType* utv);
UnionTypeIterator end(const UnionType* utv);

using IntersectionTypeIterator = TypeIterator<IntersectionType>;
IntersectionTypeIterator begin(const IntersectionType* itv);
IntersectionTypeIterator end(const IntersectionType* itv);

/* Traverses the type T yielding each TypeId.
 * If the iterator encounters a nested type T, it will instead yield each TypeId within.
 */
template<typename T>
struct TypeIterator
{
    using value_type = Luau::TypeId;
    using pointer = value_type*;
    using reference = value_type&;
    using difference_type = size_t;
    using iterator_category = std::input_iterator_tag;

    explicit TypeIterator(const T* t)
    {
        LUAU_ASSERT(t);

        const std::vector<TypeId>& types = getTypes(t);
        if (!types.empty())
            stack.push_front({t, 0});

        seen.insert(t);
        descend();
    }

    TypeIterator<T>& operator++()
    {
        advance();
        descend();
        return *this;
    }

    TypeIterator<T> operator++(int)
    {
        TypeIterator<T> copy = *this;
        ++*this;
        return copy;
    }

    bool operator==(const TypeIterator<T>& rhs) const
    {
        if (!stack.empty() && !rhs.stack.empty())
            return stack.front() == rhs.stack.front();

        return stack.empty() && rhs.stack.empty();
    }

    bool operator!=(const TypeIterator<T>& rhs) const
    {
        return !(*this == rhs);
    }

    TypeId operator*()
    {
        descend();

        LUAU_ASSERT(!stack.empty());

        auto [t, currentIndex] = stack.front();
        LUAU_ASSERT(t);

        const std::vector<TypeId>& types = getTypes(t);
        LUAU_ASSERT(currentIndex < types.size());

        TypeId ty = follow(types[currentIndex]);
        LUAU_ASSERT(!get<T>(ty));

        return ty;
    }

    // Normally, we'd have `begin` and `end` be a template but there's too much trouble
    // with templates portability in this area, so not worth it. Thanks MSVC.
    friend UnionTypeIterator end(const UnionType*);
    friend IntersectionTypeIterator end(const IntersectionType*);

private:
    TypeIterator() = default;

    // (T* t, size_t currentIndex)
    using SavedIterInfo = std::pair<const T*, size_t>;

    VecDeque<SavedIterInfo> stack;
    DenseHashSet<const T*> seen{nullptr}; // Only needed to protect the iterator from hanging the thread.

    void advance()
    {
        while (!stack.empty())
        {
            auto& [t, currentIndex] = stack.front();
            ++currentIndex;

            const std::vector<TypeId>& types = getTypes(t);
            if (currentIndex >= types.size())
                stack.pop_front();
            else
                break;
        }
    }

    void descend()
    {
        while (!stack.empty())
        {
            auto [current, currentIndex] = stack.front();
            const std::vector<TypeId>& types = getTypes(current);
            if (auto inner = get<T>(follow(types[currentIndex])))
            {
                // If we're about to descend into a cyclic type, we should skip over this.
                // Ideally this should never happen, but alas it does from time to time. :(
                if (seen.contains(inner))
                    advance();
                else
                {
                    seen.insert(inner);
                    stack.push_front({inner, 0});
                }

                continue;
            }

            break;
        }
    }
};

TypeId freshType(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes, Scope* scope);

using TypeIdPredicate = std::function<std::optional<TypeId>(TypeId)>;
std::vector<TypeId> filterMap(TypeId type, TypeIdPredicate predicate);

void attachTag(TypeId ty, const std::string& tagName);
void attachTag(Property& prop, const std::string& tagName);

bool hasTag(TypeId ty, const std::string& tagName);
bool hasTag(const Property& prop, const std::string& tagName);
bool hasTag(const Tags& tags, const std::string& tagName); // Do not use in new work.

template<typename T>
bool hasTypeInIntersection(TypeId ty)
{
    TypeId tf = follow(ty);
    if (get<T>(tf))
        return true;
    for (auto t : flattenIntersection(tf))
        if (get<T>(follow(t)))
            return true;
    return false;
}

bool hasPrimitiveTypeInIntersection(TypeId ty, PrimitiveType::Type primTy);
/*
 * Use this to change the kind of a particular type.
 *
 * LUAU_NOINLINE so that the calling frame doesn't have to pay the stack storage for the new variant.
 */
template<typename T, typename... Args>
LUAU_NOINLINE T* emplaceType(Type* ty, Args&&... args)
{
    return &ty->ty.emplace<T>(std::forward<Args>(args)...);
}

template<>
LUAU_NOINLINE Unifiable::Bound<TypeId>* emplaceType<BoundType>(Type* ty, TypeId& tyArg);

} // namespace Luau

#line __LINE__ "Luau/TypeArena.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypePack.h>

#line __LINE__ "Luau/TypePack.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <set>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

struct TypeArena;
struct TypePackFunction;
struct TxnLog;

struct TypePack;
struct VariadicTypePack;
struct BlockedTypePack;
struct TypeFunctionInstanceTypePack;

struct FreeTypePack
{
    explicit FreeTypePack(TypeLevel level);
    explicit FreeTypePack(Scope* scope);
    FreeTypePack(Scope* scope, TypeLevel level);

    int index;
    TypeLevel level;
    Scope* scope = nullptr;
};

struct GenericTypePack
{
    // By default, generics are global, with a synthetic name
    GenericTypePack();
    explicit GenericTypePack(TypeLevel level);
    explicit GenericTypePack(const Name& name);
    explicit GenericTypePack(Scope* scope);
    GenericTypePack(TypeLevel level, const Name& name);
    GenericTypePack(Scope* scope, const Name& name);

    int index;
    TypeLevel level;
    Scope* scope = nullptr;
    Name name;
    bool explicitName = false;
};

using BoundTypePack = Unifiable::Bound<TypePackId>;
using ErrorTypePack = Unifiable::Error;

using TypePackVariant =
    Unifiable::Variant<TypePackId, FreeTypePack, GenericTypePack, TypePack, VariadicTypePack, BlockedTypePack, TypeFunctionInstanceTypePack>;

/* A TypePack is a rope-like string of TypeIds.  We use this structure to encode
 * notions like packs of unknown length and packs of any length, as well as more
 * nuanced compositions like "a pack which is a number prepended to this other pack,"
 * or "a pack that is 2 numbers followed by any number of any other types."
 */
struct TypePack
{
    std::vector<TypeId> head;
    std::optional<TypePackId> tail;
};

struct VariadicTypePack
{
    TypeId ty;
    bool hidden = false; // if true, we don't display this when toString()ing a pack with this variadic as its tail.
};

/**
 * Analogous to a BlockedType.
 */
struct BlockedTypePack
{
    BlockedTypePack();
    size_t index;

    struct Constraint* owner = nullptr;

    static size_t nextIndex;
};

/**
 * Analogous to a TypeFunctionInstanceType.
 */
struct TypeFunctionInstanceTypePack
{
    NotNull<const TypePackFunction> family;

    std::vector<TypeId> typeArguments;
    std::vector<TypePackId> packArguments;
};

struct TypePackVar
{
    explicit TypePackVar(const TypePackVariant& ty);
    explicit TypePackVar(TypePackVariant&& ty);
    TypePackVar(TypePackVariant&& ty, bool persistent);

    bool operator==(const TypePackVar& rhs) const;

    TypePackVar& operator=(TypePackVariant&& tp);

    TypePackVar& operator=(const TypePackVar& rhs);

    // Re-assignes the content of the pack, but doesn't change the owning arena and can't make pack persistent.
    void reassign(const TypePackVar& rhs)
    {
        ty = rhs.ty;
    }

    TypePackVariant ty;

    bool persistent = false;

    // Pointer to the type arena that allocated this pack.
    TypeArena* owningArena = nullptr;
};

/* Walk the set of TypeIds in a TypePack.
 *
 * Like Types, individual TypePacks can be free, generic, or any.
 *
 * We afford the ability to work with these kinds of packs by giving the
 * iterator a .tail() property that yields the tail-most TypePack in the
 * rope.
 *
 * It is very commonplace to want to walk each type in a pack, then handle
 * the tail specially.  eg when checking parameters, it might be the case
 * that the parameter pack ends with a VariadicTypePack.  In this case, we
 * want to allow any number of extra arguments.
 *
 * The iterator obtained by calling end(tp) does not have a .tail(), but is
 * equivalent with end(tp2) for any two type packs.
 */
struct TypePackIterator
{
    using value_type = Luau::TypeId;
    using pointer = value_type*;
    using reference = value_type&;
    using difference_type = size_t;
    using iterator_category = std::input_iterator_tag;

    TypePackIterator() = default;
    explicit TypePackIterator(TypePackId tp);
    TypePackIterator(TypePackId tp, const TxnLog* log);

    TypePackIterator& operator++();
    TypePackIterator operator++(int);
    bool operator!=(const TypePackIterator& rhs);
    bool operator==(const TypePackIterator& rhs);

    const TypeId& operator*();

    /** Return the tail of a TypePack.
     * This may *only* be called on an iterator that has been incremented to the end.
     * Returns nullopt if the pack has fixed length.
     */
    std::optional<TypePackId> tail();

    friend TypePackIterator end(TypePackId tp);

private:
    TypePackId currentTypePack = nullptr;
    const TypePack* tp = nullptr;
    size_t currentIndex = 0;

    const TxnLog* log;
};

TypePackIterator begin(TypePackId tp);
TypePackIterator begin(TypePackId tp, const TxnLog* log);
TypePackIterator end(TypePackId tp);

using SeenSet = std::set<std::pair<const void*, const void*>>;

bool areEqual(SeenSet& seen, const TypePackVar& lhs, const TypePackVar& rhs);

TypePackId follow(TypePackId tp);
TypePackId follow(TypePackId t, const void* context, TypePackId (*mapper)(const void*, TypePackId));

size_t size(TypePackId tp, TxnLog* log = nullptr);
bool finite(TypePackId tp, TxnLog* log = nullptr);
size_t size(const TypePack& tp, TxnLog* log = nullptr);
std::optional<TypeId> first(TypePackId tp, bool ignoreHiddenVariadics = true);

TypePackVar* asMutable(TypePackId tp);
TypePack* asMutable(const TypePack* tp);

template<typename T>
const T* get(TypePackId tp)
{
    LUAU_ASSERT(tp);

    if constexpr (!std::is_same_v<T, BoundTypePack>)
        LUAU_ASSERT(get_if<BoundTypePack>(&tp->ty) == nullptr);

    return get_if<T>(&(tp->ty));
}

template<typename T>
T* getMutable(TypePackId tp)
{
    LUAU_ASSERT(tp);

    if constexpr (!std::is_same_v<T, BoundTypePack>)
        LUAU_ASSERT(get_if<BoundTypePack>(&tp->ty) == nullptr);

    return get_if<T>(&(asMutable(tp)->ty));
}

/// Returns true if the type pack is known to be empty (no types in the head and no/an empty tail).
bool isEmpty(TypePackId tp);

/// Flattens out a type pack.  Also returns a valid TypePackId tail if the type pack's full size is not known
std::pair<std::vector<TypeId>, std::optional<TypePackId>> flatten(TypePackId tp);
std::pair<std::vector<TypeId>, std::optional<TypePackId>> flatten(TypePackId tp, const TxnLog& log);

/// Returs true if the type pack arose from a function that is declared to be variadic.
/// Returns *false* for function argument packs that are inferred to be safe to oversaturate!
bool isVariadic(TypePackId tp);
bool isVariadic(TypePackId tp, const TxnLog& log);

// Returns true if the TypePack is Generic or Variadic.  Does not walk TypePacks!!
bool isVariadicTail(TypePackId tp, const TxnLog& log, bool includeHiddenVariadics = false);

bool containsNever(TypePackId tp);

/*
 * Use this to change the kind of a particular type pack.
 *
 * LUAU_NOINLINE so that the calling frame doesn't have to pay the stack storage for the new variant.
 */
template<typename T, typename... Args>
LUAU_NOINLINE T* emplaceTypePack(TypePackVar* ty, Args&&... args)
{
    return &ty->ty.emplace<T>(std::forward<Args>(args)...);
}

template<>
LUAU_NOINLINE Unifiable::Bound<TypePackId>* emplaceTypePack<BoundTypePack>(TypePackVar* ty, TypePackId& tyArg);

} // namespace Luau

#line __LINE__ "Luau/TypeArena.h"

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{
struct Module;

struct TypeArena
{
    TypedAllocator<Type> types;
    TypedAllocator<TypePackVar> typePacks;

    // Owning module, if any
    Module* owningModule = nullptr;

    void clear();

    template<typename T>
    TypeId addType(T tv)
    {
        if constexpr (std::is_same_v<T, UnionType>)
            LUAU_ASSERT(tv.options.size() >= 2);

        return addTV(Type(std::move(tv)));
    }

    TypeId addTV(Type&& tv);

    TypeId freshType(TypeLevel level);
    TypeId freshType(Scope* scope);
    TypeId freshType(Scope* scope, TypeLevel level);

    TypePackId freshTypePack(Scope* scope);

    TypePackId addTypePack(std::initializer_list<TypeId> types);
    TypePackId addTypePack(std::vector<TypeId> types, std::optional<TypePackId> tail = {});
    TypePackId addTypePack(TypePack pack);
    TypePackId addTypePack(TypePackVar pack);

    template<typename T>
    TypePackId addTypePack(T tp)
    {
        return addTypePack(TypePackVar(std::move(tp)));
    }

    TypeId addTypeFunction(const TypeFunction& family, std::initializer_list<TypeId> types);
    TypeId addTypeFunction(const TypeFunction& family, std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments = {});
    TypePackId addTypePackFunction(const TypePackFunction& family, std::initializer_list<TypeId> types);
    TypePackId addTypePackFunction(const TypePackFunction& family, std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments = {});
};

void freeze(TypeArena& arena);
void unfreeze(TypeArena& arena);

} // namespace Luau

#line __LINE__ "Luau/Substitution.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// We provide an implementation of substitution on types,
// which recursively replaces types by other types.
// Examples include quantification (replacing free types by generics)
// and instantiation (replacing generic types by free ones).
//
// To implement a substitution, implement a subclass of `Substitution`
// and provide implementations of `isDirty` (which should be true for types that
// should be replaced) and `clean` which replaces any dirty types.
//
// struct MySubst : Substitution
// {
//     bool isDirty(TypeId ty) override { ... }
//     bool isDirty(TypePackId tp) override { ... }
//     TypeId clean(TypeId ty) override { ... }
//     TypePackId clean(TypePackId tp) override { ... }
//     bool ignoreChildren(TypeId ty) override { ... }
//     bool ignoreChildren(TypePackId tp) override { ... }
// };
//
// For example, `Instantiation` in `TypeInfer.cpp` uses this.

// The implementation of substitution tries not to copy types
// unnecessarily. It first finds all the types which can reach
// a dirty type, and either cleans them (if they are dirty)
// or clones them (if they are not). It then updates the children
// of the newly created types. When considering reachability,
// we do not consider the children of any type where ignoreChildren(ty) is true.

// There is a gotcha for cyclic types, which means we can't just use
// a straightforward DFS. For example:
//
// type T = { f : () -> T, g: () -> number, h: X }
//
// If X is dirty, and is being replaced by X' then the result should be:
//
// type T' = { f : () -> T', g: () -> number, h: X' }
//
// that is the type of `f` is replaced, but the type of `g` is not.
//
// For this reason, we first use Tarjan's algorithm to find strongly
// connected components. If any type in an SCC can reach a dirty type,
// them the whole SCC can. For instance, in the above example,
// `T`, and the type of `f` are in the same SCC, which is why `f` gets
// replaced.

namespace Luau
{

struct TxnLog;

enum class TarjanResult
{
    TooManyChildren,
    Ok
};

struct TarjanWorklistVertex
{
    int index;
    int currEdge;
    int lastEdge;
};

struct TarjanNode
{
    TypeId ty;
    TypePackId tp;

    bool onStack;
    bool dirty;

    // Tarjan calculates the lowlink for each vertex,
    // which is the lowest ancestor index reachable from the vertex.
    int lowlink;
};

// Tarjan's algorithm for finding the SCCs in a cyclic structure.
// https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
struct Tarjan
{
    Tarjan();

    // Vertices (types and type packs) are indexed, using pre-order traversal.
    DenseHashMap<TypeId, int> typeToIndex{nullptr};
    DenseHashMap<TypePackId, int> packToIndex{nullptr};

    std::vector<TarjanNode> nodes;

    // Tarjan keeps a stack of vertices where we're still in the process
    // of finding their SCC.
    std::vector<int> stack;

    int childCount = 0;
    int childLimit = 0;

    // This should never be null; ensure you initialize it before calling
    // substitution methods.
    const TxnLog* log = nullptr;

    std::vector<TypeId> edgesTy;
    std::vector<TypePackId> edgesTp;
    std::vector<TarjanWorklistVertex> worklist;

    // This is hot code, so we optimize recursion to a stack.
    TarjanResult loop();

    // Find or create the index for a vertex.
    // Return a boolean which is `true` if it's a freshly created index.
    std::pair<int, bool> indexify(TypeId ty);
    std::pair<int, bool> indexify(TypePackId tp);

    // Recursively visit all the children of a vertex
    void visitChildren(TypeId ty, int index);
    void visitChildren(TypePackId tp, int index);

    void visitChild(TypeId ty);
    void visitChild(TypePackId ty);

    template<typename Ty>
    void visitChild(std::optional<Ty> ty)
    {
        if (ty)
            visitChild(*ty);
    }

    // Visit the root vertex.
    TarjanResult visitRoot(TypeId ty);
    TarjanResult visitRoot(TypePackId ty);

    // Used to reuse the object for a new operation
    void clearTarjan(const TxnLog* log);

    // Get/set the dirty bit for an index (grows the vector if needed)
    bool getDirty(int index);
    void setDirty(int index, bool d);

    // Find all the dirty vertices reachable from `t`.
    TarjanResult findDirty(TypeId t);
    TarjanResult findDirty(TypePackId t);

    // We find dirty vertices using Tarjan
    void visitEdge(int index, int parentIndex);
    void visitSCC(int index);

    // Each subclass can decide to ignore some nodes.
    virtual bool ignoreChildren(TypeId ty)
    {
        return false;
    }

    virtual bool ignoreChildren(TypePackId ty)
    {
        return false;
    }

    // Some subclasses might ignore children visit, but not other actions like replacing the children
    virtual bool ignoreChildrenVisit(TypeId ty)
    {
        return ignoreChildren(ty);
    }

    virtual bool ignoreChildrenVisit(TypePackId ty)
    {
        return ignoreChildren(ty);
    }

    // Subclasses should say which vertices are dirty,
    // and what to do with dirty vertices.
    virtual bool isDirty(TypeId ty) = 0;
    virtual bool isDirty(TypePackId tp) = 0;
    virtual void foundDirty(TypeId ty) = 0;
    virtual void foundDirty(TypePackId tp) = 0;
};

// And finally substitution, which finds all the reachable dirty vertices
// and replaces them with clean ones.
struct Substitution : Tarjan
{
protected:
    Substitution(const TxnLog* log_, TypeArena* arena);

    /*
     * By default, Substitution assumes that the types produced by clean() are
     * freshly allocated types that are safe to mutate.
     *
     * If your clean() implementation produces a type that is not safe to
     * mutate, you must call dontTraverseInto on this type (or type pack) to
     * prevent Substitution from attempting to perform substitutions within the
     * cleaned type.
     *
     * See the test weird_cyclic_instantiation for an example.
     */
    void dontTraverseInto(TypeId ty);
    void dontTraverseInto(TypePackId tp);

public:
    TypeArena* arena;
    DenseHashMap<TypeId, TypeId> newTypes{nullptr};
    DenseHashMap<TypePackId, TypePackId> newPacks{nullptr};
    DenseHashSet<TypeId> replacedTypes{nullptr};
    DenseHashSet<TypePackId> replacedTypePacks{nullptr};

    DenseHashSet<TypeId> noTraverseTypes{nullptr};
    DenseHashSet<TypePackId> noTraverseTypePacks{nullptr};

    std::optional<TypeId> substitute(TypeId ty);
    std::optional<TypePackId> substitute(TypePackId tp);

    void resetState(const TxnLog* log, TypeArena* arena);

    TypeId replace(TypeId ty);
    TypePackId replace(TypePackId tp);

    void replaceChildren(TypeId ty);
    void replaceChildren(TypePackId tp);

    TypeId clone(TypeId ty);
    TypePackId clone(TypePackId tp);

    // Substitutions use Tarjan to find dirty nodes and replace them
    void foundDirty(TypeId ty) override;
    void foundDirty(TypePackId tp) override;

    // Implementing subclasses define how to clean a dirty type.
    virtual TypeId clean(TypeId ty) = 0;
    virtual TypePackId clean(TypePackId tp) = 0;

    // Helper functions to create new types (used by subclasses)
    template<typename T>
    TypeId addType(const T& tv)
    {
        return arena->addType(tv);
    }

    template<typename T>
    TypePackId addTypePack(const T& tp)
    {
        return arena->addTypePack(TypePackVar{tp});
    }

private:
    template<typename Ty>
    std::optional<Ty> replace(std::optional<Ty> ty)
    {
        if (ty)
            return replace(*ty);
        else
            return std::nullopt;
    }
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/ApplyTypeFunction.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TxnLog.h>

#line __LINE__ "Luau/TxnLog.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <unordered_map>

namespace Luau
{

using TypeOrPackId = const void*;

// Pending state for a Type. Generated by a TxnLog and committed via
// TxnLog::commit.
struct PendingType
{
    // The pending Type state.
    Type pending;

    // On very rare occasions, we need to delete an entry from the TxnLog.
    // DenseHashMap does not afford that so we note its deadness here.
    bool dead = false;

    explicit PendingType(Type state)
        : pending(std::move(state))
    {
    }
};

std::string toString(PendingType* pending);
std::string dump(PendingType* pending);

// Pending state for a TypePackVar. Generated by a TxnLog and committed via
// TxnLog::commit.
struct PendingTypePack
{
    // The pending TypePackVar state.
    TypePackVar pending;

    explicit PendingTypePack(TypePackVar state)
        : pending(std::move(state))
    {
    }
};

std::string toString(PendingTypePack* pending);
std::string dump(PendingTypePack* pending);

template<typename T>
T* getMutable(PendingType* pending)
{
    // We use getMutable here because this state is intended to be mutated freely.
    return getMutable<T>(&pending->pending);
}

template<typename T>
T* getMutable(PendingTypePack* pending)
{
    // We use getMutable here because this state is intended to be mutated freely.
    return getMutable<T>(&pending->pending);
}

// Log of what TypeIds we are rebinding, to be committed later.
struct TxnLog
{
    explicit TxnLog(bool useScopes = false)
        : typeVarChanges(nullptr)
        , typePackChanges(nullptr)
        , ownedSeen()
        , useScopes(useScopes)
        , sharedSeen(&ownedSeen)
    {
    }

    explicit TxnLog(TxnLog* parent)
        : typeVarChanges(nullptr)
        , typePackChanges(nullptr)
        , parent(parent)
    {
        if (parent)
        {
            sharedSeen = parent->sharedSeen;
        }
        else
        {
            sharedSeen = &ownedSeen;
        }
    }

    explicit TxnLog(std::vector<std::pair<TypeOrPackId, TypeOrPackId>>* sharedSeen)
        : typeVarChanges(nullptr)
        , typePackChanges(nullptr)
        , sharedSeen(sharedSeen)
    {
    }

    TxnLog(const TxnLog&) = delete;
    TxnLog& operator=(const TxnLog&) = delete;

    TxnLog(TxnLog&&) = default;
    TxnLog& operator=(TxnLog&&) = default;

    // Gets an empty TxnLog pointer. This is useful for constructs that
    // take a TxnLog, like TypePackIterator - use the empty log if you
    // don't have a TxnLog to give it.
    static const TxnLog* empty();

    // Joins another TxnLog onto this one. You should use std::move to avoid
    // copying the rhs TxnLog.
    //
    // If both logs talk about the same type, pack, or table, the rhs takes
    // priority.
    void concat(TxnLog rhs);
    void concatAsIntersections(TxnLog rhs, NotNull<TypeArena> arena);
    void concatAsUnion(TxnLog rhs, NotNull<TypeArena> arena);

    // Commits the TxnLog, rebinding all type pointers to their pending states.
    // Clears the TxnLog afterwards.
    void commit();

    // Clears the TxnLog without committing any pending changes.
    void clear();

    // Computes an inverse of this TxnLog at the current time.
    // This method should be called before commit is called in order to give an
    // accurate result. Committing the inverse of a TxnLog will undo the changes
    // made by commit, assuming the inverse log is accurate.
    TxnLog inverse();

    bool haveSeen(TypeId lhs, TypeId rhs) const;
    void pushSeen(TypeId lhs, TypeId rhs);
    void popSeen(TypeId lhs, TypeId rhs);

    bool haveSeen(TypePackId lhs, TypePackId rhs) const;
    void pushSeen(TypePackId lhs, TypePackId rhs);
    void popSeen(TypePackId lhs, TypePackId rhs);

    // Queues a type for modification. The original type will not change until commit
    // is called. Use pending to get the pending state.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* queue(TypeId ty);

    // Queues a type pack for modification. The original type pack will not change
    // until commit is called. Use pending to get the pending state.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingTypePack* queue(TypePackId tp);

    // Returns the pending state of a type, or nullptr if there isn't any. It is important
    // to note that this pending state is not transitive: the pending state may reference
    // non-pending types freely, so you may need to call pending multiple times to view the
    // entire pending state of a type graph.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* pending(TypeId ty) const;

    // Returns the pending state of a type pack, or nullptr if there isn't any. It is
    // important to note that this pending state is not transitive: the pending state may
    // reference non-pending types freely, so you may need to call pending multiple times
    // to view the entire pending state of a type graph.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingTypePack* pending(TypePackId tp) const;

    // Queues a replacement of a type with another type.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* replace(TypeId ty, Type replacement);

    // Queues a replacement of a type pack with another type pack.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingTypePack* replace(TypePackId tp, TypePackVar replacement);

    // Queues a replacement of a table type with another table type that is bound
    // to a specific value.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* bindTable(TypeId ty, std::optional<TypeId> newBoundTo);

    // Queues a replacement of a type with a level with a duplicate of that type
    // with a new type level.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* changeLevel(TypeId ty, TypeLevel newLevel);

    // Queues a replacement of a type pack with a level with a duplicate of that
    // type pack with a new type level.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingTypePack* changeLevel(TypePackId tp, TypeLevel newLevel);

    // Queues the replacement of a type's scope with the provided scope.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* changeScope(TypeId ty, NotNull<Scope> scope);

    // Queues the replacement of a type pack's scope with the provided scope.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingTypePack* changeScope(TypePackId tp, NotNull<Scope> scope);

    // Queues a replacement of a table type with another table type with a new
    // indexer.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    PendingType* changeIndexer(TypeId ty, std::optional<TableIndexer> indexer);

    // Returns the type level of the pending state of the type, or the level of that
    // type, if no pending state exists. If the type doesn't have a notion of a level,
    // returns nullopt. If the pending state doesn't have a notion of a level, but the
    // original state does, returns nullopt.
    std::optional<TypeLevel> getLevel(TypeId ty) const;

    // Follows a type, accounting for pending type states. The returned type may have
    // pending state; you should use `pending` or `get` to find out.
    TypeId follow(TypeId ty) const;

    // Follows a type pack, accounting for pending type states. The returned type pack
    // may have pending state; you should use `pending` or `get` to find out.
    TypePackId follow(TypePackId tp) const;

    // Replaces a given type's state with a new variant. Returns the new pending state
    // of that type.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    template<typename T>
    PendingType* replace(TypeId ty, T replacement)
    {
        return replace(ty, Type(replacement));
    }

    // Replaces a given type pack's state with a new variant. Returns the new
    // pending state of that type pack.
    //
    // The pointer returned lives until `commit` or `clear` is called.
    template<typename T>
    PendingTypePack* replace(TypePackId tp, T replacement)
    {
        return replace(tp, TypePackVar(replacement));
    }

    // Returns T if a given type or type pack is this variant, respecting the
    // log's pending state.
    //
    // Do not retain this pointer; it has the potential to be invalidated when
    // commit or clear is called.
    template<typename T, typename TID>
    T* getMutable(TID ty) const
    {
        auto* pendingTy = pending(ty);
        if (pendingTy)
            return Luau::getMutable<T>(pendingTy);

        return Luau::getMutable<T>(ty);
    }

    template<typename T, typename TID>
    const T* get(TID ty) const
    {
        return this->getMutable<T>(ty);
    }

    // Returns whether a given type or type pack is a given state, respecting the
    // log's pending state.
    //
    // This method will not assert if called on a BoundType or BoundTypePack.
    template<typename T, typename TID>
    bool is(TID ty) const
    {
        // We do not use getMutable here because this method can be called on
        // BoundTypes, which triggers an assertion.
        auto* pendingTy = pending(ty);
        if (pendingTy)
            return Luau::get_if<T>(&pendingTy->pending.ty) != nullptr;

        return Luau::get_if<T>(&ty->ty) != nullptr;
    }

    std::pair<std::vector<TypeId>, std::vector<TypePackId>> getChanges() const;

private:
    // unique_ptr is used to give us stable pointers across insertions into the
    // map. Otherwise, it would be really easy to accidentally invalidate the
    // pointers returned from queue/pending.
    DenseHashMap<TypeId, std::unique_ptr<PendingType>> typeVarChanges;
    DenseHashMap<TypePackId, std::unique_ptr<PendingTypePack>> typePackChanges;

    TxnLog* parent = nullptr;

    // Owned version of sharedSeen. This should not be accessed directly in
    // TxnLogs; use sharedSeen instead. This field exists because in the tree
    // of TxnLogs, the root must own its seen set. In all descendant TxnLogs,
    // this is an empty vector.
    std::vector<std::pair<TypeOrPackId, TypeOrPackId>> ownedSeen;

    bool haveSeen(TypeOrPackId lhs, TypeOrPackId rhs) const;
    void pushSeen(TypeOrPackId lhs, TypeOrPackId rhs);
    void popSeen(TypeOrPackId lhs, TypeOrPackId rhs);

public:
    // There is one spot in the code where TxnLog has to reconcile collisions
    // between parallel logs. In that codepath, we have to work out which of two
    // FreeTypes subsumes the other. If useScopes is false, the TypeLevel is
    // used.  Else we use the embedded Scope*.
    bool useScopes = false;

    // It is sometimes the case under DCR that we speculatively rebind
    // GenericTypes to other types as though they were free.  We mark logs that
    // contain these kinds of substitutions as radioactive so that we know that
    // we must never commit one.
    bool radioactive = false;

    // Used to avoid infinite recursion when types are cyclic.
    // Shared with all the descendent TxnLogs.
    std::vector<std::pair<TypeOrPackId, TypeOrPackId>>* sharedSeen;
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/ApplyTypeFunction.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

namespace Luau
{

// A substitution which replaces the type parameters of a type function by arguments
struct ApplyTypeFunction : Substitution
{
    ApplyTypeFunction(TypeArena* arena)
        : Substitution(TxnLog::empty(), arena)
        , encounteredForwardedType(false)
    {
    }

    // Never set under deferred constraint resolution.
    bool encounteredForwardedType;
    std::unordered_map<TypeId, TypeId> typeArguments;
    std::unordered_map<TypePackId, TypePackId> typePackArguments;
    bool ignoreChildren(TypeId ty) override;
    bool ignoreChildren(TypePackId tp) override;
    bool isDirty(TypeId ty) override;
    bool isDirty(TypePackId tp) override;
    TypeId clean(TypeId ty) override;
    TypePackId clean(TypePackId tp) override;
};

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/LValue.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeInfer.h>

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Anyification.h>

#line __LINE__ "Luau/Anyification.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <memory>

namespace Luau
{

struct TypeArena;
struct Scope;
struct InternalErrorReporter;
using ScopePtr = std::shared_ptr<Scope>;

// A substitution which replaces free types by any
struct Anyification : Substitution
{
    Anyification(TypeArena* arena, NotNull<Scope> scope, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter* iceHandler, TypeId anyType,
        TypePackId anyTypePack);
    Anyification(TypeArena* arena, const ScopePtr& scope, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter* iceHandler, TypeId anyType,
        TypePackId anyTypePack);
    NotNull<Scope> scope;
    NotNull<BuiltinTypes> builtinTypes;
    InternalErrorReporter* iceHandler;

    TypeId anyType;
    TypePackId anyTypePack;
    bool normalizationTooComplex = false;
    bool isDirty(TypeId ty) override;
    bool isDirty(TypePackId tp) override;
    TypeId clean(TypeId ty) override;
    TypePackId clean(TypePackId tp) override;

    bool ignoreChildren(TypeId ty) override;
    bool ignoreChildren(TypePackId ty) override;
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ControlFlow.h>

#line __LINE__ "Luau/ControlFlow.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : was already included! <memory>

namespace Luau
{

struct Scope;
using ScopePtr = std::shared_ptr<Scope>;

enum class ControlFlow
{
    None = 0b00001,
    Returns = 0b00010,
    Throws = 0b00100,
    Breaks = 0b01000,
    Continues = 0b10000,
};

inline ControlFlow operator&(ControlFlow a, ControlFlow b)
{
    return ControlFlow(int(a) & int(b));
}

inline ControlFlow operator|(ControlFlow a, ControlFlow b)
{
    return ControlFlow(int(a) | int(b));
}

inline bool matches(ControlFlow a, ControlFlow b)
{
    return (a & b) != ControlFlow(0);
}

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Error.h>

#line __LINE__ "Luau/Error.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : was already included! <set>

namespace Luau
{

struct FileResolver;
struct TypeArena;
struct TypeError;

struct TypeMismatch
{
    enum Context
    {
        CovariantContext,
        InvariantContext
    };

    TypeMismatch() = default;
    TypeMismatch(TypeId wantedType, TypeId givenType);
    TypeMismatch(TypeId wantedType, TypeId givenType, std::string reason);
    TypeMismatch(TypeId wantedType, TypeId givenType, std::string reason, std::optional<TypeError> error);

    TypeMismatch(TypeId wantedType, TypeId givenType, Context context);
    TypeMismatch(TypeId wantedType, TypeId givenType, std::string reason, Context context);
    TypeMismatch(TypeId wantedType, TypeId givenType, std::string reason, std::optional<TypeError> error, Context context);

    TypeId wantedType = nullptr;
    TypeId givenType = nullptr;
    Context context = CovariantContext;

    std::string reason;
    std::shared_ptr<TypeError> error;

    bool operator==(const TypeMismatch& rhs) const;
};

struct UnknownSymbol
{
    enum Context
    {
        Binding,
        Type,
    };
    Name name;
    Context context;

    bool operator==(const UnknownSymbol& rhs) const;
};

struct UnknownProperty
{
    TypeId table;
    Name key;

    bool operator==(const UnknownProperty& rhs) const;
};

struct NotATable
{
    TypeId ty;

    bool operator==(const NotATable& rhs) const;
};

struct CannotExtendTable
{
    enum Context
    {
        Property,
        Indexer,
        Metatable
    };
    TypeId tableType;
    Context context;
    Name prop;

    bool operator==(const CannotExtendTable& rhs) const;
};

struct OnlyTablesCanHaveMethods
{
    TypeId tableType;

    bool operator==(const OnlyTablesCanHaveMethods& rhs) const;
};

struct DuplicateTypeDefinition
{
    Name name;
    std::optional<Location> previousLocation;

    bool operator==(const DuplicateTypeDefinition& rhs) const;
};

struct CountMismatch
{
    enum Context
    {
        Arg,
        FunctionResult,
        ExprListResult,
        Return,
    };
    size_t expected;
    std::optional<size_t> maximum;
    size_t actual;
    Context context = Arg;
    bool isVariadic = false;
    std::string function;

    bool operator==(const CountMismatch& rhs) const;
};

struct FunctionDoesNotTakeSelf
{
    bool operator==(const FunctionDoesNotTakeSelf& rhs) const;
};

struct FunctionRequiresSelf
{
    bool operator==(const FunctionRequiresSelf& rhs) const;
};

struct OccursCheckFailed
{
    bool operator==(const OccursCheckFailed& rhs) const;
};

struct UnknownRequire
{
    std::string modulePath;

    bool operator==(const UnknownRequire& rhs) const;
};

struct IncorrectGenericParameterCount
{
    Name name;
    TypeFun typeFun;
    size_t actualParameters;
    size_t actualPackParameters;

    bool operator==(const IncorrectGenericParameterCount& rhs) const;
};

struct SyntaxError
{
    std::string message;

    bool operator==(const SyntaxError& rhs) const;
};

struct CodeTooComplex
{
    bool operator==(const CodeTooComplex&) const;
};

struct UnificationTooComplex
{
    bool operator==(const UnificationTooComplex&) const;
};

// Could easily be folded into UnknownProperty with an extra field, std::set<Name> candidates.
// But for telemetry purposes, we want to have this be a distinct variant.
struct UnknownPropButFoundLikeProp
{
    TypeId table;
    Name key;
    std::set<Name> candidates;

    bool operator==(const UnknownPropButFoundLikeProp& rhs) const;
};

struct GenericError
{
    std::string message;

    bool operator==(const GenericError& rhs) const;
};

struct InternalError
{
    std::string message;

    bool operator==(const InternalError& rhs) const;
};

struct CannotCallNonFunction
{
    TypeId ty;

    bool operator==(const CannotCallNonFunction& rhs) const;
};

struct ExtraInformation
{
    std::string message;
    bool operator==(const ExtraInformation& rhs) const;
};

struct DeprecatedApiUsed
{
    std::string symbol;
    std::string useInstead;
    bool operator==(const DeprecatedApiUsed& rhs) const;
};

struct ModuleHasCyclicDependency
{
    std::vector<ModuleName> cycle;
    bool operator==(const ModuleHasCyclicDependency& rhs) const;
};

struct FunctionExitsWithoutReturning
{
    TypePackId expectedReturnType;
    bool operator==(const FunctionExitsWithoutReturning& rhs) const;
};

struct IllegalRequire
{
    std::string moduleName;
    std::string reason;

    bool operator==(const IllegalRequire& rhs) const;
};

struct MissingProperties
{
    enum Context
    {
        Missing,
        Extra
    };
    TypeId superType;
    TypeId subType;
    std::vector<Name> properties;
    Context context = Missing;

    bool operator==(const MissingProperties& rhs) const;
};

struct DuplicateGenericParameter
{
    std::string parameterName;

    bool operator==(const DuplicateGenericParameter& rhs) const;
};

struct CannotInferBinaryOperation
{
    enum OpKind
    {
        Operation,
        Comparison,
    };

    AstExprBinary::Op op;
    std::optional<std::string> suggestedToAnnotate;
    OpKind kind;

    bool operator==(const CannotInferBinaryOperation& rhs) const;
};

struct SwappedGenericTypeParameter
{
    enum Kind
    {
        Type,
        Pack,
    };

    std::string name;
    // What was `name` being used as?
    Kind kind;

    bool operator==(const SwappedGenericTypeParameter& rhs) const;
};

struct OptionalValueAccess
{
    TypeId optional;

    bool operator==(const OptionalValueAccess& rhs) const;
};

struct MissingUnionProperty
{
    TypeId type;
    std::vector<TypeId> missing;
    Name key;

    bool operator==(const MissingUnionProperty& rhs) const;
};

struct TypesAreUnrelated
{
    TypeId left;
    TypeId right;

    bool operator==(const TypesAreUnrelated& rhs) const;
};

struct NormalizationTooComplex
{
    bool operator==(const NormalizationTooComplex&) const
    {
        return true;
    }
};

struct TypePackMismatch
{
    TypePackId wantedTp;
    TypePackId givenTp;
    std::string reason;

    bool operator==(const TypePackMismatch& rhs) const;
};

struct DynamicPropertyLookupOnClassesUnsafe
{
    TypeId ty;

    bool operator==(const DynamicPropertyLookupOnClassesUnsafe& rhs) const;
};

struct UninhabitedTypeFunction
{
    TypeId ty;

    bool operator==(const UninhabitedTypeFunction& rhs) const;
};

struct ExplicitFunctionAnnotationRecommended
{
    std::vector<std::pair<std::string, TypeId>> recommendedArgs;
    TypeId recommendedReturn;
    bool operator==(const ExplicitFunctionAnnotationRecommended& rhs) const;
};

struct UninhabitedTypePackFunction
{
    TypePackId tp;

    bool operator==(const UninhabitedTypePackFunction& rhs) const;
};

struct WhereClauseNeeded
{
    TypeId ty;

    bool operator==(const WhereClauseNeeded& rhs) const;
};

struct PackWhereClauseNeeded
{
    TypePackId tp;

    bool operator==(const PackWhereClauseNeeded& rhs) const;
};

struct CheckedFunctionCallError
{
    TypeId expected;
    TypeId passed;
    std::string checkedFunctionName;
    // TODO: make this a vector<argumentIndices>
    size_t argumentIndex;
    bool operator==(const CheckedFunctionCallError& rhs) const;
};

struct NonStrictFunctionDefinitionError
{
    std::string functionName;
    std::string argument;
    TypeId argumentType;
    bool operator==(const NonStrictFunctionDefinitionError& rhs) const;
};

struct PropertyAccessViolation
{
    TypeId table;
    Name key;

    enum
    {
        CannotRead,
        CannotWrite
    } context;

    bool operator==(const PropertyAccessViolation& rhs) const;
};

struct CheckedFunctionIncorrectArgs
{
    std::string functionName;
    size_t expected;
    size_t actual;
    bool operator==(const CheckedFunctionIncorrectArgs& rhs) const;
};

struct CannotAssignToNever
{
    // type of the rvalue being assigned
    TypeId rhsType;

    // Originating type.
    std::vector<TypeId> cause;

    enum class Reason
    {
        // when assigning to a property in a union of tables, the properties type
        // is narrowed to the intersection of its type in each variant.
        PropertyNarrowed,
    };

    Reason reason;

    bool operator==(const CannotAssignToNever& rhs) const;
};

struct UnexpectedTypeInSubtyping
{
    TypeId ty;

    bool operator==(const UnexpectedTypeInSubtyping& rhs) const;
};

struct UnexpectedTypePackInSubtyping
{
    TypePackId tp;

    bool operator==(const UnexpectedTypePackInSubtyping& rhs) const;
};

using TypeErrorData =
    Variant<TypeMismatch, UnknownSymbol, UnknownProperty, NotATable, CannotExtendTable, OnlyTablesCanHaveMethods, DuplicateTypeDefinition,
        CountMismatch, FunctionDoesNotTakeSelf, FunctionRequiresSelf, OccursCheckFailed, UnknownRequire, IncorrectGenericParameterCount, SyntaxError,
        CodeTooComplex, UnificationTooComplex, UnknownPropButFoundLikeProp, GenericError, InternalError, CannotCallNonFunction, ExtraInformation,
        DeprecatedApiUsed, ModuleHasCyclicDependency, IllegalRequire, FunctionExitsWithoutReturning, DuplicateGenericParameter, CannotAssignToNever,
        CannotInferBinaryOperation, MissingProperties, SwappedGenericTypeParameter, OptionalValueAccess, MissingUnionProperty, TypesAreUnrelated,
        NormalizationTooComplex, TypePackMismatch, DynamicPropertyLookupOnClassesUnsafe, UninhabitedTypeFunction, UninhabitedTypePackFunction,
        WhereClauseNeeded, PackWhereClauseNeeded, CheckedFunctionCallError, NonStrictFunctionDefinitionError, PropertyAccessViolation,
        CheckedFunctionIncorrectArgs, UnexpectedTypeInSubtyping, UnexpectedTypePackInSubtyping, ExplicitFunctionAnnotationRecommended>;

struct TypeErrorSummary
{
    Location location;
    ModuleName moduleName;
    int code;

    TypeErrorSummary(const Location& location, const ModuleName& moduleName, int code)
        : location(location)
        , moduleName(moduleName)
        , code(code)
    {
    }
};

struct TypeError
{
    Location location;
    ModuleName moduleName;
    TypeErrorData data;

    static int minCode();
    int code() const;

    TypeError() = default;

    TypeError(const Location& location, const ModuleName& moduleName, const TypeErrorData& data)
        : location(location)
        , moduleName(moduleName)
        , data(data)
    {
    }

    TypeError(const Location& location, const TypeErrorData& data)
        : TypeError(location, {}, data)
    {
    }

    bool operator==(const TypeError& rhs) const;

    TypeErrorSummary summary() const;
};

template<typename T>
const T* get(const TypeError& e)
{
    return get_if<T>(&e.data);
}

template<typename T>
T* get(TypeError& e)
{
    return get_if<T>(&e.data);
}

using ErrorVec = std::vector<TypeError>;

struct TypeErrorToStringOptions
{
    FileResolver* fileResolver = nullptr;
};

std::string toString(const TypeError& error);
std::string toString(const TypeError& error, TypeErrorToStringOptions options);

bool containsParseErrorName(const TypeError& error);

// Copy any types named in the error into destArena.
void copyErrors(ErrorVec& errors, struct TypeArena& destArena, NotNull<BuiltinTypes> builtinTypes);

// Internal Compiler Error
struct InternalErrorReporter
{
    std::function<void(const char*)> onInternalError;
    std::string moduleName;

    [[noreturn]] void ice(const std::string& message, const Location& location) const;
    [[noreturn]] void ice(const std::string& message) const;
};

class InternalCompilerError : public std::exception
{
public:
    explicit InternalCompilerError(const std::string& message)
        : message(message)
    {
    }
    explicit InternalCompilerError(const std::string& message, const std::string& moduleName)
        : message(message)
        , moduleName(moduleName)
    {
    }
    explicit InternalCompilerError(const std::string& message, const std::string& moduleName, const Location& location)
        : message(message)
        , moduleName(moduleName)
        , location(location)
    {
    }
    virtual const char* what() const throw();

    const std::string message;
    const std::optional<std::string> moduleName;
    const std::optional<Location> location;
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Instantiation.h>

#line __LINE__ "Luau/Instantiation.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/VisitType.h>

#line __LINE__ "Luau/VisitType.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.lua : not found, likely and std header
#include <unordered_set>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/RecursionCounter.h>

#line __LINE__ "Luau/RecursionCounter.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.lua : not found, likely and std header
#include <stdexcept>

// @@@@@ PACK.lua : not found, likely and std header
#include <exception>

namespace Luau
{

struct RecursionLimitException : public InternalCompilerError
{
    RecursionLimitException()
        : InternalCompilerError("Internal recursion counter limit exceeded")
    {
    }
};

struct RecursionCounter
{
    RecursionCounter(int* count)
        : count(count)
    {
        ++(*count);
    }

    ~RecursionCounter()
    {
        LUAU_ASSERT(*count > 0);
        --(*count);
    }

protected:
    int* count;
};

struct RecursionLimiter : RecursionCounter
{
    RecursionLimiter(int* count, int limit)
        : RecursionCounter(count)
    {
        if (limit > 0 && *count > limit)
        {
            throw RecursionLimitException();
        }
    }
};

} // namespace Luau

#line __LINE__ "Luau/VisitType.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// DONE : was aleready inlined <Type.h>

LUAU_FASTINT(LuauVisitRecursionLimit)
LUAU_FASTFLAG(LuauBoundLazyTypes2)
LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

namespace Luau
{

namespace visit_detail
{
/**
 * Apply f(tid, t, seen) if doing so would pass type checking, else apply f(tid, t)
 *
 * We do this to permit (but not require) Type visitors to accept the seen set as an argument.
 */
template<typename F, typename A, typename B, typename C>
auto apply(A tid, const B& t, C& c, F& f) -> decltype(f(tid, t, c))
{
    return f(tid, t, c);
}

template<typename A, typename B, typename C, typename F>
auto apply(A tid, const B& t, C&, F& f) -> decltype(f(tid, t))
{
    return f(tid, t);
}

inline bool hasSeen(std::unordered_set<void*>& seen, const void* tv)
{
    void* ttv = const_cast<void*>(tv);
    return !seen.insert(ttv).second;
}

inline bool hasSeen(DenseHashSet<void*>& seen, const void* tv)
{
    void* ttv = const_cast<void*>(tv);

    if (seen.contains(ttv))
        return true;

    seen.insert(ttv);
    return false;
}

inline void unsee(std::unordered_set<void*>& seen, const void* tv)
{
    void* ttv = const_cast<void*>(tv);
    seen.erase(ttv);
}

inline void unsee(DenseHashSet<void*>& seen, const void* tv)
{
    // When DenseHashSet is used for 'visitTypeOnce', where don't forget visited elements
}

} // namespace visit_detail

// recursion counter is equivalent here, but we'd like a better name to express the intent.
using TypeFunctionDepthCounter = RecursionCounter;

template<typename S>
struct GenericTypeVisitor
{
    using Set = S;

    Set seen;
    bool skipBoundTypes = false;
    int recursionCounter = 0;
    int typeFunctionDepth = 0;

    GenericTypeVisitor() = default;

    explicit GenericTypeVisitor(Set seen, bool skipBoundTypes = false)
        : seen(std::move(seen))
        , skipBoundTypes(skipBoundTypes)
    {
    }

    virtual void cycle(TypeId) {}
    virtual void cycle(TypePackId) {}

    virtual bool visit(TypeId ty)
    {
        return true;
    }
    virtual bool visit(TypeId ty, const BoundType& btv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const FreeType& ftv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const GenericType& gtv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const ErrorType& etv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const PrimitiveType& ptv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const FunctionType& ftv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const TableType& ttv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const MetatableType& mtv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const ClassType& ctv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const AnyType& atv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const UnknownType& utv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const NeverType& ntv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const UnionType& utv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const IntersectionType& itv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const BlockedType& btv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const PendingExpansionType& petv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const SingletonType& stv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const NegationType& ntv)
    {
        return visit(ty);
    }
    virtual bool visit(TypeId ty, const TypeFunctionInstanceType& tfit)
    {
        return visit(ty);
    }

    virtual bool visit(TypePackId tp)
    {
        return true;
    }
    virtual bool visit(TypePackId tp, const BoundTypePack& btp)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const FreeTypePack& ftp)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const GenericTypePack& gtp)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const Unifiable::Error& etp)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const TypePack& pack)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const VariadicTypePack& vtp)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const BlockedTypePack& btp)
    {
        return visit(tp);
    }
    virtual bool visit(TypePackId tp, const TypeFunctionInstanceTypePack& tfitp)
    {
        return visit(tp);
    }

    void traverse(TypeId ty)
    {
        RecursionLimiter limiter{&recursionCounter, FInt::LuauVisitRecursionLimit};

        if (visit_detail::hasSeen(seen, ty))
        {
            cycle(ty);
            return;
        }

        if (auto btv = get<BoundType>(ty))
        {
            if (skipBoundTypes)
                traverse(btv->boundTo);
            else if (visit(ty, *btv))
                traverse(btv->boundTo);
        }
        else if (auto ftv = get<FreeType>(ty))
        {
            if (FFlag::DebugLuauDeferredConstraintResolution)
            {
                if (visit(ty, *ftv))
                {
                    // TODO: Replace these if statements with assert()s when we
                    // delete FFlag::DebugLuauDeferredConstraintResolution.
                    //
                    // When the old solver is used, these pointers are always
                    // unused. When the new solver is used, they are never null.
                    if (ftv->lowerBound)
                        traverse(ftv->lowerBound);

                    if (ftv->upperBound)
                        traverse(ftv->upperBound);
                }
            }
            else
                visit(ty, *ftv);
        }
        else if (auto gtv = get<GenericType>(ty))
            visit(ty, *gtv);
        else if (auto etv = get<ErrorType>(ty))
            visit(ty, *etv);
        else if (auto ptv = get<PrimitiveType>(ty))
            visit(ty, *ptv);
        else if (auto ftv = get<FunctionType>(ty))
        {
            if (visit(ty, *ftv))
            {
                traverse(ftv->argTypes);
                traverse(ftv->retTypes);
            }
        }
        else if (auto ttv = get<TableType>(ty))
        {
            // Some visitors want to see bound tables, that's why we traverse the original type
            if (skipBoundTypes && ttv->boundTo)
            {
                traverse(*ttv->boundTo);
            }
            else if (visit(ty, *ttv))
            {
                if (ttv->boundTo)
                {
                    traverse(*ttv->boundTo);
                }
                else
                {
                    for (auto& [_name, prop] : ttv->props)
                    {
                        if (FFlag::DebugLuauDeferredConstraintResolution)
                        {
                            if (auto ty = prop.readTy)
                                traverse(*ty);

                            // In the case that the readType and the writeType
                            // are the same pointer, just traverse once.
                            // Traversing each property twice has pretty
                            // significant performance consequences.
                            if (auto ty = prop.writeTy; ty && !prop.isShared())
                                traverse(*ty);
                        }
                        else
                            traverse(prop.type());
                    }

                    if (ttv->indexer)
                    {
                        traverse(ttv->indexer->indexType);
                        traverse(ttv->indexer->indexResultType);
                    }
                }
            }
        }
        else if (auto mtv = get<MetatableType>(ty))
        {
            if (visit(ty, *mtv))
            {
                traverse(mtv->table);
                traverse(mtv->metatable);
            }
        }
        else if (auto ctv = get<ClassType>(ty))
        {
            if (visit(ty, *ctv))
            {
                for (const auto& [name, prop] : ctv->props)
                {
                    if (FFlag::DebugLuauDeferredConstraintResolution)
                    {
                        if (auto ty = prop.readTy)
                            traverse(*ty);

                        // In the case that the readType and the writeType are
                        // the same pointer, just traverse once. Traversing each
                        // property twice would have pretty significant
                        // performance consequences.
                        if (auto ty = prop.writeTy; ty && !prop.isShared())
                            traverse(*ty);
                    }
                    else
                        traverse(prop.type());
                }

                if (ctv->parent)
                    traverse(*ctv->parent);

                if (ctv->metatable)
                    traverse(*ctv->metatable);

                if (ctv->indexer)
                {
                    traverse(ctv->indexer->indexType);
                    traverse(ctv->indexer->indexResultType);
                }
            }
        }
        else if (auto atv = get<AnyType>(ty))
            visit(ty, *atv);
        else if (auto utv = get<UnionType>(ty))
        {
            if (visit(ty, *utv))
            {
                bool unionChanged = false;
                for (TypeId optTy : utv->options)
                {
                    traverse(optTy);
                    if (!get<UnionType>(follow(ty)))
                    {
                        unionChanged = true;
                        break;
                    }
                }

                if (unionChanged)
                    traverse(ty);
            }
        }
        else if (auto itv = get<IntersectionType>(ty))
        {
            if (visit(ty, *itv))
            {
                bool intersectionChanged = false;
                for (TypeId partTy : itv->parts)
                {
                    traverse(partTy);
                    if (!get<IntersectionType>(follow(ty)))
                    {
                        intersectionChanged = true;
                        break;
                    }
                }

                if (intersectionChanged)
                    traverse(ty);
            }
        }
        else if (auto ltv = get<LazyType>(ty))
        {
            if (TypeId unwrapped = ltv->unwrapped)
                traverse(unwrapped);

            // Visiting into LazyType that hasn't been unwrapped may necessarily cause infinite expansion, so we don't do that on purpose.
            // Asserting also makes no sense, because the type _will_ happen here, most likely as a property of some ClassType
            // that doesn't need to be expanded.
        }
        else if (auto stv = get<SingletonType>(ty))
            visit(ty, *stv);
        else if (auto btv = get<BlockedType>(ty))
            visit(ty, *btv);
        else if (auto utv = get<UnknownType>(ty))
            visit(ty, *utv);
        else if (auto ntv = get<NeverType>(ty))
            visit(ty, *ntv);
        else if (auto petv = get<PendingExpansionType>(ty))
        {
            if (visit(ty, *petv))
            {
                for (TypeId a : petv->typeArguments)
                    traverse(a);

                for (TypePackId a : petv->packArguments)
                    traverse(a);
            }
        }
        else if (auto ntv = get<NegationType>(ty))
        {
            if (visit(ty, *ntv))
                traverse(ntv->ty);
        }
        else if (auto tfit = get<TypeFunctionInstanceType>(ty))
        {
            TypeFunctionDepthCounter tfdc{&typeFunctionDepth};

            if (visit(ty, *tfit))
            {
                for (TypeId p : tfit->typeArguments)
                    traverse(p);

                for (TypePackId p : tfit->packArguments)
                    traverse(p);
            }
        }
        else
            LUAU_ASSERT(!"GenericTypeVisitor::traverse(TypeId) is not exhaustive!");

        visit_detail::unsee(seen, ty);
    }

    void traverse(TypePackId tp)
    {
        if (visit_detail::hasSeen(seen, tp))
        {
            cycle(tp);
            return;
        }

        if (auto btv = get<BoundTypePack>(tp))
        {
            if (visit(tp, *btv))
                traverse(btv->boundTo);
        }

        else if (auto ftv = get<FreeTypePack>(tp))
            visit(tp, *ftv);

        else if (auto gtv = get<GenericTypePack>(tp))
            visit(tp, *gtv);

        else if (auto etv = get<Unifiable::Error>(tp))
            visit(tp, *etv);

        else if (auto pack = get<TypePack>(tp))
        {
            bool res = visit(tp, *pack);
            if (res)
            {
                for (TypeId ty : pack->head)
                    traverse(ty);

                if (pack->tail)
                    traverse(*pack->tail);
            }
        }
        else if (auto pack = get<VariadicTypePack>(tp))
        {
            bool res = visit(tp, *pack);
            if (res)
                traverse(pack->ty);
        }
        else if (auto btp = get<BlockedTypePack>(tp))
            visit(tp, *btp);
        else if (auto tfitp = get<TypeFunctionInstanceTypePack>(tp))
        {
            TypeFunctionDepthCounter tfdc{&typeFunctionDepth};

            if (visit(tp, *tfitp))
            {
                for (TypeId t : tfitp->typeArguments)
                    traverse(t);

                for (TypePackId t : tfitp->packArguments)
                    traverse(t);
            }
        }

        else
            LUAU_ASSERT(!"GenericTypeVisitor::traverse(TypePackId) is not exhaustive!");

        visit_detail::unsee(seen, tp);
    }
};

/** Visit each type under a given type.  Skips over cycles and keeps recursion depth under control.
 *
 * The same type may be visited multiple times if there are multiple distinct paths to it.  If this is undesirable, use
 * TypeOnceVisitor.
 */
struct TypeVisitor : GenericTypeVisitor<std::unordered_set<void*>>
{
    explicit TypeVisitor(bool skipBoundTypes = false)
        : GenericTypeVisitor{{}, skipBoundTypes}
    {
    }
};

/// Visit each type under a given type.  Each type will only be checked once even if there are multiple paths to it.
struct TypeOnceVisitor : GenericTypeVisitor<DenseHashSet<void*>>
{
    explicit TypeOnceVisitor(bool skipBoundTypes = false)
        : GenericTypeVisitor{DenseHashSet<void*>{nullptr}, skipBoundTypes}
    {
    }
};

} // namespace Luau

#line __LINE__ "Luau/Instantiation.h"

namespace Luau
{

struct TxnLog;
struct TypeArena;
struct TypeCheckLimits;

// A substitution which replaces generic types in a given set by free types.
struct ReplaceGenerics : Substitution
{
    ReplaceGenerics(const TxnLog* log, TypeArena* arena, NotNull<BuiltinTypes> builtinTypes, TypeLevel level, Scope* scope,
        const std::vector<TypeId>& generics, const std::vector<TypePackId>& genericPacks)
        : Substitution(log, arena)
        , builtinTypes(builtinTypes)
        , level(level)
        , scope(scope)
        , generics(generics)
        , genericPacks(genericPacks)
    {
    }

    void resetState(const TxnLog* log, TypeArena* arena, NotNull<BuiltinTypes> builtinTypes, TypeLevel level, Scope* scope,
        const std::vector<TypeId>& generics, const std::vector<TypePackId>& genericPacks);

    NotNull<BuiltinTypes> builtinTypes;

    TypeLevel level;
    Scope* scope;
    std::vector<TypeId> generics;
    std::vector<TypePackId> genericPacks;

    bool ignoreChildren(TypeId ty) override;
    bool isDirty(TypeId ty) override;
    bool isDirty(TypePackId tp) override;
    TypeId clean(TypeId ty) override;
    TypePackId clean(TypePackId tp) override;
};

// A substitution which replaces generic functions by monomorphic functions
struct Instantiation : Substitution
{
    Instantiation(const TxnLog* log, TypeArena* arena, NotNull<BuiltinTypes> builtinTypes, TypeLevel level, Scope* scope)
        : Substitution(log, arena)
        , builtinTypes(builtinTypes)
        , level(level)
        , scope(scope)
        , reusableReplaceGenerics(log, arena, builtinTypes, level, scope, {}, {})
    {
    }

    void resetState(const TxnLog* log, TypeArena* arena, NotNull<BuiltinTypes> builtinTypes, TypeLevel level, Scope* scope);

    NotNull<BuiltinTypes> builtinTypes;

    TypeLevel level;
    Scope* scope;

    ReplaceGenerics reusableReplaceGenerics;

    bool ignoreChildren(TypeId ty) override;
    bool isDirty(TypeId ty) override;
    bool isDirty(TypePackId tp) override;
    TypeId clean(TypeId ty) override;
    TypePackId clean(TypePackId tp) override;
};

// Used to find if a FunctionType requires generic type cleanup during instantiation
struct GenericTypeFinder : TypeOnceVisitor
{
    bool found = false;

    bool visit(TypeId ty) override
    {
        return !found;
    }

    bool visit(TypePackId ty) override
    {
        return !found;
    }

    bool visit(TypeId ty, const Luau::FunctionType& ftv) override
    {
        if (ftv.hasNoFreeOrGenericTypes)
            return false;

        if (!ftv.generics.empty() || !ftv.genericPacks.empty())
            found = true;

        return !found;
    }

    bool visit(TypeId ty, const Luau::TableType& ttv) override
    {
        if (ttv.state == Luau::TableState::Generic)
            found = true;

        return !found;
    }

    bool visit(TypeId ty, const Luau::GenericType&) override
    {
        found = true;
        return false;
    }

    bool visit(TypePackId ty, const Luau::GenericTypePack&) override
    {
        found = true;
        return false;
    }

    bool visit(TypeId ty, const Luau::ClassType&) override
    {
        // During function instantiation, classes are not traversed even if they have generics
        return false;
    }
};

/** Attempt to instantiate a type.  Only used under local type inference.
 *
 * When given a generic function type, instantiate() will return a copy with the
 * generics replaced by fresh types.  Instantiation will return the same TypeId
 * back if the function does not have any generics.
 *
 * All higher order generics are left as-is.  For example, instantiation of
 * <X>(<Y>(Y) -> (X, Y)) -> (X, Y) is (<Y>(Y) -> ('x, Y)) -> ('x, Y)
 *
 * We substitute the generic X for the free 'x, but leave the generic Y alone.
 *
 * Instantiation fails only when processing the type causes internal recursion
 * limits to be exceeded.
 */
std::optional<TypeId> instantiate(
    NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, NotNull<TypeCheckLimits> limits, NotNull<Scope> scope, TypeId ty);

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Module.h>

#line __LINE__ "Luau/Module.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Linter.h>

#line __LINE__ "Luau/Linter.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
#include "luau_config_int.hpp"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

struct AstName;
class AstStat;
class AstNameTable;
struct TypeChecker;
struct Module;

using ScopePtr = std::shared_ptr<struct Scope>;

struct LintResult
{
    std::vector<LintWarning> errors;
    std::vector<LintWarning> warnings;
};

std::vector<LintWarning> lint(AstStat* root, const AstNameTable& names, const ScopePtr& env, const Module* module,
    const std::vector<HotComment>& hotcomments, const LintOptions& options);

std::vector<AstName> getDeprecatedGlobals(const AstNameTable& names);

} // namespace Luau

#line __LINE__ "Luau/Module.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/FileResolver.h>

#line __LINE__ "Luau/FileResolver.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

class AstExpr;

using ModuleName = std::string;

struct SourceCode
{
    enum Type
    {
        None,
        Module,
        Script,
        Local
    };

    std::string source;
    Type type;
};

struct ModuleInfo
{
    ModuleName name;
    bool optional = false;
};

struct FileResolver
{
    virtual ~FileResolver() {}

    virtual std::optional<SourceCode> readSource(const ModuleName& name) = 0;

    virtual std::optional<ModuleInfo> resolveModule(const ModuleInfo* context, AstExpr* expr)
    {
        return std::nullopt;
    }

    virtual std::string getHumanReadableModuleName(const ModuleName& name) const
    {
        return name;
    }

    virtual std::optional<std::string> getEnvironmentForModule(const ModuleName& name) const
    {
        return std::nullopt;
    }
};

struct NullFileResolver : FileResolver
{
    std::optional<SourceCode> readSource(const ModuleName& name) override
    {
        return std::nullopt;
    }
};

} // namespace Luau

#line __LINE__ "Luau/Module.h"

// @@@@@ DONE : was aleready included <Luau/ParseOptions.h>

// @@@@@ DONE : was aleready included <Luau/ParseResult.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Scope.h>

#line __LINE__ "Luau/Scope.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Def.h>

#line __LINE__ "Luau/Def.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypedAllocator.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct Def;
using DefId = NotNull<const Def>;

/**
 * A cell is a "single-object" value.
 *
 * Leaky implementation note: sometimes "multiple-object" values, but none of which were interesting enough to warrant creating a phi node instead.
 * That can happen because there's no point in creating a phi node that points to either resultant in `if math.random() > 0.5 then 5 else "hello"`.
 * This might become of utmost importance if we wanted to do some backward reasoning, e.g. if `5` is taken, then `cond` must be `truthy`.
 */
struct Cell
{
    bool subscripted = false;
};

/**
 * A phi node is a union of cells.
 *
 * We need this because we're statically evaluating a program, and sometimes a place may be assigned with
 * different cells, and when that happens, we need a special data type that merges in all the cells
 * that will flow into that specific place. For example, consider this simple program:
 *
 * ```
 * x-1
 * if cond() then
 *   x-2 = 5
 * else
 *   x-3 = "hello"
 * end
 * x-4 : {x-2, x-3}
 * ```
 *
 * At x-4, we know for a fact statically that either `5` or `"hello"` can flow into the variable `x` after the branch, but
 * we cannot make any definitive decisions about which one, so we just take in both.
 */
struct Phi
{
    std::vector<DefId> operands;
};

/**
 * We statically approximate a value at runtime using a symbolic value, which we call a Def.
 *
 * DataFlowGraphBuilder will allocate these defs as a stand-in for some Luau values, and bind them to places that
 * can hold a Luau value, and then observes how those defs will commute as it statically evaluate the program.
 *
 * It must also be noted that defs are a cyclic graph, so it is not safe to recursively traverse into it expecting it to terminate.
 */
struct Def
{
    using V = Variant<struct Cell, struct Phi>;

    V v;
};

template<typename T>
const T* get(DefId def)
{
    return get_if<T>(&def->v);
}

bool containsSubscriptedDefinition(DefId def);
void collectOperands(DefId def, std::vector<DefId>* operands);

struct DefArena
{
    TypedAllocator<Def> allocator;

    DefId freshCell(bool subscripted = false);
    DefId phi(DefId a, DefId b);
    DefId phi(const std::vector<DefId>& defs);
};

} // namespace Luau

#line __LINE__ "Luau/Scope.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/LValue.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Symbol.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <memory>

namespace Luau
{

struct Scope;

using ScopePtr = std::shared_ptr<Scope>;

struct Binding
{
    TypeId typeId;
    Location location;
    bool deprecated = false;
    std::string deprecatedSuggestion;
    std::optional<std::string> documentationSymbol;
};

struct Scope
{
    explicit Scope(TypePackId returnType);                    // root scope
    explicit Scope(const ScopePtr& parent, int subLevel = 0); // child scope.  Parent must not be nullptr.

    const ScopePtr parent; // null for the root

    // All the children of this scope.
    std::vector<NotNull<Scope>> children;
    std::unordered_map<Symbol, Binding> bindings;
    TypePackId returnType;
    std::optional<TypePackId> varargPack;

    TypeLevel level;

    Location location; // the spanning location associated with this scope

    std::unordered_map<Name, TypeFun> exportedTypeBindings;
    std::unordered_map<Name, TypeFun> privateTypeBindings;
    std::unordered_map<Name, Location> typeAliasLocations;
    std::unordered_map<Name, Location> typeAliasNameLocations;
    std::unordered_map<Name, ModuleName> importedModules; // Mapping from the name in the require statement to the internal moduleName.
    std::unordered_map<Name, std::unordered_map<Name, TypeFun>> importedTypeBindings;

    DenseHashSet<Name> builtinTypeNames{""};
    void addBuiltinTypeBinding(const Name& name, const TypeFun& tyFun);

    std::optional<TypeId> lookup(Symbol sym) const;
    std::optional<TypeId> lookupUnrefinedType(DefId def) const;
    std::optional<TypeId> lookup(DefId def) const;
    std::optional<std::pair<TypeId, Scope*>> lookupEx(DefId def);
    std::optional<std::pair<Binding*, Scope*>> lookupEx(Symbol sym);

    std::optional<TypeFun> lookupType(const Name& name) const;
    std::optional<TypeFun> lookupImportedType(const Name& moduleAlias, const Name& name) const;

    std::unordered_map<Name, TypePackId> privateTypePackBindings;
    std::optional<TypePackId> lookupPack(const Name& name) const;

    // WARNING: This function linearly scans for a string key of equal value!  It is thus O(n**2)
    std::optional<Binding> linearSearchForBinding(const std::string& name, bool traverseScopeChain = true) const;

    RefinementMap refinements;

    // This can be viewed as the "unrefined" type of each binding.
    DenseHashMap<const Def*, TypeId> lvalueTypes{nullptr};

    // Luau values are routinely refined more narrowly than their actual
    // inferred type through control flow statements.  We retain those refined
    // types here.
    DenseHashMap<const Def*, TypeId> rvalueRefinements{nullptr};

    void inheritAssignments(const ScopePtr& childScope);
    void inheritRefinements(const ScopePtr& childScope);

    // For mutually recursive type aliases, it's important that
    // they use the same types for the same names.
    // For instance, in `type Tree<T> { data: T, children: Forest<T> } type Forest<T> = {Tree<T>}`
    // we need that the generic type `T` in both cases is the same, so we use a cache.
    std::unordered_map<Name, TypeId> typeAliasTypeParameters;
    std::unordered_map<Name, TypePackId> typeAliasTypePackParameters;
};

// Returns true iff the left scope encloses the right scope.  A Scope* equal to
// nullptr is considered to be the outermost-possible scope.
bool subsumesStrict(Scope* left, Scope* right);

// Returns true if the left scope encloses the right scope, or if they are the
// same scope.  As in subsumesStrict(), nullptr is considered to be the
// outermost-possible scope.
bool subsumes(Scope* left, Scope* right);

inline Scope* max(Scope* left, Scope* right)
{
    if (subsumes(left, right))
        return right;
    else
        return left;
}

} // namespace Luau

#line __LINE__ "Luau/Module.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct Module;

using ScopePtr = std::shared_ptr<struct Scope>;
using ModulePtr = std::shared_ptr<Module>;

class AstType;
class AstTypePack;

/// Root of the AST of a parsed source file
struct SourceModule
{
    ModuleName name; // Module identifier or a filename
    std::string humanReadableName;

    SourceCode::Type type = SourceCode::None;
    std::optional<std::string> environmentName;
    bool cyclic = false;

    std::shared_ptr<Allocator> allocator;
    std::shared_ptr<AstNameTable> names;
    std::vector<ParseError> parseErrors;

    AstStatBlock* root = nullptr;
    std::optional<Mode> mode;

    std::vector<HotComment> hotcomments;
    std::vector<Comment> commentLocations;

    SourceModule()
        : allocator(new Allocator)
        , names(new AstNameTable(*allocator))
    {
    }
};

bool isWithinComment(const SourceModule& sourceModule, Position pos);
bool isWithinComment(const ParseResult& result, Position pos);

struct RequireCycle
{
    Location location;
    std::vector<ModuleName> path; // one of the paths for a require() to go all the way back to the originating module
};

struct Module
{
    ~Module();

    ModuleName name;
    std::string humanReadableName;

    TypeArena interfaceTypes;
    TypeArena internalTypes;

    // Scopes and AST types refer to parse data, so we need to keep that alive
    std::shared_ptr<Allocator> allocator;
    std::shared_ptr<AstNameTable> names;

    std::vector<std::pair<Location, ScopePtr>> scopes; // never empty

    DenseHashMap<const AstExpr*, TypeId> astTypes{nullptr};
    DenseHashMap<const AstExpr*, TypePackId> astTypePacks{nullptr};
    DenseHashMap<const AstExpr*, TypeId> astExpectedTypes{nullptr};

    // For AST nodes that are function calls, this map provides the
    // unspecialized type of the function that was called. If a function call
    // resolves to a __call metamethod application, this map will point at that
    // metamethod.
    //
    // This is useful for type checking and Signature Help.
    DenseHashMap<const AstNode*, TypeId> astOriginalCallTypes{nullptr};

    // The specialization of a function that was selected.  If the function is
    // generic, those generic type parameters will be replaced with the actual
    // types that were passed.  If the function is an overload, this map will
    // point at the specific overloads that were selected.
    DenseHashMap<const AstNode*, TypeId> astOverloadResolvedTypes{nullptr};

    // Only used with for...in loops.  The computed type of the next() function
    // is kept here for type checking.
    DenseHashMap<const AstNode*, TypeId> astForInNextTypes{nullptr};

    DenseHashMap<const AstType*, TypeId> astResolvedTypes{nullptr};
    DenseHashMap<const AstTypePack*, TypePackId> astResolvedTypePacks{nullptr};

    // The computed result type of a compound assignment. (eg foo += 1)
    //
    // Type checking uses this to check that the result of such an operation is
    // actually compatible with the left-side operand.
    DenseHashMap<const AstStat*, TypeId> astCompoundAssignResultTypes{nullptr};

    DenseHashMap<TypeId, std::vector<std::pair<Location, TypeId>>> upperBoundContributors{nullptr};

    // Map AST nodes to the scope they create.  Cannot be NotNull<Scope> because
    // we need a sentinel value for the map.
    DenseHashMap<const AstNode*, Scope*> astScopes{nullptr};

    std::unordered_map<Name, TypeId> declaredGlobals;
    ErrorVec errors;
    LintResult lintResult;
    Mode mode;
    SourceCode::Type type;
    double checkDurationSec = 0.0;
    bool timeout = false;
    bool cancelled = false;

    TypePackId returnType = nullptr;
    std::unordered_map<Name, TypeFun> exportedTypeBindings;

    bool hasModuleScope() const;
    ScopePtr getModuleScope() const;

    // Once a module has been typechecked, we clone its public interface into a
    // separate arena. This helps us to force Type ownership into a DAG rather
    // than a DCG.
    void clonePublicInterface(NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter& ice);
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Predicate.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Symbol.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeCheckLimits.h>

#line __LINE__ "Luau/TypeCheckLimits.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Cancellation.h>

#line __LINE__ "Luau/Cancellation.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : was already included! <atomic>

namespace Luau
{

struct FrontendCancellationToken
{
    void cancel()
    {
        cancelled.store(true);
    }

    bool requested()
    {
        return cancelled.load();
    }

    std::atomic<bool> cancelled;
};

} // namespace Luau

#line __LINE__ "Luau/TypeCheckLimits.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

namespace Luau
{

class TimeLimitError : public InternalCompilerError
{
public:
    explicit TimeLimitError(const std::string& moduleName)
        : InternalCompilerError("Typeinfer failed to complete in allotted time", moduleName)
    {
    }
};

class UserCancelError : public InternalCompilerError
{
public:
    explicit UserCancelError(const std::string& moduleName)
        : InternalCompilerError("Analysis has been cancelled by user", moduleName)
    {
    }
};

struct TypeCheckLimits
{
    std::optional<double> finishTime;
    std::optional<int> instantiationChildLimit;
    std::optional<int> unifierIterationLimit;

    std::shared_ptr<FrontendCancellationToken> cancellationToken;
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeUtils.h>

#line __LINE__ "Luau/TypeUtils.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct TxnLog;
struct TypeArena;
class Normalizer;

enum class ValueContext
{
    LValue,
    RValue
};

/// the current context of the type checker
enum class TypeContext
{
    /// the default context
    Default,
    /// inside of a condition
    Condition,
};

bool inConditional(const TypeContext& context);

// sets the given type context to `Condition` and restores it to its original
// value when the struct drops out of scope
struct InConditionalContext
{
    TypeContext* typeContext;
    TypeContext oldValue;

    InConditionalContext(TypeContext* c)
        : typeContext(c)
        , oldValue(*c)
    {
        *typeContext = TypeContext::Condition;
    }

    ~InConditionalContext()
    {
        *typeContext = oldValue;
    }
};

using ScopePtr = std::shared_ptr<struct Scope>;

std::optional<Property> findTableProperty(
    NotNull<BuiltinTypes> builtinTypes, ErrorVec& errors, TypeId ty, const std::string& name, Location location);

std::optional<TypeId> findMetatableEntry(
    NotNull<BuiltinTypes> builtinTypes, ErrorVec& errors, TypeId type, const std::string& entry, Location location);
std::optional<TypeId> findTablePropertyRespectingMeta(
    NotNull<BuiltinTypes> builtinTypes, ErrorVec& errors, TypeId ty, const std::string& name, Location location);
std::optional<TypeId> findTablePropertyRespectingMeta(
    NotNull<BuiltinTypes> builtinTypes, ErrorVec& errors, TypeId ty, const std::string& name, ValueContext context, Location location);

bool occursCheck(TypeId needle, TypeId haystack);

// Returns the minimum and maximum number of types the argument list can accept.
std::pair<size_t, std::optional<size_t>> getParameterExtents(const TxnLog* log, TypePackId tp, bool includeHiddenVariadics = false);

// Extend the provided pack to at least `length` types.
// Returns a temporary TypePack that contains those types plus a tail.
TypePack extendTypePack(
    TypeArena& arena, NotNull<BuiltinTypes> builtinTypes, TypePackId pack, size_t length, std::vector<std::optional<TypeId>> overrides = {});

/**
 * Reduces a union by decomposing to the any/error type if it appears in the
 * type list, and by merging child unions. Also strips out duplicate (by pointer
 * identity) types.
 * @param types the input type list to reduce.
 * @returns the reduced type list.
 */
std::vector<TypeId> reduceUnion(const std::vector<TypeId>& types);

/**
 * Tries to remove nil from a union type, if there's another option. T | nil
 * reduces to T, but nil itself does not reduce.
 * @param builtinTypes the singleton types to use
 * @param arena the type arena to allocate the new type in, if necessary
 * @param ty the type to remove nil from
 * @returns a type with nil removed, or nil itself if that were the only option.
 */
TypeId stripNil(NotNull<BuiltinTypes> builtinTypes, TypeArena& arena, TypeId ty);

struct ErrorSuppression
{
    enum Value
    {
        Suppress,
        DoNotSuppress,
        NormalizationFailed,
    };

    ErrorSuppression() = default;
    constexpr ErrorSuppression(Value enumValue)
        : value(enumValue)
    {
    }

    constexpr operator Value() const
    {
        return value;
    }
    explicit operator bool() const = delete;

    ErrorSuppression orElse(const ErrorSuppression& other) const
    {
        switch (value)
        {
        case DoNotSuppress:
            return other;
        default:
            return *this;
        }
    }

private:
    Value value;
};

/**
 * Normalizes the given type using the normalizer to determine if the type
 * should suppress any errors that would be reported involving it.
 * @param normalizer the normalizer to use
 * @param ty the type to check for error suppression
 * @returns an enum indicating whether or not to suppress the error or to signal a normalization failure
 */
ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer, TypeId ty);

/**
 * Flattens and normalizes the given typepack using the normalizer to determine if the type
 * should suppress any errors that would be reported involving it.
 * @param normalizer the normalizer to use
 * @param tp the typepack to check for error suppression
 * @returns an enum indicating whether or not to suppress the error or to signal a normalization failure
 */
ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer, TypePackId tp);

/**
 * Normalizes the two given type using the normalizer to determine if either type
 * should suppress any errors that would be reported involving it.
 * @param normalizer the normalizer to use
 * @param ty1 the first type to check for error suppression
 * @param ty2 the second type to check for error suppression
 * @returns an enum indicating whether or not to suppress the error or to signal a normalization failure
 */
ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer, TypeId ty1, TypeId ty2);

/**
 * Flattens and normalizes the two given typepacks using the normalizer to determine if either type
 * should suppress any errors that would be reported involving it.
 * @param normalizer the normalizer to use
 * @param tp1 the first typepack to check for error suppression
 * @param tp2 the second typepack to check for error suppression
 * @returns an enum indicating whether or not to suppress the error or to signal a normalization failure
 */
ErrorSuppression shouldSuppressErrors(NotNull<Normalizer> normalizer, TypePackId tp1, TypePackId tp2);

// Similar to `std::optional<std::pair<A, B>>`, but whose `sizeof()` is the same as `std::pair<A, B>`
// and cooperates with C++'s `if (auto p = ...)` syntax without the extra fatness of `std::optional`.
template<typename A, typename B>
struct TryPair
{
    A first;
    B second;

    explicit operator bool() const
    {
        return bool(first) && bool(second);
    }
};

template<typename A, typename B, typename Ty>
TryPair<const A*, const B*> get2(Ty one, Ty two)
{
    static_assert(std::is_pointer_v<Ty>, "argument must be a pointer type");

    const A* a = get<A>(one);
    const B* b = get<B>(two);
    if (a && b)
        return {a, b};
    else
        return {nullptr, nullptr};
}

template<typename T, typename Ty>
const T* get(std::optional<Ty> ty)
{
    if (ty)
        return get<T>(*ty);
    else
        return nullptr;
}

template<typename T, typename Ty>
T* getMutable(std::optional<Ty> ty)
{
    if (ty)
        return getMutable<T>(*ty);
    else
        return nullptr;
}

template<typename Ty>
std::optional<Ty> follow(std::optional<Ty> ty)
{
    if (ty)
        return follow(*ty);
    else
        return std::nullopt;
}

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Unifier.h>

#line __LINE__ "Luau/Unifier.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ParseOptions.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/UnifierSharedState.h>

#line __LINE__ "Luau/UnifierSharedState.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <utility>

namespace Luau
{
struct InternalErrorReporter;

struct TypeIdPairHash
{
    size_t hashOne(Luau::TypeId key) const
    {
        return (uintptr_t(key) >> 4) ^ (uintptr_t(key) >> 9);
    }

    size_t operator()(const std::pair<Luau::TypeId, Luau::TypeId>& x) const
    {
        return hashOne(x.first) ^ (hashOne(x.second) << 1);
    }
};

struct UnifierCounters
{
    int recursionCount = 0;
    int recursionLimit = 0;
    int iterationCount = 0;
    int iterationLimit = 0;
};

struct UnifierSharedState
{
    UnifierSharedState(InternalErrorReporter* iceHandler)
        : iceHandler(iceHandler)
    {
    }

    InternalErrorReporter* iceHandler;

    DenseHashMap<TypeId, bool> skipCacheForType{nullptr};
    DenseHashSet<std::pair<TypeId, TypeId>, TypeIdPairHash> cachedUnify{{nullptr, nullptr}};
    DenseHashMap<std::pair<TypeId, TypeId>, TypeErrorData, TypeIdPairHash> cachedUnifyError{{nullptr, nullptr}};

    DenseHashSet<TypeId> tempSeenTy{nullptr};
    DenseHashSet<TypePackId> tempSeenTp{nullptr};

    UnifierCounters counters;
};

} // namespace Luau

#line __LINE__ "Luau/Unifier.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Normalize.h>

#line __LINE__ "Luau/Normalize.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Set.h>

#line __LINE__ "Luau/Set.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

LUAU_FASTFLAG(DebugLuauDeferredConstraintResolution)

namespace Luau
{

template<typename T>
using SetHashDefault = std::conditional_t<std::is_pointer_v<T>, DenseHashPointer, std::hash<T>>;

// This is an implementation of `unordered_set` using `DenseHashMap<T, bool>` to support erasure.
// This lets us work around `DenseHashSet` limitations and get a more traditional set interface.
template<typename T, typename Hash = SetHashDefault<T>>
class Set
{
private:
    using Impl = DenseHashMap<T, bool, Hash>;
    Impl mapping;
    size_t entryCount = 0;

public:
    class const_iterator;
    using iterator = const_iterator;

    Set(const T& empty_key)
        : mapping{empty_key}
    {
    }

    bool insert(const T& element)
    {
        bool& entry = mapping[element];
        bool fresh = !entry;

        if (fresh)
        {
            entry = true;
            entryCount++;
        }

        return fresh;
    }

    template<class Iterator>
    void insert(Iterator begin, Iterator end)
    {
        for (Iterator it = begin; it != end; ++it)
            insert(*it);
    }

    void erase(T&& element)
    {
        bool& entry = mapping[element];

        if (entry)
        {
            entry = false;
            entryCount--;
        }
    }

    void erase(const T& element)
    {
        bool& entry = mapping[element];

        if (entry)
        {
            entry = false;
            entryCount--;
        }
    }

    void clear()
    {
        mapping.clear();
        entryCount = 0;
    }

    size_t size() const
    {
        return entryCount;
    }

    bool empty() const
    {
        return entryCount == 0;
    }

    size_t count(const T& element) const
    {
        const bool* entry = mapping.find(element);
        return (entry && *entry) ? 1 : 0;
    }

    bool contains(const T& element) const
    {
        return count(element) != 0;
    }

    const_iterator begin() const
    {
        return const_iterator(mapping.begin(), mapping.end());
    }

    const_iterator end() const
    {
        return const_iterator(mapping.end(), mapping.end());
    }

    bool operator==(const Set<T>& there) const
    {
        // if the sets are unequal sizes, then they cannot possibly be equal.
        if (size() != there.size())
            return false;

        // otherwise, we'll need to check that every element we have here is in `there`.
        for (auto [elem, present] : mapping)
        {
            // if it's not, we'll return `false`
            if (present && there.contains(elem))
                return false;
        }

        // otherwise, we've proven the two equal!
        return true;
    }

    class const_iterator
    {
    public:
        using value_type = T;
        using reference = T&;
        using pointer = T*;
        using difference_type = ptrdiff_t;
        using iterator_category = std::forward_iterator_tag;

        const_iterator(typename Impl::const_iterator impl_, typename Impl::const_iterator end_)
            : impl(impl_)
            , end(end_)
        {
            while (impl != end && impl->second == false)
                ++impl;
        }

        const T& operator*() const
        {
            return impl->first;
        }

        const T* operator->() const
        {
            return &impl->first;
        }

        bool operator==(const const_iterator& other) const
        {
            return impl == other.impl;
        }

        bool operator!=(const const_iterator& other) const
        {
            return impl != other.impl;
        }

        const_iterator& operator++()
        {
            do
            {
                impl++;
            } while (impl != end && impl->second == false);
            // keep iterating past pairs where the value is `false`

            return *this;
        }

        const_iterator operator++(int)
        {
            const_iterator res = *this;
            ++*this;
            return res;
        }

    private:
        typename Impl::const_iterator impl;
        typename Impl::const_iterator end;
    };
};

} // namespace Luau

#line __LINE__ "Luau/Normalize.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/UnifierSharedState.h>

// @@@@@ PACK.LUA : was already included! <initializer_list>

// @@@@@ PACK.LUA : was already included! <map>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

struct InternalErrorReporter;
struct Module;
struct Scope;

using ModulePtr = std::shared_ptr<Module>;

bool isSubtype(TypeId subTy, TypeId superTy, NotNull<Scope> scope, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter& ice);
bool isSubtype(TypePackId subTy, TypePackId superTy, NotNull<Scope> scope, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter& ice);
bool isConsistentSubtype(TypeId subTy, TypeId superTy, NotNull<Scope> scope, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter& ice);
bool isConsistentSubtype(TypePackId subTy, TypePackId superTy, NotNull<Scope> scope, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter& ice);

class TypeIds
{
private:
    DenseHashMap<TypeId, bool> types{nullptr};
    std::vector<TypeId> order;
    std::size_t hash = 0;

public:
    using iterator = std::vector<TypeId>::iterator;
    using const_iterator = std::vector<TypeId>::const_iterator;

    TypeIds() = default;
    ~TypeIds() = default;

    TypeIds(std::initializer_list<TypeId> tys);

    TypeIds(const TypeIds&) = default;
    TypeIds& operator=(const TypeIds&) = default;

    TypeIds(TypeIds&&) = default;
    TypeIds& operator=(TypeIds&&) = default;

    void insert(TypeId ty);
    /// Erase every element that does not also occur in tys
    void retain(const TypeIds& tys);
    void clear();

    TypeId front() const;
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;
    iterator erase(const_iterator it);

    size_t size() const;
    bool empty() const;
    size_t count(TypeId ty) const;

    template<class Iterator>
    void insert(Iterator begin, Iterator end)
    {
        for (Iterator it = begin; it != end; ++it)
            insert(*it);
    }

    bool operator==(const TypeIds& there) const;
    size_t getHash() const;
    bool isNever() const;
};

} // namespace Luau

template<>
struct std::hash<Luau::TypeIds>
{
    std::size_t operator()(const Luau::TypeIds& tys) const
    {
        return tys.getHash();
    }
};

template<>
struct std::hash<const Luau::TypeIds*>
{
    std::size_t operator()(const Luau::TypeIds* tys) const
    {
        return tys->getHash();
    }
};

template<>
struct std::equal_to<Luau::TypeIds>
{
    bool operator()(const Luau::TypeIds& here, const Luau::TypeIds& there) const
    {
        return here == there;
    }
};

template<>
struct std::equal_to<const Luau::TypeIds*>
{
    bool operator()(const Luau::TypeIds* here, const Luau::TypeIds* there) const
    {
        return *here == *there;
    }
};

namespace Luau
{

/** A normalized string type is either `string` (represented by `nullopt`) or a
 * union of string singletons.
 *
 * The representation is as follows:
 *
 * * A union of string singletons is finite and includes the singletons named by
 *   the `singletons` field.
 * * An intersection of negated string singletons is cofinite and includes the
 *   singletons excluded by the `singletons` field.  It is implied that cofinite
 *   values are exclusions from `string` itself.
 * * The `string` data type is a cofinite set minus zero elements.
 * * The `never` data type is a finite set plus zero elements.
 */
struct NormalizedStringType
{
    // When false, this type represents a union of singleton string types.
    // eg "a" | "b" | "c"
    //
    // When true, this type represents string intersected with negated string
    // singleton types.
    // eg string & ~"a" & ~"b" & ...
    bool isCofinite = false;

    std::map<std::string, TypeId> singletons;

    void resetToString();
    void resetToNever();

    bool isNever() const;
    bool isString() const;

    /// Returns true if the string has finite domain.
    ///
    /// Important subtlety: This method returns true for `never`.  The empty set
    /// is indeed an empty set.
    bool isUnion() const;

    /// Returns true if the string has infinite domain.
    bool isIntersection() const;

    bool includes(const std::string& str) const;

    static const NormalizedStringType never;

    NormalizedStringType();
    NormalizedStringType(bool isCofinite, std::map<std::string, TypeId> singletons);
};

bool isSubtype(const NormalizedStringType& subStr, const NormalizedStringType& superStr);

struct NormalizedClassType
{
    /** Has the following structure:
     *
     * (C1 & ~N11 & ... & ~Nn) | (C2 & ~N21 & ... & ~N2n) | ...
     *
     * C2 is either not a subtype of any other Cm, or it is and is also a
     * subtype of one of Nmn types within the same cluster.
     *
     * Each TypeId is a class type.
     */
    std::unordered_map<TypeId, TypeIds> classes;

    /**
     * In order to maintain a consistent insertion order, we use this vector to
     * keep track of it. An ordered std::map will sort by pointer identity,
     * which is undesirable.
     */
    std::vector<TypeId> ordering;

    void pushPair(TypeId ty, TypeIds negations);

    void resetToNever();
    bool isNever() const;
};

// A normalized function type can be `never`, the top function type `function`,
// or an intersection of function types.
//
// NOTE: type normalization can fail on function types with generics (e.g.
// because we do not support unions and intersections of generic type packs), so
// this type may contain `error`.
struct NormalizedFunctionType
{
    bool isTop = false;
    TypeIds parts;

    void resetToNever();
    void resetToTop();

    bool isNever() const;
};

// A normalized generic/free type is a union, where each option is of the form (X & T) where
// * X is either a free type, a generic or a blocked type.
// * T is a normalized type.
struct NormalizedType;
using NormalizedTyvars = std::unordered_map<TypeId, std::unique_ptr<NormalizedType>>;

// Operations provided by `Normalizer` can have ternary results:
//   1. The operation returned true.
//   2. The operation returned false.
//   3. They can hit resource limitations, which invalidates _all normalized types_.
enum class NormalizationResult
{
    // The operation returned true or succeeded.
    True,
    // The operation returned false or failed.
    False,
    // Resource limits were hit, invalidating all normalized types.
    HitLimits,
};

// A normalized type is either any, unknown, or one of the form P | T | F | G where
// * P is a union of primitive types (including singletons, classes and the error type)
// * T is a union of table types
// * F is a union of an intersection of function types
// * G is a union of generic/free/blocked types, intersected with a normalized type
struct NormalizedType
{
    // The top part of the type.
    // This type is either never, unknown, or any.
    // If this type is not never, all the other fields are null.
    TypeId tops;

    // The boolean part of the type.
    // This type is either never, boolean type, or a boolean singleton.
    TypeId booleans;

    NormalizedClassType classes;

    // The error part of the type.
    // This type is either never or the error type.
    TypeId errors;

    // The nil part of the type.
    // This type is either never or nil.
    TypeId nils;

    // The number part of the type.
    // This type is either never or number.
    TypeId numbers;

    // The string part of the type.
    // This may be the `string` type, or a union of singletons.
    NormalizedStringType strings;

    // The thread part of the type.
    // This type is either never or thread.
    TypeId threads;

    // The buffer part of the type.
    // This type is either never or buffer.
    TypeId buffers;

    // The (meta)table part of the type.
    // Each element of this set is a (meta)table type, or the top `table` type.
    // An empty set denotes never.
    TypeIds tables;

    // The function part of the type.
    NormalizedFunctionType functions;

    // The generic/free part of the type.
    NormalizedTyvars tyvars;

    // Free types, blocked types, and certain other types change shape as type
    // inference is done. If we were to cache the normalization of these types,
    // we'd be reusing bad, stale data.
    bool isCacheable = true;

    NormalizedType(NotNull<BuiltinTypes> builtinTypes);

    NormalizedType() = delete;
    ~NormalizedType() = default;

    NormalizedType(const NormalizedType&) = delete;
    NormalizedType& operator=(const NormalizedType&) = delete;

    NormalizedType(NormalizedType&&) = default;
    NormalizedType& operator=(NormalizedType&&) = default;

    // IsType functions
    bool isUnknown() const;
    /// Returns true if the type is exactly a number. Behaves like Type::isNumber()
    bool isExactlyNumber() const;

    /// Returns true if the type is a subtype of string(it could be a singleton). Behaves like Type::isString()
    bool isSubtypeOfString() const;

    /// Returns true if the type is a subtype of boolean(it could be a singleton). Behaves like Type::isBoolean()
    bool isSubtypeOfBooleans() const;

    /// Returns true if this type should result in error suppressing behavior.
    bool shouldSuppressErrors() const;

    /// Returns true if this type contains the primitve top table type, `table`.
    bool hasTopTable() const;

    // Helpers that improve readability of the above (they just say if the component is present)
    bool hasTops() const;
    bool hasBooleans() const;
    bool hasClasses() const;
    bool hasErrors() const;
    bool hasNils() const;
    bool hasNumbers() const;
    bool hasStrings() const;
    bool hasThreads() const;
    bool hasBuffers() const;
    bool hasTables() const;
    bool hasFunctions() const;
    bool hasTyvars() const;

    bool isFalsy() const;
    bool isTruthy() const;
};

class Normalizer
{
    std::unordered_map<TypeId, std::shared_ptr<NormalizedType>> cachedNormals;
    std::unordered_map<const TypeIds*, TypeId> cachedIntersections;
    std::unordered_map<const TypeIds*, TypeId> cachedUnions;
    std::unordered_map<const TypeIds*, std::unique_ptr<TypeIds>> cachedTypeIds;

    DenseHashMap<TypeId, bool> cachedIsInhabited{nullptr};
    DenseHashMap<std::pair<TypeId, TypeId>, bool, TypeIdPairHash> cachedIsInhabitedIntersection{{nullptr, nullptr}};

    bool withinResourceLimits();

public:
    TypeArena* arena;
    NotNull<BuiltinTypes> builtinTypes;
    NotNull<UnifierSharedState> sharedState;
    bool cacheInhabitance = false;

    Normalizer(TypeArena* arena, NotNull<BuiltinTypes> builtinTypes, NotNull<UnifierSharedState> sharedState, bool cacheInhabitance = false);
    Normalizer(const Normalizer&) = delete;
    Normalizer(Normalizer&&) = delete;
    Normalizer() = delete;
    ~Normalizer() = default;
    Normalizer& operator=(Normalizer&&) = delete;
    Normalizer& operator=(Normalizer&) = delete;

    // If this returns null, the typechecker should emit a "too complex" error
    std::shared_ptr<const NormalizedType> normalize(TypeId ty);
    void clearNormal(NormalizedType& norm);

    // ------- Cached TypeIds
    TypeId unionType(TypeId here, TypeId there);
    TypeId intersectionType(TypeId here, TypeId there);
    const TypeIds* cacheTypeIds(TypeIds tys);
    void clearCaches();

    // ------- Normalizing unions
    void unionTysWithTy(TypeIds& here, TypeId there);
    TypeId unionOfTops(TypeId here, TypeId there);
    TypeId unionOfBools(TypeId here, TypeId there);
    void unionClassesWithClass(TypeIds& heres, TypeId there);
    void unionClasses(TypeIds& heres, const TypeIds& theres);
    void unionClassesWithClass(NormalizedClassType& heres, TypeId there);
    void unionClasses(NormalizedClassType& heres, const NormalizedClassType& theres);
    void unionStrings(NormalizedStringType& here, const NormalizedStringType& there);
    std::optional<TypePackId> unionOfTypePacks(TypePackId here, TypePackId there);
    std::optional<TypeId> unionOfFunctions(TypeId here, TypeId there);
    std::optional<TypeId> unionSaturatedFunctions(TypeId here, TypeId there);
    void unionFunctionsWithFunction(NormalizedFunctionType& heress, TypeId there);
    void unionFunctions(NormalizedFunctionType& heress, const NormalizedFunctionType& theress);
    void unionTablesWithTable(TypeIds& heres, TypeId there);
    void unionTables(TypeIds& heres, const TypeIds& theres);
    NormalizationResult unionNormals(NormalizedType& here, const NormalizedType& there, int ignoreSmallerTyvars = -1);
    NormalizationResult unionNormalWithTy(NormalizedType& here, TypeId there, Set<TypeId>& seenSetTypes, int ignoreSmallerTyvars = -1);

    // ------- Negations
    std::optional<NormalizedType> negateNormal(const NormalizedType& here);
    TypeIds negateAll(const TypeIds& theres);
    TypeId negate(TypeId there);
    void subtractPrimitive(NormalizedType& here, TypeId ty);
    void subtractSingleton(NormalizedType& here, TypeId ty);
    NormalizationResult intersectNormalWithNegationTy(TypeId toNegate, NormalizedType& intersect);

    // ------- Normalizing intersections
    TypeId intersectionOfTops(TypeId here, TypeId there);
    TypeId intersectionOfBools(TypeId here, TypeId there);
    void intersectClasses(NormalizedClassType& heres, const NormalizedClassType& theres);
    void intersectClassesWithClass(NormalizedClassType& heres, TypeId there);
    void intersectStrings(NormalizedStringType& here, const NormalizedStringType& there);
    std::optional<TypePackId> intersectionOfTypePacks(TypePackId here, TypePackId there);
    std::optional<TypeId> intersectionOfTables(TypeId here, TypeId there, Set<TypeId>& seenSet);
    void intersectTablesWithTable(TypeIds& heres, TypeId there, Set<TypeId>& seenSetTypes);
    void intersectTables(TypeIds& heres, const TypeIds& theres);
    std::optional<TypeId> intersectionOfFunctions(TypeId here, TypeId there);
    void intersectFunctionsWithFunction(NormalizedFunctionType& heress, TypeId there);
    void intersectFunctions(NormalizedFunctionType& heress, const NormalizedFunctionType& theress);
    NormalizationResult intersectTyvarsWithTy(NormalizedTyvars& here, TypeId there, Set<TypeId>& seenSetTypes);
    NormalizationResult intersectNormals(NormalizedType& here, const NormalizedType& there, int ignoreSmallerTyvars = -1);
    NormalizationResult intersectNormalWithTy(NormalizedType& here, TypeId there, Set<TypeId>& seenSetTypes);
    NormalizationResult normalizeIntersections(const std::vector<TypeId>& intersections, NormalizedType& outType, Set<TypeId>& seenSet);

    // Check for inhabitance
    NormalizationResult isInhabited(TypeId ty);
    NormalizationResult isInhabited(TypeId ty, Set<TypeId>& seen);
    NormalizationResult isInhabited(const NormalizedType* norm);
    NormalizationResult isInhabited(const NormalizedType* norm, Set<TypeId>& seen);

    // Check for intersections being inhabited
    NormalizationResult isIntersectionInhabited(TypeId left, TypeId right);
    NormalizationResult isIntersectionInhabited(TypeId left, TypeId right, Set<TypeId>& seenSet);

    // -------- Convert back from a normalized type to a type
    TypeId typeFromNormal(const NormalizedType& norm);
};

} // namespace Luau

#line __LINE__ "Luau/Unifier.h"

// @@@@@ PACK.LUA : was already included! <unordered_set>

namespace Luau
{

enum Variance
{
    Covariant,
    Invariant
};

// A substitution which replaces singleton types by their wider types
struct Widen : Substitution
{
    Widen(TypeArena* arena, NotNull<BuiltinTypes> builtinTypes)
        : Substitution(TxnLog::empty(), arena)
        , builtinTypes(builtinTypes)
    {
    }

    NotNull<BuiltinTypes> builtinTypes;

    bool isDirty(TypeId ty) override;
    bool isDirty(TypePackId ty) override;
    TypeId clean(TypeId ty) override;
    TypePackId clean(TypePackId ty) override;
    bool ignoreChildren(TypeId ty) override;

    TypeId operator()(TypeId ty);
    TypePackId operator()(TypePackId ty);
};

/**
 * Normally, when we unify table properties, we must do so invariantly, but we
 * can introduce a special exception: If the table property in the subtype
 * position arises from a literal expression, it is safe to instead perform a
 * covariant check.
 *
 * This is very useful for typechecking cases where table literals (and trees of
 * table literals) are passed directly to functions.
 *
 * In this case, we know that the property has no other name referring to it and
 * so it is perfectly safe for the function to mutate the table any way it
 * wishes.
 */
using LiteralProperties = DenseHashSet<Name>;

// TODO: Use this more widely.
struct UnifierOptions
{
    bool isFunctionCall = false;
};

struct Unifier
{
    TypeArena* const types;
    NotNull<BuiltinTypes> builtinTypes;
    NotNull<Normalizer> normalizer;

    NotNull<Scope> scope; // const Scope maybe
    TxnLog log;
    bool failure = false;
    ErrorVec errors;
    Location location;
    Variance variance = Covariant;
    bool normalize = true;      // Normalize unions and intersections if necessary
    bool checkInhabited = true; // Normalize types to check if they are inhabited
    CountMismatch::Context ctx = CountMismatch::Arg;

    // If true, generics act as free types when unifying.
    bool hideousFixMeGenericsAreActuallyFree = false;

    UnifierSharedState& sharedState;

    // When the Unifier is forced to unify two blocked types (or packs), they
    // get added to these vectors.  The ConstraintSolver can use this to know
    // when it is safe to reattempt dispatching a constraint.
    std::vector<TypeId> blockedTypes;
    std::vector<TypePackId> blockedTypePacks;

    Unifier(NotNull<Normalizer> normalizer, NotNull<Scope> scope, const Location& location, Variance variance, TxnLog* parentLog = nullptr);

    // Configure the Unifier to test for scope subsumption via embedded Scope
    // pointers rather than TypeLevels.
    void enableNewSolver();

    // Test whether the two type vars unify.  Never commits the result.
    ErrorVec canUnify(TypeId subTy, TypeId superTy);
    ErrorVec canUnify(TypePackId subTy, TypePackId superTy, bool isFunctionCall = false);

    /** Attempt to unify.
     * Populate the vector errors with any type errors that may arise.
     * Populate the transaction log with the set of TypeIds that need to be reset to undo the unification attempt.
     */
    void tryUnify(
        TypeId subTy, TypeId superTy, bool isFunctionCall = false, bool isIntersection = false, const LiteralProperties* aliasableMap = nullptr);

private:
    void tryUnify_(
        TypeId subTy, TypeId superTy, bool isFunctionCall = false, bool isIntersection = false, const LiteralProperties* aliasableMap = nullptr);
    void tryUnifyUnionWithType(TypeId subTy, const UnionType* uv, TypeId superTy);

    // Traverse the two types provided and block on any BlockedTypes we find.
    // Returns true if any types were blocked on.
    bool DEPRECATED_blockOnBlockedTypes(TypeId subTy, TypeId superTy);

    void tryUnifyTypeWithUnion(TypeId subTy, TypeId superTy, const UnionType* uv, bool cacheEnabled, bool isFunctionCall);
    void tryUnifyTypeWithIntersection(TypeId subTy, TypeId superTy, const IntersectionType* uv);
    void tryUnifyIntersectionWithType(TypeId subTy, const IntersectionType* uv, TypeId superTy, bool cacheEnabled, bool isFunctionCall);
    void tryUnifyNormalizedTypes(TypeId subTy, TypeId superTy, const NormalizedType& subNorm, const NormalizedType& superNorm, std::string reason,
        std::optional<TypeError> error = std::nullopt);
    void tryUnifyPrimitives(TypeId subTy, TypeId superTy);
    void tryUnifySingletons(TypeId subTy, TypeId superTy);
    void tryUnifyFunctions(TypeId subTy, TypeId superTy, bool isFunctionCall = false);
    void tryUnifyTables(TypeId subTy, TypeId superTy, bool isIntersection = false, const LiteralProperties* aliasableMap = nullptr);
    void tryUnifyScalarShape(TypeId subTy, TypeId superTy, bool reversed);
    void tryUnifyWithMetatable(TypeId subTy, TypeId superTy, bool reversed);
    void tryUnifyWithClass(TypeId subTy, TypeId superTy, bool reversed);
    void tryUnifyNegations(TypeId subTy, TypeId superTy);

    TypePackId tryApplyOverloadedFunction(TypeId function, const NormalizedFunctionType& overloads, TypePackId args);

    TypeId widen(TypeId ty);
    TypePackId widen(TypePackId tp);

    TypeId deeplyOptional(TypeId ty, std::unordered_map<TypeId, TypeId> seen = {});

    bool canCacheResult(TypeId subTy, TypeId superTy);
    void cacheResult(TypeId subTy, TypeId superTy, size_t prevErrorCount);

public:
    void tryUnify(TypePackId subTy, TypePackId superTy, bool isFunctionCall = false);

private:
    void tryUnify_(TypePackId subTy, TypePackId superTy, bool isFunctionCall = false);
    void tryUnifyVariadics(TypePackId subTy, TypePackId superTy, bool reversed, int subOffset = 0);

    void tryUnifyWithAny(TypeId subTy, TypeId anyTy);
    void tryUnifyWithAny(TypePackId subTy, TypePackId anyTp);

    std::optional<TypeId> findTablePropertyRespectingMeta(TypeId lhsType, Name name);

    TxnLog combineLogsIntoIntersection(std::vector<TxnLog> logs);
    TxnLog combineLogsIntoUnion(std::vector<TxnLog> logs);

public:
    // Returns true if the type "needle" already occurs within "haystack" and reports an "infinite type error"
    bool occursCheck(TypeId needle, TypeId haystack, bool reversed);
    bool occursCheck(DenseHashSet<TypeId>& seen, TypeId needle, TypeId haystack);
    bool occursCheck(TypePackId needle, TypePackId haystack, bool reversed);
    bool occursCheck(DenseHashSet<TypePackId>& seen, TypePackId needle, TypePackId haystack);

    Unifier makeChildUnifier();

    void reportError(TypeError err);
    LUAU_NOINLINE void reportError(Location location, TypeErrorData data);

private:
    TypeMismatch::Context mismatchContext();

    void checkChildUnifierTypeMismatch(const ErrorVec& innerErrors, TypeId wantedType, TypeId givenType);
    void checkChildUnifierTypeMismatch(const ErrorVec& innerErrors, const std::string& prop, TypeId wantedType, TypeId givenType);

    [[noreturn]] void ice(const std::string& message, const Location& location);
    [[noreturn]] void ice(const std::string& message);

    // Available after regular type pack unification errors
    std::optional<int> firstPackErrorPos;

    // If true, we do a bunch of small things differently to work better with
    // the new type inference engine. Most notably, we use the Scope hierarchy
    // directly rather than using TypeLevels.
    bool useNewSolver = false;
};

void promoteTypeLevels(TxnLog& log, const TypeArena* arena, TypeLevel minLevel, Scope* outerScope, bool useScope, TypePackId tp);
std::optional<TypeError> hasUnificationTooComplex(const ErrorVec& errors);
std::optional<TypeError> hasCountMismatch(const ErrorVec& errors);

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/TypeInfer.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/UnifierSharedState.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <unordered_set>

namespace Luau
{

struct Scope;
struct TypeChecker;
struct ModuleResolver;
struct FrontendCancellationToken;

using Name = std::string;
using ScopePtr = std::shared_ptr<Scope>;

struct OverloadErrorEntry
{
    TxnLog log;
    ErrorVec errors;
    std::vector<TypeId> arguments;
    const FunctionType* fnTy;
};

bool doesCallError(const AstExprCall* call);
bool hasBreak(AstStat* node);
const AstStat* getFallthrough(const AstStat* node);

struct UnifierOptions;
struct Unifier;

struct GenericTypeDefinitions
{
    std::vector<GenericTypeDefinition> genericTypes;
    std::vector<GenericTypePackDefinition> genericPacks;
};

struct HashBoolNamePair
{
    size_t operator()(const std::pair<bool, Name>& pair) const;
};

// All Types are retained via Environment::types.  All TypeIds
// within a program are borrowed pointers into this set.
struct TypeChecker
{
    explicit TypeChecker(
        const ScopePtr& globalScope, ModuleResolver* resolver, NotNull<BuiltinTypes> builtinTypes, InternalErrorReporter* iceHandler);
    TypeChecker(const TypeChecker&) = delete;
    TypeChecker& operator=(const TypeChecker&) = delete;

    ModulePtr check(const SourceModule& module, Mode mode, std::optional<ScopePtr> environmentScope = std::nullopt);
    ModulePtr checkWithoutRecursionCheck(const SourceModule& module, Mode mode, std::optional<ScopePtr> environmentScope = std::nullopt);

    std::vector<std::pair<Location, ScopePtr>> getScopes() const;

    ControlFlow check(const ScopePtr& scope, const AstStat& statement);
    ControlFlow check(const ScopePtr& scope, const AstStatBlock& statement);
    ControlFlow check(const ScopePtr& scope, const AstStatIf& statement);
    ControlFlow check(const ScopePtr& scope, const AstStatWhile& statement);
    ControlFlow check(const ScopePtr& scope, const AstStatRepeat& statement);
    ControlFlow check(const ScopePtr& scope, const AstStatReturn& return_);
    ControlFlow check(const ScopePtr& scope, const AstStatAssign& assign);
    ControlFlow check(const ScopePtr& scope, const AstStatCompoundAssign& assign);
    ControlFlow check(const ScopePtr& scope, const AstStatLocal& local);
    ControlFlow check(const ScopePtr& scope, const AstStatFor& local);
    ControlFlow check(const ScopePtr& scope, const AstStatForIn& forin);
    ControlFlow check(const ScopePtr& scope, TypeId ty, const ScopePtr& funScope, const AstStatFunction& function);
    ControlFlow check(const ScopePtr& scope, TypeId ty, const ScopePtr& funScope, const AstStatLocalFunction& function);
    ControlFlow check(const ScopePtr& scope, const AstStatTypeAlias& typealias);
    ControlFlow check(const ScopePtr& scope, const AstStatDeclareClass& declaredClass);
    ControlFlow check(const ScopePtr& scope, const AstStatDeclareFunction& declaredFunction);

    void prototype(const ScopePtr& scope, const AstStatTypeAlias& typealias, int subLevel = 0);
    void prototype(const ScopePtr& scope, const AstStatDeclareClass& declaredClass);

    ControlFlow checkBlock(const ScopePtr& scope, const AstStatBlock& statement);
    ControlFlow checkBlockWithoutRecursionCheck(const ScopePtr& scope, const AstStatBlock& statement);
    void checkBlockTypeAliases(const ScopePtr& scope, std::vector<AstStat*>& sorted);

    WithPredicate<TypeId> checkExpr(
        const ScopePtr& scope, const AstExpr& expr, std::optional<TypeId> expectedType = std::nullopt, bool forceSingleton = false);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprLocal& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprGlobal& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprVarargs& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprCall& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprIndexName& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprIndexExpr& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprFunction& expr, std::optional<TypeId> expectedType = std::nullopt);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprTable& expr, std::optional<TypeId> expectedType = std::nullopt);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprUnary& expr);
    TypeId checkRelationalOperation(
        const ScopePtr& scope, const AstExprBinary& expr, TypeId lhsType, TypeId rhsType, const PredicateVec& predicates = {});
    TypeId checkBinaryOperation(
        const ScopePtr& scope, const AstExprBinary& expr, TypeId lhsType, TypeId rhsType, const PredicateVec& predicates = {});
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprBinary& expr, std::optional<TypeId> expectedType = std::nullopt);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprTypeAssertion& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprError& expr);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprIfElse& expr, std::optional<TypeId> expectedType = std::nullopt);
    WithPredicate<TypeId> checkExpr(const ScopePtr& scope, const AstExprInterpString& expr);

    TypeId checkExprTable(const ScopePtr& scope, const AstExprTable& expr, const std::vector<std::pair<TypeId, TypeId>>& fieldTypes,
        std::optional<TypeId> expectedType);

    // Returns the type of the lvalue.
    TypeId checkLValue(const ScopePtr& scope, const AstExpr& expr, ValueContext ctx);

    // Returns the type of the lvalue.
    TypeId checkLValueBinding(const ScopePtr& scope, const AstExpr& expr, ValueContext ctx);
    TypeId checkLValueBinding(const ScopePtr& scope, const AstExprLocal& expr);
    TypeId checkLValueBinding(const ScopePtr& scope, const AstExprGlobal& expr);
    TypeId checkLValueBinding(const ScopePtr& scope, const AstExprIndexName& expr, ValueContext ctx);
    TypeId checkLValueBinding(const ScopePtr& scope, const AstExprIndexExpr& expr, ValueContext ctx);

    TypeId checkFunctionName(const ScopePtr& scope, AstExpr& funName, TypeLevel level);
    std::pair<TypeId, ScopePtr> checkFunctionSignature(const ScopePtr& scope, int subLevel, const AstExprFunction& expr,
        std::optional<Location> originalNameLoc, std::optional<TypeId> selfType, std::optional<TypeId> expectedType);
    void checkFunctionBody(const ScopePtr& scope, TypeId type, const AstExprFunction& function);

    void checkArgumentList(const ScopePtr& scope, const AstExpr& funName, Unifier& state, TypePackId paramPack, TypePackId argPack,
        const std::vector<Location>& argLocations);

    WithPredicate<TypePackId> checkExprPack(const ScopePtr& scope, const AstExpr& expr);

    WithPredicate<TypePackId> checkExprPackHelper(const ScopePtr& scope, const AstExpr& expr);
    WithPredicate<TypePackId> checkExprPackHelper(const ScopePtr& scope, const AstExprCall& expr);
    WithPredicate<TypePackId> checkExprPackHelper2(
        const ScopePtr& scope, const AstExprCall& expr, TypeId selfType, TypeId actualFunctionType, TypeId functionType, TypePackId retPack);

    std::vector<std::optional<TypeId>> getExpectedTypesForCall(const std::vector<TypeId>& overloads, size_t argumentCount, bool selfCall);

    std::unique_ptr<WithPredicate<TypePackId>> checkCallOverload(const ScopePtr& scope, const AstExprCall& expr, TypeId fn, TypePackId retPack,
        TypePackId argPack, TypePack* args, const std::vector<Location>* argLocations, const WithPredicate<TypePackId>& argListResult,
        std::vector<TypeId>& overloadsThatMatchArgCount, std::vector<TypeId>& overloadsThatDont, std::vector<OverloadErrorEntry>& errors);
    bool handleSelfCallMismatch(const ScopePtr& scope, const AstExprCall& expr, TypePack* args, const std::vector<Location>& argLocations,
        const std::vector<OverloadErrorEntry>& errors);
    void reportOverloadResolutionError(const ScopePtr& scope, const AstExprCall& expr, TypePackId retPack, TypePackId argPack,
        const std::vector<Location>& argLocations, const std::vector<TypeId>& overloads, const std::vector<TypeId>& overloadsThatMatchArgCount,
        std::vector<OverloadErrorEntry>& errors);

    WithPredicate<TypePackId> checkExprList(const ScopePtr& scope, const Location& location, const AstArray<AstExpr*>& exprs,
        bool substituteFreeForNil = false, const std::vector<bool>& lhsAnnotations = {},
        const std::vector<std::optional<TypeId>>& expectedTypes = {});

    static std::optional<AstExpr*> matchRequire(const AstExprCall& call);
    TypeId checkRequire(const ScopePtr& scope, const ModuleInfo& moduleInfo, const Location& location);

    // Try to infer that the provided type is a table of some sort.
    // Reports an error if the type is already some kind of non-table.
    void tablify(TypeId type);

    /** In nonstrict mode, many types need to be replaced by any.
     */
    TypeId anyIfNonstrict(TypeId ty) const;

    /** Attempt to unify the types.
     * Treat any failures as type errors in the final typecheck report.
     */
    bool unify(TypeId subTy, TypeId superTy, const ScopePtr& scope, const Location& location);
    bool unify(TypeId subTy, TypeId superTy, const ScopePtr& scope, const Location& location, const UnifierOptions& options);
    bool unify(TypePackId subTy, TypePackId superTy, const ScopePtr& scope, const Location& location,
        CountMismatch::Context ctx = CountMismatch::Context::Arg);

    /** Attempt to unify the types.
     * If this fails, and the subTy type can be instantiated, do so and try unification again.
     */
    bool unifyWithInstantiationIfNeeded(TypeId subTy, TypeId superTy, const ScopePtr& scope, const Location& location);
    void unifyWithInstantiationIfNeeded(TypeId subTy, TypeId superTy, const ScopePtr& scope, Unifier& state);

    /** Attempt to unify.
     * If there are errors, undo everything and return the errors.
     * If there are no errors, commit and return an empty error vector.
     */
    template<typename Id>
    ErrorVec tryUnify_(Id subTy, Id superTy, const ScopePtr& scope, const Location& location);
    ErrorVec tryUnify(TypeId subTy, TypeId superTy, const ScopePtr& scope, const Location& location);
    ErrorVec tryUnify(TypePackId subTy, TypePackId superTy, const ScopePtr& scope, const Location& location);

    // Test whether the two type vars unify.  Never commits the result.
    template<typename Id>
    ErrorVec canUnify_(Id subTy, Id superTy, const ScopePtr& scope, const Location& location);
    ErrorVec canUnify(TypeId subTy, TypeId superTy, const ScopePtr& scope, const Location& location);
    ErrorVec canUnify(TypePackId subTy, TypePackId superTy, const ScopePtr& scope, const Location& location);

    std::optional<TypeId> findMetatableEntry(TypeId type, std::string entry, const Location& location, bool addErrors);
    std::optional<TypeId> findTablePropertyRespectingMeta(TypeId lhsType, Name name, const Location& location, bool addErrors);

    std::optional<TypeId> getIndexTypeFromType(const ScopePtr& scope, TypeId type, const Name& name, const Location& location, bool addErrors);
    std::optional<TypeId> getIndexTypeFromTypeImpl(const ScopePtr& scope, TypeId type, const Name& name, const Location& location, bool addErrors);

    std::optional<TypeId> tryStripUnionFromNil(TypeId ty);
    TypeId stripFromNilAndReport(TypeId ty, const Location& location);

public:
    /*
     * Convert monotype into a a polytype, by replacing any metavariables in descendant scopes
     * by bound generic type variables. This is used to infer that a function is generic.
     */
    TypeId quantify(const ScopePtr& scope, TypeId ty, Location location);

    /*
     * Convert a polytype into a monotype, by replacing any bound generic types by type metavariables.
     * This is used to typecheck particular calls to generic functions, and when generic functions
     * are passed as arguments.
     *
     * The "changed" boolean is used to permit us to return the same TypeId in the case that the instantiated type is unchanged.
     * This is important in certain cases, such as methods on objects, where a table contains a function whose first argument is the table.
     * Without this property, we can wind up in a situation where a new TypeId is allocated for the outer table.  This can cause us to produce
     * unfortunate types like
     *
     *     {method: ({method: (<CYCLE>) -> a}) -> a}
     *
     */
    TypeId instantiate(const ScopePtr& scope, TypeId ty, Location location, const TxnLog* log = TxnLog::empty());

    // Replace any free types or type packs by `any`.
    // This is used when exporting types from modules, to make sure free types don't leak.
    TypeId anyify(const ScopePtr& scope, TypeId ty, Location location);
    TypePackId anyify(const ScopePtr& scope, TypePackId ty, Location location);

    TypePackId anyifyModuleReturnTypePackGenerics(TypePackId ty);

    void reportError(const TypeError& error);
    void reportError(const Location& location, TypeErrorData error);
    void reportErrors(const ErrorVec& errors);

    [[noreturn]] void ice(const std::string& message, const Location& location);
    [[noreturn]] void ice(const std::string& message);
    [[noreturn]] void throwTimeLimitError();
    [[noreturn]] void throwUserCancelError();

    ScopePtr childFunctionScope(const ScopePtr& parent, const Location& location, int subLevel = 0);
    ScopePtr childScope(const ScopePtr& parent, const Location& location);

    // Wrapper for merge(l, r, toUnion) but without the lambda junk.
    void merge(RefinementMap& l, const RefinementMap& r);

    // Produce an "emergency backup type" for recovery from type errors.
    // This comes in two flavours, depening on whether or not we can make a good guess
    // for an error recovery type.
    TypeId errorRecoveryType(TypeId guess);
    TypePackId errorRecoveryTypePack(TypePackId guess);
    TypeId errorRecoveryType(const ScopePtr& scope);
    TypePackId errorRecoveryTypePack(const ScopePtr& scope);

private:
    void prepareErrorsForDisplay(ErrorVec& errVec);
    void diagnoseMissingTableKey(UnknownProperty* utk, TypeErrorData& data);
    void reportErrorCodeTooComplex(const Location& location);

private:
    Unifier mkUnifier(const ScopePtr& scope, const Location& location);

    // These functions are only safe to call when we are in the process of typechecking a module.

    // Produce a new free type var.
    TypeId freshType(const ScopePtr& scope);
    TypeId freshType(TypeLevel level);

    // Produce a new singleton type var.
    TypeId singletonType(bool value);
    TypeId singletonType(std::string value);

    TypeIdPredicate mkTruthyPredicate(bool sense, TypeId emptySetTy);

    // TODO: Return TypeId only.
    std::optional<TypeId> filterMapImpl(TypeId type, TypeIdPredicate predicate);
    std::pair<std::optional<TypeId>, bool> filterMap(TypeId type, TypeIdPredicate predicate);

public:
    std::pair<std::optional<TypeId>, bool> pickTypesFromSense(TypeId type, bool sense, TypeId emptySetTy);

private:
    TypeId unionOfTypes(TypeId a, TypeId b, const ScopePtr& scope, const Location& location, bool unifyFreeTypes = true);

    // ex
    //      TypeId id = addType(FreeType());
    template<typename T>
    TypeId addType(const T& tv)
    {
        return addTV(Type(tv));
    }

    TypeId addTV(Type&& tv);

    TypePackId addTypePack(TypePackVar&& tp);
    TypePackId addTypePack(TypePack&& tp);

    TypePackId addTypePack(const std::vector<TypeId>& ty);
    TypePackId addTypePack(const std::vector<TypeId>& ty, std::optional<TypePackId> tail);
    TypePackId addTypePack(std::initializer_list<TypeId>&& ty);
    TypePackId freshTypePack(const ScopePtr& scope);
    TypePackId freshTypePack(TypeLevel level);

    TypeId resolveType(const ScopePtr& scope, const AstType& annotation);
    TypeId resolveTypeWorker(const ScopePtr& scope, const AstType& annotation);
    TypePackId resolveTypePack(const ScopePtr& scope, const AstTypeList& types);
    TypePackId resolveTypePack(const ScopePtr& scope, const AstTypePack& annotation);
    TypeId instantiateTypeFun(const ScopePtr& scope, const TypeFun& tf, const std::vector<TypeId>& typeParams,
        const std::vector<TypePackId>& typePackParams, const Location& location);

    // Note: `scope` must be a fresh scope.
    GenericTypeDefinitions createGenericTypes(const ScopePtr& scope, std::optional<TypeLevel> levelOpt, const AstNode& node,
        const AstArray<AstGenericType>& genericNames, const AstArray<AstGenericTypePack>& genericPackNames, bool useCache = false);

public:
    void resolve(const PredicateVec& predicates, const ScopePtr& scope, bool sense);

private:
    void refineLValue(const LValue& lvalue, RefinementMap& refis, const ScopePtr& scope, TypeIdPredicate predicate);

    std::optional<TypeId> resolveLValue(const ScopePtr& scope, const LValue& lvalue);
    std::optional<TypeId> resolveLValue(const RefinementMap& refis, const ScopePtr& scope, const LValue& lvalue);

    void resolve(const PredicateVec& predicates, RefinementMap& refis, const ScopePtr& scope, bool sense, bool fromOr = false);
    void resolve(const Predicate& predicate, RefinementMap& refis, const ScopePtr& scope, bool sense, bool fromOr);
    void resolve(const TruthyPredicate& truthyP, RefinementMap& refis, const ScopePtr& scope, bool sense, bool fromOr);
    void resolve(const AndPredicate& andP, RefinementMap& refis, const ScopePtr& scope, bool sense);
    void resolve(const OrPredicate& orP, RefinementMap& refis, const ScopePtr& scope, bool sense);
    void resolve(const IsAPredicate& isaP, RefinementMap& refis, const ScopePtr& scope, bool sense);
    void resolve(const TypeGuardPredicate& typeguardP, RefinementMap& refis, const ScopePtr& scope, bool sense);
    void resolve(const EqPredicate& eqP, RefinementMap& refis, const ScopePtr& scope, bool sense);

    bool isNonstrictMode() const;
    bool useConstrainedIntersections() const;

public:
    /** Extract the types in a type pack, given the assumption that the pack must have some exact length.
     * TypePacks can have free tails, which means that inference has not yet determined the length of the pack.
     * Calling this function means submitting evidence that the pack must have the length provided.
     * If the pack is known not to have the correct length, an error will be reported.
     * The return vector is always of the exact requested length.  In the event that the pack's length does
     * not match up, excess TypeIds will be ErrorTypes.
     */
    std::vector<TypeId> unTypePack(const ScopePtr& scope, TypePackId pack, size_t expectedLength, const Location& location);

    const ScopePtr& globalScope;

    ModuleResolver* resolver;
    ModulePtr currentModule;

    std::function<void(const ModuleName&, const ScopePtr&)> prepareModuleScope;
    NotNull<BuiltinTypes> builtinTypes;
    InternalErrorReporter* iceHandler;

    UnifierSharedState unifierState;
    Normalizer normalizer;

    Instantiation reusableInstantiation;

    std::vector<RequireCycle> requireCycles;

    // Type inference limits
    std::optional<double> finishTime;
    std::optional<int> instantiationChildLimit;
    std::optional<int> unifierIterationLimit;

    std::shared_ptr<FrontendCancellationToken> cancellationToken;

public:
    const TypeId nilType;
    const TypeId numberType;
    const TypeId stringType;
    const TypeId booleanType;
    const TypeId threadType;
    const TypeId bufferType;
    const TypeId anyType;
    const TypeId unknownType;
    const TypeId neverType;

    const TypePackId anyTypePack;
    const TypePackId neverTypePack;
    const TypePackId uninhabitableTypePack;

private:
    int checkRecursionCount = 0;
    int recursionCount = 0;

    /**
     * We use this to avoid doing second-pass analysis of type aliases that are duplicates. We record a pair
     * (exported, name) to properly deal with the case where the two duplicates do not have the same export status.
     */
    DenseHashSet<std::pair<bool, Name>, HashBoolNamePair> duplicateTypeAliases;

    /**
     * A set of incorrect class definitions which is used to avoid a second-pass analysis.
     */
    DenseHashSet<const AstStatDeclareClass*> incorrectClassDefinitions{nullptr};

    std::vector<std::pair<TypeId, ScopePtr>> deferredQuantification;
};

using PrintLineProc = void (*)(const std::string&);

extern PrintLineProc luauPrintLine;

// Unit test hook
void setPrintLine(PrintLineProc pl);
void resetPrintLine();

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Set.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/FileResolver.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Clone.h>

#line __LINE__ "Analysis/include/Luau/Clone.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : was already included! <unordered_map>

namespace Luau
{

// Only exposed so they can be unit tested.
using SeenTypes = std::unordered_map<TypeId, TypeId>;
using SeenTypePacks = std::unordered_map<TypePackId, TypePackId>;

struct CloneState
{
    NotNull<BuiltinTypes> builtinTypes;

    SeenTypes seenTypes;
    SeenTypePacks seenTypePacks;
};

TypePackId clone(TypePackId tp, TypeArena& dest, CloneState& cloneState);
TypeId clone(TypeId tp, TypeArena& dest, CloneState& cloneState);
TypeFun clone(const TypeFun& typeFun, TypeArena& dest, CloneState& cloneState);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Constraint.h>

#line __LINE__ "Analysis/include/Luau/Constraint.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>
 // Used for some of the enumerations
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

enum class ValueContext;
struct Scope;

// if resultType is a freeType, assignmentType <: freeType <: resultType bounds
struct EqualityConstraint
{
    TypeId resultType;
    TypeId assignmentType;
};

// subType <: superType
struct SubtypeConstraint
{
    TypeId subType;
    TypeId superType;
};

// subPack <: superPack
struct PackSubtypeConstraint
{
    TypePackId subPack;
    TypePackId superPack;

    // HACK!! TODO clip.
    // We need to know which of `PackSubtypeConstraint` are emitted from `AstStatReturn` vs any others.
    // Then we force these specific `PackSubtypeConstraint` to only dispatch in the order of the `return`s.
    bool returns = false;
};

// generalizedType ~ gen sourceType
struct GeneralizationConstraint
{
    TypeId generalizedType;
    TypeId sourceType;

    std::vector<TypeId> interiorTypes;
};

// variables ~ iterate iterator
// Unpack the iterator, figure out what types it iterates over, and bind those types to variables.
struct IterableConstraint
{
    TypePackId iterator;
    std::vector<TypeId> variables;

    const AstNode* nextAstFragment;
    DenseHashMap<const AstNode*, TypeId>* astForInNextTypes;
};

// name(namedType) = name
struct NameConstraint
{
    TypeId namedType;
    std::string name;
    bool synthetic = false;
    std::vector<TypeId> typeParameters;
    std::vector<TypePackId> typePackParameters;
};

// target ~ inst target
struct TypeAliasExpansionConstraint
{
    // Must be a PendingExpansionType.
    TypeId target;
};

struct FunctionCallConstraint
{
    TypeId fn;
    TypePackId argsPack;
    TypePackId result;
    class AstExprCall* callSite = nullptr;
    std::vector<std::optional<TypeId>> discriminantTypes;

    // When we dispatch this constraint, we update the key at this map to record
    // the overload that we selected.
    DenseHashMap<const AstNode*, TypeId>* astOverloadResolvedTypes = nullptr;
};

// function_check fn argsPack
//
// If fn is a function type and argsPack is a partially solved
// pack of arguments to be supplied to the function, propagate the argument
// types of fn into the types of argsPack. This is used to implement
// bidirectional inference of lambda arguments.
struct FunctionCheckConstraint
{
    TypeId fn;
    TypePackId argsPack;

    class AstExprCall* callSite = nullptr;
    NotNull<DenseHashMap<const AstExpr*, TypeId>> astTypes;
    NotNull<DenseHashMap<const AstExpr*, TypeId>> astExpectedTypes;
};

// prim FreeType ExpectedType PrimitiveType
//
// FreeType is bounded below by the singleton type and above by PrimitiveType
// initially. When this constraint is resolved, it will check that the bounds
// of the free type are well-formed by subtyping.
//
// If they are not well-formed, then FreeType is replaced by its lower bound
//
// If they are well-formed and ExpectedType is potentially a singleton (an
// actual singleton or a union that contains a singleton),
// then FreeType is replaced by its lower bound
//
// else FreeType is replaced by PrimitiveType
struct PrimitiveTypeConstraint
{
    TypeId freeType;

    // potentially gets used to force the lower bound?
    std::optional<TypeId> expectedType;

    // the primitive type to check against
    TypeId primitiveType;
};

// result ~ hasProp type "prop_name"
//
// If the subject is a table, bind the result to the named prop.  If the table
// has an indexer, bind it to the index result type. If the subject is a union,
// bind the result to the union of its constituents' properties.
//
// It would be nice to get rid of this constraint and someday replace it with
//
// T <: {p: X}
//
// Where {} describes an inexact shape type.
struct HasPropConstraint
{
    TypeId resultType;
    TypeId subjectType;
    std::string prop;
    ValueContext context;

    // We want to track if this `HasPropConstraint` comes from a conditional.
    // If it does, we're going to change the behavior of property look-up a bit.
    // In particular, we're going to return `unknownType` for property lookups
    // on `table` or inexact table types where the property is not present.
    //
    // This allows us to refine table types to have additional properties
    // without reporting errors in typechecking on the property tests.
    bool inConditional = false;

    // HACK: We presently need types like true|false or string|"hello" when
    // deciding whether a particular literal expression should have a singleton
    // type.  This boolean is set to true when extracting the property type of a
    // value that may be a union of tables.
    //
    // For example, in the following code fragment, we want the lookup of the
    // success property to yield true|false when extracting an expectedType in
    // this expression:
    //
    // type Result<T, E> = {success:true, result: T} | {success:false, error: E}
    //
    // local r: Result<number, string> = {success=true, result=9}
    //
    // If we naively simplify the expectedType to boolean, we will erroneously
    // compute the type boolean for the success property of the table literal.
    // This causes type checking to fail.
    bool suppressSimplification = false;
};

// resultType ~ hasIndexer subjectType indexType
//
// If the subject type is a table or table-like thing that supports indexing,
// populate the type result with the result type of such an index operation.
//
// If the subject is not indexable, resultType is bound to errorType.
struct HasIndexerConstraint
{
    TypeId resultType;
    TypeId subjectType;
    TypeId indexType;
};

// assignProp lhsType propName rhsType
//
// Assign a value of type rhsType into the named property of lhsType.

struct AssignPropConstraint
{
    TypeId lhsType;
    std::string propName;
    TypeId rhsType;

    /// If a new property is to be inserted into a table type, it will be
    /// ascribed this location.
    std::optional<Location> propLocation;

    /// The canonical write type of the property.  It is _solely_ used to
    /// populate astTypes during constraint resolution.  Nothing should ever
    /// block on it.
    TypeId propType;

    // When we generate constraints, we increment the remaining prop count on
    // the table if we are able. This flag informs the solver as to whether or
    // not it should in turn decrement the prop count when this constraint is
    // dispatched.
    bool decrementPropCount = false;
};

struct AssignIndexConstraint
{
    TypeId lhsType;
    TypeId indexType;
    TypeId rhsType;

    /// The canonical write type of the property.  It is _solely_ used to
    /// populate astTypes during constraint resolution.  Nothing should ever
    /// block on it.
    TypeId propType;
};

// resultTypes ~ unpack sourceTypePack
//
// Similar to PackSubtypeConstraint, but with one important difference: If the
// sourcePack is blocked, this constraint blocks.
struct UnpackConstraint
{
    std::vector<TypeId> resultPack;
    TypePackId sourcePack;
};

// ty ~ reduce ty
//
// Try to reduce ty, if it is a TypeFunctionInstanceType. Otherwise, do nothing.
struct ReduceConstraint
{
    TypeId ty;
};

// tp ~ reduce tp
//
// Analogous to ReduceConstraint, but for type packs.
struct ReducePackConstraint
{
    TypePackId tp;
};

using ConstraintV = Variant<SubtypeConstraint, PackSubtypeConstraint, GeneralizationConstraint, IterableConstraint, NameConstraint,
    TypeAliasExpansionConstraint, FunctionCallConstraint, FunctionCheckConstraint, PrimitiveTypeConstraint, HasPropConstraint, HasIndexerConstraint,
    AssignPropConstraint, AssignIndexConstraint, UnpackConstraint, ReduceConstraint, ReducePackConstraint, EqualityConstraint>;

struct Constraint
{
    Constraint(NotNull<Scope> scope, const Location& location, ConstraintV&& c);

    Constraint(const Constraint&) = delete;
    Constraint& operator=(const Constraint&) = delete;

    NotNull<Scope> scope;
    Location location;
    ConstraintV c;

    std::vector<NotNull<Constraint>> dependencies;

    DenseHashSet<TypeId> getMaybeMutatedFreeTypes() const;
};

using ConstraintPtr = std::unique_ptr<Constraint>;

bool isReferenceCountedType(const TypeId typ);

inline Constraint& asMutable(const Constraint& c)
{
    return const_cast<Constraint&>(c);
}

template<typename T>
T* getMutable(Constraint& c)
{
    return ::Luau::get_if<T>(&c.c);
}

template<typename T>
const T* get(const Constraint& c)
{
    return getMutable<T>(asMutable(c));
}

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/JsonEmitter.h>

#line __LINE__ "Analysis/include/Luau/JsonEmitter.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : was already included! <type_traits>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

namespace Luau::Json
{

struct JsonEmitter;

/// Writes a value to the JsonEmitter. Note that this can produce invalid JSON
/// if you do not insert commas or appropriate object / array syntax.
template<typename T>
void write(JsonEmitter&, T) = delete;

/// Writes a boolean to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param b the boolean to write.
void write(JsonEmitter& emitter, bool b);

/// Writes an integer to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param i the integer to write.
void write(JsonEmitter& emitter, int i);

/// Writes an integer to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param i the integer to write.
void write(JsonEmitter& emitter, long i);

/// Writes an integer to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param i the integer to write.
void write(JsonEmitter& emitter, long long i);

/// Writes an integer to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param i the integer to write.
void write(JsonEmitter& emitter, unsigned int i);

/// Writes an integer to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param i the integer to write.
void write(JsonEmitter& emitter, unsigned long i);

/// Writes an integer to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param i the integer to write.
void write(JsonEmitter& emitter, unsigned long long i);

/// Writes a double to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param d the double to write.
void write(JsonEmitter& emitter, double d);

/// Writes a string to a JsonEmitter. The string will be escaped.
/// @param emitter the emitter to write to.
/// @param sv the string to write.
void write(JsonEmitter& emitter, std::string_view sv);

/// Writes a character to a JsonEmitter as a single-character string. The
/// character will be escaped.
/// @param emitter the emitter to write to.
/// @param c the string to write.
void write(JsonEmitter& emitter, char c);

/// Writes a string to a JsonEmitter. The string will be escaped.
/// @param emitter the emitter to write to.
/// @param str the string to write.
void write(JsonEmitter& emitter, const char* str);

/// Writes a string to a JsonEmitter. The string will be escaped.
/// @param emitter the emitter to write to.
/// @param str the string to write.
void write(JsonEmitter& emitter, const std::string& str);

/// Writes null to a JsonEmitter.
/// @param emitter the emitter to write to.
void write(JsonEmitter& emitter, std::nullptr_t);

/// Writes null to a JsonEmitter.
/// @param emitter the emitter to write to.
void write(JsonEmitter& emitter, std::nullopt_t);

struct ObjectEmitter;
struct ArrayEmitter;

struct JsonEmitter
{
    JsonEmitter();

    /// Converts the current contents of the JsonEmitter to a string value. This
    /// does not invalidate the emitter, but it does not clear it either.
    std::string str();

    /// Returns the current comma state and resets it to false. Use popComma to
    /// restore the old state.
    /// @returns the previous comma state.
    bool pushComma();

    /// Restores a previous comma state.
    /// @param c the comma state to restore.
    void popComma(bool c);

    /// Writes a raw sequence of characters to the buffer, without escaping or
    /// other processing.
    /// @param sv the character sequence to write.
    void writeRaw(std::string_view sv);

    /// Writes a character to the buffer, without escaping or other processing.
    /// @param c the character to write.
    void writeRaw(char c);

    /// Writes a comma if this wasn't the first time writeComma has been
    /// invoked. Otherwise, sets the comma state to true.
    /// @see pushComma
    /// @see popComma
    void writeComma();

    /// Begins writing an object to the emitter.
    /// @returns an ObjectEmitter that can be used to write key-value pairs.
    ObjectEmitter writeObject();

    /// Begins writing an array to the emitter.
    /// @returns an ArrayEmitter that can be used to write values.
    ArrayEmitter writeArray();

private:
    bool comma = false;
    std::vector<std::string> chunks;

    void newChunk();
};

/// An interface for writing an object into a JsonEmitter instance.
/// @see JsonEmitter::writeObject
struct ObjectEmitter
{
    ObjectEmitter(NotNull<JsonEmitter> emitter);
    ~ObjectEmitter();

    NotNull<JsonEmitter> emitter;
    bool comma;
    bool finished;

    /// Writes a key-value pair to the associated JsonEmitter. Keys will be escaped.
    /// @param name the name of the key-value pair.
    /// @param value the value to write.
    template<typename T>
    void writePair(std::string_view name, T value)
    {
        if (finished)
        {
            return;
        }

        emitter->writeComma();
        write(*emitter, name);
        emitter->writeRaw(':');
        write(*emitter, value);
    }

    /// Finishes writing the object, appending a closing `}` character and
    /// resetting the comma state of the associated emitter. This can only be
    /// called once, and once called will render the emitter unusable. This
    /// method is also called when the ObjectEmitter is destructed.
    void finish();
};

/// An interface for writing an array into a JsonEmitter instance. Array values
/// do not need to be the same type.
/// @see JsonEmitter::writeArray
struct ArrayEmitter
{
    ArrayEmitter(NotNull<JsonEmitter> emitter);
    ~ArrayEmitter();

    NotNull<JsonEmitter> emitter;
    bool comma;
    bool finished;

    /// Writes a value to the array.
    /// @param value the value to write.
    template<typename T>
    void writeValue(T value)
    {
        if (finished)
        {
            return;
        }

        emitter->writeComma();
        write(*emitter, value);
    }

    /// Finishes writing the object, appending a closing `]` character and
    /// resetting the comma state of the associated emitter. This can only be
    /// called once, and once called will render the emitter unusable. This
    /// method is also called when the ArrayEmitter is destructed.
    void finish();
};

/// Writes a vector as an array to a JsonEmitter.
/// @param emitter the emitter to write to.
/// @param vec the vector to write.
template<typename T>
void write(JsonEmitter& emitter, const std::vector<T>& vec)
{
    ArrayEmitter a = emitter.writeArray();

    for (const T& value : vec)
        a.writeValue(value);

    a.finish();
}

/// Writes an optional to a JsonEmitter. Will write the contained value, if
/// present, or null, if no value is present.
/// @param emitter the emitter to write to.
/// @param v the value to write.
template<typename T>
void write(JsonEmitter& emitter, const std::optional<T>& v)
{
    if (v.has_value())
        write(emitter, *v);
    else
        emitter.writeRaw("null");
}

template<typename T>
void write(JsonEmitter& emitter, const std::unordered_map<std::string, T>& map)
{
    ObjectEmitter o = emitter.writeObject();

    for (const auto& [k, v] : map)
        o.writePair(k, v);

    o.finish();
}

} // namespace Luau::Json

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Refinement.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/RequireTracer.h>

#line __LINE__ "Analysis/include/Luau/RequireTracer.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/FileResolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

class AstStat;
class AstExpr;
class AstStatBlock;
struct AstLocal;

struct RequireTraceResult
{
    DenseHashMap<const AstExpr*, ModuleInfo> exprs{nullptr};

    std::vector<std::pair<ModuleName, Location>> requireList;
};

RequireTraceResult traceRequires(FileResolver* fileResolver, AstStatBlock* root, const ModuleName& currentModuleName);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Def.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Transpiler.h>

#line __LINE__ "Analysis/include/Luau/Transpiler.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ParseOptions.h>

// @@@@@ PACK.LUA : was already included! <string>

namespace Luau
{
class AstNode;
class AstStatBlock;

struct TranspileResult
{
    std::string code;
    Location errorLocation;
    std::string parseError; // Nonempty if the transpile failed
};

std::string toString(AstNode* node);
void dump(AstNode* node);

// Never fails on a well-formed AST
std::string transpile(AstStatBlock& ast);
std::string transpileWithTypes(AstStatBlock& block);

// Only fails when parsing fails
TranspileResult transpile(std::string_view source, ParseOptions options = ParseOptions{}, bool withTypes = false);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Predicate.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/ControlFlow.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Unifier.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Subtyping.h>

#line __LINE__ "Analysis/include/Luau/Subtyping.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Set.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypePairHash.h>

#line __LINE__ "Luau/TypePairHash.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.lua : not found, likely and std header
#include <stdint.h>

// @@@@@ PACK.LUA : was already included! <utility>

namespace Luau
{

struct TypePairHash
{
    size_t hashOne(TypeId key) const
    {
        return (uintptr_t(key) >> 4) ^ (uintptr_t(key) >> 9);
    }

    size_t hashOne(TypePackId key) const
    {
        return (uintptr_t(key) >> 4) ^ (uintptr_t(key) >> 9);
    }

    size_t operator()(const std::pair<TypeId, TypeId>& x) const
    {
        return hashOne(x.first) ^ (hashOne(x.second) << 1);
    }

    size_t operator()(const std::pair<TypePackId, TypePackId>& x) const
    {
        return hashOne(x.first) ^ (hashOne(x.second) << 1);
    }
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/Subtyping.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypePath.h>

#line __LINE__ "Luau/TypePath.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

namespace TypePath
{

/// Represents a property of a class, table, or anything else with a concept of
/// a named property.
struct Property
{
    /// The name of the property.
    std::string name;
    /// Whether to look at the read or the write type.
    bool isRead = true;

    explicit Property(std::string name);
    Property(std::string name, bool read)
        : name(std::move(name))
        , isRead(read)
    {
    }

    static Property read(std::string name);
    static Property write(std::string name);

    bool operator==(const Property& other) const;
};

/// Represents an index into a type or a pack. For a type, this indexes into a
/// union or intersection's list. For a pack, this indexes into the pack's nth
/// element.
struct Index
{
    /// The 0-based index to use for the lookup.
    size_t index;

    bool operator==(const Index& other) const;
};

/// Represents fields of a type or pack that contain a type.
enum class TypeField
{
    /// The metatable of a type. This could be a metatable type, a primitive
    /// type, a class type, or perhaps even a string singleton type.
    Metatable,
    /// The lower bound of this type, if one is present.
    LowerBound,
    /// The upper bound of this type, if present.
    UpperBound,
    /// The index type.
    IndexLookup,
    /// The indexer result type.
    IndexResult,
    /// The negated type, for negations.
    Negated,
    /// The variadic type for a type pack.
    Variadic,
};

/// Represents fields of a type or type pack that contain a type pack.
enum class PackField
{
    /// What arguments this type accepts.
    Arguments,
    /// What this type returns when called.
    Returns,
    /// The tail of a type pack.
    Tail,
};

/// Component that represents the result of a reduction
/// `resultType` is `never` if the reduction could not proceed
struct Reduction
{
    TypeId resultType;

    bool operator==(const Reduction& other) const;
};

/// A single component of a path, representing one inner type or type pack to
/// traverse into.
using Component = Luau::Variant<Property, Index, TypeField, PackField, Reduction>;

/// A path through a type or type pack accessing a particular type or type pack
/// contained within.
///
/// Paths are always relative; to make use of a Path, you need to specify an
/// entry point. They are not canonicalized; two Paths may not compare equal but
/// may point to the same result, depending on the layout of the entry point.
///
/// Paths always descend through an entry point. This doesn't mean that they
/// cannot reach "upwards" in the actual type hierarchy in some cases, but it
/// does mean that there is no equivalent to `../` in file system paths. This is
/// intentional and unavoidable, because types and type packs don't have a
/// concept of a parent - they are a directed cyclic graph, with no hierarchy
/// that actually holds in all cases.
struct Path
{
    /// The Components of this Path.
    std::vector<Component> components;

    /// Creates a new empty Path.
    Path() {}

    /// Creates a new Path from a list of components.
    explicit Path(std::vector<Component> components)
        : components(std::move(components))
    {
    }

    /// Creates a new single-component Path.
    explicit Path(Component component)
        : components({component})
    {
    }

    /// Creates a new Path by appending another Path to this one.
    /// @param suffix the Path to append
    /// @return a new Path representing `this + suffix`
    Path append(const Path& suffix) const;

    /// Creates a new Path by appending a Component to this Path.
    /// @param component the Component to append
    /// @return a new Path with `component` appended to it.
    Path push(Component component) const;

    /// Creates a new Path by prepending a Component to this Path.
    /// @param component the Component to prepend
    /// @return a new Path with `component` prepended to it.
    Path push_front(Component component) const;

    /// Creates a new Path by removing the last Component of this Path.
    /// If the Path is empty, this is a no-op.
    /// @return a Path with the last component removed.
    Path pop() const;

    /// Returns the last Component of this Path, if present.
    std::optional<Component> last() const;

    /// Returns whether this Path is empty, meaning it has no components at all.
    /// Traversing an empty Path results in the type you started with.
    bool empty() const;

    bool operator==(const Path& other) const;
    bool operator!=(const Path& other) const
    {
        return !(*this == other);
    }
};

struct PathHash
{
    size_t operator()(const Property& prop) const;
    size_t operator()(const Index& idx) const;
    size_t operator()(const TypeField& field) const;
    size_t operator()(const PackField& field) const;
    size_t operator()(const Reduction& reduction) const;
    size_t operator()(const Component& component) const;
    size_t operator()(const Path& path) const;
};

/// The canonical "empty" Path, meaning a Path with no components.
static const Path kEmpty{};

struct PathBuilder
{
    std::vector<Component> components;

    Path build();

    PathBuilder& readProp(std::string name);
    PathBuilder& writeProp(std::string name);
    PathBuilder& prop(std::string name);
    PathBuilder& index(size_t i);
    PathBuilder& mt();
    PathBuilder& lb();
    PathBuilder& ub();
    PathBuilder& indexKey();
    PathBuilder& indexValue();
    PathBuilder& negated();
    PathBuilder& variadic();
    PathBuilder& args();
    PathBuilder& rets();
    PathBuilder& tail();
};

} // namespace TypePath

using Path = TypePath::Path;

/// Converts a Path to a string for debugging purposes. This output may not be
/// terribly clear to end users of the Luau type system.
std::string toString(const TypePath::Path& path, bool prefixDot = false);

std::optional<TypeOrPack> traverse(TypeId root, const Path& path, NotNull<BuiltinTypes> builtinTypes);
std::optional<TypeOrPack> traverse(TypePackId root, const Path& path, NotNull<BuiltinTypes> builtinTypes);

/// Traverses a path from a type to its end point, which must be a type.
/// @param root the entry point of the traversal
/// @param path the path to traverse
/// @param builtinTypes the built-in types in use (used to acquire the string metatable)
/// @returns the TypeId at the end of the path, or nullopt if the traversal failed.
std::optional<TypeId> traverseForType(TypeId root, const Path& path, NotNull<BuiltinTypes> builtinTypes);

/// Traverses a path from a type pack to its end point, which must be a type.
/// @param root the entry point of the traversal
/// @param path the path to traverse
/// @param builtinTypes the built-in types in use (used to acquire the string metatable)
/// @returns the TypeId at the end of the path, or nullopt if the traversal failed.
std::optional<TypeId> traverseForType(TypePackId root, const Path& path, NotNull<BuiltinTypes> builtinTypes);

/// Traverses a path from a type to its end point, which must be a type pack.
/// @param root the entry point of the traversal
/// @param path the path to traverse
/// @param builtinTypes the built-in types in use (used to acquire the string metatable)
/// @returns the TypePackId at the end of the path, or nullopt if the traversal failed.
std::optional<TypePackId> traverseForPack(TypeId root, const Path& path, NotNull<BuiltinTypes> builtinTypes);

/// Traverses a path from a type pack to its end point, which must be a type pack.
/// @param root the entry point of the traversal
/// @param path the path to traverse
/// @param builtinTypes the built-in types in use (used to acquire the string metatable)
/// @returns the TypePackId at the end of the path, or nullopt if the traversal failed.
std::optional<TypePackId> traverseForPack(TypePackId root, const Path& path, NotNull<BuiltinTypes> builtinTypes);

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/Subtyping.h"
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeFunction.h>

#line __LINE__ "Luau/TypeFunction.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ConstraintSolver.h>

#line __LINE__ "Luau/ConstraintSolver.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// DONE : was aleready inlined <Luau/Constraint.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ToString.h>

#line __LINE__ "Luau/ToString.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <vector>

LUAU_FASTINT(LuauTableTypeMaximumStringifierLength)
LUAU_FASTINT(LuauTypeMaximumStringifierLength)

namespace Luau
{

class AstExpr;

struct Scope;

struct Constraint;

struct Position;
struct Location;

struct ToStringNameMap
{
    std::unordered_map<TypeId, std::string> types;
    std::unordered_map<TypePackId, std::string> typePacks;
};

struct ToStringOptions
{
    ToStringOptions(bool exhaustive = false)
        : exhaustive(exhaustive)
    {
    }

    bool exhaustive = false;                      // If true, we produce complete output rather than comprehensible output
    bool useLineBreaks = false;                   // If true, we insert new lines to separate long results such as table entries/metatable.
    bool functionTypeArguments = false;           // If true, output function type argument names when they are available
    bool hideTableKind = false;                   // If true, all tables will be surrounded with plain '{}'
    bool hideNamedFunctionTypeParameters = false; // If true, type parameters of functions will be hidden at top-level.
    bool hideFunctionSelfArgument = false;        // If true, `self: X` will be omitted from the function signature if the function has self
    size_t maxTableLength = size_t(FInt::LuauTableTypeMaximumStringifierLength); // Only applied to TableTypes
    size_t maxTypeLength = size_t(FInt::LuauTypeMaximumStringifierLength);
    size_t compositeTypesSingleLineLimit = 5; // The number of type elements permitted on a single line when printing type unions/intersections
    ToStringNameMap nameMap;
    std::shared_ptr<Scope> scope; // If present, module names will be added and types that are not available in scope will be marked as 'invalid'
    std::vector<std::string> namedFunctionOverrideArgNames; // If present, named function argument names will be overridden
};

struct ToStringResult
{
    std::string name;

    bool invalid = false;
    bool error = false;
    bool cycle = false;
    bool truncated = false;
};

ToStringResult toStringDetailed(TypeId ty, ToStringOptions& opts);
ToStringResult toStringDetailed(TypePackId ty, ToStringOptions& opts);

std::string toString(TypeId ty, ToStringOptions& opts);
std::string toString(TypePackId ty, ToStringOptions& opts);

// These overloads are selected when a temporary ToStringOptions is passed. (eg
// via an initializer list)
inline std::string toString(TypePackId ty, ToStringOptions&& opts)
{
    // Delegate to the overload (TypePackId, ToStringOptions&)
    return toString(ty, opts);
}
inline std::string toString(TypeId ty, ToStringOptions&& opts)
{
    // Delegate to the overload (TypeId, ToStringOptions&)
    return toString(ty, opts);
}

// These are offered as overloads rather than a default parameter so that they can be easily invoked from within the MSVC debugger.
// You can use them in watch expressions!
inline std::string toString(TypeId ty)
{
    return toString(ty, ToStringOptions{});
}
inline std::string toString(TypePackId ty)
{
    return toString(ty, ToStringOptions{});
}

std::string toString(const Constraint& c, ToStringOptions& opts);

inline std::string toString(const Constraint& c, ToStringOptions&& opts)
{
    return toString(c, opts);
}

std::string toString(const Constraint& c);

std::string toString(const Type& tv, ToStringOptions& opts);
std::string toString(const TypePackVar& tp, ToStringOptions& opts);

inline std::string toString(const Type& tv)
{
    ToStringOptions opts;
    return toString(tv, opts);
}

inline std::string toString(const TypePackVar& tp)
{
    ToStringOptions opts;
    return toString(tp, opts);
}

std::string toStringNamedFunction(const std::string& funcName, const FunctionType& ftv, ToStringOptions& opts);

inline std::string toStringNamedFunction(const std::string& funcName, const FunctionType& ftv)
{
    ToStringOptions opts;
    return toStringNamedFunction(funcName, ftv, opts);
}

std::optional<std::string> getFunctionNameAsString(const AstExpr& expr);

// It could be useful to see the text representation of a type during a debugging session instead of exploring the content of the class
// These functions will dump the type to stdout and can be evaluated in Watch/Immediate windows or as gdb/lldb expression
std::string dump(TypeId ty);
std::string dump(const std::optional<TypeId>& ty);
std::string dump(TypePackId ty);
std::string dump(const std::optional<TypePackId>& ty);
std::string dump(const Constraint& c);

std::string dump(const std::shared_ptr<Scope>& scope, const char* name);

std::string generateName(size_t n);

std::string toString(const Position& position);
std::string toString(const Location& location, int offset = 0, bool useBegin = true);

std::string toString(const TypeOrPack& tyOrTp, ToStringOptions& opts);

inline std::string toString(const TypeOrPack& tyOrTp)
{
    ToStringOptions opts{};
    return toString(tyOrTp, opts);
}

std::string dump(const TypeOrPack& tyOrTp);

} // namespace Luau

#line __LINE__ "Luau/ConstraintSolver.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <utility>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

enum class ValueContext;

struct DcrLogger;

class AstExpr;

// TypeId, TypePackId, or Constraint*. It is impossible to know which, but we
// never dereference this pointer.
using BlockedConstraintId = Variant<TypeId, TypePackId, const Constraint*>;

struct HashBlockedConstraintId
{
    size_t operator()(const BlockedConstraintId& bci) const;
};

struct ModuleResolver;

struct InstantiationSignature
{
    TypeFun fn;
    std::vector<TypeId> arguments;
    std::vector<TypePackId> packArguments;

    bool operator==(const InstantiationSignature& rhs) const;
    bool operator!=(const InstantiationSignature& rhs) const
    {
        return !((*this) == rhs);
    }
};

struct HashInstantiationSignature
{
    size_t operator()(const InstantiationSignature& signature) const;
};

struct ConstraintSolver
{
    NotNull<TypeArena> arena;
    NotNull<BuiltinTypes> builtinTypes;
    InternalErrorReporter iceReporter;
    NotNull<Normalizer> normalizer;
    // The entire set of constraints that the solver is trying to resolve.
    std::vector<NotNull<Constraint>> constraints;
    NotNull<Scope> rootScope;
    ModuleName currentModuleName;

    // Constraints that the solver has generated, rather than sourcing from the
    // scope tree.
    std::vector<std::unique_ptr<Constraint>> solverConstraints;

    // This includes every constraint that has not been fully solved.
    // A constraint can be both blocked and unsolved, for instance.
    std::vector<NotNull<const Constraint>> unsolvedConstraints;

    // A mapping of constraint pointer to how many things the constraint is
    // blocked on. Can be empty or 0 for constraints that are not blocked on
    // anything.
    std::unordered_map<NotNull<const Constraint>, size_t> blockedConstraints;
    // A mapping of type/pack pointers to the constraints they block.
    std::unordered_map<BlockedConstraintId, DenseHashSet<const Constraint*>, HashBlockedConstraintId> blocked;
    // Memoized instantiations of type aliases.
    DenseHashMap<InstantiationSignature, TypeId, HashInstantiationSignature> instantiatedAliases{{}};
    // Breadcrumbs for where a free type's upper bound was expanded. We use
    // these to provide more helpful error messages when a free type is solved
    // as never unexpectedly.
    DenseHashMap<TypeId, std::vector<std::pair<Location, TypeId>>> upperBoundContributors{nullptr};

    // A mapping from free types to the number of unresolved constraints that mention them.
    DenseHashMap<TypeId, size_t> unresolvedConstraints{{}};

    // Irreducible/uninhabited type families or type pack families.
    DenseHashSet<const void*> uninhabitedTypeFamilies{{}};

    // The set of types that will definitely be unchanged by generalization.
    DenseHashSet<TypeId> generalizedTypes_{nullptr};
    const NotNull<DenseHashSet<TypeId>> generalizedTypes{&generalizedTypes_};

    // Recorded errors that take place within the solver.
    ErrorVec errors;

    NotNull<ModuleResolver> moduleResolver;
    std::vector<RequireCycle> requireCycles;

    DcrLogger* logger;
    TypeCheckLimits limits;

    DenseHashMap<TypeId, const Constraint*> typeFamiliesToFinalize{nullptr};

    explicit ConstraintSolver(NotNull<Normalizer> normalizer, NotNull<Scope> rootScope, std::vector<NotNull<Constraint>> constraints,
        ModuleName moduleName, NotNull<ModuleResolver> moduleResolver, std::vector<RequireCycle> requireCycles, DcrLogger* logger,
        TypeCheckLimits limits);

    // Randomize the order in which to dispatch constraints
    void randomize(unsigned seed);

    /**
     * Attempts to dispatch all pending constraints and reach a type solution
     * that satisfies all of the constraints.
     **/
    void run();

    /**
     * Attempts to perform one final reduction on type families after every constraint has been completed
     *
     **/
    void finalizeTypeFamilies();

    bool isDone();

private:
    /**
     * Bind a type variable to another type.
     *
     * A constraint is required and will validate that blockedTy is owned by this
     * constraint. This prevents one constraint from interfering with another's
     * blocked types.
     *
     * Bind will also unblock the type variable for you.
     */
    void bind(NotNull<const Constraint> constraint, TypeId ty, TypeId boundTo);
    void bind(NotNull<const Constraint> constraint, TypePackId tp, TypePackId boundTo);

    template<typename T, typename... Args>
    void emplace(NotNull<const Constraint> constraint, TypeId ty, Args&&... args);

    template<typename T, typename... Args>
    void emplace(NotNull<const Constraint> constraint, TypePackId tp, Args&&... args);

public:
    /** Attempt to dispatch a constraint.  Returns true if it was successful. If
     * tryDispatch() returns false, the constraint remains in the unsolved set
     * and will be retried later.
     */
    bool tryDispatch(NotNull<const Constraint> c, bool force);

    bool tryDispatch(const SubtypeConstraint& c, NotNull<const Constraint> constraint, bool force);
    bool tryDispatch(const PackSubtypeConstraint& c, NotNull<const Constraint> constraint, bool force);
    bool tryDispatch(const GeneralizationConstraint& c, NotNull<const Constraint> constraint, bool force);
    bool tryDispatch(const IterableConstraint& c, NotNull<const Constraint> constraint, bool force);
    bool tryDispatch(const NameConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const TypeAliasExpansionConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const FunctionCallConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const FunctionCheckConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const PrimitiveTypeConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const HasPropConstraint& c, NotNull<const Constraint> constraint);

    bool tryDispatchHasIndexer(
        int& recursionDepth, NotNull<const Constraint> constraint, TypeId subjectType, TypeId indexType, TypeId resultType, Set<TypeId>& seen);
    bool tryDispatch(const HasIndexerConstraint& c, NotNull<const Constraint> constraint);

    bool tryDispatch(const AssignPropConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const AssignIndexConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const UnpackConstraint& c, NotNull<const Constraint> constraint);
    bool tryDispatch(const ReduceConstraint& c, NotNull<const Constraint> constraint, bool force);
    bool tryDispatch(const ReducePackConstraint& c, NotNull<const Constraint> constraint, bool force);
    bool tryDispatch(const EqualityConstraint& c, NotNull<const Constraint> constraint, bool force);

    // for a, ... in some_table do
    // also handles __iter metamethod
    bool tryDispatchIterableTable(TypeId iteratorTy, const IterableConstraint& c, NotNull<const Constraint> constraint, bool force);

    // for a, ... in next_function, t, ... do
    bool tryDispatchIterableFunction(TypeId nextTy, TypeId tableTy, const IterableConstraint& c, NotNull<const Constraint> constraint, bool force);

    std::pair<std::vector<TypeId>, std::optional<TypeId>> lookupTableProp(NotNull<const Constraint> constraint, TypeId subjectType,
        const std::string& propName, ValueContext context, bool inConditional = false, bool suppressSimplification = false);
    std::pair<std::vector<TypeId>, std::optional<TypeId>> lookupTableProp(NotNull<const Constraint> constraint, TypeId subjectType,
        const std::string& propName, ValueContext context, bool inConditional, bool suppressSimplification, DenseHashSet<TypeId>& seen);

    /**
     * Generate constraints to unpack the types of srcTypes and assign each
     * value to the corresponding BlockedType in destTypes.
     *
     * This function also overwrites the owners of each BlockedType.  This is
     * okay because this function is only used to decompose IterableConstraint
     * into an UnpackConstraint.
     *
     * @param destTypes A vector of types comprised of BlockedTypes.
     * @param srcTypes A TypePack that represents rvalues to be assigned.
     * @returns The underlying UnpackConstraint.  There's a bit of code in
     * iteration that needs to pass blocks on to this constraint.
     */
    NotNull<const Constraint> unpackAndAssign(const std::vector<TypeId> destTypes, TypePackId srcTypes, NotNull<const Constraint> constraint);

    void block(NotNull<const Constraint> target, NotNull<const Constraint> constraint);
    /**
     * Block a constraint on the resolution of a Type.
     * @returns false always.  This is just to allow tryDispatch to return the result of block()
     */
    bool block(TypeId target, NotNull<const Constraint> constraint);
    bool block(TypePackId target, NotNull<const Constraint> constraint);

    // Block on every target
    template<typename T>
    bool block(const T& targets, NotNull<const Constraint> constraint)
    {
        for (TypeId target : targets)
            block(target, constraint);

        return false;
    }

    /**
     * For all constraints that are blocked on one constraint, make them block
     * on a new constraint.
     * @param source the constraint to copy blocks from.
     * @param addition the constraint that other constraints should now block on.
     */
    void inheritBlocks(NotNull<const Constraint> source, NotNull<const Constraint> addition);

    // Traverse the type.  If any pending types are found, block the constraint
    // on them.
    //
    // Returns false if a type blocks the constraint.
    //
    // FIXME: This use of a boolean for the return result is an appalling
    // interface.
    bool blockOnPendingTypes(TypeId target, NotNull<const Constraint> constraint);
    bool blockOnPendingTypes(TypePackId target, NotNull<const Constraint> constraint);

    void unblock(NotNull<const Constraint> progressed);
    void unblock(TypeId progressed, Location location);
    void unblock(TypePackId progressed, Location location);
    void unblock(const std::vector<TypeId>& types, Location location);
    void unblock(const std::vector<TypePackId>& packs, Location location);

    /**
     * @returns true if the TypeId is in a blocked state.
     */
    bool isBlocked(TypeId ty);

    /**
     * @returns true if the TypePackId is in a blocked state.
     */
    bool isBlocked(TypePackId tp);

    /**
     * Returns whether the constraint is blocked on anything.
     * @param constraint the constraint to check.
     */
    bool isBlocked(NotNull<const Constraint> constraint);

    /** Pushes a new solver constraint to the solver.
     * @param cv the body of the constraint.
     **/
    NotNull<Constraint> pushConstraint(NotNull<Scope> scope, const Location& location, ConstraintV cv);

    /**
     * Attempts to resolve a module from its module information. Returns the
     * module-level return type of the module, or the error type if one cannot
     * be found. Reports errors to the solver if the module cannot be found or
     * the require is illegal.
     * @param module the module information to look up.
     * @param location the location where the require is taking place; used for
     * error locations.
     **/
    TypeId resolveModule(const ModuleInfo& module, const Location& location);

    void reportError(TypeErrorData&& data, const Location& location);
    void reportError(TypeError e);

    /**
     * Shifts the count of references from `source` to `target`. This should be paired
     * with any instance of binding a free type in order to maintain accurate refcounts.
     * If `target` is not a free type, this is a noop.
     * @param source the free type which is being bound
     * @param target the type which the free type is being bound to
     */
    void shiftReferences(TypeId source, TypeId target);

    /**
     * Generalizes the given free type if the reference counting allows it.
     * @param the scope to generalize in
     * @param type the free type we want to generalize
     * @returns a non-free type that generalizes the argument, or `std::nullopt` if one
     * does not exist
     */
    std::optional<TypeId> generalizeFreeType(NotNull<Scope> scope, TypeId type, bool avoidSealingTables = false);

    /**
     * Checks the existing set of constraints to see if there exist any that contain
     * the provided free type, indicating that it is not yet ready to be replaced by
     * one of its bounds.
     * @param ty the free type that to check for related constraints
     * @returns whether or not it is unsafe to replace the free type by one of its bounds
     */
    bool hasUnresolvedConstraints(TypeId ty);

    /** Attempts to unify subTy with superTy.  If doing so would require unifying
     * BlockedTypes, fail and block the constraint on those BlockedTypes.
     *
     * Note: TID can only be TypeId or TypePackId.
     *
     * If unification fails, replace all free types with errorType.
     *
     * If unification succeeds, unblock every type changed by the unification.
     *
     * @returns true if the unification succeeded.  False if the unification was
     * too complex.
     */
    template<typename TID>
    bool unify(NotNull<const Constraint> constraint, TID subTy, TID superTy);

    /**
     * Marks a constraint as being blocked on a type or type pack. The constraint
     * solver will not attempt to dispatch blocked constraints until their
     * dependencies have made progress.
     * @param target the type or type pack pointer that the constraint is blocked on.
     * @param constraint the constraint to block.
     **/
    bool block_(BlockedConstraintId target, NotNull<const Constraint> constraint);

    /**
     * Informs the solver that progress has been made on a type or type pack. The
     * solver will wake up all constraints that are blocked on the type or type pack,
     * and will resume attempting to dispatch them.
     * @param progressed the type or type pack pointer that has progressed.
     **/
    void unblock_(BlockedConstraintId progressed);

    /**
     * Reproduces any constraints necessary for new types that are copied when applying a substitution.
     * At the time of writing, this pertains only to type families.
     * @param subst the substitution that was applied
     **/
    void reproduceConstraints(NotNull<Scope> scope, const Location& location, const Substitution& subst);

    TypeId errorRecoveryType() const;
    TypePackId errorRecoveryTypePack() const;

    TypePackId anyifyModuleReturnTypePackGenerics(TypePackId tp);

    void throwTimeLimitError();
    void throwUserCancelError();

    ToStringOptions opts;
};

void dump(NotNull<Scope> rootScope, struct ToStringOptions& opts);

} // namespace Luau

#line __LINE__ "Luau/TypeFunction.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <functional>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct TypeArena;
struct TxnLog;
class Normalizer;

struct TypeFunctionContext
{
    NotNull<TypeArena> arena;
    NotNull<BuiltinTypes> builtins;
    NotNull<Scope> scope;
    NotNull<Normalizer> normalizer;
    NotNull<InternalErrorReporter> ice;
    NotNull<TypeCheckLimits> limits;

    // nullptr if the type function is being reduced outside of the constraint solver.
    ConstraintSolver* solver;
    // The constraint being reduced in this run of the reduction
    const Constraint* constraint;

    TypeFunctionContext(NotNull<ConstraintSolver> cs, NotNull<Scope> scope, NotNull<const Constraint> constraint)
        : arena(cs->arena)
        , builtins(cs->builtinTypes)
        , scope(scope)
        , normalizer(cs->normalizer)
        , ice(NotNull{&cs->iceReporter})
        , limits(NotNull{&cs->limits})
        , solver(cs.get())
        , constraint(constraint.get())
    {
    }

    TypeFunctionContext(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtins, NotNull<Scope> scope, NotNull<Normalizer> normalizer,
        NotNull<InternalErrorReporter> ice, NotNull<TypeCheckLimits> limits)
        : arena(arena)
        , builtins(builtins)
        , scope(scope)
        , normalizer(normalizer)
        , ice(ice)
        , limits(limits)
        , solver(nullptr)
        , constraint(nullptr)
    {
    }

    NotNull<Constraint> pushConstraint(ConstraintV&& c);
};

/// Represents a reduction result, which may have successfully reduced the type,
/// may have concretely failed to reduce the type, or may simply be stuck
/// without more information.
template<typename Ty>
struct TypeFunctionReductionResult
{
    /// The result of the reduction, if any. If this is nullopt, the type function
    /// could not be reduced.
    std::optional<Ty> result;
    /// Whether the result is uninhabited: whether we know, unambiguously and
    /// permanently, whether this type function reduction results in an
    /// uninhabitable type. This will trigger an error to be reported.
    bool uninhabited;
    /// Any types that need to be progressed or mutated before the reduction may
    /// proceed.
    std::vector<TypeId> blockedTypes;
    /// Any type packs that need to be progressed or mutated before the
    /// reduction may proceed.
    std::vector<TypePackId> blockedPacks;
};

template<typename T>
using ReducerFunction =
    std::function<TypeFunctionReductionResult<T>(T, const std::vector<TypeId>&, const std::vector<TypePackId>&, NotNull<TypeFunctionContext>)>;

/// Represents a type function that may be applied to map a series of types and
/// type packs to a single output type.
struct TypeFunction
{
    /// The human-readable name of the type function. Used to stringify instance
    /// types.
    std::string name;

    /// The reducer function for the type function.
    ReducerFunction<TypeId> reducer;
};

/// Represents a type function that may be applied to map a series of types and
/// type packs to a single output type pack.
struct TypePackFunction
{
    /// The human-readable name of the type pack function. Used to stringify
    /// instance packs.
    std::string name;

    /// The reducer function for the type pack function.
    ReducerFunction<TypePackId> reducer;
};

struct FunctionGraphReductionResult
{
    ErrorVec errors;
    DenseHashSet<TypeId> blockedTypes{nullptr};
    DenseHashSet<TypePackId> blockedPacks{nullptr};
    DenseHashSet<TypeId> reducedTypes{nullptr};
    DenseHashSet<TypePackId> reducedPacks{nullptr};
};

/**
 * Attempt to reduce all instances of any type or type pack functions in the type
 * graph provided.
 *
 * @param entrypoint the entry point to the type graph.
 * @param location the location the reduction is occurring at; used to populate
 * type errors.
 * @param arena an arena to allocate types into.
 * @param builtins the built-in types.
 * @param normalizer the normalizer to use when normalizing types
 * @param ice the internal error reporter to use for ICEs
 */
FunctionGraphReductionResult reduceTypeFunctions(TypeId entrypoint, Location location, TypeFunctionContext, bool force = false);

/**
 * Attempt to reduce all instances of any type or type pack functions in the type
 * graph provided.
 *
 * @param entrypoint the entry point to the type graph.
 * @param location the location the reduction is occurring at; used to populate
 * type errors.
 * @param arena an arena to allocate types into.
 * @param builtins the built-in types.
 * @param normalizer the normalizer to use when normalizing types
 * @param ice the internal error reporter to use for ICEs
 */
FunctionGraphReductionResult reduceTypeFunctions(TypePackId entrypoint, Location location, TypeFunctionContext, bool force = false);

struct BuiltinTypeFunctions
{
    BuiltinTypeFunctions();

    TypeFunction notFunc;
    TypeFunction lenFunc;
    TypeFunction unmFunc;

    TypeFunction addFunc;
    TypeFunction subFunc;
    TypeFunction mulFunc;
    TypeFunction divFunc;
    TypeFunction idivFunc;
    TypeFunction powFunc;
    TypeFunction modFunc;

    TypeFunction concatFunc;

    TypeFunction andFunc;
    TypeFunction orFunc;

    TypeFunction ltFunc;
    TypeFunction leFunc;
    TypeFunction eqFunc;

    TypeFunction refineFunc;
    TypeFunction singletonFunc;
    TypeFunction unionFunc;
    TypeFunction intersectFunc;

    TypeFunction keyofFunc;
    TypeFunction rawkeyofFunc;
    TypeFunction indexFunc;
    TypeFunction rawgetFunc;

    void addToScope(NotNull<TypeArena> arena, NotNull<Scope> scope) const;
};

const BuiltinTypeFunctions& builtinTypeFunctions();

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/Subtyping.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

template<typename A, typename B>
struct TryPair;
struct InternalErrorReporter;

class TypeIds;
class Normalizer;
struct NormalizedClassType;
struct NormalizedFunctionType;
struct NormalizedStringType;
struct NormalizedType;
struct Property;
struct Scope;
struct TableIndexer;
struct TypeArena;
struct TypeCheckLimits;

enum class SubtypingVariance
{
    // Used for an empty key. Should never appear in actual code.
    Invalid,
    Covariant,
    // This is used to identify cases where we have a covariant + a
    // contravariant reason and we need to merge them.
    Contravariant,
    Invariant,
};

struct SubtypingReasoning
{
    // The path, relative to the _root subtype_, where subtyping failed.
    Path subPath;
    // The path, relative to the _root supertype_, where subtyping failed.
    Path superPath;
    SubtypingVariance variance = SubtypingVariance::Covariant;

    bool operator==(const SubtypingReasoning& other) const;
};

struct SubtypingReasoningHash
{
    size_t operator()(const SubtypingReasoning& r) const;
};

using SubtypingReasonings = DenseHashSet<SubtypingReasoning, SubtypingReasoningHash>;
static const SubtypingReasoning kEmptyReasoning = SubtypingReasoning{TypePath::kEmpty, TypePath::kEmpty, SubtypingVariance::Invalid};

struct SubtypingResult
{
    bool isSubtype = false;
    bool normalizationTooComplex = false;
    bool isCacheable = true;
    ErrorVec errors;
    /// The reason for isSubtype to be false. May not be present even if
    /// isSubtype is false, depending on the input types.
    SubtypingReasonings reasoning{kEmptyReasoning};

    SubtypingResult& andAlso(const SubtypingResult& other);
    SubtypingResult& orElse(const SubtypingResult& other);
    SubtypingResult& withBothComponent(TypePath::Component component);
    SubtypingResult& withSuperComponent(TypePath::Component component);
    SubtypingResult& withSubComponent(TypePath::Component component);
    SubtypingResult& withBothPath(TypePath::Path path);
    SubtypingResult& withSubPath(TypePath::Path path);
    SubtypingResult& withSuperPath(TypePath::Path path);
    SubtypingResult& withErrors(ErrorVec& err);
    SubtypingResult& withError(TypeError err);

    // Only negates the `isSubtype`.
    static SubtypingResult negate(const SubtypingResult& result);
    static SubtypingResult all(const std::vector<SubtypingResult>& results);
    static SubtypingResult any(const std::vector<SubtypingResult>& results);
};

struct SubtypingEnvironment
{
    struct GenericBounds
    {
        DenseHashSet<TypeId> lowerBound{nullptr};
        DenseHashSet<TypeId> upperBound{nullptr};
    };

    /*
     * When we encounter a generic over the course of a subtyping test, we need
     * to tentatively map that generic onto a type on the other side.
     */
    DenseHashMap<TypeId, GenericBounds> mappedGenerics{nullptr};
    DenseHashMap<TypePackId, TypePackId> mappedGenericPacks{nullptr};

    /*
     * See the test cyclic_tables_are_assumed_to_be_compatible_with_classes for
     * details.
     *
     * An empty value is equivalent to a nonexistent key.
     */
    DenseHashMap<TypeId, TypeId> substitutions{nullptr};

    DenseHashMap<std::pair<TypeId, TypeId>, SubtypingResult, TypePairHash> ephemeralCache{{}};

    /// Applies `mappedGenerics` to the given type.
    /// This is used specifically to substitute for generics in type function instances.
    std::optional<TypeId> applyMappedGenerics(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, TypeId ty);
};

struct Subtyping
{
    NotNull<BuiltinTypes> builtinTypes;
    NotNull<TypeArena> arena;
    NotNull<Normalizer> normalizer;
    NotNull<InternalErrorReporter> iceReporter;

    NotNull<Scope> scope;
    TypeCheckLimits limits;

    enum class Variance
    {
        Covariant,
        Contravariant
    };

    Variance variance = Variance::Covariant;

    using SeenSet = Set<std::pair<TypeId, TypeId>, TypePairHash>;

    SeenSet seenTypes{{}};

    Subtyping(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> typeArena, NotNull<Normalizer> normalizer,
        NotNull<InternalErrorReporter> iceReporter, NotNull<Scope> scope);

    Subtyping(const Subtyping&) = delete;
    Subtyping& operator=(const Subtyping&) = delete;

    Subtyping(Subtyping&&) = default;
    Subtyping& operator=(Subtyping&&) = default;

    // Only used by unit tests to test that the cache works.
    const DenseHashMap<std::pair<TypeId, TypeId>, SubtypingResult, TypePairHash>& peekCache() const
    {
        return resultCache;
    }

    // TODO cache
    // TODO cyclic types
    // TODO recursion limits

    SubtypingResult isSubtype(TypeId subTy, TypeId superTy);
    SubtypingResult isSubtype(TypePackId subTy, TypePackId superTy);

private:
    DenseHashMap<std::pair<TypeId, TypeId>, SubtypingResult, TypePairHash> resultCache{{}};

    SubtypingResult cache(SubtypingEnvironment& env, SubtypingResult res, TypeId subTy, TypeId superTy);

    SubtypingResult isCovariantWith(SubtypingEnvironment& env, TypeId subTy, TypeId superTy);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, TypePackId subTy, TypePackId superTy);

    template<typename SubTy, typename SuperTy>
    SubtypingResult isContravariantWith(SubtypingEnvironment& env, SubTy&& subTy, SuperTy&& superTy);

    template<typename SubTy, typename SuperTy>
    SubtypingResult isInvariantWith(SubtypingEnvironment& env, SubTy&& subTy, SuperTy&& superTy);

    template<typename SubTy, typename SuperTy>
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TryPair<const SubTy*, const SuperTy*>& pair);

    template<typename SubTy, typename SuperTy>
    SubtypingResult isContravariantWith(SubtypingEnvironment& env, const TryPair<const SubTy*, const SuperTy*>& pair);

    template<typename SubTy, typename SuperTy>
    SubtypingResult isInvariantWith(SubtypingEnvironment& env, const TryPair<const SubTy*, const SuperTy*>& pair);

    SubtypingResult isCovariantWith(SubtypingEnvironment& env, TypeId subTy, const UnionType* superUnion);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const UnionType* subUnion, TypeId superTy);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, TypeId subTy, const IntersectionType* superIntersection);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const IntersectionType* subIntersection, TypeId superTy);

    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const NegationType* subNegation, TypeId superTy);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TypeId subTy, const NegationType* superNegation);

    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const PrimitiveType* subPrim, const PrimitiveType* superPrim);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const SingletonType* subSingleton, const PrimitiveType* superPrim);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const SingletonType* subSingleton, const SingletonType* superSingleton);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TableType* subTable, const TableType* superTable);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const MetatableType* subMt, const MetatableType* superMt);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const MetatableType* subMt, const TableType* superTable);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const ClassType* subClass, const ClassType* superClass);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, TypeId subTy, const ClassType* subClass, TypeId superTy, const TableType* superTable);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const FunctionType* subFunction, const FunctionType* superFunction);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const PrimitiveType* subPrim, const TableType* superTable);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const SingletonType* subSingleton, const TableType* superTable);

    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TableIndexer& subIndexer, const TableIndexer& superIndexer);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const Property& subProperty, const Property& superProperty, const std::string& name);

    SubtypingResult isCovariantWith(
        SubtypingEnvironment& env, const std::shared_ptr<const NormalizedType>& subNorm, const std::shared_ptr<const NormalizedType>& superNorm);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const NormalizedClassType& subClass, const NormalizedClassType& superClass);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const NormalizedClassType& subClass, const TypeIds& superTables);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const NormalizedStringType& subString, const NormalizedStringType& superString);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const NormalizedStringType& subString, const TypeIds& superTables);
    SubtypingResult isCovariantWith(
        SubtypingEnvironment& env, const NormalizedFunctionType& subFunction, const NormalizedFunctionType& superFunction);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TypeIds& subTypes, const TypeIds& superTypes);

    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const VariadicTypePack* subVariadic, const VariadicTypePack* superVariadic);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TypeFunctionInstanceType* subFamilyInstance, const TypeId superTy);
    SubtypingResult isCovariantWith(SubtypingEnvironment& env, const TypeId subTy, const TypeFunctionInstanceType* superFamilyInstance);

    bool bindGeneric(SubtypingEnvironment& env, TypeId subTp, TypeId superTp);
    bool bindGeneric(SubtypingEnvironment& env, TypePackId subTp, TypePackId superTp);

    template<typename T, typename Container>
    TypeId makeAggregateType(const Container& container, TypeId orElse);

    std::pair<TypeId, ErrorVec> handleTypeFunctionReductionResult(const TypeFunctionInstanceType* familyInstance);

    [[noreturn]] void unexpected(TypeId ty);
    [[noreturn]] void unexpected(TypePackId tp);
};

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeOrPack.h>

#line __LINE__ "Analysis/include/Luau/TypeOrPack.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <type_traits>

namespace Luau
{

const void* ptr(TypeOrPack ty);

template<typename T, typename std::enable_if_t<TypeOrPack::is_part_of_v<T>, bool> = true>
const T* get(const TypeOrPack& tyOrTp)
{
    return tyOrTp.get_if<T>();
}

template<typename T, typename std::enable_if_t<TypeVariant::is_part_of_v<T>, bool> = true>
const T* get(const TypeOrPack& tyOrTp)
{
    if (const TypeId* ty = get<TypeId>(tyOrTp))
        return get<T>(*ty);
    else
        return nullptr;
}

template<typename T, typename std::enable_if_t<TypePackVariant::is_part_of_v<T>, bool> = true>
const T* get(const TypeOrPack& tyOrTp)
{
    if (const TypePackId* tp = get<TypePackId>(tyOrTp))
        return get<T>(*tp);
    else
        return nullptr;
}

TypeOrPack follow(TypeOrPack ty);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Documentation.h>

#line __LINE__ "Analysis/include/Luau/Documentation.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

struct FunctionDocumentation;
struct TableDocumentation;
struct OverloadedFunctionDocumentation;
struct BasicDocumentation;

using Documentation = Luau::Variant<BasicDocumentation, FunctionDocumentation, TableDocumentation, OverloadedFunctionDocumentation>;
using DocumentationSymbol = std::string;

struct BasicDocumentation
{
    std::string documentation;
    std::string learnMoreLink;
    std::string codeSample;
};

struct FunctionParameterDocumentation
{
    std::string name;
    DocumentationSymbol documentation;
};

// Represents documentation for anything callable. This could be a method or a
// callback or a free function.
struct FunctionDocumentation
{
    std::string documentation;
    std::vector<FunctionParameterDocumentation> parameters;
    std::vector<DocumentationSymbol> returns;
    std::string learnMoreLink;
    std::string codeSample;
};

struct OverloadedFunctionDocumentation
{
    // This is a map of function signature to overload symbol name.
    Luau::DenseHashMap<std::string, DocumentationSymbol> overloads;
};

// Represents documentation for a table-like item, meaning "anything with keys".
// This could be a table or a class.
struct TableDocumentation
{
    std::string documentation;
    Luau::DenseHashMap<std::string, DocumentationSymbol> keys;
    std::string learnMoreLink;
    std::string codeSample;
};

using DocumentationDatabase = Luau::DenseHashMap<DocumentationSymbol, Documentation>;

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypedAllocator.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/IostreamHelpers.h>

#line __LINE__ "Analysis/include/Luau/IostreamHelpers.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePath.h>

// @@@@@ PACK.lua : not found, likely and std header
#include <ostream>

namespace Luau
{

std::ostream& operator<<(std::ostream& lhs, const Position& position);
std::ostream& operator<<(std::ostream& lhs, const Location& location);
std::ostream& operator<<(std::ostream& lhs, const AstName& name);

std::ostream& operator<<(std::ostream& lhs, const TypeError& error);
std::ostream& operator<<(std::ostream& lhs, const TypeMismatch& error);
std::ostream& operator<<(std::ostream& lhs, const UnknownSymbol& error);
std::ostream& operator<<(std::ostream& lhs, const UnknownProperty& error);
std::ostream& operator<<(std::ostream& lhs, const NotATable& error);
std::ostream& operator<<(std::ostream& lhs, const CannotExtendTable& error);
std::ostream& operator<<(std::ostream& lhs, const OnlyTablesCanHaveMethods& error);
std::ostream& operator<<(std::ostream& lhs, const DuplicateTypeDefinition& error);
std::ostream& operator<<(std::ostream& lhs, const CountMismatch& error);
std::ostream& operator<<(std::ostream& lhs, const FunctionDoesNotTakeSelf& error);
std::ostream& operator<<(std::ostream& lhs, const FunctionRequiresSelf& error);
std::ostream& operator<<(std::ostream& lhs, const OccursCheckFailed& error);
std::ostream& operator<<(std::ostream& lhs, const UnknownRequire& error);
std::ostream& operator<<(std::ostream& lhs, const UnknownPropButFoundLikeProp& e);
std::ostream& operator<<(std::ostream& lhs, const GenericError& error);
std::ostream& operator<<(std::ostream& lhs, const InternalError& error);
std::ostream& operator<<(std::ostream& lhs, const FunctionExitsWithoutReturning& error);
std::ostream& operator<<(std::ostream& lhs, const MissingProperties& error);
std::ostream& operator<<(std::ostream& lhs, const IllegalRequire& error);
std::ostream& operator<<(std::ostream& lhs, const ModuleHasCyclicDependency& error);
std::ostream& operator<<(std::ostream& lhs, const DuplicateGenericParameter& error);
std::ostream& operator<<(std::ostream& lhs, const CannotInferBinaryOperation& error);
std::ostream& operator<<(std::ostream& lhs, const SwappedGenericTypeParameter& error);
std::ostream& operator<<(std::ostream& lhs, const OptionalValueAccess& error);
std::ostream& operator<<(std::ostream& lhs, const MissingUnionProperty& error);
std::ostream& operator<<(std::ostream& lhs, const TypesAreUnrelated& error);

std::ostream& operator<<(std::ostream& lhs, const TableState& tv);
std::ostream& operator<<(std::ostream& lhs, const Type& tv);
std::ostream& operator<<(std::ostream& lhs, const TypePackVar& tv);

std::ostream& operator<<(std::ostream& lhs, const TypeErrorData& ted);

std::ostream& operator<<(std::ostream& lhs, TypeId ty);
std::ostream& operator<<(std::ostream& lhs, TypePackId tp);

namespace TypePath
{

std::ostream& operator<<(std::ostream& lhs, const Path& path);

}; // namespace TypePath

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TopoSortStatements.h>

#line __LINE__ "Analysis/include/Luau/TopoSortStatements.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

template<typename T>
struct AstArray;

class AstStat;

bool containsFunctionCall(const AstStat& stat);
bool containsFunctionCallOrReturn(const AstStat& stat);
bool isFunction(const AstStat& stat);
void toposort(std::vector<AstStat*>& stats);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Substitution.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Cancellation.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypeCheckLimits.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/DataFlowGraph.h>

#line __LINE__ "Analysis/include/Luau/DataFlowGraph.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details

// Do not include LValue. It should never be used here.
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ControlFlow.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Def.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Symbol.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypedAllocator.h>

// @@@@@ PACK.LUA : was already included! <unordered_map>

namespace Luau
{

struct RefinementKey
{
    const RefinementKey* parent = nullptr;
    DefId def;
    std::optional<std::string> propName;
};

struct RefinementKeyArena
{
    TypedAllocator<RefinementKey> allocator;

    const RefinementKey* leaf(DefId def);
    const RefinementKey* node(const RefinementKey* parent, DefId def, const std::string& propName);
};

struct DataFlowGraph
{
    DataFlowGraph(DataFlowGraph&&) = default;
    DataFlowGraph& operator=(DataFlowGraph&&) = default;

    DefId getDef(const AstExpr* expr) const;
    // Look up for the rvalue def for a compound assignment.
    std::optional<DefId> getRValueDefForCompoundAssign(const AstExpr* expr) const;

    DefId getDef(const AstLocal* local) const;

    DefId getDef(const AstStatDeclareGlobal* global) const;
    DefId getDef(const AstStatDeclareFunction* func) const;

    const RefinementKey* getRefinementKey(const AstExpr* expr) const;

private:
    DataFlowGraph() = default;

    DataFlowGraph(const DataFlowGraph&) = delete;
    DataFlowGraph& operator=(const DataFlowGraph&) = delete;

    DefArena defArena;
    RefinementKeyArena keyArena;

    DenseHashMap<const AstExpr*, const Def*> astDefs{nullptr};

    // Sometimes we don't have the AstExprLocal* but we have AstLocal*, and sometimes we need to extract that DefId.
    DenseHashMap<const AstLocal*, const Def*> localDefs{nullptr};

    // There's no AstStatDeclaration, and it feels useless to introduce it just to enforce an invariant in one place.
    // All keys in this maps are really only statements that ambiently declares a symbol.
    DenseHashMap<const AstStat*, const Def*> declaredDefs{nullptr};

    // Compound assignments are in a weird situation where the local being assigned to is also being used at its
    // previous type implicitly in an rvalue position. This map provides the previous binding.
    DenseHashMap<const AstExpr*, const Def*> compoundAssignDefs{nullptr};

    DenseHashMap<const AstExpr*, const RefinementKey*> astRefinementKeys{nullptr};

    friend struct DataFlowGraphBuilder;
};

struct DfgScope
{
    enum ScopeType
    {
        Linear,
        Loop,
        Function,
    };

    DfgScope* parent;
    ScopeType scopeType;

    using Bindings = DenseHashMap<Symbol, const Def*>;
    using Props = DenseHashMap<const Def*, std::unordered_map<std::string, const Def*>>;

    Bindings bindings{Symbol{}};
    Props props{nullptr};

    std::optional<DefId> lookup(Symbol symbol) const;
    std::optional<DefId> lookup(DefId def, const std::string& key) const;

    void inherit(const DfgScope* childScope);

    bool canUpdateDefinition(Symbol symbol) const;
    bool canUpdateDefinition(DefId def, const std::string& key) const;
};

struct DataFlowResult
{
    DefId def;
    const RefinementKey* parent = nullptr;
};

struct DataFlowGraphBuilder
{
    static DataFlowGraph build(AstStatBlock* root, NotNull<struct InternalErrorReporter> handle);

private:
    DataFlowGraphBuilder() = default;

    DataFlowGraphBuilder(const DataFlowGraphBuilder&) = delete;
    DataFlowGraphBuilder& operator=(const DataFlowGraphBuilder&) = delete;

    DataFlowGraph graph;
    NotNull<DefArena> defArena{&graph.defArena};
    NotNull<RefinementKeyArena> keyArena{&graph.keyArena};

    struct InternalErrorReporter* handle = nullptr;
    DfgScope* moduleScope = nullptr;

    std::vector<std::unique_ptr<DfgScope>> scopes;

    struct FunctionCapture
    {
        std::vector<DefId> captureDefs;
        std::vector<DefId> allVersions;
        size_t versionOffset = 0;
    };

    DenseHashMap<Symbol, FunctionCapture> captures{Symbol{}};
    void resolveCaptures();

    DfgScope* childScope(DfgScope* scope, DfgScope::ScopeType scopeType = DfgScope::Linear);

    void join(DfgScope* p, DfgScope* a, DfgScope* b);
    void joinBindings(DfgScope* p, const DfgScope& a, const DfgScope& b);
    void joinProps(DfgScope* p, const DfgScope& a, const DfgScope& b);

    DefId lookup(DfgScope* scope, Symbol symbol);
    DefId lookup(DfgScope* scope, DefId def, const std::string& key);

    ControlFlow visit(DfgScope* scope, AstStatBlock* b);
    ControlFlow visitBlockWithoutChildScope(DfgScope* scope, AstStatBlock* b);

    ControlFlow visit(DfgScope* scope, AstStat* s);
    ControlFlow visit(DfgScope* scope, AstStatIf* i);
    ControlFlow visit(DfgScope* scope, AstStatWhile* w);
    ControlFlow visit(DfgScope* scope, AstStatRepeat* r);
    ControlFlow visit(DfgScope* scope, AstStatBreak* b);
    ControlFlow visit(DfgScope* scope, AstStatContinue* c);
    ControlFlow visit(DfgScope* scope, AstStatReturn* r);
    ControlFlow visit(DfgScope* scope, AstStatExpr* e);
    ControlFlow visit(DfgScope* scope, AstStatLocal* l);
    ControlFlow visit(DfgScope* scope, AstStatFor* f);
    ControlFlow visit(DfgScope* scope, AstStatForIn* f);
    ControlFlow visit(DfgScope* scope, AstStatAssign* a);
    ControlFlow visit(DfgScope* scope, AstStatCompoundAssign* c);
    ControlFlow visit(DfgScope* scope, AstStatFunction* f);
    ControlFlow visit(DfgScope* scope, AstStatLocalFunction* l);
    ControlFlow visit(DfgScope* scope, AstStatTypeAlias* t);
    ControlFlow visit(DfgScope* scope, AstStatDeclareGlobal* d);
    ControlFlow visit(DfgScope* scope, AstStatDeclareFunction* d);
    ControlFlow visit(DfgScope* scope, AstStatDeclareClass* d);
    ControlFlow visit(DfgScope* scope, AstStatError* error);

    DataFlowResult visitExpr(DfgScope* scope, AstExpr* e);
    DataFlowResult visitExpr(DfgScope* scope, AstExprGroup* group);
    DataFlowResult visitExpr(DfgScope* scope, AstExprLocal* l);
    DataFlowResult visitExpr(DfgScope* scope, AstExprGlobal* g);
    DataFlowResult visitExpr(DfgScope* scope, AstExprCall* c);
    DataFlowResult visitExpr(DfgScope* scope, AstExprIndexName* i);
    DataFlowResult visitExpr(DfgScope* scope, AstExprIndexExpr* i);
    DataFlowResult visitExpr(DfgScope* scope, AstExprFunction* f);
    DataFlowResult visitExpr(DfgScope* scope, AstExprTable* t);
    DataFlowResult visitExpr(DfgScope* scope, AstExprUnary* u);
    DataFlowResult visitExpr(DfgScope* scope, AstExprBinary* b);
    DataFlowResult visitExpr(DfgScope* scope, AstExprTypeAssertion* t);
    DataFlowResult visitExpr(DfgScope* scope, AstExprIfElse* i);
    DataFlowResult visitExpr(DfgScope* scope, AstExprInterpString* i);
    DataFlowResult visitExpr(DfgScope* scope, AstExprError* error);

    void visitLValue(DfgScope* scope, AstExpr* e, DefId incomingDef, bool isCompoundAssignment = false);
    DefId visitLValue(DfgScope* scope, AstExprLocal* l, DefId incomingDef, bool isCompoundAssignment);
    DefId visitLValue(DfgScope* scope, AstExprGlobal* g, DefId incomingDef, bool isCompoundAssignment);
    DefId visitLValue(DfgScope* scope, AstExprIndexName* i, DefId incomingDef);
    DefId visitLValue(DfgScope* scope, AstExprIndexExpr* i, DefId incomingDef);
    DefId visitLValue(DfgScope* scope, AstExprError* e, DefId incomingDef);

    void visitType(DfgScope* scope, AstType* t);
    void visitType(DfgScope* scope, AstTypeReference* r);
    void visitType(DfgScope* scope, AstTypeTable* t);
    void visitType(DfgScope* scope, AstTypeFunction* f);
    void visitType(DfgScope* scope, AstTypeTypeof* t);
    void visitType(DfgScope* scope, AstTypeUnion* u);
    void visitType(DfgScope* scope, AstTypeIntersection* i);
    void visitType(DfgScope* scope, AstTypeError* error);

    void visitTypePack(DfgScope* scope, AstTypePack* p);
    void visitTypePack(DfgScope* scope, AstTypePackExplicit* e);
    void visitTypePack(DfgScope* scope, AstTypePackVariadic* v);
    void visitTypePack(DfgScope* scope, AstTypePackGeneric* g);

    void visitTypeList(DfgScope* scope, AstTypeList l);

    void visitGenerics(DfgScope* scope, AstArray<AstGenericType> g);
    void visitGenericPacks(DfgScope* scope, AstArray<AstGenericTypePack> g);
};

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypeFunction.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeChecker2.h>

#line __LINE__ "Analysis/include/Luau/TypeChecker2.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

namespace Luau
{

struct BuiltinTypes;
struct DcrLogger;
struct TypeCheckLimits;
struct UnifierSharedState;
struct SourceModule;
struct Module;

void check(NotNull<BuiltinTypes> builtinTypes, NotNull<UnifierSharedState> sharedState, NotNull<TypeCheckLimits> limits, DcrLogger* logger,
    const SourceModule& sourceModule, Module* module);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/OverloadResolution.h>

#line __LINE__ "Analysis/include/Luau/OverloadResolution.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/InsertionOrderedMap.h>

#line __LINE__ "Luau/InsertionOrderedMap.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <type_traits>

// @@@@@ PACK.lua : not found, likely and std header
#include <iterator>

namespace Luau
{

template<typename K, typename V>
struct InsertionOrderedMap
{
    static_assert(std::is_trivially_copyable_v<K>, "key must be trivially copyable");

private:
    using vec = std::vector<std::pair<K, V>>;

public:
    using iterator = typename vec::iterator;
    using const_iterator = typename vec::const_iterator;

    void insert(K k, V v)
    {
        if (indices.count(k) != 0)
            return;

        pairs.push_back(std::make_pair(k, std::move(v)));
        indices[k] = pairs.size() - 1;
    }

    void clear()
    {
        pairs.clear();
        indices.clear();
    }

    size_t size() const
    {
        LUAU_ASSERT(pairs.size() == indices.size());
        return pairs.size();
    }

    bool contains(const K& k) const
    {
        return indices.count(k) > 0;
    }

    const V* get(const K& k) const
    {
        auto it = indices.find(k);
        if (it == indices.end())
            return nullptr;
        else
            return &pairs.at(it->second).second;
    }

    V* get(const K& k)
    {
        auto it = indices.find(k);
        if (it == indices.end())
            return nullptr;
        else
            return &pairs.at(it->second).second;
    }

    const_iterator begin() const
    {
        return pairs.begin();
    }

    const_iterator end() const
    {
        return pairs.end();
    }

    iterator begin()
    {
        return pairs.begin();
    }

    iterator end()
    {
        return pairs.end();
    }

    const_iterator find(K k) const
    {
        auto indicesIt = indices.find(k);
        if (indicesIt == indices.end())
            return end();
        else
            return begin() + indicesIt->second;
    }

    iterator find(K k)
    {
        auto indicesIt = indices.find(k);
        if (indicesIt == indices.end())
            return end();
        else
            return begin() + indicesIt->second;
    }

    void erase(iterator it)
    {
        if (it == pairs.end())
            return;

        K k = it->first;
        auto indexIt = indices.find(k);
        if (indexIt == indices.end())
            return;

        size_t removed = indexIt->second;
        indices.erase(indexIt);
        pairs.erase(it);

        for (auto& [_, index] : indices)
        {
            if (index > removed)
                --index;
        }
    }

private:
    vec pairs;
    std::unordered_map<K, size_t> indices;
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/OverloadResolution.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// DONE : was aleready inlined <Luau/Subtyping.h>

namespace Luau
{

struct BuiltinTypes;
struct TypeArena;
struct Scope;
struct InternalErrorReporter;
struct TypeCheckLimits;
struct Subtyping;

class Normalizer;

struct OverloadResolver
{
    enum Analysis
    {
        Ok,
        TypeIsNotAFunction,
        ArityMismatch,
        OverloadIsNonviable, // Arguments were incompatible with the overloads parameters but were otherwise compatible by arity
    };

    OverloadResolver(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, NotNull<Normalizer> normalizer, NotNull<Scope> scope,
        NotNull<InternalErrorReporter> reporter, NotNull<TypeCheckLimits> limits, Location callLocation);

    NotNull<BuiltinTypes> builtinTypes;
    NotNull<TypeArena> arena;
    NotNull<Normalizer> normalizer;
    NotNull<Scope> scope;
    NotNull<InternalErrorReporter> ice;
    NotNull<TypeCheckLimits> limits;
    Subtyping subtyping;
    Location callLoc;

    // Resolver results
    std::vector<TypeId> ok;
    std::vector<TypeId> nonFunctions;
    std::vector<std::pair<TypeId, ErrorVec>> arityMismatches;
    std::vector<std::pair<TypeId, ErrorVec>> nonviableOverloads;
    InsertionOrderedMap<TypeId, std::pair<OverloadResolver::Analysis, size_t>> resolution;

    std::pair<OverloadResolver::Analysis, TypeId> selectOverload(TypeId ty, TypePackId args);
    void resolve(TypeId fnTy, const TypePack* args, AstExpr* selfExpr, const std::vector<AstExpr*>* argExprs);

private:
    std::optional<ErrorVec> testIsSubtype(const Location& location, TypeId subTy, TypeId superTy);
    std::optional<ErrorVec> testIsSubtype(const Location& location, TypePackId subTy, TypePackId superTy);
    std::pair<Analysis, ErrorVec> checkOverload(
        TypeId fnTy, const TypePack* args, AstExpr* fnLoc, const std::vector<AstExpr*>* argExprs, bool callMetamethodOk = true);
    static bool isLiteral(AstExpr* expr);
    LUAU_NOINLINE
    std::pair<Analysis, ErrorVec> checkOverload_(
        TypeId fnTy, const FunctionType* fn, const TypePack* args, AstExpr* fnExpr, const std::vector<AstExpr*>* argExprs);
    size_t indexof(Analysis analysis);
    void add(Analysis analysis, TypeId ty, ErrorVec&& errors);
};

struct SolveResult
{
    enum OverloadCallResult
    {
        Ok,
        CodeTooComplex,
        OccursCheckFailed,
        NoMatchingOverload,
    };

    OverloadCallResult result;
    std::optional<TypePackId> typePackId; // nullopt if result != Ok

    TypeId overloadToUse = nullptr;
    TypeId inferredTy = nullptr;
    DenseHashMap<TypeId, std::vector<TypeId>> expandedFreeTypes{nullptr};
};

// Helper utility, presently used for binary operator type families.
//
// Given a function and a set of arguments, select a suitable overload.
SolveResult solveFunctionCall(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes, NotNull<Normalizer> normalizer,
    NotNull<InternalErrorReporter> iceReporter, NotNull<TypeCheckLimits> limits, NotNull<Scope> scope, const Location& location, TypeId fn,
    TypePackId argsPack);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Error.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Frontend.h>

#line __LINE__ "Analysis/include/Luau/Frontend.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ DONE : was aleready included <Luau/Config.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/GlobalTypes.h>

#line __LINE__ "Luau/GlobalTypes.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeArena.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

namespace Luau
{

struct GlobalTypes
{
    explicit GlobalTypes(NotNull<BuiltinTypes> builtinTypes);

    NotNull<BuiltinTypes> builtinTypes; // Global types are based on builtin types

    TypeArena globalTypes;
    SourceModule globalNames; // names for symbols entered into globalScope
    ScopePtr globalScope;     // shared by all modules
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/Frontend.h"

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>
// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ModuleResolver.h>

#line __LINE__ "Luau/ModuleResolver.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/FileResolver.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

namespace Luau
{

class AstExpr;
struct Module;

using ModulePtr = std::shared_ptr<Module>;

struct ModuleResolver
{
    virtual ~ModuleResolver() {}

    /** Compute a ModuleName from an AST fragment.  This AST fragment is generally the argument to the require() function.
     *
     * You probably want to implement this with some variation of pathExprToModuleName.
     *
     * @returns The ModuleInfo if the expression is a syntactically legal path.
     * @returns std::nullopt if we are unable to determine whether or not the expression is a valid path.  Type inference will
     * silently assume that it could succeed in this case.
     *
     * FIXME: This is clearly not the right behaviour longterm.  We'll want to adust this interface to be able to signal
     *  a) success,
     *  b) Definitive failure (this expression will absolutely cause require() to fail at runtime), and
     *  c) uncertainty
     */
    virtual std::optional<ModuleInfo> resolveModuleInfo(const ModuleName& currentModuleName, const AstExpr& pathExpr) = 0;

    /** Get a typechecked module from its name.
     *
     * This can return null under two circumstances: the module is unknown at compile time,
     * or there's a cycle, and we are still in the middle of typechecking the module.
     */
    virtual const ModulePtr getModule(const ModuleName& moduleName) const = 0;

    /** Is a module known at compile time?
     *
     * This function can be used to distinguish the above two cases.
     */
    virtual bool moduleExists(const ModuleName& moduleName) const = 0;

    virtual std::string getHumanReadableModuleName(const ModuleName& moduleName) const = 0;
};

struct NullModuleResolver : ModuleResolver
{
    std::optional<ModuleInfo> resolveModuleInfo(const ModuleName& currentModuleName, const AstExpr& pathExpr) override
    {
        return std::nullopt;
    }
    const ModulePtr getModule(const ModuleName& moduleName) const override
    {
        return nullptr;
    }
    bool moduleExists(const ModuleName& moduleName) const override
    {
        return false;
    }
    std::string getHumanReadableModuleName(const ModuleName& moduleName) const override
    {
        return moduleName;
    }
};

} // namespace Luau

#line __LINE__ "Analysis/include/Luau/Frontend.h"

// DONE : was aleready inlined <Luau/RequireTracer.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.lua : not found, likely and std header
#include <mutex>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

class AstStat;
class ParseError;
struct Frontend;
struct TypeError;
struct LintWarning;
struct GlobalTypes;
struct TypeChecker;
struct FileResolver;
struct ModuleResolver;
struct ParseResult;
struct HotComment;
struct BuildQueueItem;
struct FrontendCancellationToken;

struct LoadDefinitionFileResult
{
    bool success;
    ParseResult parseResult;
    SourceModule sourceModule;
    ModulePtr module;
};

std::optional<Mode> parseMode(const std::vector<HotComment>& hotcomments);

std::vector<std::string_view> parsePathExpr(const AstExpr& pathExpr);

// Exported only for convenient testing.
std::optional<ModuleName> pathExprToModuleName(const ModuleName& currentModuleName, const std::vector<std::string_view>& expr);

/** Try to convert an AST fragment into a ModuleName.
 * Returns std::nullopt if the expression cannot be resolved.  This will most likely happen in cases where
 * the import path involves some dynamic computation that we cannot see into at typechecking time.
 *
 * Unintuitively, weirdly-formulated modules (like game.Parent.Parent.Parent.Foo) will successfully produce a ModuleName
 * as long as it falls within the permitted syntax.  This is ok because we will fail to find the module and produce an
 * error when we try during typechecking.
 */
std::optional<ModuleName> pathExprToModuleName(const ModuleName& currentModuleName, const AstExpr& expr);

struct SourceNode
{
    bool hasDirtySourceModule() const
    {
        return dirtySourceModule;
    }

    bool hasDirtyModule(bool forAutocomplete) const
    {
        return forAutocomplete ? dirtyModuleForAutocomplete : dirtyModule;
    }

    ModuleName name;
    std::string humanReadableName;
    DenseHashSet<ModuleName> requireSet{{}};
    std::vector<std::pair<ModuleName, Location>> requireLocations;
    bool dirtySourceModule = true;
    bool dirtyModule = true;
    bool dirtyModuleForAutocomplete = true;
    double autocompleteLimitsMult = 1.0;
};

struct FrontendOptions
{
    // When true, we retain full type information about every term in the AST.
    // Setting this to false cuts back on RAM and is a good idea for batch
    // jobs where the type graph is not deeply inspected after typechecking
    // is complete.
    bool retainFullTypeGraphs = false;

    // Run typechecking only in mode required for autocomplete (strict mode in
    // order to get more precise type information)
    bool forAutocomplete = false;

    bool runLintChecks = false;

    // If not empty, randomly shuffle the constraint set before attempting to
    // solve.  Use this value to seed the random number generator.
    std::optional<unsigned> randomizeConstraintResolutionSeed;

    std::optional<LintOptions> enabledLintWarnings;

    std::shared_ptr<FrontendCancellationToken> cancellationToken;

    // Time limit for typechecking a single module
    std::optional<double> moduleTimeLimitSec;

    // When true, some internal complexity limits will be scaled down for modules that miss the limit set by moduleTimeLimitSec
    bool applyInternalLimitScaling = false;
};

struct CheckResult
{
    std::vector<TypeError> errors;

    LintResult lintResult;

    std::vector<ModuleName> timeoutHits;
};

struct FrontendModuleResolver : ModuleResolver
{
    FrontendModuleResolver(Frontend* frontend);

    const ModulePtr getModule(const ModuleName& moduleName) const override;
    bool moduleExists(const ModuleName& moduleName) const override;
    std::optional<ModuleInfo> resolveModuleInfo(const ModuleName& currentModuleName, const AstExpr& pathExpr) override;
    std::string getHumanReadableModuleName(const ModuleName& moduleName) const override;

    void setModule(const ModuleName& moduleName, ModulePtr module);
    void clearModules();

private:
    Frontend* frontend;

    mutable std::mutex moduleMutex;
    std::unordered_map<ModuleName, ModulePtr> modules;
};

struct Frontend
{
    struct Stats
    {
        size_t files = 0;
        size_t lines = 0;

        size_t filesStrict = 0;
        size_t filesNonstrict = 0;

        double timeRead = 0;
        double timeParse = 0;
        double timeCheck = 0;
        double timeLint = 0;
    };

    Frontend(FileResolver* fileResolver, ConfigResolver* configResolver, const FrontendOptions& options = {});

    // Parse module graph and prepare SourceNode/SourceModule data, including required dependencies without running typechecking
    void parse(const ModuleName& name);

    // Parse and typecheck module graph
    CheckResult check(const ModuleName& name, std::optional<FrontendOptions> optionOverride = {}); // new shininess

    bool isDirty(const ModuleName& name, bool forAutocomplete = false) const;
    void markDirty(const ModuleName& name, std::vector<ModuleName>* markedDirty = nullptr);

    /** Borrow a pointer into the SourceModule cache.
     *
     * Returns nullptr if we don't have it.  This could mean that the script
     * doesn't exist, or simply that its contents have changed since the previous
     * check, in which case we do not have its AST.
     *
     * IMPORTANT: this pointer is only valid until the next call to markDirty.  Do not retain it.
     */
    SourceModule* getSourceModule(const ModuleName& name);
    const SourceModule* getSourceModule(const ModuleName& name) const;

    void clearStats();
    void clear();

    ScopePtr addEnvironment(const std::string& environmentName);
    ScopePtr getEnvironmentScope(const std::string& environmentName) const;

    void registerBuiltinDefinition(const std::string& name, std::function<void(Frontend&, GlobalTypes&, ScopePtr)>);
    void applyBuiltinDefinitionToEnvironment(const std::string& environmentName, const std::string& definitionName);

    LoadDefinitionFileResult loadDefinitionFile(GlobalTypes& globals, ScopePtr targetScope, std::string_view source, const std::string& packageName,
        bool captureComments, bool typeCheckForAutocomplete = false);

    // Batch module checking. Queue modules and check them together, retrieve results with 'getCheckResult'
    // If provided, 'executeTask' function is allowed to call the 'task' function on any thread and return without waiting for 'task' to complete
    void queueModuleCheck(const std::vector<ModuleName>& names);
    void queueModuleCheck(const ModuleName& name);
    std::vector<ModuleName> checkQueuedModules(std::optional<FrontendOptions> optionOverride = {},
        std::function<void(std::function<void()> task)> executeTask = {}, std::function<bool(size_t done, size_t total)> progress = {});

    std::optional<CheckResult> getCheckResult(const ModuleName& name, bool accumulateNested, bool forAutocomplete = false);

private:
    ModulePtr check(const SourceModule& sourceModule, Mode mode, std::vector<RequireCycle> requireCycles, std::optional<ScopePtr> environmentScope,
        bool forAutocomplete, bool recordJsonLog, TypeCheckLimits typeCheckLimits);

    std::pair<SourceNode*, SourceModule*> getSourceNode(const ModuleName& name);
    SourceModule parse(const ModuleName& name, std::string_view src, const ParseOptions& parseOptions);

    bool parseGraph(
        std::vector<ModuleName>& buildQueue, const ModuleName& root, bool forAutocomplete, std::function<bool(const ModuleName&)> canSkip = {});

    void addBuildQueueItems(std::vector<BuildQueueItem>& items, std::vector<ModuleName>& buildQueue, bool cycleDetected,
        DenseHashSet<Luau::ModuleName>& seen, const FrontendOptions& frontendOptions);
    void checkBuildQueueItem(BuildQueueItem& item);
    void checkBuildQueueItems(std::vector<BuildQueueItem>& items);
    void recordItemResult(const BuildQueueItem& item);

    static LintResult classifyLints(const std::vector<LintWarning>& warnings, const Config& config);

    ScopePtr getModuleEnvironment(const SourceModule& module, const Config& config, bool forAutocomplete) const;

    std::unordered_map<std::string, ScopePtr> environments;
    std::unordered_map<std::string, std::function<void(Frontend&, GlobalTypes&, ScopePtr)>> builtinDefinitions;

    BuiltinTypes builtinTypes_;

public:
    const NotNull<BuiltinTypes> builtinTypes;

    FileResolver* fileResolver;

    FrontendModuleResolver moduleResolver;
    FrontendModuleResolver moduleResolverForAutocomplete;

    GlobalTypes globals;
    GlobalTypes globalsForAutocomplete;

    ConfigResolver* configResolver;
    FrontendOptions options;
    InternalErrorReporter iceHandler;
    std::function<void(const ModuleName& name, const ScopePtr& scope, bool forAutocomplete)> prepareModuleScope;
    std::function<void(const ModuleName& name, std::string log)> writeJsonLog = {};

    std::unordered_map<ModuleName, std::shared_ptr<SourceNode>> sourceNodes;
    std::unordered_map<ModuleName, std::shared_ptr<SourceModule>> sourceModules;
    std::unordered_map<ModuleName, RequireTraceResult> requireTrace;

    Stats stats = {};

    std::vector<ModuleName> moduleQueue;
};

ModulePtr check(const SourceModule& sourceModule, Mode mode, const std::vector<RequireCycle>& requireCycles, NotNull<BuiltinTypes> builtinTypes,
    NotNull<InternalErrorReporter> iceHandler, NotNull<ModuleResolver> moduleResolver, NotNull<FileResolver> fileResolver,
    const ScopePtr& globalScope, std::function<void(const ModuleName&, const ScopePtr&)> prepareModuleScope, FrontendOptions options,
    TypeCheckLimits limits);

ModulePtr check(const SourceModule& sourceModule, Mode mode, const std::vector<RequireCycle>& requireCycles, NotNull<BuiltinTypes> builtinTypes,
    NotNull<InternalErrorReporter> iceHandler, NotNull<ModuleResolver> moduleResolver, NotNull<FileResolver> fileResolver,
    const ScopePtr& globalScope, std::function<void(const ModuleName&, const ScopePtr&)> prepareModuleScope, FrontendOptions options,
    TypeCheckLimits limits, bool recordJsonLog, std::function<void(const ModuleName&, std::string)> writeJsonLog);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ConstraintGenerator.h>

#line __LINE__ "Analysis/include/Luau/ConstraintGenerator.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Constraint.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ControlFlow.h>

// DONE : was aleready inlined <Luau/DataFlowGraph.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/InsertionOrderedMap.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ModuleResolver.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Refinement.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Symbol.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <unordered_map>

namespace Luau
{

struct Scope;
using ScopePtr = std::shared_ptr<Scope>;

struct DcrLogger;

struct Inference
{
    TypeId ty = nullptr;
    RefinementId refinement = nullptr;

    Inference() = default;

    explicit Inference(TypeId ty, RefinementId refinement = nullptr)
        : ty(ty)
        , refinement(refinement)
    {
    }
};

struct InferencePack
{
    TypePackId tp = nullptr;
    std::vector<RefinementId> refinements;

    InferencePack() = default;

    explicit InferencePack(TypePackId tp, const std::vector<RefinementId>& refinements = {})
        : tp(tp)
        , refinements(refinements)
    {
    }
};

struct ConstraintGenerator
{
    // A list of all the scopes in the module. This vector holds ownership of the
    // scope pointers; the scopes themselves borrow pointers to other scopes to
    // define the scope hierarchy.
    std::vector<std::pair<Location, ScopePtr>> scopes;

    ModulePtr module;
    NotNull<BuiltinTypes> builtinTypes;
    const NotNull<TypeArena> arena;
    // The root scope of the module we're generating constraints for.
    // This is null when the CG is initially constructed.
    Scope* rootScope;

    TypeContext typeContext = TypeContext::Default;

    struct InferredBinding
    {
        Scope* scope;
        Location location;
        TypeIds types;
    };

    // Some locals have multiple type states.  We wish for Scope::bindings to
    // map each local name onto the union of every type that the local can have
    // over its lifetime, so we use this map to accumulate the set of types it
    // might have.
    //
    // See the functions recordInferredBinding and fillInInferredBindings.
    DenseHashMap<Symbol, InferredBinding> inferredBindings{{}};

    // Constraints that go straight to the solver.
    std::vector<ConstraintPtr> constraints;

    // Constraints that do not go to the solver right away.  Other constraints
    // will enqueue them during solving.
    std::vector<ConstraintPtr> unqueuedConstraints;

    // The private scope of type aliases for which the type parameters belong to.
    DenseHashMap<const AstStatTypeAlias*, ScopePtr> astTypeAliasDefiningScopes{nullptr};

    NotNull<const DataFlowGraph> dfg;
    RefinementArena refinementArena;

    int recursionCount = 0;

    // It is pretty uncommon for constraint generation to itself produce errors, but it can happen.
    std::vector<TypeError> errors;

    // Needed to be able to enable error-suppression preservation for immediate refinements.
    NotNull<Normalizer> normalizer;
    // Needed to resolve modules to make 'require' import types properly.
    NotNull<ModuleResolver> moduleResolver;
    // Occasionally constraint generation needs to produce an ICE.
    const NotNull<InternalErrorReporter> ice;

    ScopePtr globalScope;

    std::function<void(const ModuleName&, const ScopePtr&)> prepareModuleScope;
    std::vector<RequireCycle> requireCycles;

    DenseHashMap<TypeId, TypeIds> localTypes{nullptr};

    DcrLogger* logger;

    ConstraintGenerator(ModulePtr module, NotNull<Normalizer> normalizer, NotNull<ModuleResolver> moduleResolver, NotNull<BuiltinTypes> builtinTypes,
        NotNull<InternalErrorReporter> ice, const ScopePtr& globalScope, std::function<void(const ModuleName&, const ScopePtr&)> prepareModuleScope,
        DcrLogger* logger, NotNull<DataFlowGraph> dfg, std::vector<RequireCycle> requireCycles);

    /**
     * The entry point to the ConstraintGenerator. This will construct a set
     * of scopes, constraints, and free types that can be solved later.
     * @param block the root block to generate constraints for.
     */
    void visitModuleRoot(AstStatBlock* block);

private:
    std::vector<std::vector<TypeId>> interiorTypes;

    /**
     * Fabricates a new free type belonging to a given scope.
     * @param scope the scope the free type belongs to.
     */
    TypeId freshType(const ScopePtr& scope);

    /**
     * Fabricates a new free type pack belonging to a given scope.
     * @param scope the scope the free type pack belongs to.
     */
    TypePackId freshTypePack(const ScopePtr& scope);

    /**
     * Allocate a new TypePack with the given head and tail.
     *
     * Avoids allocating 0-length type packs:
     *
     * If the head is non-empty, allocate and return a type pack with the given
     * head and tail.
     * If the head is empty and tail is non-empty, return *tail.
     * If both the head and tail are empty, return an empty type pack.
     */
    TypePackId addTypePack(std::vector<TypeId> head, std::optional<TypePackId> tail);

    /**
     * Fabricates a scope that is a child of another scope.
     * @param node the lexical node that the scope belongs to.
     * @param parent the parent scope of the new scope. Must not be null.
     */
    ScopePtr childScope(AstNode* node, const ScopePtr& parent);

    std::optional<TypeId> lookup(const ScopePtr& scope, Location location, DefId def, bool prototype = true);

    /**
     * Adds a new constraint with no dependencies to a given scope.
     * @param scope the scope to add the constraint to.
     * @param cv the constraint variant to add.
     * @return the pointer to the inserted constraint
     */
    NotNull<Constraint> addConstraint(const ScopePtr& scope, const Location& location, ConstraintV cv);

    /**
     * Adds a constraint to a given scope.
     * @param scope the scope to add the constraint to. Must not be null.
     * @param c the constraint to add.
     * @return the pointer to the inserted constraint
     */
    NotNull<Constraint> addConstraint(const ScopePtr& scope, std::unique_ptr<Constraint> c);

    struct RefinementPartition
    {
        // Types that we want to intersect against the type of the expression.
        std::vector<TypeId> discriminantTypes;

        // Sometimes the type we're discriminating against is implicitly nil.
        bool shouldAppendNilType = false;
    };

    using RefinementContext = InsertionOrderedMap<DefId, RefinementPartition>;
    void unionRefinements(const ScopePtr& scope, Location location, const RefinementContext& lhs, const RefinementContext& rhs,
        RefinementContext& dest, std::vector<ConstraintV>* constraints);
    void computeRefinement(const ScopePtr& scope, Location location, RefinementId refinement, RefinementContext* refis, bool sense, bool eq,
        std::vector<ConstraintV>* constraints);
    void applyRefinements(const ScopePtr& scope, Location location, RefinementId refinement);

    ControlFlow visitBlockWithoutChildScope(const ScopePtr& scope, AstStatBlock* block);

    ControlFlow visit(const ScopePtr& scope, AstStat* stat);
    ControlFlow visit(const ScopePtr& scope, AstStatBlock* block);
    ControlFlow visit(const ScopePtr& scope, AstStatLocal* local);
    ControlFlow visit(const ScopePtr& scope, AstStatFor* for_);
    ControlFlow visit(const ScopePtr& scope, AstStatForIn* forIn);
    ControlFlow visit(const ScopePtr& scope, AstStatWhile* while_);
    ControlFlow visit(const ScopePtr& scope, AstStatRepeat* repeat);
    ControlFlow visit(const ScopePtr& scope, AstStatLocalFunction* function);
    ControlFlow visit(const ScopePtr& scope, AstStatFunction* function);
    ControlFlow visit(const ScopePtr& scope, AstStatReturn* ret);
    ControlFlow visit(const ScopePtr& scope, AstStatAssign* assign);
    ControlFlow visit(const ScopePtr& scope, AstStatCompoundAssign* assign);
    ControlFlow visit(const ScopePtr& scope, AstStatIf* ifStatement);
    ControlFlow visit(const ScopePtr& scope, AstStatTypeAlias* alias);
    ControlFlow visit(const ScopePtr& scope, AstStatDeclareGlobal* declareGlobal);
    ControlFlow visit(const ScopePtr& scope, AstStatDeclareClass* declareClass);
    ControlFlow visit(const ScopePtr& scope, AstStatDeclareFunction* declareFunction);
    ControlFlow visit(const ScopePtr& scope, AstStatError* error);

    InferencePack checkPack(const ScopePtr& scope, AstArray<AstExpr*> exprs, const std::vector<std::optional<TypeId>>& expectedTypes = {});
    InferencePack checkPack(
        const ScopePtr& scope, AstExpr* expr, const std::vector<std::optional<TypeId>>& expectedTypes = {}, bool generalize = true);

    InferencePack checkPack(const ScopePtr& scope, AstExprCall* call);

    /**
     * Checks an expression that is expected to evaluate to one type.
     * @param scope the scope the expression is contained within.
     * @param expr the expression to check.
     * @param expectedType the type of the expression that is expected from its
     *      surrounding context.  Used to implement bidirectional type checking.
     * @param generalize If true, generalize any lambdas that are encountered.
     * @return the type of the expression.
     */
    Inference check(
        const ScopePtr& scope, AstExpr* expr, std::optional<TypeId> expectedType = {}, bool forceSingleton = false, bool generalize = true);

    Inference check(const ScopePtr& scope, AstExprConstantString* string, std::optional<TypeId> expectedType, bool forceSingleton);
    Inference check(const ScopePtr& scope, AstExprConstantBool* bool_, std::optional<TypeId> expectedType, bool forceSingleton);
    Inference check(const ScopePtr& scope, AstExprLocal* local);
    Inference check(const ScopePtr& scope, AstExprGlobal* global);
    Inference checkIndexName(const ScopePtr& scope, const RefinementKey* key, AstExpr* indexee, const std::string& index, Location indexLocation);
    Inference check(const ScopePtr& scope, AstExprIndexName* indexName);
    Inference check(const ScopePtr& scope, AstExprIndexExpr* indexExpr);
    Inference check(const ScopePtr& scope, AstExprFunction* func, std::optional<TypeId> expectedType, bool generalize);
    Inference check(const ScopePtr& scope, AstExprUnary* unary);
    Inference check(const ScopePtr& scope, AstExprBinary* binary, std::optional<TypeId> expectedType);
    Inference check(const ScopePtr& scope, AstExprIfElse* ifElse, std::optional<TypeId> expectedType);
    Inference check(const ScopePtr& scope, AstExprTypeAssertion* typeAssert);
    Inference check(const ScopePtr& scope, AstExprInterpString* interpString);
    Inference check(const ScopePtr& scope, AstExprTable* expr, std::optional<TypeId> expectedType);
    std::tuple<TypeId, TypeId, RefinementId> checkBinary(const ScopePtr& scope, AstExprBinary* binary, std::optional<TypeId> expectedType);

    void visitLValue(const ScopePtr& scope, AstExpr* expr, TypeId rhsType);
    void visitLValue(const ScopePtr& scope, AstExprLocal* local, TypeId rhsType);
    void visitLValue(const ScopePtr& scope, AstExprGlobal* global, TypeId rhsType);
    void visitLValue(const ScopePtr& scope, AstExprIndexName* indexName, TypeId rhsType);
    void visitLValue(const ScopePtr& scope, AstExprIndexExpr* indexExpr, TypeId rhsType);

    struct FunctionSignature
    {
        // The type of the function.
        TypeId signature;
        // The scope that encompasses the function's signature. May be nullptr
        // if there was no need for a signature scope (the function has no
        // generics).
        ScopePtr signatureScope;
        // The scope that encompasses the function's body. Is a child scope of
        // signatureScope, if present.
        ScopePtr bodyScope;
    };

    FunctionSignature checkFunctionSignature(
        const ScopePtr& parent, AstExprFunction* fn, std::optional<TypeId> expectedType = {}, std::optional<Location> originalName = {});

    /**
     * Checks the body of a function expression.
     * @param scope the interior scope of the body of the function.
     * @param fn the function expression to check.
     */
    void checkFunctionBody(const ScopePtr& scope, AstExprFunction* fn);

    /**
     * Resolves a type from its AST annotation.
     * @param scope the scope that the type annotation appears within.
     * @param ty the AST annotation to resolve.
     * @param inTypeArguments whether we are resolving a type that's contained within type arguments, `<...>`.
     * @return the type of the AST annotation.
     **/
    TypeId resolveType(const ScopePtr& scope, AstType* ty, bool inTypeArguments, bool replaceErrorWithFresh = false);

    /**
     * Resolves a type pack from its AST annotation.
     * @param scope the scope that the type annotation appears within.
     * @param tp the AST annotation to resolve.
     * @param inTypeArguments whether we are resolving a type that's contained within type arguments, `<...>`.
     * @return the type pack of the AST annotation.
     **/
    TypePackId resolveTypePack(const ScopePtr& scope, AstTypePack* tp, bool inTypeArguments, bool replaceErrorWithFresh = false);

    /**
     * Resolves a type pack from its AST annotation.
     * @param scope the scope that the type annotation appears within.
     * @param list the AST annotation to resolve.
     * @param inTypeArguments whether we are resolving a type that's contained within type arguments, `<...>`.
     * @return the type pack of the AST annotation.
     **/
    TypePackId resolveTypePack(const ScopePtr& scope, const AstTypeList& list, bool inTypeArguments, bool replaceErrorWithFresh = false);

    /**
     * Creates generic types given a list of AST definitions, resolving default
     * types as required.
     * @param scope the scope that the generics should belong to.
     * @param generics the AST generics to create types for.
     * @param useCache whether to use the generic type cache for the given
     * scope.
     * @param addTypes whether to add the types to the scope's
     * privateTypeBindings map.
     **/
    std::vector<std::pair<Name, GenericTypeDefinition>> createGenerics(
        const ScopePtr& scope, AstArray<AstGenericType> generics, bool useCache = false, bool addTypes = true);

    /**
     * Creates generic type packs given a list of AST definitions, resolving
     * default type packs as required.
     * @param scope the scope that the generic packs should belong to.
     * @param generics the AST generics to create type packs for.
     * @param useCache whether to use the generic type pack cache for the given
     * scope.
     * @param addTypes whether to add the types to the scope's
     * privateTypePackBindings map.
     **/
    std::vector<std::pair<Name, GenericTypePackDefinition>> createGenericPacks(
        const ScopePtr& scope, AstArray<AstGenericTypePack> packs, bool useCache = false, bool addTypes = true);

    Inference flattenPack(const ScopePtr& scope, Location location, InferencePack pack);

    void reportError(Location location, TypeErrorData err);
    void reportCodeTooComplex(Location location);

    // make a union type function of these two types
    TypeId makeUnion(const ScopePtr& scope, Location location, TypeId lhs, TypeId rhs);
    // make an intersect type function of these two types
    TypeId makeIntersect(const ScopePtr& scope, Location location, TypeId lhs, TypeId rhs);

    /** Scan the program for global definitions.
     *
     * ConstraintGenerator needs to differentiate between globals and accesses to undefined symbols. Doing this "for
     * real" in a general way is going to be pretty hard, so we are choosing not to tackle that yet. For now, we do an
     * initial scan of the AST and note what globals are defined.
     */
    void prepopulateGlobalScope(const ScopePtr& globalScope, AstStatBlock* program);

    bool recordPropertyAssignment(TypeId ty);

    // Record the fact that a particular local has a particular type in at least
    // one of its states.
    void recordInferredBinding(AstLocal* local, TypeId ty);

    void fillInInferredBindings(const ScopePtr& globalScope, AstStatBlock* block);

    /** Given a function type annotation, return a vector describing the expected types of the calls to the function
     *  For example, calling a function with annotation ((number) -> string & ((string) -> number))
     *  yields a vector of size 1, with value: [number | string]
     */
    std::vector<std::optional<TypeId>> getExpectedCallTypesForFunctionOverloads(const TypeId fnType);

    TypeId createTypeFunctionInstance(
        const TypeFunction& family, std::vector<TypeId> typeArguments, std::vector<TypePackId> packArguments, const ScopePtr& scope, Location location);
};

/** Borrow a vector of pointers from a vector of owning pointers to constraints.
 */
std::vector<NotNull<Constraint>> borrowConstraints(const std::vector<ConstraintPtr>& constraints);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TxnLog.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Module.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Simplify.h>

#line __LINE__ "Analysis/include/Luau/Simplify.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <set>

namespace Luau
{

struct TypeArena;

struct SimplifyResult
{
    TypeId result;

    DenseHashSet<TypeId> blockedTypes;
};

SimplifyResult simplifyIntersection(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, TypeId ty, TypeId discriminant);
SimplifyResult simplifyIntersection(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, std::set<TypeId> parts);

SimplifyResult simplifyUnion(NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, TypeId ty, TypeId discriminant);

enum class Relation
{
    Disjoint,   // No A is a B or vice versa
    Coincident, // Every A is in B and vice versa
    Intersects, // Some As are in B and some Bs are in A.  ex (number | string) <-> (string | boolean)
    Subset,     // Every A is in B
    Superset,   // Every B is in A
};

Relation relate(TypeId left, TypeId right);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Instantiation2.h>

#line __LINE__ "Analysis/include/Luau/Instantiation2.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Substitution.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TxnLog.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>

namespace Luau
{

struct TypeArena;
struct TypeCheckLimits;

struct Replacer : Substitution
{
    DenseHashMap<TypeId, TypeId> replacements;
    DenseHashMap<TypePackId, TypePackId> replacementPacks;

    Replacer(NotNull<TypeArena> arena, DenseHashMap<TypeId, TypeId> replacements, DenseHashMap<TypePackId, TypePackId> replacementPacks)
        : Substitution(TxnLog::empty(), arena)
        , replacements(std::move(replacements))
        , replacementPacks(std::move(replacementPacks))
    {
    }

    bool isDirty(TypeId ty) override
    {
        return replacements.find(ty) != nullptr;
    }

    bool isDirty(TypePackId tp) override
    {
        return replacementPacks.find(tp) != nullptr;
    }

    TypeId clean(TypeId ty) override
    {
        TypeId res = replacements[ty];
        LUAU_ASSERT(res);
        dontTraverseInto(res);
        return res;
    }

    TypePackId clean(TypePackId tp) override
    {
        TypePackId res = replacementPacks[tp];
        LUAU_ASSERT(res);
        dontTraverseInto(res);
        return res;
    }
};

// A substitution which replaces generic functions by monomorphic functions
struct Instantiation2 : Substitution
{
    // Mapping from generic types to free types to be used in instantiation.
    DenseHashMap<TypeId, TypeId> genericSubstitutions{nullptr};
    // Mapping from generic type packs to `TypePack`s of free types to be used in instantiation.
    DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions{nullptr};

    Instantiation2(TypeArena* arena, DenseHashMap<TypeId, TypeId> genericSubstitutions, DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions)
        : Substitution(TxnLog::empty(), arena)
        , genericSubstitutions(std::move(genericSubstitutions))
        , genericPackSubstitutions(std::move(genericPackSubstitutions))
    {
    }

    bool ignoreChildren(TypeId ty) override;
    bool isDirty(TypeId ty) override;
    bool isDirty(TypePackId tp) override;
    TypeId clean(TypeId ty) override;
    TypePackId clean(TypePackId tp) override;
};

std::optional<TypeId> instantiate2(
    TypeArena* arena, DenseHashMap<TypeId, TypeId> genericSubstitutions, DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions, TypeId ty);
std::optional<TypePackId> instantiate2(TypeArena* arena, DenseHashMap<TypeId, TypeId> genericSubstitutions,
    DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions, TypePackId tp);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Quantify.h>

#line __LINE__ "Analysis/include/Luau/Quantify.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Unifiable.h>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct TypeArena;
struct Scope;

void quantify(TypeId ty, TypeLevel level);

// TODO: This is eerily similar to the pattern that NormalizedClassType
// implements. We could, and perhaps should, merge them together.
template<typename K, typename V>
struct OrderedMap
{
    std::vector<K> keys;
    DenseHashMap<K, V> pairings{nullptr};

    void push(K k, V v)
    {
        keys.push_back(k);
        pairings[k] = v;
    }
};

struct QuantifierResult
{
    TypeId result;
    OrderedMap<TypeId, TypeId> insertedGenerics;
    OrderedMap<TypePackId, TypePackId> insertedGenericPacks;
};

std::optional<QuantifierResult> quantify(TypeArena* arena, TypeId ty, Scope* scope);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Metamethods.h>

#line __LINE__ "Analysis/include/Luau/Metamethods.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : was already included! <unordered_map>

namespace Luau
{

static const std::unordered_map<AstExprBinary::Op, const char*> kBinaryOpMetamethods{
    {AstExprBinary::Op::CompareEq, "__eq"},
    {AstExprBinary::Op::CompareNe, "__eq"},
    {AstExprBinary::Op::CompareGe, "__lt"},
    {AstExprBinary::Op::CompareGt, "__le"},
    {AstExprBinary::Op::CompareLe, "__le"},
    {AstExprBinary::Op::CompareLt, "__lt"},
    {AstExprBinary::Op::Add, "__add"},
    {AstExprBinary::Op::Sub, "__sub"},
    {AstExprBinary::Op::Mul, "__mul"},
    {AstExprBinary::Op::Div, "__div"},
    {AstExprBinary::Op::FloorDiv, "__idiv"},
    {AstExprBinary::Op::Pow, "__pow"},
    {AstExprBinary::Op::Mod, "__mod"},
    {AstExprBinary::Op::Concat, "__concat"},
};

static const std::unordered_map<AstExprUnary::Op, const char*> kUnaryOpMetamethods{
    {AstExprUnary::Op::Minus, "__unm"},
    {AstExprUnary::Op::Len, "__len"},
};

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Unifiable.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/RecursionCounter.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeAttach.h>

#line __LINE__ "Analysis/include/Luau/TypeAttach.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : was already included! <unordered_set>

namespace Luau
{

struct TypeRehydrationOptions
{
    std::unordered_set<std::string> bannedNames;
    bool expandClassProps = false;
};

void attachTypeData(SourceModule& source, Module& result);

AstType* rehydrateAnnotation(TypeId type, Allocator* allocator, const TypeRehydrationOptions& options = {});

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypePairHash.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TypeFunctionReductionGuesser.h>

#line __LINE__ "Analysis/include/Luau/TypeFunctionReductionGuesser.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VecDeque.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFunction.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePack.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeUtils.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Normalize.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/VisitType.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// DONE : was aleready inlined <TypeArena.h>

namespace Luau
{

struct TypeFunctionReductionGuessResult
{
    std::vector<std::pair<std::string, TypeId>> guessedFunctionAnnotations;
    TypeId guessedReturnType;
    bool shouldRecommendAnnotation = true;
};

// An Inference result for a type function is a list of types corresponding to the guessed argument types, followed by a type for the result
struct TypeFunctionInferenceResult
{
    std::vector<TypeId> operandInference;
    TypeId familyResultInference;
};

struct TypeFunctionReductionGuesser
{
    // Tracks our hypothesis about what a type function reduces to
    DenseHashMap<TypeId, TypeId> familyReducesTo{nullptr};
    // Tracks our constraints on type function operands
    DenseHashMap<TypeId, TypeId> substitutable{nullptr};
    // List of instances to try progress
    VecDeque<TypeId> toInfer;
    DenseHashSet<TypeId> cyclicInstances{nullptr};

    // Utilities
    NotNull<TypeArena> arena;
    NotNull<BuiltinTypes> builtins;
    NotNull<Normalizer> normalizer;

    TypeFunctionReductionGuesser(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtins, NotNull<Normalizer> normalizer);

    std::optional<TypeId> guess(TypeId typ);
    std::optional<TypePackId> guess(TypePackId typ);
    TypeFunctionReductionGuessResult guessTypeFunctionReductionForFunctionExpr(const AstExprFunction& expr, const FunctionType* ftv, TypeId retTy);

private:
    std::optional<TypeId> guessType(TypeId arg);
    void dumpGuesses();

    bool isNumericBinopFamily(const TypeFunctionInstanceType& instance);
    bool isComparisonFamily(const TypeFunctionInstanceType& instance);
    bool isOrAndFamily(const TypeFunctionInstanceType& instance);
    bool isNotFamily(const TypeFunctionInstanceType& instance);
    bool isLenFamily(const TypeFunctionInstanceType& instance);
    bool isUnaryMinus(const TypeFunctionInstanceType& instance);

    // Operand is assignable if it looks like a cyclic family instance, or a generic type
    bool operandIsAssignable(TypeId ty);
    std::optional<TypeId> tryAssignOperandType(TypeId ty);

    std::shared_ptr<const NormalizedType> normalize(TypeId ty);
    void step();
    void infer();
    bool done();

    bool isFunctionGenericsSaturated(const FunctionType& ftv, DenseHashSet<TypeId>& instanceArgs);
    void inferTypeFunctionSubstitutions(TypeId ty, const TypeFunctionInstanceType* instance);
    TypeFunctionInferenceResult inferNumericBinopFamily(const TypeFunctionInstanceType* instance);
    TypeFunctionInferenceResult inferComparisonFamily(const TypeFunctionInstanceType* instance);
    TypeFunctionInferenceResult inferOrAndFamily(const TypeFunctionInstanceType* instance);
    TypeFunctionInferenceResult inferNotFamily(const TypeFunctionInstanceType* instance);
    TypeFunctionInferenceResult inferLenFamily(const TypeFunctionInstanceType* instance);
    TypeFunctionInferenceResult inferUnaryMinusFamily(const TypeFunctionInstanceType* instance);
};
} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Unifier2.h>

#line __LINE__ "Analysis/include/Luau/Unifier2.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Constraint.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeCheckLimits.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypePairHash.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <vector>

// @@@@@ PACK.LUA : was already included! <utility>

namespace Luau
{

struct InternalErrorReporter;
struct Scope;
struct TypeArena;

enum class OccursCheckResult
{
    Pass,
    Fail
};

struct Unifier2
{
    NotNull<TypeArena> arena;
    NotNull<BuiltinTypes> builtinTypes;
    NotNull<Scope> scope;
    NotNull<InternalErrorReporter> ice;
    TypeCheckLimits limits;

    DenseHashSet<std::pair<TypeId, TypeId>, TypePairHash> seenTypePairings{{nullptr, nullptr}};
    DenseHashSet<std::pair<TypePackId, TypePackId>, TypePairHash> seenTypePackPairings{{nullptr, nullptr}};

    DenseHashMap<TypeId, std::vector<TypeId>> expandedFreeTypes{nullptr};

    // Mapping from generic types to free types to be used in instantiation.
    DenseHashMap<TypeId, TypeId> genericSubstitutions{nullptr};
    // Mapping from generic type packs to `TypePack`s of free types to be used in instantiation.
    DenseHashMap<TypePackId, TypePackId> genericPackSubstitutions{nullptr};

    int recursionCount = 0;
    int recursionLimit = 0;

    std::vector<ConstraintV> incompleteSubtypes;
    // null if not in a constraint solving context
    DenseHashSet<const void*>* uninhabitedTypeFamilies;

    Unifier2(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes, NotNull<Scope> scope, NotNull<InternalErrorReporter> ice);
    Unifier2(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes, NotNull<Scope> scope, NotNull<InternalErrorReporter> ice,
        DenseHashSet<const void*>* uninhabitedTypeFamilies);

    /** Attempt to commit the subtype relation subTy <: superTy to the type
     * graph.
     *
     * @returns true if successful.
     *
     * Note that incoherent types can and will successfully be unified.  We stop
     * when we *cannot know* how to relate the provided types, not when doing so
     * would narrow something down to never or broaden it to unknown.
     *
     * Presently, the only way unification can fail is if we attempt to bind one
     * free TypePack to another and encounter an occurs check violation.
     */
    bool unify(TypeId subTy, TypeId superTy);
    bool unifyFreeWithType(TypeId subTy, TypeId superTy);
    bool unify(TypeId subTy, const FunctionType* superFn);
    bool unify(const UnionType* subUnion, TypeId superTy);
    bool unify(TypeId subTy, const UnionType* superUnion);
    bool unify(const IntersectionType* subIntersection, TypeId superTy);
    bool unify(TypeId subTy, const IntersectionType* superIntersection);
    bool unify(TableType* subTable, const TableType* superTable);
    bool unify(const MetatableType* subMetatable, const MetatableType* superMetatable);

    bool unify(const AnyType* subAny, const FunctionType* superFn);
    bool unify(const FunctionType* subFn, const AnyType* superAny);
    bool unify(const AnyType* subAny, const TableType* superTable);
    bool unify(const TableType* subTable, const AnyType* superAny);

    // TODO think about this one carefully.  We don't do unions or intersections of type packs
    bool unify(TypePackId subTp, TypePackId superTp);

    std::optional<TypeId> generalize(TypeId ty);

private:
    /**
     * @returns simplify(left | right)
     */
    TypeId mkUnion(TypeId left, TypeId right);

    /**
     * @returns simplify(left & right)
     */
    TypeId mkIntersection(TypeId left, TypeId right);

    // Returns true if needle occurs within haystack already.  ie if we bound
    // needle to haystack, would a cyclic type result?
    OccursCheckResult occursCheck(DenseHashSet<TypeId>& seen, TypeId needle, TypeId haystack);

    // Returns true if needle occurs within haystack already.  ie if we bound
    // needle to haystack, would a cyclic TypePack result?
    OccursCheckResult occursCheck(DenseHashSet<TypePackId>& seen, TypePackId needle, TypePackId haystack);
};

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypeUtils.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/NotNull.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Symbol.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/BuiltinDefinitions.h>

#line __LINE__ "Analysis/include/Luau/BuiltinDefinitions.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct Frontend;
struct GlobalTypes;
struct TypeChecker;
struct TypeArena;

void registerBuiltinGlobals(Frontend& frontend, GlobalTypes& globals, bool typeCheckForAutocomplete = false);
TypeId makeUnion(TypeArena& arena, std::vector<TypeId>&& types);
TypeId makeIntersection(TypeArena& arena, std::vector<TypeId>&& types);

/** Build an optional 't'
 */
TypeId makeOption(NotNull<BuiltinTypes> builtinTypes, TypeArena& arena, TypeId t);

/** Small utility function for building up type definitions from C++.
 */
TypeId makeFunction( // Monomorphic
    TypeArena& arena, std::optional<TypeId> selfType, std::initializer_list<TypeId> paramTypes, std::initializer_list<TypeId> retTypes,
    bool checked = false);

TypeId makeFunction( // Polymorphic
    TypeArena& arena, std::optional<TypeId> selfType, std::initializer_list<TypeId> generics, std::initializer_list<TypePackId> genericPacks,
    std::initializer_list<TypeId> paramTypes, std::initializer_list<TypeId> retTypes, bool checked = false);

TypeId makeFunction( // Monomorphic
    TypeArena& arena, std::optional<TypeId> selfType, std::initializer_list<TypeId> paramTypes, std::initializer_list<std::string> paramNames,
    std::initializer_list<TypeId> retTypes, bool checked = false);

TypeId makeFunction( // Polymorphic
    TypeArena& arena, std::optional<TypeId> selfType, std::initializer_list<TypeId> generics, std::initializer_list<TypePackId> genericPacks,
    std::initializer_list<TypeId> paramTypes, std::initializer_list<std::string> paramNames, std::initializer_list<TypeId> retTypes,
    bool checked = false);

void attachMagicFunction(TypeId ty, MagicFunction fn);
void attachDcrMagicFunction(TypeId ty, DcrMagicFunction fn);
void attachDcrMagicRefinement(TypeId ty, DcrMagicRefinement fn);

Property makeProperty(TypeId ty, std::optional<std::string> documentationSymbol = std::nullopt);
void assignPropDocumentationSymbols(TableType::Props& props, const std::string& baseName);

std::string getBuiltinDefinitionSource();

void addGlobalBinding(GlobalTypes& globals, const std::string& name, TypeId ty, const std::string& packageName);
void addGlobalBinding(GlobalTypes& globals, const std::string& name, Binding binding);
void addGlobalBinding(GlobalTypes& globals, const ScopePtr& scope, const std::string& name, TypeId ty, const std::string& packageName);
void addGlobalBinding(GlobalTypes& globals, const ScopePtr& scope, const std::string& name, Binding binding);
std::optional<Binding> tryGetGlobalBinding(GlobalTypes& globals, const std::string& name);
Binding* tryGetGlobalBindingRef(GlobalTypes& globals, const std::string& name);
TypeId getGlobalBinding(GlobalTypes& globals, const std::string& name);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/ToString.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Anyification.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/VisitType.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Type.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypeArena.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/ConstraintSolver.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Linter.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Generalization.h>

#line __LINE__ "Analysis/include/Luau/Generalization.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

namespace Luau
{

std::optional<TypeId> generalize(NotNull<TypeArena> arena, NotNull<BuiltinTypes> builtinTypes, NotNull<Scope> scope,
    NotNull<DenseHashSet<TypeId>> bakedTypes, TypeId ty, /* avoid sealing tables*/ bool avoidSealingTables = false);
}

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Normalize.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Scope.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Differ.h>

#line __LINE__ "Analysis/include/Luau/Differ.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/UnifierSharedState.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <unordered_set>

namespace Luau
{
struct DiffPathNode
{
    // TODO: consider using Variants to simplify toString implementation
    enum Kind
    {
        TableProperty,
        FunctionArgument,
        FunctionReturn,
        Union,
        Intersection,
        Negation,
    };
    Kind kind;
    // non-null when TableProperty
    std::optional<Name> tableProperty;
    // non-null when FunctionArgument (unless variadic arg), FunctionReturn (unless variadic arg), Union, or Intersection (i.e. anonymous fields)
    std::optional<size_t> index;

    /**
     * Do not use for leaf nodes
     */
    DiffPathNode(Kind kind)
        : kind(kind)
    {
    }

    DiffPathNode(Kind kind, std::optional<Name> tableProperty, std::optional<size_t> index)
        : kind(kind)
        , tableProperty(tableProperty)
        , index(index)
    {
    }

    std::string toString() const;

    static DiffPathNode constructWithTableProperty(Name tableProperty);

    static DiffPathNode constructWithKindAndIndex(Kind kind, size_t index);

    static DiffPathNode constructWithKind(Kind kind);
};

struct DiffPathNodeLeaf
{
    std::optional<TypeId> ty;
    std::optional<Name> tableProperty;
    std::optional<int> minLength;
    bool isVariadic;
    // TODO: Rename to anonymousIndex, for both union and Intersection
    std::optional<size_t> unionIndex;
    DiffPathNodeLeaf(
        std::optional<TypeId> ty, std::optional<Name> tableProperty, std::optional<int> minLength, bool isVariadic, std::optional<size_t> unionIndex)
        : ty(ty)
        , tableProperty(tableProperty)
        , minLength(minLength)
        , isVariadic(isVariadic)
        , unionIndex(unionIndex)
    {
    }

    static DiffPathNodeLeaf detailsNormal(TypeId ty);

    static DiffPathNodeLeaf detailsTableProperty(TypeId ty, Name tableProperty);

    static DiffPathNodeLeaf detailsUnionIndex(TypeId ty, size_t index);

    static DiffPathNodeLeaf detailsLength(int minLength, bool isVariadic);

    static DiffPathNodeLeaf nullopts();
};

struct DiffPath
{
    std::vector<DiffPathNode> path;

    std::string toString(bool prependDot) const;
};
struct DiffError
{
    enum Kind
    {
        Normal,
        MissingTableProperty,
        MissingUnionMember,
        MissingIntersectionMember,
        IncompatibleGeneric,
        LengthMismatchInFnArgs,
        LengthMismatchInFnRets,
    };
    Kind kind;

    DiffPath diffPath;
    DiffPathNodeLeaf left;
    DiffPathNodeLeaf right;

    std::string leftRootName;
    std::string rightRootName;

    DiffError(Kind kind, DiffPathNodeLeaf left, DiffPathNodeLeaf right, std::string leftRootName, std::string rightRootName)
        : kind(kind)
        , left(left)
        , right(right)
        , leftRootName(leftRootName)
        , rightRootName(rightRootName)
    {
        checkValidInitialization(left, right);
    }
    DiffError(Kind kind, DiffPath diffPath, DiffPathNodeLeaf left, DiffPathNodeLeaf right, std::string leftRootName, std::string rightRootName)
        : kind(kind)
        , diffPath(diffPath)
        , left(left)
        , right(right)
        , leftRootName(leftRootName)
        , rightRootName(rightRootName)
    {
        checkValidInitialization(left, right);
    }

    std::string toString(bool multiLine = false) const;

private:
    std::string toStringALeaf(std::string rootName, const DiffPathNodeLeaf& leaf, const DiffPathNodeLeaf& otherLeaf, bool multiLine) const;
    void checkValidInitialization(const DiffPathNodeLeaf& left, const DiffPathNodeLeaf& right);
    void checkNonMissingPropertyLeavesHaveNulloptTableProperty() const;
};

struct DifferResult
{
    std::optional<DiffError> diffError;

    DifferResult() {}
    DifferResult(DiffError diffError)
        : diffError(diffError)
    {
    }

    void wrapDiffPath(DiffPathNode node);
};
struct DifferEnvironment
{
    TypeId rootLeft;
    TypeId rootRight;
    std::optional<std::string> externalSymbolLeft;
    std::optional<std::string> externalSymbolRight;
    DenseHashMap<TypeId, TypeId> genericMatchedPairs;
    DenseHashMap<TypePackId, TypePackId> genericTpMatchedPairs;

    DifferEnvironment(
        TypeId rootLeft, TypeId rootRight, std::optional<std::string> externalSymbolLeft, std::optional<std::string> externalSymbolRight)
        : rootLeft(rootLeft)
        , rootRight(rootRight)
        , externalSymbolLeft(externalSymbolLeft)
        , externalSymbolRight(externalSymbolRight)
        , genericMatchedPairs(nullptr)
        , genericTpMatchedPairs(nullptr)
    {
    }

    bool isProvenEqual(TypeId left, TypeId right) const;
    bool isAssumedEqual(TypeId left, TypeId right) const;
    void recordProvenEqual(TypeId left, TypeId right);
    void pushVisiting(TypeId left, TypeId right);
    void popVisiting();
    std::vector<std::pair<TypeId, TypeId>>::const_reverse_iterator visitingBegin() const;
    std::vector<std::pair<TypeId, TypeId>>::const_reverse_iterator visitingEnd() const;
    std::string getDevFixFriendlyNameLeft() const;
    std::string getDevFixFriendlyNameRight() const;

private:
    // TODO: consider using DenseHashSet
    std::unordered_set<std::pair<TypeId, TypeId>, TypeIdPairHash> provenEqual;
    // Ancestors of current types
    std::unordered_set<std::pair<TypeId, TypeId>, TypeIdPairHash> visiting;
    std::vector<std::pair<TypeId, TypeId>> visitingStack;
};
DifferResult diff(TypeId ty1, TypeId ty2);
DifferResult diffWithSymbols(TypeId ty1, TypeId ty2, std::optional<std::string> symbol1, std::optional<std::string> symbol2);

/**
 * True if ty is a "simple" type, i.e. cannot contain types.
 * string, number, boolean are simple types.
 * function and table are not simple types.
 */
bool isSimple(TypeId ty);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/AstQuery.h>

#line __LINE__ "Analysis/include/Luau/AstQuery.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Ast.h>

// DONE : was aleready inlined <Luau/Documentation.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <memory>

namespace Luau
{

struct Binding;
struct SourceModule;
struct Module;

using ScopePtr = std::shared_ptr<struct Scope>;

struct ExprOrLocal
{
    AstExpr* getExpr()
    {
        return expr;
    }
    AstLocal* getLocal()
    {
        return local;
    }
    void setExpr(AstExpr* newExpr)
    {
        expr = newExpr;
        local = nullptr;
    }
    void setLocal(AstLocal* newLocal)
    {
        local = newLocal;
        expr = nullptr;
    }
    std::optional<Location> getLocation()
    {
        return expr ? expr->location : (local ? local->location : std::optional<Location>{});
    }
    std::optional<AstName> getName()
    {
        if (expr)
        {
            if (AstName name = getIdentifier(expr); name.value)
            {
                return name;
            }
        }
        else if (local)
        {
            return local->name;
        }
        return std::nullopt;
    }

private:
    AstExpr* expr = nullptr;
    AstLocal* local = nullptr;
};

std::vector<AstNode*> findAncestryAtPositionForAutocomplete(const SourceModule& source, Position pos);
std::vector<AstNode*> findAncestryAtPositionForAutocomplete(AstStatBlock* root, Position pos);
std::vector<AstNode*> findAstAncestryOfPosition(const SourceModule& source, Position pos, bool includeTypes = false);
std::vector<AstNode*> findAstAncestryOfPosition(AstStatBlock* root, Position pos, bool includeTypes = false);
AstNode* findNodeAtPosition(const SourceModule& source, Position pos);
AstNode* findNodeAtPosition(AstStatBlock* root, Position pos);
AstExpr* findExprAtPosition(const SourceModule& source, Position pos);
ScopePtr findScopeAtPosition(const Module& module, Position pos);
std::optional<Binding> findBindingAtPosition(const Module& module, const SourceModule& source, Position pos);
ExprOrLocal findExprOrLocalAtPosition(const SourceModule& source, Position pos);

std::optional<TypeId> findTypeAtPosition(const Module& module, const SourceModule& sourceModule, Position pos);
std::optional<TypeId> findExpectedTypeAtPosition(const Module& module, const SourceModule& sourceModule, Position pos);

std::optional<DocumentationSymbol> getDocumentationSymbolAtPosition(const SourceModule& source, const Module& module, Position position);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/ModuleResolver.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/InsertionOrderedMap.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/Instantiation.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/TableLiteralInference.h>

#line __LINE__ "Analysis/include/Luau/TableLiteralInference.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/DenseHash.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

namespace Luau
{

struct TypeArena;
struct BuiltinTypes;
struct Unifier2;
class AstExpr;

TypeId matchLiteralType(NotNull<DenseHashMap<const AstExpr*, TypeId>> astTypes, NotNull<DenseHashMap<const AstExpr*, TypeId>> astExpectedTypes,
    NotNull<BuiltinTypes> builtinTypes, NotNull<TypeArena> arena, NotNull<Unifier2> unifier, TypeId expectedType, TypeId exprType,
    const AstExpr* expr, std::vector<TypeId>& toBlock);
} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypePack.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/AstJsonEncoder.h>

#line __LINE__ "Analysis/include/Luau/AstJsonEncoder.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

class AstNode;
struct Comment;

std::string toJson(AstNode* node);
std::string toJson(AstNode* node, const std::vector<Comment>& commentLocations);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/GlobalTypes.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/TypePath.h>

// @@@@@ PACK.LUA : was already included! <Analysis/include/Luau/UnifierSharedState.h>

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/NonStrictTypeChecker.h>

#line __LINE__ "Analysis/include/Luau/NonStrictTypeChecker.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/DataFlowGraph.h>

namespace Luau
{

struct BuiltinTypes;
struct UnifierSharedState;
struct TypeCheckLimits;

void checkNonStrict(NotNull<BuiltinTypes> builtinTypes, NotNull<InternalErrorReporter> ice, NotNull<UnifierSharedState> unifierState,
    NotNull<const DataFlowGraph> dfg, NotNull<TypeCheckLimits> limits, const SourceModule& sourceModule, Module* module);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/DcrLogger.h>

#line __LINE__ "Analysis/include/Luau/DcrLogger.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Constraint.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/NotNull.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Scope.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Module.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/ToString.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Error.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Variant.h>

// @@@@@ PACK.LUA : was already included! <optional>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <vector>

namespace Luau
{

struct ErrorSnapshot
{
    std::string message;
    Location location;
};

struct BindingSnapshot
{
    std::string typeId;
    std::string typeString;
    Location location;
};

struct TypeBindingSnapshot
{
    std::string typeId;
    std::string typeString;
};

struct ExprTypesAtLocation
{
    Location location;
    TypeId ty;
    std::optional<TypeId> expectedTy;
};

struct AnnotationTypesAtLocation
{
    Location location;
    TypeId resolvedTy;
};

struct ConstraintGenerationLog
{
    std::string source;
    std::vector<ErrorSnapshot> errors;

    std::vector<ExprTypesAtLocation> exprTypeLocations;
    std::vector<AnnotationTypesAtLocation> annotationTypeLocations;
};

struct ScopeSnapshot
{
    std::unordered_map<Name, BindingSnapshot> bindings;
    std::unordered_map<Name, TypeBindingSnapshot> typeBindings;
    std::unordered_map<Name, TypeBindingSnapshot> typePackBindings;
    std::vector<ScopeSnapshot> children;
};

using ConstraintBlockTarget = Variant<TypeId, TypePackId, NotNull<const Constraint>>;

struct ConstraintBlock
{
    ConstraintBlockTarget target;
    std::string stringification;
};

struct ConstraintSnapshot
{
    std::string stringification;
    Location location;
    std::vector<ConstraintBlock> blocks;
};

struct BoundarySnapshot
{
    DenseHashMap<const Constraint*, ConstraintSnapshot> unsolvedConstraints{nullptr};
    ScopeSnapshot rootScope;
    DenseHashMap<const void*, std::string> typeStrings{nullptr};
};

struct StepSnapshot
{
    const Constraint* currentConstraint;
    bool forced;
    DenseHashMap<const Constraint*, ConstraintSnapshot> unsolvedConstraints{nullptr};
    ScopeSnapshot rootScope;
    DenseHashMap<const void*, std::string> typeStrings{nullptr};
};

struct TypeSolveLog
{
    BoundarySnapshot initialState;
    std::vector<StepSnapshot> stepStates;
    BoundarySnapshot finalState;
};

struct TypeCheckLog
{
    std::vector<ErrorSnapshot> errors;
};

struct DcrLogger
{
    std::string compileOutput();

    void captureSource(std::string source);
    void captureGenerationError(const TypeError& error);
    void captureConstraintLocation(NotNull<const Constraint> constraint, Location location);
    void captureGenerationModule(const ModulePtr& module);

    void pushBlock(NotNull<const Constraint> constraint, TypeId block);
    void pushBlock(NotNull<const Constraint> constraint, TypePackId block);
    void pushBlock(NotNull<const Constraint> constraint, NotNull<const Constraint> block);
    void popBlock(TypeId block);
    void popBlock(TypePackId block);
    void popBlock(NotNull<const Constraint> block);

    void captureInitialSolverState(const Scope* rootScope, const std::vector<NotNull<const Constraint>>& unsolvedConstraints);
    StepSnapshot prepareStepSnapshot(
        const Scope* rootScope, NotNull<const Constraint> current, bool force, const std::vector<NotNull<const Constraint>>& unsolvedConstraints);
    void commitStepSnapshot(StepSnapshot snapshot);
    void captureFinalSolverState(const Scope* rootScope, const std::vector<NotNull<const Constraint>>& unsolvedConstraints);

    void captureTypeCheckError(const TypeError& error);

private:
    ConstraintGenerationLog generationLog;
    std::unordered_map<NotNull<const Constraint>, std::vector<ConstraintBlockTarget>> constraintBlocks;
    TypeSolveLog solveLog;
    TypeCheckLog checkLog;

    ToStringOptions opts{true};

    std::vector<ConstraintBlock> snapshotBlocks(NotNull<const Constraint> constraint);
    void captureBoundaryState(BoundarySnapshot& target, const Scope* rootScope, const std::vector<NotNull<const Constraint>>& unsolvedConstraints);
};

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/ToDot.h>

#line __LINE__ "Analysis/include/Luau/ToDot.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Common.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/TypeFwd.h>

// @@@@@ PACK.LUA : was already included! <string>

namespace Luau
{

struct ToDotOptions
{
    bool showPointers = true;        // Show pointer value in the node label
    bool duplicatePrimitives = true; // Display primitive types and 'any' as separate nodes
};

std::string toDot(TypeId ty, const ToDotOptions& opts);
std::string toDot(TypePackId tp, const ToDotOptions& opts);

std::string toDot(TypeId ty);
std::string toDot(TypePackId tp);

void dumpDot(TypeId ty);
void dumpDot(TypePackId tp);

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"

// @@@@@ PACK.lua : done, inlined <Analysis/include/Luau/Autocomplete.h>

#line __LINE__ "Analysis/include/Luau/Autocomplete.h"

// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details
// @@@@@ PACK.LUA : unknown was already included! <Luau/Location.h>

// @@@@@ PACK.LUA : unknown was already included! <Luau/Type.h>

// @@@@@ PACK.LUA : was already included! <unordered_map>

// @@@@@ PACK.LUA : was already included! <string>

// @@@@@ PACK.LUA : was already included! <memory>

// @@@@@ PACK.LUA : was already included! <optional>

namespace Luau
{

struct Frontend;
struct SourceModule;
struct Module;
struct TypeChecker;

using ModulePtr = std::shared_ptr<Module>;

enum class AutocompleteContext
{
    Unknown,
    Expression,
    Statement,
    Property,
    Type,
    Keyword,
    String,
};

enum class AutocompleteEntryKind
{
    Property,
    Binding,
    Keyword,
    String,
    Type,
    Module,
    GeneratedFunction,
};

enum class ParenthesesRecommendation
{
    None,
    CursorAfter,
    CursorInside,
};

enum class TypeCorrectKind
{
    None,
    Correct,
    CorrectFunctionResult,
};

struct AutocompleteEntry
{
    AutocompleteEntryKind kind = AutocompleteEntryKind::Property;
    // Nullopt if kind is Keyword
    std::optional<TypeId> type = std::nullopt;
    bool deprecated = false;
    // Only meaningful if kind is Property.
    bool wrongIndexType = false;
    // Set if this suggestion matches the type expected in the context
    TypeCorrectKind typeCorrect = TypeCorrectKind::None;

    std::optional<const ClassType*> containingClass = std::nullopt;
    std::optional<const Property*> prop = std::nullopt;
    std::optional<std::string> documentationSymbol = std::nullopt;
    Tags tags;
    ParenthesesRecommendation parens = ParenthesesRecommendation::None;
    std::optional<std::string> insertText;

    // Only meaningful if kind is Property.
    bool indexedWithSelf = false;
};

using AutocompleteEntryMap = std::unordered_map<std::string, AutocompleteEntry>;
struct AutocompleteResult
{
    AutocompleteEntryMap entryMap;
    std::vector<AstNode*> ancestry;
    AutocompleteContext context = AutocompleteContext::Unknown;

    AutocompleteResult() = default;
    AutocompleteResult(AutocompleteEntryMap entryMap, std::vector<AstNode*> ancestry, AutocompleteContext context)
        : entryMap(std::move(entryMap))
        , ancestry(std::move(ancestry))
        , context(context)
    {
    }
};

using ModuleName = std::string;
using StringCompletionCallback =
    std::function<std::optional<AutocompleteEntryMap>(std::string tag, std::optional<const ClassType*> ctx, std::optional<std::string> contents)>;

AutocompleteResult autocomplete(Frontend& frontend, const ModuleName& moduleName, Position position, StringCompletionCallback callback);

constexpr char kGeneratedAnonymousFunctionEntryName[] = "function (anonymous autofilled)";

} // namespace Luau

#line __LINE__ "luau_analysis_int.hpp"
